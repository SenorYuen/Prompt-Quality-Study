System Prompt:
Provided are instructions for generating the code for a class. Please provide the only code in your response.

User Prompt:
a. Understand the Overall Purpose:
    - The SQLGenerator class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.
b. To ensure the function of this class, it will need all of these methods:
    - Initialize the table name (__init__)
    - Generates a SELECT SQL statement (select)
    - Generates an INSERT SQL statement (insert)
    - Generates an UPDATE SQL statement (update)
    - Generates a DELETE SQL statement (delete)
    - Generates a SQL statement to select females under a specified age (select_female_under_age)
    - Generates a SQL statement to select records (select_by_age_range)
c. Detail each method:
    - __init__(self, table_name):
        - This method will act as the constructor.
        - This method will initialize the table name.
        - This method will get "table_name" as str.
        - self.table_name = table_name.
    - select(self, fields=None, condition=None):
        - This method will generate a SELECT SQL statement based on the specified fields and conditions.
        - This method will get "fields" as list which is the list of fields to be queried that is optional and default is None, "condition" as str which is the condition expression for the query that is optional and default is None.
        - This method will return the generated SQL statement as str. 
        - Example Usage:   
        - >>> sql = SQLGenerator('table1')
        - >>> sql.select(['field1', 'field2'], 'filed3 = value1')
        - >>> The expected return value for example usage is : 'SELECT field1, field2 FROM table1 WHERE filed3 = value1;'
    - insert(self, data):
        - This method will generate an INSERT SQL statement based on the given data.
        - This method will get "data" as dict which is the data to be inserted, in dictionary form where keys are field names and values are field values.
        - This method will return the generated SQL statement as str. 
        - Example Usage:   
        - >>> sql.insert({'key1': 'value1', 'key2': 'value2'})
        - >>> The expected return value for example usage is : "INSERT INTO table1 (key1, key2) VALUES ('value1', 'value2');"
    - update(self, data, condition):
        - This method will generate an UPDATE SQL statement based on the given data and condition.
        - This method will get "data" as dict which is the data to be updated, in dictionary form where keys are field names and values are new field values, "condition" as str which is the condition expression for the update.
        - This method will return the generated SQL statement as str. 
        - Example Usage:   
        - >>> sql.update({'field1': 'new_value1', 'field2': 'new_value2'}, "field3 = value1")
        - >>> The expected return value for example usage is : "UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2' WHERE field3 = value1;"
    - delete(self, condition):
        - This method will generate an DELETE SQL statement based on the given data and condition.
        - This method will get "condition" as str which is the condition expression for the delete.
        - This method will return the generated SQL statement as str. 
        - Example Usage:   
        - >>> sql.delete("field1 = value1")
        - >>> The expected return value for example usage is : 'DELETE FROM table1 WHERE field1 = value1;'
    - select_female_under_age(self, age):
        - This method will generate a SQL statement to select females under a specified age.
        - This method will get "age" as int which is the specified age.
        - This method will return the generated SQL statement as str. 
        - Example Usage:   
        - >>> sql.select_female_under_age(30)
        - >>> The expected return value for example usage is : "SELECT * FROM table1 WHERE age < 30 AND gender = 'female';"
    - select_by_age_range(self, min_age, max_age):
        - This method will generate a SQL statement to select records within a specified age range.
        - This method will get "min_age" as int which is the minimum age, "max_age" as int which is the maximum age.
        - This method will return the generated SQL statement as str. 
        - Example Usage:   
        - >>> sql.select_by_age_range(20, 30)
        - >>> The expected return value for example usage is : 'SELECT * FROM table1 WHERE age BETWEEN 20 AND 30;'
d. Plan the implementation:
    - For each method, consider the input parameters, the actions that must be performed, and the expected outcome. 
e. Import statements:
    - No import 
f. Implement the methods:
    - Write the code for each method step-by-step, following this outlined plan. Please only include the code output in your response, and do not include example usage or test cases in this code.           

 Use the following prompt and solution pair as context for generating the previously mentioned class: 
a. Understand the Overall Purpose:
    - The ZipFileProcessor class can read and decompress zip files. The ZipFileProcessor class also can compress a list of specified files into a zip file. 
b. Identify the Required Methods:
    - To ensure the function of this class, it will need all of these methods:
        - Initialize file name (__init__)
        - Read files (read_zip_file)
        - Extract all files (extract_all)
        - Extract a specific file identified by name (extract_file)
        - Compress files into zip (create_zip_file)
c. Detail each method:
    - __init__(self, file_name):
        - This method will act as the constructor.
        - This method will initialize the file name.
        - This Method will accept "file_name" as str ehich is the name of the file to be processed.
        - self.file_name = file_name
    - read_zip_file(self):
        - This method will get open file object, and return the open file object if successful; otherwise, returns None
        - Example Usage: 
        - >>> zfp = ZipFileProcessor("aaa.zip")
        - >>> file = zfp.read_zip_file()
    - extract_all(self, output_path):
        - This method will extract all zip files and place them in the specified path
        - This method will get the "output_path" as str which is the location of the extracted file.
        - This method will return True or False to represent if the extraction operation was successful. 
        - Example Usage:
        - >>> zfp = ZipFileProcessor("aaa.zip")
        - >>> zfp.extract_all("result/aaa")
    - extract_file(self, file_name, output_path):  
        - This method will extract the file with the specified name from the zip file and place it in the specified path  
        - This method will get "file_name" as str whcih is the name of the file to be uncompressed, "output_path" as str which is the location of the extracted file. 
        - The method will return True or False, representing whether the extraction operation was successful
        - Example usage: 
        - >>> zfp = ZipFileProcessor("aaa.zip")
        - >>> zfp.extract_file("bbb.txt", "result/aaa")
    - create_zip_file(self, files, output_file_name):
        - This method will compress the specified file list into a zip file and place it in the specified path. 
        - This method will get "files" as a list of string which is the List of files to compress, "output_file_name" as str which specifies output path.
        - This method will return True or False, representing whether the compression operation was successful 
        - Example Usage:
        - >>> zfp = ZipFileProcessor("aaa.zip")
        - >>> zfp.create_zip_file(["bbb.txt", "ccc,txt", "ddd.txt"], "output/bcd") 
d. Plan the implementation:
    - For each method, consider the input parameters, the actions that must be performed, and the expected outcome. 
e. Import statements:
    - import zipfile
f. Implement the methods:
    - Write the code for each method step-by-step, following this outlined plan. Please only include the code output in your response, and do not include example usage or test cases in this code. 


import zipfile


class ZipFileProcessor:
    def __init__(self, file_name):
        self.file_name = file_name

    def read_zip_file(self):
        try:
            zip_file = zipfile.ZipFile(self.file_name, 'r')
            return zip_file
        except:
            return None

    def extract_all(self, output_path):
        try:
            with zipfile.ZipFile(self.file_name, 'r') as zip_file:
                zip_file.extractall(output_path)
            return True
        except:
            return False

    def extract_file(self, file_name, output_path):
        try:
            with zipfile.ZipFile(self.file_name, 'r') as zip_file:
                zip_file.extract(file_name, output_path)
            return True
        except:
            return False

    def create_zip_file(self, files, output_file_name):
        try:
            with zipfile.ZipFile(output_file_name, 'w') as zip_file:
                for file in files:
                    zip_file.write(file)
            return True
        except:
            return False
