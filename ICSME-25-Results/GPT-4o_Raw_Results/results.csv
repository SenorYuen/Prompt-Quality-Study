Question Source,Question ID,Original Code,Prompt Version,Output Code,BLEU-3,CodeBLEU,Rouge 1-r,Rouge 1-p,Rouge 1-f,Rouge 2-r,Rouge 2-p,Rouge 2-f,Rouge L-r,Rouge L-p,Rouge L-f,,,BLEU-3,Rouge 1-r,Rouge 1-p,Rouge 1-f,Rouge 2-r,Rouge 2-p,Rouge 2-f,Rouge L-r,Rouge L-p,Rouge L-f
GPT,0,"import logging
import datetime


class AccessGatewayFilter:

    def __init__(self):
        pass

    def filter(self, request):
        request_uri = request['path']
        method = request['method']

        if self.is_start_with(request_uri):
            return True

        try:
            token = self.get_jwt_user(request)
            user = token['user']
            if user['level'] > 2:
                self.set_current_user_info_and_log(user)
                return True
        except:
            return False

    def is_start_with(self, request_uri):
        start_with = [""/api"", '/login']
        for s in start_with:
            if request_uri.startswith(s):
                return True
        return False

    def get_jwt_user(self, request):
        token = request['headers']['Authorization']
        user = token['user']
        if token['jwt'].startswith(user['name']):
            jwt_str_date = token['jwt'].split(user['name'])[1]
            jwt_date = datetime.datetime.strptime(jwt_str_date, ""%Y-%m-%d"")
            if datetime.datetime.today() - jwt_date >= datetime.timedelta(days=3):
                return None
        return token

    def set_current_user_info_and_log(self, user):
        host = user['address']
        logging.log(msg=user['name'] + host + str(datetime.datetime.now()), level=1)",COT,"```python
import datetime

class AccessGatewayFilter:
    def __init__(self):
        pass

    def filter(self, request):
        if self.is_start_with(request['path']):
            return True
        user = self.get_jwt_user(request)
        if user:
            self.set_current_user_info_and_log(user)
            return True
        return False

    def is_start_with(self, request_uri):
        allowed_prefixes = ['/api', '/login', '/public']
        return any(request_uri.startswith(prefix) for prefix in allowed_prefixes)

    def get_jwt_user(self, request):
        auth_header = request.get('headers', {}).get('Authorization', None)
        if auth_header:
            token = auth_header.get('jwt', None)
            if token and token.endswith(str(datetime.date.today())):
                return auth_header.get('user', None)
        return None

    def set_current_user_info_and_log(self, user):
        # Assuming user is a dictionary with user information
        print(f""User {user.get('name')} accessed the system."")
        # Additional logging can be implemented here
```",0.169736031,0.223715787,0.4375,0.388888889,0.411764701,0.27,0.278350515,0.27411167,0.4375,0.388888889,0.411764701,,COT,0.378813621,0.442284178,0.715709729,0.732268612,0.711964827,0.568041526,0.589608637,0.573070603,0.70782726,0.731456044
GPT,10,"class BinaryDataProcessor:
    def __init__(self, binary_string):
        self.binary_string = binary_string
        self.clean_non_binary_chars()

    def clean_non_binary_chars(self):
        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))

    def calculate_binary_info(self):
        zeroes_count = self.binary_string.count('0')
        ones_count = self.binary_string.count('1')
        total_length = len(self.binary_string)

        zeroes_percentage = (zeroes_count / total_length)
        ones_percentage = (ones_count / total_length)

        return {
            'Zeroes': zeroes_percentage,
            'Ones': ones_percentage,
            'Bit length': total_length
        }

    def convert_to_ascii(self):
        byte_array = bytearray()
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            decimal = int(byte, 2)
            byte_array.append(decimal)

        return byte_array.decode('ascii')

    def convert_to_utf8(self):
        byte_array = bytearray()
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            decimal = int(byte, 2)
            byte_array.append(decimal)

        return byte_array.decode('utf-8')",COT,"```python
class BinaryDataProcessor:
    def __init__(self, binary_string):
        self.binary_string = binary_string
        self.clean_non_binary_chars()

    def clean_non_binary_chars(self):
        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))

    def calculate_binary_info(self):
        zero_count = self.binary_string.count('0')
        one_count = self.binary_string.count('1')
        total_length = len(self.binary_string)
        return {
            'Zeroes': zero_count / total_length,
            'Ones': one_count / total_length,
            'Bit length': total_length
        }

    def convert_to_ascii(self):
        ascii_string = ''
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i + 8]
            ascii_string += chr(int(byte, 2))
        return ascii_string

    def convert_to_utf8(self):
        utf8_string = ''
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i + 8]
            utf8_string += chr(int(byte, 2))
        return utf8_string
```",0.433441955,0.486359524,0.684210526,0.75,0.715596325,0.567901235,0.58974359,0.578616347,0.666666667,0.730769231,0.697247701,,COTFS,0.396573337,0.465101523,0.705128205,0.72972973,0.73417721,0.568627451,0.595744681,0.562874247,0.694915254,0.725806452
GPT,11,"class BitStatusUtil:
    @staticmethod
    def add(states, stat):
        BitStatusUtil.check([states, stat])
        return states | stat

    @staticmethod
    def has(states, stat):
        BitStatusUtil.check([states, stat])
        return (states & stat) == stat

    @staticmethod
    def remove(states, stat):
        BitStatusUtil.check([states, stat])
        if BitStatusUtil.has(states, stat):
            return states ^ stat
        return states

    @staticmethod
    def check(args):
        for arg in args:
            if arg < 0:
                raise ValueError(f""{arg} must be greater than or equal to 0"")
            if arg % 2 != 0:
                raise ValueError(f""{arg} not even"")",COT,"```python
class BitStatusUtil:
    @staticmethod
    def add(states, stat):
        BitStatusUtil.check([states, stat])
        return states | stat

    @staticmethod
    def has(states, stat):
        BitStatusUtil.check([states, stat])
        return (states & stat) == stat

    @staticmethod
    def remove(states, stat):
        BitStatusUtil.check([states, stat])
        return states & ~stat

    @staticmethod
    def check(args):
        for arg in args:
            if arg < 0:
                raise ValueError(f""{arg} not greater than or equal to 0"")
            if arg % 2 != 0:
                raise ValueError(f""{arg} not even"")
```",0.779426232,0.804076389,0.930232558,0.930232558,0.930232553,0.803571429,0.882352941,0.84112149,0.930232558,0.930232558,0.930232553,,ZS,0.088888889,0.112362046,0.710526316,0.330769231,0.44954128,0.477876106,0.188596491,0.271604935,0.703125,0.326530612
GPT,12,"import random


class BlackjackGame:
    def __init__(self):
        self.deck = self.create_deck()
        self.player_hand = []
        self.dealer_hand = []

    def create_deck(self):
        deck = []
        suits = ['S', 'C', 'D', 'H']
        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
        for suit in suits:
            for rank in ranks:
                deck.append(rank + suit)
        random.shuffle(deck)
        return deck

    def calculate_hand_value(self, hand):
        value = 0
        num_aces = 0
        for card in hand:
            rank = card[:-1]
            if rank.isdigit():
                value += int(rank)
            elif rank in ['J', 'Q', 'K']:
                value += 10
            elif rank == 'A':
                value += 11
                num_aces += 1
        while value > 21 and num_aces > 0:
            value -= 10
            num_aces -= 1
        return value

    def check_winner(self, player_hand, dealer_hand):
        player_value = self.calculate_hand_value(player_hand)
        dealer_value = self.calculate_hand_value(dealer_hand)
        if player_value > 21 and dealer_value > 21:
            if player_value <= dealer_value:
                return 'Player wins'
            else:
                return 'Dealer wins'
        elif player_value > 21:
            return 'Dealer wins'
        elif dealer_value > 21:
            return 'Player wins'
        else:
            if player_value <= dealer_value:
                return 'Dealer wins'
            else:
                return 'Player wins'",COT,"```python
class BlackjackGame:
    def __init__(self):
        self.deck = self.create_deck()
        self.player_hand = []
        self.dealer_hand = []

    def create_deck(self):
        suits = ['S', 'H', 'D', 'C']
        ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
        deck = [rank + suit for suit in suits for rank in ranks]
        import random
        random.shuffle(deck)
        return deck

    def calculate_hand_value(self, hand):
        value = 0
        aces = 0
        for card in hand:
            rank = card[:-1]
            if rank.isdigit():
                value += int(rank)
            elif rank in ['J', 'Q', 'K']:
                value += 10
            elif rank == 'A':
                value += 11
                aces += 1

        while value > 21 and aces:
            value -= 10
            aces -= 1

        return value

    def check_winner(self, player_hand, dealer_hand):
        player_value = self.calculate_hand_value(player_hand)
        dealer_value = self.calculate_hand_value(dealer_hand)

        if player_value > 21:
            return 'Dealer wins'
        elif dealer_value > 21:
            return 'Player wins'
        elif player_value > dealer_value:
            return 'Player wins'
        else:
            return 'Dealer wins'
```",0.598964848,0.639011865,0.857142857,0.86746988,0.862275444,0.75,0.777777778,0.763636359,0.857142857,0.86746988,0.862275444,,FS,0.102639296,0.122816401,0.759259259,0.310344828,0.439790572,0.543859649,0.195402299,0.283132526,0.759259259,0.310344828
GPT,13,"class BookManagement:
    def __init__(self):
        self.inventory = {}

    def add_book(self, title, quantity=1):
        if title in self.inventory:
            self.inventory[title] += quantity
        else:
            self.inventory[title] = quantity

    def remove_book(self, title, quantity):
        if title not in self.inventory or self.inventory[title] < quantity:
            raise False
        self.inventory[title] -= quantity
        if self.inventory[title] == 0:
            del (self.inventory[title])

    def view_inventory(self):
        return self.inventory

    def view_book_quantity(self, title):
        if title not in self.inventory:
            return 0
        return self.inventory[title]",COT,"```python
class BookManagement:
    def __init__(self):
        self.inventory = {}

    def add_book(self, title, quantity=1):
        if title in self.inventory:
            self.inventory[title] += quantity
        else:
            self.inventory[title] = quantity

    def remove_book(self, title, quantity):
        if title in self.inventory:
            if self.inventory[title] > quantity:
                self.inventory[title] -= quantity
            elif self.inventory[title] == quantity:
                del self.inventory[title]
            else:
                return False
        else:
            return False

    def view_inventory(self):
        return self.inventory

    def view_book_quantity(self, title):
        return self.inventory.get(title, 0)
```",0.533554006,0.602581147,0.789473684,0.833333333,0.810810806,0.672413793,0.672413793,0.672413788,0.789473684,0.833333333,0.810810806,,,,,,,,,,,,
GPT,14,"import sqlite3

class BookManagementDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS books (
                id INTEGER PRIMARY KEY,
                title TEXT,
                author TEXT,
                available INTEGER
            )
        ''')
        self.connection.commit()

    def add_book(self, title, author):
        self.cursor.execute('''
            INSERT INTO books (title, author, available)
            VALUES (?, ?, 1)
        ''', (title, author))
        self.connection.commit()

    def remove_book(self, book_id):
        self.cursor.execute('''
            DELETE FROM books WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def borrow_book(self, book_id):
        self.cursor.execute('''
            UPDATE books SET available = 0 WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def return_book(self, book_id):
        self.cursor.execute('''
            UPDATE books SET available = 1 WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def search_books(self):
        self.cursor.execute('''
            SELECT * FROM books
        ''')
        books = self.cursor.fetchall()
        return books",COT,"```python
import sqlite3

class BookManagementDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute(""""""
        CREATE TABLE IF NOT EXISTS books (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT NOT NULL,
            author TEXT NOT NULL,
            available INTEGER NOT NULL
        )
        """""")
        self.connection.commit()

    def add_book(self, title, author):
        self.cursor.execute(""INSERT INTO books (title, author, available) VALUES (?, ?, 1)"", (title, author))
        self.connection.commit()

    def remove_book(self, book_id):
        self.cursor.execute(""DELETE FROM books WHERE id = ?"", (book_id,))
        self.connection.commit()

    def borrow_book(self, book_id):
        self.cursor.execute(""UPDATE books SET available = 0 WHERE id = ?"", (book_id,))
        self.connection.commit()

    def return_book(self, book_id):
        self.cursor.execute(""UPDATE books SET available = 1 WHERE id = ?"", (book_id,))
        self.connection.commit()

    def search_books(self):
        self.cursor.execute(""SELECT * FROM books"")
        return self.cursor.fetchall()
```",0.504349691,0.557721341,0.833333333,0.774647887,0.802919703,0.696969697,0.676470588,0.686567159,0.833333333,0.774647887,0.802919703,,,,,,,,,,,,
GPT,15,"class BoyerMooreSearch:
    def __init__(self, text, pattern):
        self.text, self.pattern = text, pattern
        self.textLen, self.patLen = len(text), len(pattern)

    def match_in_pattern(self, char):
        for i in range(self.patLen - 1, -1, -1):
            if char == self.pattern[i]:
                return i
        return -1

    def mismatch_in_text(self, currentPos):
        for i in range(self.patLen - 1, -1, -1):
            if self.pattern[i] != self.text[currentPos + i]:
                return currentPos + i
        return -1

    def bad_character_heuristic(self):
        positions = []
        for i in range(self.textLen - self.patLen + 1):
            mismatch_index = self.mismatch_in_text(i)
            if mismatch_index == -1:
                positions.append(i)
            else:
                match_index = self.match_in_pattern(self.text[mismatch_index])
                i = (mismatch_index - match_index)
        return positions",COT,"```python
class BoyerMooreSearch:
    def __init__(self, text, pattern):
        self.text = text
        self.pattern = pattern
        self.textLen = len(text)
        self.patLen = len(pattern)

    def match_in_pattern(self, char):
        for i in range(self.patLen - 1, -1, -1):
            if self.pattern[i] == char:
                return i
        return -1

    def mismatch_in_text(self, currentPos):
        for i in range(self.patLen):
            if self.pattern[i] != self.text[currentPos + i]:
                return i
        return -1

    def bad_character_heuristic(self):
        positions = []
        currentPos = 0
        while currentPos <= self.textLen - self.patLen:
            mismatchIndex = self.mismatch_in_text(currentPos)
            if mismatchIndex == -1:
                positions.append(currentPos)
                currentPos += self.patLen
            else:
                charIndex = self.match_in_pattern(self.text[currentPos + mismatchIndex])
                shift = max(1, mismatchIndex - charIndex)
                currentPos += shift
        return positions
```",0.364583333,0.427278726,0.769230769,0.677966102,0.720720716,0.574712644,0.505050505,0.537634404,0.769230769,0.677966102,0.720720716,,,,,,,,,,,,
GPT,16,"class Calculator:
    def __init__(self):
        self.operators = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '/': lambda x, y: x / y,
            '^': lambda x, y: x ** y
        }

    def calculate(self, expression):
        operand_stack = []
        operator_stack = []
        num_buffer = ''

        for char in expression:
            if char.isdigit() or char == '.':
                num_buffer += char
            else:
                if num_buffer:
                    operand_stack.append(float(num_buffer))
                    num_buffer = ''

                if char in '+-*/^':
                    while (
                            operator_stack and
                            operator_stack[-1] != '(' and
                            self.precedence(operator_stack[-1]) >= self.precedence(char)
                    ):
                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

                    operator_stack.append(char)
                elif char == '(':
                    operator_stack.append(char)
                elif char == ')':
                    while operator_stack and operator_stack[-1] != '(':
                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

                    operator_stack.pop()

        if num_buffer:
            operand_stack.append(float(num_buffer))

        while operator_stack:
            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

        return operand_stack[-1] if operand_stack else None

    def precedence(self, operator):
        precedences = {
            '+': 1,
            '-': 1,
            '*': 2,
            '/': 2,
            '^': 3
        }
        return precedences.get(operator, 0)

    def apply_operator(self, operand_stack, operator_stack):
        operator = operator_stack.pop()
        if operator == '^':
            operand2 = operand_stack.pop()
            operand1 = operand_stack.pop()
            result = self.operators[operator](operand1, operand2)
            operand_stack.append(result)
        else:
            operand2 = operand_stack.pop()
            operand1 = operand_stack.pop()
            result = self.operators[operator](operand1, operand2)
            operand_stack.append(result)
        return operand_stack, operator_stack",COT,"```python
class Calculator:
    def __init__(self):
        self.operators = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '/': lambda x, y: x / y,
            '^': lambda x, y: x ** y
        }

    def calculate(self, expression):
        def precedence(op):
            if op == '+' or op == '-':
                return 1
            if op == '*' or op == '/':
                return 2
            if op == '^':
                return 3
            return 0

        def apply_operator(operand_stack, operator_stack):
            right = operand_stack.pop()
            left = operand_stack.pop()
            op = operator_stack.pop()
            operand_stack.append(self.operators[op](left, right))

        operand_stack = []
        operator_stack = []
        i = 0
        while i < len(expression):
            if expression[i].isdigit() or expression[i] == '.':
                num = ''
                while i < len(expression) and (expression[i].isdigit() or expression[i] == '.'):
                    num += expression[i]
                    i += 1
                operand_stack.append(float(num))
                i -= 1
            elif expression[i] in self.operators:
                while (operator_stack and
                       precedence(operator_stack[-1]) >= precedence(expression[i])):
                    apply_operator(operand_stack, operator_stack)
                operator_stack.append(expression[i])
            i += 1

        while operator_stack:
            apply_operator(operand_stack, operator_stack)

        return operand_stack[0] if operand_stack else None

    def precedence(self, operator):
        if operator in self.operators:
            return {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}[operator]
        return 0

    def apply_operator(self, operand_stack, operator_stack):
        right = operand_stack.pop()
        left = operand_stack.pop()
        op = operator_stack.pop()
        operand_stack.append(self.operators[op](left, right))
        return operand_stack, operator_stack
```",0.316326531,0.383854538,0.689655172,0.659340659,0.674157298,0.470198675,0.43030303,0.449367084,0.67816092,0.648351648,0.662921343,,,,,,,,,,,,
GPT,17,"from datetime import datetime, timedelta

class CalendarUtil:
    def __init__(self):
        self.events = []

    def add_event(self, event):
        self.events.append(event)

    def remove_event(self, event):
        if event in self.events:
            self.events.remove(event)

    def get_events(self, date):
        events_on_date = []
        for event in self.events:
            if event['date'].date() == date.date():
                events_on_date.append(event)
        return events_on_date

    def is_available(self, start_time, end_time):
        for event in self.events:
            if start_time < event['end_time'] and end_time > event['start_time']:
                return False
        return True

    def get_available_slots(self, date):
        available_slots = []
        start_time = datetime(date.year, date.month, date.day, 0, 0)
        end_time = datetime(date.year, date.month, date.day, 23, 59)

        while start_time < end_time:
            slot_end_time = start_time + timedelta(minutes=60)
            if self.is_available(start_time, slot_end_time):
                available_slots.append((start_time, slot_end_time))
            start_time += timedelta(minutes=60)


        return available_slots

    def get_upcoming_events(self, num_events):
        now = datetime.now()
        upcoming_events = []
        for event in self.events:
            if event['start_time'] >= now:
                upcoming_events.append(event)
            if len(upcoming_events) == num_events:
                break
        return upcoming_events",COT,"```python
from datetime import datetime, timedelta

class CalendarUtil:
    def __init__(self):
        self.events = []

    def add_event(self, event):
        self.events.append(event)

    def get_events(self, date):
        return [event for event in self.events if event['date'].date() == date.date()]

    def remove_event(self, event):
        self.events = [e for e in self.events if e != event]

    def is_available(self, start_time, end_time):
        for event in self.events:
            if event['start_time'] < end_time and start_time < event['end_time']:
                return False
        return True

    def get_available_slots(self, date):
        slots = []
        start_of_day = datetime(date.year, date.month, date.day, 0, 0)
        end_of_day = start_of_day + timedelta(days=1)
        current_time = start_of_day

        for event in sorted(self.get_events(date), key=lambda e: e['start_time']):
            if current_time < event['start_time']:
                slots.append((current_time, event['start_time']))
            current_time = max(current_time, event['end_time'])

        if current_time < end_of_day:
            slots.append((current_time, end_of_day))

        return slots

    def get_upcoming_events(self, num_events):
        sorted_events = sorted(self.events, key=lambda e: e['start_time'])
        return sorted_events[:num_events]
```",0.308974742,0.365471768,0.666666667,0.632911392,0.649350644,0.441666667,0.452991453,0.447257379,0.653333333,0.620253165,0.636363631,,,,,,,,,,,,
GPT,18,"class CamelCaseMap:
    def __init__(self):
        self._data = {}

    def __getitem__(self, key):
        return self._data[self._convert_key(key)]

    def __setitem__(self, key, value):
        self._data[self._convert_key(key)] = value

    def __delitem__(self, key):
        del self._data[self._convert_key(key)]

    def __iter__(self):
        return iter(self._data)

    def __len__(self):
        return len(self._data)

    def _convert_key(self, key):
        if isinstance(key, str):
            return self._to_camel_case(key)
        return key

    @staticmethod
    def _to_camel_case(key):
        parts = key.split('_')
        return parts[0] + ''.join(part.title() for part in parts[1:])",COT,"```python
class CamelCaseMap:
    def __init__(self):
        self._data = {}

    def __getitem__(self, key):
        camel_case_key = self._convert_key(key)
        return self._data[camel_case_key]

    def __setitem__(self, key, value):
        camel_case_key = self._convert_key(key)
        self._data[camel_case_key] = value

    def __delitem__(self, key):
        camel_case_key = self._convert_key(key)
        del self._data[camel_case_key]

    def __iter__(self):
        return iter(self._data)

    def __len__(self):
        return len(self._data)

    def _convert_key(self, key):
        return self._to_camel_case(key)

    @staticmethod
    def _to_camel_case(key):
        parts = key.split('_')
        return parts[0] + ''.join(word.capitalize() for word in parts[1:])
```",0.483333333,0.545394812,0.813953488,0.813953488,0.813953483,0.704918033,0.693548387,0.699186987,0.813953488,0.813953488,0.813953483,,,,,,,,,,,,
GPT,19,"class ChandrasekharSieve:
    def __init__(self, n):
        self.n = n
        self.primes = self.generate_primes()

    def generate_primes(self):
        if self.n < 2:
            return []

        sieve = [True] * (self.n + 1)
        sieve[0] = sieve[1] = False

        p = 2
        while p * p <= self.n:
            if sieve[p]:
                for i in range(p * p, self.n + 1, p):
                    sieve[i] = False
            p += 1

        primes = []
        for i in range(2, self.n + 1):
            if sieve[i]:
                primes.append(i)

        return primes

    def get_primes(self):
        return self.primes",COT,"```python
class ChandrasekharSieve:
    def __init__(self, n):
        self.n = n
        self.primes = self.generate_primes()

    def generate_primes(self):
        if self.n < 2:
            return []
        
        prime = [True] * (self.n + 1)
        p = 2
        while p * p <= self.n:
            if prime[p]:
                for i in range(p * p, self.n + 1, p):
                    prime[i] = False
            p += 1
        
        return [p for p in range(2, self.n + 1) if prime[p]]

    def get_primes(self):
        return self.primes
```",0.585483035,0.626724169,0.826086957,0.844444444,0.83516483,0.72,0.76056338,0.739726022,0.826086957,0.844444444,0.83516483,,,,,,,,,,,,
GPT,1,"import math


class AreaCalculator:

    def __init__(self, radius):
        self.radius = radius

    def calculate_circle_area(self):
        return math.pi * self.radius ** 2

    def calculate_sphere_area(self):
        return 4 * math.pi * self.radius ** 2

    def calculate_cylinder_area(self, height):
        return 2 * math.pi * self.radius * (self.radius + height)

    def calculate_sector_area(self, angle):
        return self.radius ** 2 * angle / 2

    def calculate_annulus_area(self, inner_radius, outer_radius):
        return math.pi * (outer_radius ** 2 - inner_radius ** 2)",COT,"```python
class AreaCalculator:
    def __init__(self, radius):
        self.radius = radius

    def calculate_circle_area(self):
        return 3.141592653589793 * self.radius * self.radius

    def calculate_sphere_area(self):
        return 4 * 3.141592653589793 * self.radius * self.radius

    def calculate_cylinder_area(self, height):
        return 2 * 3.141592653589793 * self.radius * (self.radius + height)

    def calculate_sector_area(self, angle):
        return 0.5 * self.radius * self.radius * angle

    def calculate_annulus_area(self, inner_radius, outer_radius):
        return 3.141592653589793 * (outer_radius * outer_radius - inner_radius * inner_radius)
```",0.421875,0.496950232,0.823529412,0.777777778,0.799999995,0.698113208,0.711538462,0.7047619,0.823529412,0.777777778,0.799999995,,,,,,,,,,,,
GPT,20,"from datetime import datetime

class Chat:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username in self.users:
            return False
        else:
            self.users[username] = []
            return True

    def remove_user(self, username):
        if username in self.users:
            del self.users[username]
            return True
        else:
            return False

    def send_message(self, sender, receiver, message):
        if sender not in self.users or receiver not in self.users:
            return False

        timestamp = datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
        message_info = {
            'sender': sender,
            'receiver': receiver,
            'message': message,
            'timestamp': timestamp
        }
        self.users[sender].append(message_info)
        self.users[receiver].append(message_info)
        return True

    def get_messages(self, username):
        if username not in self.users:
            return []
        return self.users[username]",COT,"```python
from datetime import datetime

class Chat:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username in self.users:
            return False
        self.users[username] = []
        return True

    def remove_user(self, username):
        if username in self.users:
            del self.users[username]
            return True
        return False

    def send_message(self, sender, receiver, message):
        if sender not in self.users or receiver not in self.users:
            return False
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        message_info = {
            'sender': sender,
            'receiver': receiver,
            'message': message,
            'timestamp': timestamp
        }
        self.users[sender].append(message_info)
        return True

    def get_messages(self, username):
        if username in self.users:
            return self.users[username]
        return []
```",0.781818973,0.820890655,0.918367347,0.918367347,0.918367342,0.858974359,0.905405405,0.881578942,0.918367347,0.918367347,0.918367342,,,,,,,,,,,,
GPT,21,"from datetime import datetime


class Classroom:
    def __init__(self, id):
        self.id = id
        self.courses = []

    def add_course(self, course):

        if course not in self.courses:
            self.courses.append(course)

    def remove_course(self, course):
        if course in self.courses:
            self.courses.remove(course)

    def is_free_at(self, check_time):
        check_time = datetime.strptime(check_time, '%H:%M')

        for course in self.courses:
            if datetime.strptime(course['start_time'], '%H:%M') <= check_time <= datetime.strptime(course['end_time'],
                                                                                                   '%H:%M'):
                return False
        return True

    def check_course_conflict(self, new_course):
        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M')
        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M')

        flag = True
        for course in self.courses:
            start_time = datetime.strptime(course['start_time'], '%H:%M')
            end_time = datetime.strptime(course['end_time'], '%H:%M')
            if start_time <= new_start_time and end_time >= new_start_time:
                flag = False
            if start_time <= new_end_time and end_time >= new_end_time:
                flag = False
        return flag",COT,"```python
class ClassRegistrationSystem:
    def __init__(self):
        self.students = []
        self.students_registration_classes = {}

    def register_student(self, student):
        for s in self.students:
            if s['name'] == student['name']:
                return 0
        self.students.append(student)
        return 1

    def register_class(self, student_name, class_name):
        if student_name not in self.students_registration_classes:
            self.students_registration_classes[student_name] = []
        if class_name not in self.students_registration_classes[student_name]:
            self.students_registration_classes[student_name].append(class_name)
        return self.students_registration_classes[student_name]

    def get_students_by_major(self, major):
        return [student['name'] for student in self.students if student['major'] == major]

    def get_all_majors(self):
        return list(set(student['major'] for student in self.students))

    def get_most_popular_class_in_major(self, major):
        class_count = {}
        students_in_major = self.get_students_by_major(major)
        for student in students_in_major:
            if student in self.students_registration_classes:
                for class_name in self.students_registration_classes[student]:
                    if class_name in class_count:
                        class_count[class_name] += 1
                    else:
                        class_count[class_name] = 1
        if not class_count:
            return None
        return max(class_count, key=class_count.get)
```",0.000934579,0.262624019,0.204081633,0.169491525,0.18518518,0.032608696,0.028846154,0.03061224,0.204081633,0.169491525,0.18518518,,,,,,,,,,,,
GPT,22,"class ClassRegistrationSystem:

    def __init__(self):
        self.students = []
        self.students_registration_classes = {}

    def register_student(self, student):
        if student in self.students:
            return 0
        else:
            self.students.append(student)
            return 1

    def register_class(self, student_name, class_name):
        if student_name in self.students_registration_classes:
            self.students_registration_classes[student_name].append(class_name)
        else:
            self.students_registration_classes[student_name] = [class_name]
        return self.students_registration_classes[student_name]

    def get_students_by_major(self, major):
        student_list = []
        for student in self.students:
            if student[""major""] == major:
                student_list.append(student[""name""])
        return student_list

    def get_all_major(self):
        major_list = []
        for student in self.students:
            if student[""major""] not in major_list:
                major_list.append(student[""major""])
        return major_list

    def get_most_popular_class_in_major(self, major):
        class_list = []
        for student in self.students:
            if student[""major""] == major:
                class_list += self.students_registration_classes[student[""name""]]
        most_popular_class = max(set(class_list), key=class_list.count)
        return most_popular_class",COT,"```python
from datetime import datetime

class Classroom:
    def __init__(self, id):
        self.id = id
        self.courses = []

    def add_course(self, course):
        if course not in self.courses:
            self.courses.append(course)

    def remove_course(self, course):
        if course in self.courses:
            self.courses.remove(course)

    def is_free_at(self, check_time):
        check_time = datetime.strptime(check_time, '%H:%M')
        for course in self.courses:
            start_time = datetime.strptime(course['start_time'], '%H:%M')
            end_time = datetime.strptime(course['end_time'], '%H:%M')
            if start_time <= check_time < end_time:
                return False
        return True

    def check_course_conflict(self, new_course):
        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M')
        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M')
        for course in self.courses:
            start_time = datetime.strptime(course['start_time'], '%H:%M')
            end_time = datetime.strptime(course['end_time'], '%H:%M')
            if not (new_end_time <= start_time or new_start_time >= end_time):
                return False
        return True
```",0.001030928,0.278062025,0.2,0.196078431,0.198019797,0.035714286,0.036585366,0.036144573,0.2,0.196078431,0.198019797,,,,,,,,,,,,
GPT,23,"import math
from typing import List

class CombinationCalculator:
    def __init__(self, datas: List[str]):
        self.datas = datas

    @staticmethod
    def count(n: int, m: int) -> int:
        if m == 0 or n == m:
            return 1
        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))

    @staticmethod
    def count_all(n: int) -> int:
        if n < 0 or n > 63:
            return False
        return (1 << n) - 1 if n != 63 else float(""inf"")

    def select(self, m: int) -> List[List[str]]:
        result = []
        self._select(0, [None] * m, 0, result)
        return result

    def select_all(self) -> List[List[str]]:
        result = []
        for i in range(1, len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):
        resultLen = len(resultList)
        resultCount = resultIndex + 1
        if resultCount > resultLen:
            result.append(resultList.copy())
            return

        for i in range(dataIndex, len(self.datas) + resultCount - resultLen):
            resultList[resultIndex] = self.datas[i]
            self._select(i + 1, resultList, resultIndex + 1, result)",COT,"```python
import math
from typing import List

class CombinationCalculator:
    def __init__(self, datas: List[str]):
        self.datas = datas

    @staticmethod
    def count(n: int, m: int) -> int:
        if m > n:
            return 0
        return math.comb(n, m)

    @staticmethod
    def count_all(n: int) -> int:
        total = sum(math.comb(n, i) for i in range(1, n + 1))
        return total if total <= (2**63 - 1) else float(""inf"")

    def select(self, m: int) -> List[List[str]]:
        result = []
        self._select(0, [None] * m, 0, result)
        return result

    def select_all(self) -> List[List[str]]:
        result = []
        for m in range(1, len(self.datas) + 1):
            result.extend(self.select(m))
        return result

    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):
        if resultIndex == len(resultList):
            result.append(resultList.copy())
            return
        for i in range(dataIndex, len(self.datas)):
            resultList[resultIndex] = self.datas[i]
            self._select(i + 1, resultList, resultIndex + 1, result)
```",0.546747923,0.582521629,0.766666667,0.831325301,0.797687856,0.613138686,0.682926829,0.646153841,0.755555556,0.819277108,0.786127163,,,,,,,,,,,,
GPT,24,"class ComplexCalculator:
    def __init__(self):
        pass

    @staticmethod
    def add(c1, c2):
        real = c1.real + c2.real
        imaginary = c1.imag + c2.imag
        answer = complex(real, imaginary)
        return answer
    
    @staticmethod
    def subtract(c1, c2):
        real = c1.real - c2.real
        imaginary = c1.imag - c2.imag
        return complex(real, imaginary)
    
    @staticmethod
    def multiply(c1, c2):
        real = c1.real * c2.real - c1.imag * c2.imag
        imaginary = c1.real * c2.imag + c1.imag * c2.real
        return complex(real, imaginary)
    
    @staticmethod
    def divide(c1, c2):
        denominator = c2.real**2 + c2.imag**2
        real = (c1.real * c2.real + c1.imag * c2.imag) / denominator
        imaginary = (c1.imag * c2.real - c1.real * c2.imag) / denominator
        return complex(real, imaginary)",COT,"```python
class ComplexCalculator:
    def __init__(self):
        pass

    @staticmethod
    def add(c1, c2):
        return c1 + c2

    @staticmethod
    def subtract(c1, c2):
        return c1 - c2

    @staticmethod
    def multiply(c1, c2):
        return c1 * c2

    @staticmethod
    def divide(c1, c2):
        return c1 / c2
```",0.071667913,0.084334101,0.6,0.9,0.719999995,0.278688525,0.62962963,0.386363632,0.6,0.9,0.719999995,,,,,,,,,,,,
GPT,25,"import json

class CookiesUtil:
    def __init__(self, cookies_file):
        self.cookies_file = cookies_file
        self.cookies = None

    def get_cookies(self, reponse):
        self.cookies = reponse['cookies']
        self._save_cookies()

    def load_cookies(self):
        try:
            with open(self.cookies_file, 'r') as file:
                cookies_data = json.load(file)
                return cookies_data
        except FileNotFoundError:
            return {}

    def _save_cookies(self):
        try:
            with open(self.cookies_file, 'w') as file:
                json.dump(self.cookies, file)
            return True
        except:
            return False

    def set_cookies(self, request):
        request['cookies'] = '; '.join([f'{key}={value}' for key, value in self.cookies.items()])",COT,"```python
import json

class CookiesUtil:
    def __init__(self, cookies_file):
        self.cookies_file = cookies_file
        self.cookies = None

    def get_cookies(self, response):
        self.cookies = response.get('cookies', {})
        self._save_cookies()

    def load_cookies(self):
        try:
            with open(self.cookies_file, 'r') as f:
                self.cookies = json.load(f)
        except FileNotFoundError:
            self.cookies = {}
        return self.cookies

    def _save_cookies(self):
        try:
            with open(self.cookies_file, 'w') as f:
                json.dump(self.cookies, f)
            return True
        except Exception:
            return False
```",0.385934979,0.45632675,0.632653061,0.756097561,0.688888884,0.514705882,0.603448276,0.555555551,0.632653061,0.756097561,0.688888884,,,,,,,,,,,,
GPT,26,"import csv


class CSVProcessor:

    def __init__(self):
        pass

    def read_csv(self, file_name):
        data = []
        with open(file_name, 'r') as file:
            reader = csv.reader(file)
            title = next(reader)
            for row in reader:
                data.append(row)
        return title, data

    def write_csv(self, data, file_name):
        try:
            with open(file_name, 'w', newline='') as file:
                writer = csv.writer(file)
                writer.writerows(data)
            return 1
        except:
            return 0

    def process_csv_data(self, N, save_file_name):
        title, data = self.read_csv(save_file_name)
        column_data = [row[N] for row in data]
        column_data = [row.upper() for row in column_data]
        new_data = [title, column_data]
        return self.write_csv(new_data, save_file_name.split('.')[0] + '_process.csv')",COT,"```python
import csv

class CSVProcessor:
    def __init__(self):
        pass

    def read_csv(self, file_name):
        with open(file_name, mode='r', newline='', encoding='utf-8') as file:
            reader = csv.reader(file)
            data = list(reader)
            title = data[0]
            data = data[1:]
        return title, data

    def write_csv(self, data, file_name):
        try:
            with open(file_name, mode='w', newline='', encoding='utf-8') as file:
                writer = csv.writer(file)
                writer.writerows(data)
            return 1
        except Exception as e:
            return 0

    def process_csv_data(self, N, save_file_name):
        try:
            title, data = self.read_csv(save_file_name)
            new_data = [[row[N].upper()] for row in data]
            new_file_name = save_file_name.replace('.csv', '_process.csv')
            self.write_csv([title] + new_data, new_file_name)
            return 1
        except Exception as e:
            return 0
```",0.375,0.438393588,0.711864407,0.677419355,0.694214871,0.536585366,0.530120482,0.533333328,0.711864407,0.677419355,0.694214871,,,,,,,,,,,,
GPT,27,"class CurrencyConverter:
    def __init__(self):
        self.rates = {
            'USD': 1.0,
            'EUR': 0.85,
            'GBP': 0.72,
            'JPY': 110.15,
            'CAD': 1.23,
            'AUD': 1.34,
            'CNY': 6.40,
        }

    def convert(self, amount, from_currency, to_currency):
        if from_currency == to_currency:
            return amount

        if from_currency not in self.rates or to_currency not in self.rates:
            return False

        from_rate = self.rates[from_currency]
        to_rate = self.rates[to_currency]

        converted_amount = (amount / from_rate) * to_rate
        return converted_amount

    def get_supported_currencies(self):
        return list(self.rates.keys())

    def add_currency_rate(self, currency, rate):
        if currency in self.rates:
            return False
        self.rates[currency] = rate

    def update_currency_rate(self, currency, new_rate):
        if currency not in self.rates:
            return False
        self.rates[currency] = new_rate",COT,"```python
class CurrencyConverter:
    def __init__(self):
        self.rates = {
            'USD': 1.0,
            'EUR': 0.85,
            'GBP': 0.72,
            'JPY': 110.15,
            'CAD': 1.23,
            'AUD': 1.34,
            'CNY': 6.40,
        }

    def convert(self, amount, from_currency, to_currency):
        if from_currency not in self.rates or to_currency not in self.rates:
            return None
        usd_amount = amount / self.rates[from_currency]
        converted_amount = usd_amount * self.rates[to_currency]
        return converted_amount

    def get_supported_currencies(self):
        return list(self.rates.keys())

    def add_currency_rate(self, currency, rate):
        if currency in self.rates:
            return False
        self.rates[currency] = rate

    def update_currency_rate(self, currency, new_rate):
        if currency not in self.rates:
            return False
        self.rates[currency] = new_rate
```",0.751743607,0.778286877,0.90625,0.935483871,0.920634916,0.811111111,0.848837209,0.82954545,0.90625,0.935483871,0.920634916,,,,,,,,,,,,
GPT,28,"import sqlite3
import pandas as pd


class DatabaseProcessor:

    def __init__(self, database_name):
        self.database_name = database_name

    def create_table(self, table_name, key1, key2):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        create_table_query = f""CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)""
        cursor.execute(create_table_query)

        conn.commit()
        conn.close()

    def insert_into_database(self, table_name, data):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        for item in data:
            insert_query = f""INSERT INTO {table_name} (name, age) VALUES (?, ?)""
            cursor.execute(insert_query, (item['name'], item['age']))

        conn.commit()
        conn.close()

    def search_database(self, table_name, name):

        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        select_query = f""SELECT * FROM {table_name} WHERE name = ?""
        cursor.execute(select_query, (name,))
        result = cursor.fetchall()

        if result:
            return result
        else:
            return None

    def delete_from_database(self, table_name, name):

        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        delete_query = f""DELETE FROM {table_name} WHERE name = ?""
        cursor.execute(delete_query, (name,))

        conn.commit()
        conn.close()",COT,"```python
import sqlite3
import pandas as pd

class DatabaseProcessor:
    def __init__(self, database_name):
        self.database_name = database_name

    def create_table(self, table_name, key1, key2):
        with sqlite3.connect(self.database_name) as conn:
            cursor = conn.cursor()
            cursor.execute(f'''
                CREATE TABLE IF NOT EXISTS {table_name} (
                    id INTEGER PRIMARY KEY,
                    {key1} TEXT,
                    {key2} INTEGER
                )
            ''')
            conn.commit()

    def insert_into_database(self, table_name, data):
        with sqlite3.connect(self.database_name) as conn:
            cursor = conn.cursor()
            for row in data:
                columns = ', '.join(row.keys())
                placeholders = ', '.join('?' * len(row))
                values = tuple(row.values())
                cursor.execute(f'''
                    INSERT INTO {table_name} ({columns})
                    VALUES ({placeholders})
                ''', values)
            conn.commit()

    def search_database(self, table_name, name):
        with sqlite3.connect(self.database_name) as conn:
            cursor = conn.cursor()
            cursor.execute(f'''
                SELECT * FROM {table_name}
                WHERE name = ?
            ''', (name,))
            return cursor.fetchall()

    def delete_from_database(self, table_name, name):
        with sqlite3.connect(self.database_name) as conn:
            cursor = conn.cursor()
            cursor.execute(f'''
                DELETE FROM {table_name}
                WHERE name = ?
            ''', (name,))
            conn.commit()
```",0.325581395,0.383850844,0.64556962,0.62962963,0.637499995,0.464285714,0.47706422,0.47058823,0.632911392,0.617283951,0.624999995,,,,,,,,,,,,
GPT,29,"from collections import Counter


class DataStatistics:
    def mean(self, data):
        return round(sum(data) / len(data), 2)

    def median(self, data):
        sorted_data = sorted(data)
        n = len(sorted_data)
        if n % 2 == 0:
            middle = n // 2
            return round((sorted_data[middle - 1] + sorted_data[middle]) / 2, 2)
        else:
            middle = n // 2
            return sorted_data[middle]

    def mode(self, data):
        counter = Counter(data)
        mode_count = max(counter.values())
        mode = [x for x, count in counter.items() if count == mode_count]
        return mode",COT,"```python
from collections import Counter

class DataStatistics:
    
    def mean(self, data):
        return round(sum(data) / len(data), 2)

    def median(self, data):
        sorted_data = sorted(data)
        n = len(sorted_data)
        mid = n // 2
        if n % 2 == 0:
            return round((sorted_data[mid - 1] + sorted_data[mid]) / 2, 2)
        else:
            return round(sorted_data[mid], 2)

    def mode(self, data):
        data_count = Counter(data)
        max_count = max(data_count.values())
        modes = [key for key, value in data_count.items() if value == max_count]
        return modes
```",0.43072484,0.489972308,0.755102041,0.725490196,0.739999995,0.557142857,0.541666667,0.54929577,0.734693878,0.705882353,0.719999995,,,,,,,,,,,,
GPT,2,"class ArgumentParser:
    def __init__(self):
        self.arguments = {}
        self.required = set()
        self.types = {}

    def parse_arguments(self, command_string):
        args = command_string.split()[1:]
        for i in range(len(args)):
            arg = args[i]
            if arg.startswith('--'):
                key_value = arg[2:].split('=')
                if len(key_value) == 2:
                    self.arguments[key_value[0]] = self._convert_type(key_value[0], key_value[1])
                else:
                    self.arguments[key_value[0]] = True
            elif arg.startswith('-'):
                key = arg[1:]
                if i + 1 < len(args) and not args[i + 1].startswith('-'):
                    self.arguments[key] = self._convert_type(key, args[i + 1])
                else:
                    self.arguments[key] = True
        missing_args = self.required - set(self.arguments.keys())
        if missing_args:
            return False, missing_args

        return True, None

    def get_argument(self, key):
        return self.arguments.get(key)

    def add_argument(self, arg, required=False, arg_type=str):
        if required:
            self.required.add(arg)
        self.types[arg] = arg_type

    def _convert_type(self, arg, value):
        try:
            return self.types[arg](value)
        except (ValueError, KeyError):
            return value",COT,"```python
class ArgumentParser:
    def __init__(self):
        self.arguments = {}
        self.required = set()
        self.types = {}

    def parse_arguments(self, command_string):
        args = command_string.split()
        missing_args = set(self.required)
        for i in range(len(args)):
            if args[i].startswith('--'):
                key, value = args[i][2:].split('=')
                self.arguments[key] = self._convert_type(key, value)
                missing_args.discard(key)
            elif args[i].startswith('-'):
                key = args[i][1:]
                if i + 1 < len(args) and not args[i + 1].startswith('-'):
                    self.arguments[key] = self._convert_type(key, args[i + 1])
                    missing_args.discard(key)
                else:
                    self.arguments[key] = True
                    missing_args.discard(key)
        if missing_args:
            return False, missing_args
        return True, None

    def get_argument(self, key):
        return self.arguments.get(key)

    def add_argument(self, arg, required=False, arg_type=str):
        if required:
            self.required.add(arg)
        self.types[arg] = arg_type

    def _convert_type(self, arg, value):
        try:
            return self.types[arg](value)
        except (ValueError, KeyError):
            return value
```",0.638281942,0.676683561,0.833333333,0.878378378,0.855263153,0.720338983,0.758928571,0.73913043,0.833333333,0.878378378,0.855263153,,,,,,,,,,,,
GPT,30,"import numpy as np


class DataStatistics2:
    def __init__(self, data):
        self.data = np.array(data)

    def get_sum(self):
        return np.sum(self.data)

    def get_min(self):
        return np.min(self.data)

    def get_max(self):
        return np.max(self.data)

    def get_variance(self):
        return round(np.var(self.data), 2)

    def get_std_deviation(self):
        return round(np.std(self.data), 2)

    def get_correlation(self):
        return np.corrcoef(self.data, rowvar=False)",COT,"```python
import numpy as np

class DataStatistics2:
    def __init__(self, data):
        self.data = np.array(data)

    def get_sum(self):
        return float(np.sum(self.data))

    def get_min(self):
        return float(np.min(self.data))

    def get_max(self):
        return float(np.max(self.data))

    def get_variance(self):
        return float(np.var(self.data, ddof=0))

    def get_std_deviation(self):
        return float(np.std(self.data, ddof=0))

    def get_correlation(self):
        return float(np.corrcoef(self.data)[0, 1])
```",0.461538462,0.502948537,0.84375,0.794117647,0.818181813,0.590909091,0.577777778,0.584269658,0.84375,0.794117647,0.818181813,,,,,,,,,,,,
GPT,31,"import math

class DataStatistics4:

    @staticmethod
    def correlation_coefficient(data1, data2):
        n = len(data1)
        mean1 = sum(data1) / n
        mean2 = sum(data2) / n

        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))
        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n))) * math.sqrt(sum((data2[i] - mean2) ** 2 for i in range(n)))

        return numerator / denominator if denominator != 0 else 0
    
    @staticmethod
    def skewness(data):
        n = len(data)
        mean = sum(data) / n
        variance = sum((x - mean) ** 2 for x in data) / n
        std_deviation = math.sqrt(variance)

        skewness = sum((x - mean) ** 3 for x in data) * n / ((n - 1) * (n - 2) * std_deviation ** 3) if std_deviation != 0 else 0

        return skewness
    
    @staticmethod
    def kurtosis(data):

        n = len(data)
        mean = sum(data) / n
        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / n)

        if std_dev == 0:
            return math.nan

        centered_data = [(x - mean) for x in data]
        fourth_moment = sum(x ** 4 for x in centered_data) / n

        kurtosis_value = (fourth_moment / std_dev ** 4) - 3

        return kurtosis_value
    
    @staticmethod
    def pdf(data, mu, sigma):
        pdf_values = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]
        return pdf_values",COT,"```python
import math

class DataStatistics4:
    @staticmethod
    def correlation_coefficient(data1, data2):
        n = len(data1)
        sum1 = sum(data1)
        sum2 = sum(data2)
        sum1_sq = sum(pow(val, 2) for val in data1)
        sum2_sq = sum(pow(val, 2) for val in data2)
        p_sum = sum(data1[i] * data2[i] for i in range(n))
        num = p_sum - (sum1 * sum2 / n)
        den = math.sqrt((sum1_sq - pow(sum1, 2) / n) * (sum2_sq - pow(sum2, 2) / n))
        if den == 0: return 0
        return num / den

    @staticmethod
    def skewness(data):
        n = len(data)
        mean = sum(data) / n
        m3 = sum((x - mean) ** 3 for x in data) / n
        m2 = sum((x - mean) ** 2 for x in data) / n
        if m2 == 0: return 0
        return m3 / m2 ** 1.5

    @staticmethod
    def kurtosis(data):
        n = len(data)
        mean = sum(data) / n
        m4 = sum((x - mean) ** 4 for x in data) / n
        m2 = sum((x - mean) ** 2 for x in data) / n
        if m2 == 0: return 0
        return m4 / m2 ** 2 - 3

    @staticmethod
    def pdf(data, mu, sigma):
        return [(1 / (sigma * math.sqrt(2 * math.pi))) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]
```",0.354824785,0.427553053,0.593023256,0.653846154,0.621951215,0.389221557,0.460992908,0.422077917,0.569767442,0.628205128,0.597560971,,,,,,,,,,,,
GPT,32,"class DecryptionUtils:
    def __init__(self, key):
        self.key = key
    
    def caesar_decipher(self, ciphertext, shift):
        plaintext = """"
        for char in ciphertext:
            if char.isalpha():
                if char.isupper():
                    ascii_offset = 65
                else:
                    ascii_offset = 97
                shifted_char = chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)
                plaintext += shifted_char
            else:
                plaintext += char
        return plaintext
    
    def vigenere_decipher(self, ciphertext):
        decrypted_text = """"
        key_index = 0
        for char in ciphertext:
            if char.isalpha():
                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')
                decrypted_char = chr((ord(char.lower()) - ord('a') - shift) % 26 + ord('a'))
                decrypted_text += decrypted_char.upper() if char.isupper() else decrypted_char
                key_index += 1
            else:
                decrypted_text += char
        return decrypted_text
    
    def rail_fence_decipher(self, encrypted_text, rails):
        fence = [['\n' for _ in range(len(encrypted_text))] for _ in range(rails)]
        direction = -1
        row, col = 0, 0

        for _ in range(len(encrypted_text)):
            if row == 0 or row == rails - 1:
                direction = -direction

            fence[row][col] = ''
            col += 1
            row += direction

        index = 0
        for i in range(rails):
            for j in range(len(encrypted_text)):
                if fence[i][j] == '':
                    fence[i][j] = encrypted_text[index]
                    index += 1

        plain_text = ''
        direction = -1
        row, col = 0, 0
        for _ in range(len(encrypted_text)):
            if row == 0 or row == rails - 1:
                direction = -direction

            plain_text += fence[row][col]
            col += 1
            row += direction

        return plain_text",COT,"```python
class DecryptionUtils:
    def __init__(self, key):
        self.key = key

    def caesar_decipher(self, ciphertext, shift):
        plaintext = ''
        for char in ciphertext:
            if char.isalpha():
                shift_amount = shift % 26
                shifted = ord(char) - shift_amount
                if char.islower() and shifted < ord('a'):
                    shifted += 26
                elif char.isupper() and shifted < ord('A'):
                    shifted += 26
                plaintext += chr(shifted)
            else:
                plaintext += char
        return plaintext

    def vigenere_decipher(self, ciphertext):
        plaintext = ''
        key_index = 0
        for char in ciphertext:
            if char.isalpha():
                shift_amount = ord(self.key[key_index % len(self.key)].lower()) - ord('a')
                shifted = ord(char) - shift_amount
                if char.islower() and shifted < ord('a'):
                    shifted += 26
                elif char.isupper() and shifted < ord('A'):
                    shifted += 26
                plaintext += chr(shifted)
                key_index += 1
            else:
                plaintext += char
        return plaintext

    def rail_fence_decipher(self, encrypted_text, rails):
        if rails == 1:
            return encrypted_text

        n = len(encrypted_text)
        rail = [['\n' for _ in range(n)] for _ in range(rails)]
        dir_down = None
        row, col = 0, 0

        for _ in range(n):
            if row == 0:
                dir_down = True
            if row == rails - 1:
                dir_down = False
            rail[row][col] = '*'
            col += 1
            row += 1 if dir_down else -1

        index = 0
        for i in range(rails):
            for j in range(n):
                if rail[i][j] == '*' and index < n:
                    rail[i][j] = encrypted_text[index]
                    index += 1

        result = []
        row, col = 0, 0
        for _ in range(n):
            if row == 0:
                dir_down = True
            if row == rails - 1:
                dir_down = False
            if rail[row][col] != '\n':
                result.append(rail[row][col])
                col += 1
            row += 1 if dir_down else -1
        return ''.join(result)
```",0.324,0.376808327,0.698795181,0.637362637,0.666666662,0.487012987,0.454545455,0.470219431,0.674698795,0.615384615,0.643678156,,,,,,,,,,,,
GPT,33,"class DiscountStrategy:
    def __init__(self, customer, cart, promotion=None):
        self.customer = customer
        self.cart = cart
        self.promotion = promotion
        self.__total = self.total()

    def total(self):
        self.__total = sum(item['quantity'] * item['price'] for item in self.cart)
        return self.__total

    def due(self):
        if self.promotion is None:
            discount = 0
        else:
            discount = self.promotion(self)
        return self.__total - discount

    @staticmethod
    def FidelityPromo(order):
        return order.total() * 0.05 if order.customer['fidelity'] >= 1000 else 0

    @staticmethod
    def BulkItemPromo(order):
        discount = 0
        for item in order.cart:
            if item['quantity'] >= 20:
                discount += item['quantity'] * item['price'] * 0.1
        return discount

    @staticmethod
    def LargeOrderPromo(order):
        return order.total() * 0.07 if len({item['product'] for item in order.cart}) >= 10 else 0",COT,"```python
class DiscountStrategy:
    def __init__(self, customer, cart, promotion=None):
        self.customer = customer
        self.cart = cart
        self.promotion = promotion
        self.total()

    def total(self):
        return sum(item['quantity'] * item['price'] for item in self.cart)

    def due(self):
        if self.promotion is None:
            discount = 0
        else:
            discount = self.promotion(self)
        return self.total() - discount

    @staticmethod
    def FidelityPromo(order):
        return order.total() * 0.05 if order.customer['fidelity'] > 1000 else 0

    @staticmethod
    def BulkItemPromo(order):
        discount = 0
        for item in order.cart:
            if item['quantity'] >= 20:
                discount += item['quantity'] * item['price'] * 0.1
        return discount

    @staticmethod
    def LargeOrderPromo(order):
        distinct_items = {item['product'] for item in order.cart}
        if len(distinct_items) >= 10:
            return order.total() * 0.07
        return 0
```",0.71,0.751388025,0.921568627,0.854545455,0.886792448,0.821052632,0.795918367,0.80829015,0.921568627,0.854545455,0.886792448,,,,,,,,,,,,
GPT,34,"from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT


class DocFileHandler:
    def __init__(self, file_path):
        self.file_path = file_path

    def read_text(self):
        doc = Document(self.file_path)
        text = []
        for paragraph in doc.paragraphs:
            text.append(paragraph.text)
        return ""\n"".join(text)

    def write_text(self, content, font_size=12, alignment='left'):
        try:
            doc = Document()
            paragraph = doc.add_paragraph()
            run = paragraph.add_run(content)
            font = run.font
            font.size = Pt(font_size)
            alignment_value = self._get_alignment_value(alignment)
            paragraph.alignment = alignment_value
            doc.save(self.file_path)
            return True
        except:
            return False

    def add_heading(self, heading, level=1):
        try:
            doc = Document(self.file_path)
            doc.add_heading(heading, level)
            doc.save(self.file_path)
            return True
        except:
            return False

    def add_table(self, data):
        try:
            doc = Document(self.file_path)
            table = doc.add_table(rows=len(data), cols=len(data[0]))
            for i, row in enumerate(data):
                for j, cell_value in enumerate(row):
                    table.cell(i, j).text = str(cell_value)
            doc.save(self.file_path)
            return True
        except:
            return False

    def _get_alignment_value(self, alignment):
        alignment_options = {
            'left': WD_PARAGRAPH_ALIGNMENT.LEFT,
            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,
            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT
        }
        return alignment_options.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)",COT,"```python
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT

class DocFileHandler:
    def __init__(self, file_path):
        self.file_path = file_path

    def read_text(self):
        document = Document(self.file_path)
        full_text = []
        for paragraph in document.paragraphs:
            full_text.append(paragraph.text)
        return '\n'.join(full_text)

    def write_text(self, content, font_size=12, alignment='left'):
        try:
            document = Document()
            paragraph = document.add_paragraph(content)
            run = paragraph.runs[0]
            run.font.size = Pt(font_size)
            paragraph.alignment = self._get_alignment_value(alignment)
            document.save(self.file_path)
            return True
        except Exception as e:
            print(f""Error writing text: {e}"")
            return False

    def add_heading(self, heading, level=1):
        try:
            document = Document(self.file_path)
            document.add_heading(heading, level=level)
            document.save(self.file_path)
            return True
        except Exception as e:
            print(f""Error adding heading: {e}"")
            return False

    def add_table(self, data):
        try:
            document = Document(self.file_path)
            table = document.add_table(rows=1, cols=len(data[0]))
            hdr_cells = table.rows[0].cells
            for i, heading in enumerate(data[0]):
                hdr_cells[i].text = heading
            for row_data in data[1:]:
                row_cells = table.add_row().cells
                for i, item in enumerate(row_data):
                    row_cells[i].text = item
            document.save(self.file_path)
            return True
        except Exception as e:
            print(f""Error adding table: {e}"")
            return False

    def _get_alignment_value(self, alignment):
        if alignment == 'center':
            return WD_PARAGRAPH_ALIGNMENT.CENTER
        elif alignment == 'right':
            return WD_PARAGRAPH_ALIGNMENT.RIGHT
        else:
            return WD_PARAGRAPH_ALIGNMENT.LEFT
```",0.26875,0.334975028,0.686746988,0.587628866,0.633333328,0.507462687,0.450331126,0.477192977,0.686746988,0.587628866,0.633333328,,,,,,,,,,,,
GPT,35,"class EightPuzzle:
    def __init__(self, initial_state):
        self.initial_state = initial_state
        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

    def find_blank(self, state):
        for i in range(3):
            for j in range(3):
                if state[i][j] == 0:
                    return i, j

    def move(self, state, direction):
        i, j = self.find_blank(state)
        new_state = [row[:] for row in state]

        if direction == 'up':
            new_state[i][j], new_state[i - 1][j] = new_state[i - 1][j], new_state[i][j]
        elif direction == 'down':
            new_state[i][j], new_state[i + 1][j] = new_state[i + 1][j], new_state[i][j]
        elif direction == 'left':
            new_state[i][j], new_state[i][j - 1] = new_state[i][j - 1], new_state[i][j]
        elif direction == 'right':
            new_state[i][j], new_state[i][j + 1] = new_state[i][j + 1], new_state[i][j]

        return new_state

    def get_possible_moves(self, state):
        moves = []
        i, j = self.find_blank(state)

        if i > 0:
            moves.append('up')
        if i < 2:
            moves.append('down')
        if j > 0:
            moves.append('left')
        if j < 2:
            moves.append('right')

        return moves

    def solve(self):
        open_list = [(self.initial_state, [])]
        closed_list = []

        while open_list:
            current_state, path = open_list.pop(0)
            closed_list.append(current_state)

            if current_state == self.goal_state:
                return path

            for move in self.get_possible_moves(current_state):
                new_state = self.move(current_state, move)
                if new_state not in closed_list:
                    open_list.append((new_state, path + [move]))

        return None",COT,"```python
class EightPuzzle:
    def __init__(self, initial_state):
        self.initial_state = initial_state
        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

    def find_blank(self, state):
        for i in range(3):
            for j in range(3):
                if state[i][j] == 0:
                    return i, j

    def move(self, state, direction):
        i, j = self.find_blank(state)
        new_state = [row[:] for row in state]

        if direction == 'up' and i > 0:
            new_state[i][j], new_state[i-1][j] = new_state[i-1][j], new_state[i][j]
        elif direction == 'down' and i < 2:
            new_state[i][j], new_state[i+1][j] = new_state[i+1][j], new_state[i][j]
        elif direction == 'left' and j > 0:
            new_state[i][j], new_state[i][j-1] = new_state[i][j-1], new_state[i][j]
        elif direction == 'right' and j < 2:
            new_state[i][j], new_state[i][j+1] = new_state[i][j+1], new_state[i][j]

        return new_state

    def get_possible_moves(self, state):
        i, j = self.find_blank(state)
        moves = []

        if i > 0:
            moves.append('up')
        if i < 2:
            moves.append('down')
        if j > 0:
            moves.append('left')
        if j < 2:
            moves.append('right')

        return moves

    def solve(self):
        from collections import deque

        open_list = deque([(self.initial_state, [])])
        visited = set()

        while open_list:
            current_state, path = open_list.popleft()

            if current_state == self.goal_state:
                return path

            visited.add(tuple(tuple(row) for row in current_state))

            for move in self.get_possible_moves(current_state):
                new_state = self.move(current_state, move)

                if tuple(tuple(row) for row in new_state) not in visited:
                    open_list.append((new_state, path + [move]))

        return None
```",0.554973822,0.597140289,0.806818182,0.71,0.755319144,0.704402516,0.658823529,0.680851059,0.806818182,0.71,0.755319144,,,,,,,,,,,,
GPT,36,"from datetime import datetime

class EmailClient:
    def __init__(self, addr, capacity) -> None:
        self.addr = addr
        self.capacity = capacity
        self.inbox = []
    
    def send_to(self, recv, content, size):
        if not recv.is_full_with_one_more_email(size):
            timestamp = datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
            email = {
                ""sender"": self.addr,
                ""receiver"": recv.addr,
                ""content"": content,
                ""size"": size,
                ""time"": timestamp,
                ""state"": ""unread""
            }
            recv.inbox.append(email)
            return True
        else:
            self.clear_inbox(size)
            return False
    
    def fetch(self):
        if len(self.inbox) == 0:
            return None
        for i in range(len(self.inbox)):
            if self.inbox[i]['state'] == ""unread"":
                self.inbox[i]['state'] = ""read""
                return self.inbox[i]
        return None

    def is_full_with_one_more_email(self, size):
        occupied_size = self.get_occupied_size()
        return True if occupied_size + size > self.capacity else False
        
    def get_occupied_size(self):
        occupied_size = 0
        for email in self.inbox:
            occupied_size += email[""size""]
        return occupied_size

    def clear_inbox(self, size):
        if len(self.addr) == 0:
            return
        freed_space = 0
        while freed_space < size and self.inbox:
            email = self.inbox[0]
            freed_space += email['size']
            del self.inbox[0]",COT,"```python
from datetime import datetime

class EmailClient:
    def __init__(self, addr, capacity):
        self.addr = addr
        self.capacity = capacity
        self.inbox = []

    def send_to(self, recv, content, size):
        if recv.is_full_with_one_more_email(size):
            return False
        email = {
            'sender': self.addr,
            'receiver': recv.addr,
            'content': content,
            'size': size,
            'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'state': 'unread'
        }
        recv.inbox.append(email)
        return True

    def fetch(self):
        for email in self.inbox:
            if email['state'] == 'unread':
                email['state'] = 'read'
                return email
        return None

    def is_full_with_one_more_email(self, size):
        return self.get_occupied_size() + size > self.capacity

    def get_occupied_size(self):
        return sum(email['size'] for email in self.inbox)

    def clear_inbox(self, size):
        while self.is_full_with_one_more_email(size):
            self.inbox.pop(0)
```",0.216051495,0.262764458,0.542168675,0.725806452,0.62068965,0.382978723,0.534653465,0.446280987,0.542168675,0.725806452,0.62068965,,,,,,,,,,,,
GPT,37,"class EncryptionUtils:
    def __init__(self, key):
        self.key = key

    def caesar_cipher(self, plaintext, shift):
        ciphertext = """"
        for char in plaintext:
            if char.isalpha():
                if char.isupper():
                    ascii_offset = 65
                else:
                    ascii_offset = 97
                shifted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)
                ciphertext += shifted_char
            else:
                ciphertext += char
        return ciphertext
    
    def vigenere_cipher(self, plain_text):
        encrypted_text = """"
        key_index = 0
        for char in plain_text:
            if char.isalpha():
                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')
                encrypted_char = chr((ord(char.lower()) - ord('a') + shift) % 26 + ord('a'))
                encrypted_text += encrypted_char.upper() if char.isupper() else encrypted_char
                key_index += 1
            else:
                encrypted_text += char
        return encrypted_text

    def rail_fence_cipher(self, plain_text, rails):
        fence = [['\n' for _ in range(len(plain_text))] for _ in range(rails)]
        direction = -1
        row, col = 0, 0

        for char in plain_text:
            if row == 0 or row == rails-1:
                direction = -direction

            fence[row][col] = char
            col += 1
            row += direction

        encrypted_text = ''
        for i in range(rails):
            for j in range(len(plain_text)):
                if fence[i][j] != '\n':
                    encrypted_text += fence[i][j]

        return encrypted_text",COT,"```python
class EncryptionUtils:
    def __init__(self, key):
        self.key = key

    def caesar_cipher(self, plaintext, shift):
        ciphertext = ''
        for char in plaintext:
            if char.isalpha():
                shift_amount = shift % 26
                shifted = ord(char) + shift_amount
                if char.islower():
                    if shifted > ord('z'):
                        shifted -= 26
                elif char.isupper():
                    if shifted > ord('Z'):
                        shifted -= 26
                ciphertext += chr(shifted)
            else:
                ciphertext += char
        return ciphertext

    def vigenere_cipher(self, plaintext):
        ciphertext = ''
        key_length = len(self.key)
        key_as_int = [ord(i) for i in self.key]
        plaintext_int = [ord(i) for i in plaintext]
        for i in range(len(plaintext_int)):
            value = (plaintext_int[i] + key_as_int[i % key_length]) % 26
            ciphertext += chr(value + 65)
        return ciphertext

    def rail_fence_cipher(self, plain_text, rails):
        if rails == 1:
            return plain_text

        rail = ['' for _ in range(rails)]
        direction_down = False
        row, col = 0, 0

        for char in plain_text:
            rail[row] += char
            if row == 0 or row == rails - 1:
                direction_down = not direction_down
            row += 1 if direction_down else -1

        return ''.join(rail)
```",0.243750659,0.308067706,0.580246914,0.55952381,0.569696965,0.361111111,0.371428571,0.366197178,0.543209877,0.523809524,0.533333328,,,,,,,,,,,,
GPT,38,"import openpyxl


class ExcelProcessor:
    def __init__(self):
        pass

    def read_excel(self, file_name):
        data = []
        try:
            workbook = openpyxl.load_workbook(file_name)
            sheet = workbook.active
            for row in sheet.iter_rows(values_only=True):
                data.append(row)
            workbook.close()
            return data
        except:
            return None

    def write_excel(self, data, file_name):
        try:
            workbook = openpyxl.Workbook()
            sheet = workbook.active
            for row in data:
                sheet.append(row)
            workbook.save(file_name)
            workbook.close()
            return 1
        except:
            return 0

    def process_excel_data(self, N, save_file_name):
        data = self.read_excel(save_file_name)
        if data is None or N >= len(data[0]):
            return 0
        new_data = []
        for row in data:
            new_row = list(row[:])
            if not str(row[N]).isdigit():
                new_row.append(str(row[N]).upper())
            else:
                new_row.append(row[N])
            new_data.append(new_row)
        new_file_name = save_file_name.split('.')[0] + '_process.xlsx'
        success = self.write_excel(new_data, new_file_name)
        return success, new_file_name",COT,"```python
import openpyxl

class ExcelProcessor:
    def __init__(self):
        pass

    def read_excel(self, file_name):
        workbook = openpyxl.load_workbook(file_name)
        sheet = workbook.active
        data = []
        for row in sheet.iter_rows(values_only=True):
            data.append(row)
        return data

    def write_excel(self, data, file_name):
        try:
            workbook = openpyxl.Workbook()
            sheet = workbook.active
            for row in data:
                sheet.append(row)
            workbook.save(file_name)
            return 1
        except Exception as e:
            print(f""An error occurred: {e}"")
            return 0

    def process_excel_data(self, N, save_file_name):
        data = self.read_excel(save_file_name)
        if not data or N >= len(data[0]):
            return 0, save_file_name

        processed_data = []
        for row in data:
            row = list(row)
            if isinstance(row[N], str):
                row[N] = row[N].upper()
            processed_data.append(tuple(row))

        success = self.write_excel(processed_data, save_file_name)
        return success, save_file_name
```",0.469486865,0.535491228,0.666666667,0.6875,0.676923072,0.565656566,0.589473684,0.577319583,0.651515152,0.671875,0.661538457,,,,,,,,,,,,
GPT,39,"import re
from collections import deque
from decimal import Decimal


class ExpressionCalculator:
    def __init__(self):
        self.postfix_stack = deque()
        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]

    def calculate(self, expression):
        self.prepare(self.transform(expression))

        result_stack = deque()
        self.postfix_stack.reverse()

        while self.postfix_stack:
            current_op = self.postfix_stack.pop()
            if not self.is_operator(current_op):
                current_op = current_op.replace(""~"", ""-"")
                result_stack.append(current_op)
            else:
                second_value = result_stack.pop()
                first_value = result_stack.pop()

                first_value = first_value.replace(""~"", ""-"")
                second_value = second_value.replace(""~"", ""-"")

                temp_result = self._calculate(first_value, second_value, current_op)
                result_stack.append(str(temp_result))

        return float(eval(""*"".join(result_stack)))

    def prepare(self, expression):
        op_stack = deque([','])
        arr = list(expression)
        current_index = 0
        count = 0

        for i, current_op in enumerate(arr):
            if self.is_operator(current_op):
                if count > 0:
                    self.postfix_stack.append("""".join(arr[current_index: current_index + count]))
                peek_op = op_stack[-1]
                if current_op == ')':
                    while op_stack[-1] != '(':
                        self.postfix_stack.append(str(op_stack.pop()))
                    op_stack.pop()
                else:
                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):
                        self.postfix_stack.append(str(op_stack.pop()))
                        peek_op = op_stack[-1]
                    op_stack.append(current_op)

                count = 0
                current_index = i + 1
            else:
                count += 1

        if count > 1 or (count == 1 and not self.is_operator(arr[current_index])):
            self.postfix_stack.append("""".join(arr[current_index: current_index + count]))

        while op_stack[-1] != ',':
            self.postfix_stack.append(str(op_stack.pop()))

    @staticmethod
    def is_operator(c):
        return c in {'+', '-', '*', '/', '(', ')', '%'}

    def compare(self, cur, peek):
        if cur == '%':
            cur = '/'
        if peek == '%':
            peek = '/'
        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]

    @staticmethod
    def _calculate(first_value, second_value, current_op):
        if current_op == '+':
            return Decimal(first_value) + Decimal(second_value)
        elif current_op == '-':
            return Decimal(first_value) - Decimal(second_value)
        elif current_op == '*':
            return Decimal(first_value) * Decimal(second_value)
        elif current_op == '/':
            return Decimal(first_value) / Decimal(second_value)
        elif current_op == '%':
            return Decimal(first_value) % Decimal(second_value)
        else:
            raise ValueError(""Unexpected operator: {}"".format(current_op))

    @staticmethod
    def transform(expression):
        expression = re.sub(r""\s+"", """", expression)
        expression = re.sub(r""=$"", """", expression)
        arr = list(expression)

        for i, c in enumerate(arr):
            if c == '-':
                if i == 0:
                    arr[i] = '~'
                else:
                    prev_c = arr[i - 1]
                    if prev_c in {'+', '-', '*', '/', '(', 'E', 'e'}:
                        arr[i] = '~'

        if arr[0] == '~' and (len(arr) > 1 and arr[1] == '('):
            arr[0] = '-'
            return ""0"" + """".join(arr)
        else:
            return """".join(arr)",COT,"```python
import re
from collections import deque
from decimal import Decimal

class ExpressionCalculator:
    def __init__(self):
        self.postfix_stack = deque()
        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]

    def calculate(self, expression):
        self.prepare(expression)
        calculation_stack = deque()
        for token in self.postfix_stack:
            if not self.is_operator(token):
                calculation_stack.append(token)
            else:
                second_value = calculation_stack.pop()
                first_value = calculation_stack.pop()
                result = self._calculate(first_value, second_value, token)
                calculation_stack.append(result)
        return float(calculation_stack.pop())

    def prepare(self, expression):
        expression = self.transform(expression)
        operator_stack = deque()
        self.postfix_stack.clear()
        for char in expression:
            if not self.is_operator(char):
                self.postfix_stack.append(char)
            else:
                while (operator_stack and operator_stack[-1] != '(' and
                       self.compare(char, operator_stack[-1])):
                    self.postfix_stack.append(operator_stack.pop())
                if char == ')':
                    operator_stack.pop()
                else:
                    operator_stack.append(char)
        while operator_stack:
            self.postfix_stack.append(operator_stack.pop())

    @staticmethod
    def is_operator(c):
        return c in {'+', '-', '*', '/', '(', ')', '%'}

    def compare(self, cur, peek):
        return self.operat_priority[ord(cur) - 40] <= self.operat_priority[ord(peek) - 40]

    @staticmethod
    def _calculate(first_value, second_value, current_op):
        first = Decimal(first_value)
        second = Decimal(second_value)
        if current_op == '+':
            return first + second
        elif current_op == '-':
            return first - second
        elif current_op == '*':
            return first * second
        elif current_op == '/':
            return first / second
        elif current_op == '%':
            return first % second

    @staticmethod
    def transform(expression):
        return re.sub(r'\s+', '', expression)
```",0.176493598,0.207939584,0.530612245,0.722222222,0.611764701,0.3125,0.508474576,0.387096769,0.503401361,0.685185185,0.580392152,,,,,,,,,,,,
GPT,3,"import itertools


class ArrangementCalculator:
    def __init__(self, datas):
        self.datas = datas

    @staticmethod
    def count(n, m=None):
        if m is None or n == m:
            return ArrangementCalculator.factorial(n)
        else:
            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)

    @staticmethod
    def count_all(n):
        total = 0
        for i in range(1, n + 1):
            total += ArrangementCalculator.count(n, i)
        return total

    def select(self, m=None):
        if m is None:
            m = len(self.datas)
        result = []
        for permutation in itertools.permutations(self.datas, m):
            result.append(list(permutation))
        return result

    def select_all(self):
        result = []
        for i in range(1, len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    @staticmethod
    def factorial(n):
        result = 1
        for i in range(2, n + 1):
            result *= i
        return result",COT,"```python
class ArrangementCalculator:
    def __init__(self, datas):
        self.datas = datas

    @staticmethod
    def count(n, m=None):
        if m is None:
            m = n
        return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)

    @staticmethod
    def count_all(n):
        total = 0
        for m in range(1, n + 1):
            total += ArrangementCalculator.count(n, m)
        return total

    def select(self, m=None):
        if m is None:
            m = len(self.datas)
        return self._permute(self.datas, m)

    def select_all(self):
        result = []
        for m in range(1, len(self.datas) + 1):
            result.extend(self._permute(self.datas, m))
        return result

    @staticmethod
    def factorial(n):
        if n == 0:
            return 1
        result = 1
        for i in range(1, n + 1):
            result *= i
        return result

    def _permute(self, items, m):
        if m == 0:
            return [[]]
        permutations = []
        for i in range(len(items)):
            for perm in self._permute(items[:i] + items[i+1:], m - 1):
                permutations.append([items[i]] + perm)
        return permutations
```",0.5078125,0.542398284,0.793103448,0.754098361,0.773109239,0.717391304,0.578947368,0.640776694,0.775862069,0.737704918,0.756302516,,,,,,,,,,,,
GPT,40,"class FitnessTracker:
    def __init__(self, height, weight, age, sex) -> None:
        self.height = height
        self.weight = weight
        self.age = age
        self.sex = sex
        self.BMI_std = [
            {""male"": [20, 25]},
            {""female"": [19, 24]}
        ]

    def get_BMI(self):
        return self.weight / self.height ** 2

    def condition_judge(self):
        BMI = self.get_BMI()
        if self.sex == ""male"":
            BMI_range = self.BMI_std[0][""male""]
        else:
            BMI_range = self.BMI_std[1][""female""]
        if BMI > BMI_range[1]:
            # too fat
            return 1
        elif BMI < BMI_range[0]:
            # too thin
            return -1
        else:
            # normal
            return 0

    def calculate_calorie_intake(self):
        if self.sex == ""male"":
            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5
        else:
            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161
        if self.condition_judge() == 1:
            calorie_intake = BMR * 1.2  # Sedentary lifestyle
        elif self.condition_judge() == -1:
            calorie_intake = BMR * 1.6  # Active lifestyle
        else:
            calorie_intake = BMR * 1.4  # Moderate lifestyle
        return calorie_intake",COT,"```python
class FitnessTracker:
    def __init__(self, height, weight, age, sex) -> None:
        self.height = height
        self.weight = weight
        self.age = age
        self.sex = sex
        self.BMI_std = {
            ""male"": [20, 25],
            ""female"": [19, 24]
        }

    def get_BMI(self):
        return self.weight / (self.height ** 2)

    def condition_judge(self):
        BMI = self.get_BMI()
        if self.sex in self.BMI_std:
            std_range = self.BMI_std[self.sex]
            if BMI < std_range[0]:
                return -1
            elif BMI > std_range[1]:
                return 1
            else:
                return 0
        else:
            raise ValueError(""Invalid sex provided"")

    def calculate_calorie_intake(self):
        if self.sex == ""male"":
            BMR = 10 * self.weight + 6.25 * self.height * 100 - 5 * self.age + 5
        elif self.sex == ""female"":
            BMR = 10 * self.weight + 6.25 * self.height * 100 - 5 * self.age - 161
        else:
            raise ValueError(""Invalid sex provided"")

        condition = self.condition_judge()
        if condition == 1:
            return BMR * 1.2
        elif condition == -1:
            return BMR * 1.6
        else:
            return BMR * 1.4
```",0.409396661,0.487509468,0.708333333,0.708333333,0.708333328,0.568181818,0.581395349,0.574712639,0.666666667,0.666666667,0.666666662,,,,,,,,,,,,
GPT,41,"class GomokuGame:
    def __init__(self, board_size):
        self.board_size = board_size
        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        return False

    def check_winner(self):
        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]
        for row in range(self.board_size):
            for col in range(self.board_size):
                if self.board[row][col] != ' ':
                    for direction in directions:
                        if self._check_five_in_a_row(row, col, direction):
                            return self.board[row][col]
        return None

    def _check_five_in_a_row(self, row, col, direction):
        dx, dy = direction
        count = 1
        symbol = self.board[row][col]
        for i in range(1, 5):
            new_row = row + dx * i
            new_col = col + dy * i
            if not (0 <= new_row < self.board_size and 0 <= new_col < self.board_size):
                return False
            if self.board[new_row][new_col] != symbol:
                return False
            count += 1
        return count == 5",COT,"```python
class GomokuGame:
    def __init__(self, board_size):
        self.board_size = board_size
        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if 0 <= row < self.board_size and 0 <= col < self.board_size and self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        return False

    def check_winner(self):
        for row in range(self.board_size):
            for col in range(self.board_size):
                if self.board[row][col] != ' ':
                    if (self._check_five_in_a_row(row, col, (0, 1)) or
                        self._check_five_in_a_row(row, col, (1, 0)) or
                        self._check_five_in_a_row(row, col, (1, 1)) or
                        self._check_five_in_a_row(row, col, (1, -1))):
                        return self.board[row][col]
        return None

    def _check_five_in_a_row(self, row, col, direction):
        dx, dy = direction
        count = 0
        current_symbol = self.board[row][col]
        for _ in range(5):
            if 0 <= row < self.board_size and 0 <= col < self.board_size and self.board[row][col] == current_symbol:
                count += 1
                row += dx
                col += dy
            else:
                break
        return count == 5
```",0.516778523,0.559340754,0.742857143,0.8,0.770370365,0.613138686,0.68852459,0.648648644,0.742857143,0.8,0.770370365,,,,,,,,,,,,
GPT,42,"class Hotel:
    def __init__(self, name, rooms):
        self.name = name
        self.available_rooms = rooms
        # available_rooms = {room_type1: room_number1, room_type2: room_number2, ...}
        # available_rooms = {'single': 5, 'double': 3}
        self.booked_rooms = {}
        # booked_rooms = {room_type1: {name1: room_number1, name2: room_number2, ...}, room_type2: {...}, ...}
        # booked_rooms = {'single': {'name1': 2, 'name2':1}, 'double': {}}

    def book_room(self, room_type, room_number, name):
        # Check if there are any rooms of the specified type available
        if room_type not in self.available_rooms.keys():
            return False

        if room_number <= self.available_rooms[room_type]:
            # Book the room by adding it to the booked_rooms dictionary
            if room_type not in self.booked_rooms.keys():
                self.booked_rooms[room_type] = {}
            self.booked_rooms[room_type][name] = room_number
            self.available_rooms[room_type] -= room_number
            return ""Success!""
        elif self.available_rooms[room_type] != 0:
            return self.available_rooms[room_type]
        else:
            return False

    def check_in(self, room_type, room_number, name):
        # Check if the room of the specified type and number is booked
        if room_type not in self.booked_rooms.keys():
            return False
        if name in self.booked_rooms[room_type]:
            if room_number > self.booked_rooms[room_type][name]:
                return False
            elif room_number == self.booked_rooms[room_type][name]:
                # Check in the room by removing it from the booked_rooms dictionary
                self.booked_rooms[room_type].pop(name)
            else:
                self.booked_rooms[room_type][name] -= room_number


    def check_out(self, room_type, room_number):
        if room_type in self.available_rooms:
            self.available_rooms[room_type] += room_number
        else:
            self.available_rooms[room_type] = room_number

    def get_available_rooms(self, room_type):
        return self.available_rooms[room_type]",COT,"```python
class Hotel:
    def __init__(self, name, rooms):
        self.name = name
        self.available_rooms = rooms
        self.booked_rooms = {}

    def book_room(self, room_type, room_number, name):
        if room_type not in self.available_rooms or self.available_rooms[room_type] == 0:
            return False
        if room_number > self.available_rooms[room_type]:
            return self.available_rooms[room_type]
        self.available_rooms[room_type] -= room_number
        if room_type not in self.booked_rooms:
            self.booked_rooms[room_type] = {}
        if name in self.booked_rooms[room_type]:
            self.booked_rooms[room_type][name] += room_number
        else:
            self.booked_rooms[room_type][name] = room_number
        return 'Success!'

    def check_in(self, room_type, room_number, name):
        if room_type not in self.booked_rooms or name not in self.booked_rooms[room_type]:
            return False
        if room_number > self.booked_rooms[room_type][name]:
            return False
        self.booked_rooms[room_type][name] -= room_number
        if self.booked_rooms[room_type][name] == 0:
            del self.booked_rooms[room_type][name]
        if not self.booked_rooms[room_type]:
            del self.booked_rooms[room_type]
        return True

    def check_out(self, room_type, room_number):
        if room_type in self.available_rooms:
            self.available_rooms[room_type] += room_number
        else:
            self.available_rooms[room_type] = room_number

    def get_available_rooms(self, room_type):
        return self.available_rooms.get(room_type, 0)
```",0.251995472,0.289059598,0.477272727,0.823529412,0.604316542,0.411392405,0.637254902,0.499999995,0.477272727,0.823529412,0.604316542,,,,,,,,,,,,
GPT,43,"class HRManagementSystem:
    def __init__(self):
        self.employees = {}

    def add_employee(self, employee_id, name, position, department, salary):
        if employee_id in self.employees:
            return False
        else:
            self.employees[employee_id] = {
                'name': name,
                'position': position,
                'department': department,
                'salary': salary
            }
            return True

    def remove_employee(self, employee_id):
        if employee_id in self.employees:
            del self.employees[employee_id]
            return True
        else:
            return False

    def update_employee(self, employee_id: int, employee_info: dict):
        employee = self.get_employee(employee_id)
        if employee == False:
            return False
        else:
            for key, value in employee_info.items():
                if key not in employee:
                    return False
            for key, value in employee_info.items():
                employee[key] = value
            return True

    def get_employee(self, employee_id):
        if employee_id in self.employees:
            return self.employees[employee_id]
        else:
            return False

    def list_employees(self):
        employee_data = {}
        if self.employees:
            for employee_id, employee_info in self.employees.items():
                employee_details = {}
                employee_details[""employee_ID""] = employee_id
                for key, value in employee_info.items():
                    employee_details[key] = value
                employee_data[employee_id] = employee_details
        return employee_data",COT,"```python
class HRManagementSystem:
    def __init__(self):
        self.employees = {}

    def add_employee(self, employee_id, name, position, department, salary):
        if employee_id in self.employees:
            return False
        self.employees[employee_id] = {
            'name': name,
            'position': position,
            'department': department,
            'salary': salary
        }
        return True

    def remove_employee(self, employee_id):
        if employee_id in self.employees:
            del self.employees[employee_id]
            return True
        return False

    def update_employee(self, employee_id, employee_info):
        if employee_id in self.employees:
            self.employees[employee_id].update(employee_info)
            return True
        return False

    def get_employee(self, employee_id):
        return self.employees.get(employee_id, False)

    def list_employees(self):
        return self.employees
```",0.300020883,0.324755574,0.603448276,0.853658537,0.707070702,0.457142857,0.761904762,0.571428567,0.603448276,0.853658537,0.707070702,,,,,,,,,,,,
GPT,44,"import re
import string
import gensim
from bs4 import BeautifulSoup


class HtmlUtil:

    def __init__(self):
        self.SPACE_MARK = '-SPACE-'
        self.JSON_MARK = '-JSON-'
        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'
        self.URL_MARK = '-URL-'
        self.NUMBER_MARK = '-NUMBER-'
        self.TRACE_MARK = '-TRACE-'
        self.COMMAND_MARK = '-COMMAND-'
        self.COMMENT_MARK = '-COMMENT-'
        self.CODE_MARK = '-CODE-'

    @staticmethod
    def __format_line_feed(text):
        return re.sub(re.compile(r'\n+'), '\n', text)

    def format_line_html_text(self, html_text):
        if html_text is None or len(html_text) == 0:
            return ''
        soup = BeautifulSoup(html_text, 'lxml')

        code_tag = soup.find_all(name=['pre', 'blockquote'])
        for tag in code_tag:
            tag.string = self.CODE_MARK

        ul_ol_group = soup.find_all(name=['ul', 'ol'])
        for ul_ol_item in ul_ol_group:
            li_group = ul_ol_item.find_all('li')
            for li_item in li_group:
                li_item_text = li_item.get_text().strip()
                if len(li_item_text) == 0:
                    continue
                if li_item_text[-1] in string.punctuation:
                    li_item.string = '[{0}]{1}'.format('-', li_item_text)
                    continue
                li_item.string = '[{0}]{1}.'.format('-', li_item_text)

        p_group = soup.find_all(name=['p'])
        for p_item in p_group:
            p_item_text = p_item.get_text().strip()
            if p_item_text:
                if p_item_text[-1] in string.punctuation:
                    p_item.string = p_item_text
                    continue
                next_sibling = p_item.find_next_sibling()
                if next_sibling and self.CODE_MARK in next_sibling.get_text():
                    p_item.string = p_item_text + ':'
                    continue
                p_item.string = p_item_text + '.'

        clean_text = gensim.utils.decode_htmlentities(soup.get_text())
        return self.__format_line_feed(clean_text)

    def extract_code_from_html_text(self, html_text):
        text_with_code_tag = self.format_line_html_text(html_text)

        if self.CODE_MARK not in text_with_code_tag:
            return []

        code_index_start = 0
        soup = BeautifulSoup(html_text, 'lxml')
        code_tag = soup.find_all(name=['pre', 'blockquote'])
        code_count = text_with_code_tag.count(self.CODE_MARK)
        code_list = []
        for code_index in range(code_index_start, code_index_start + code_count):
            code = code_tag[code_index].get_text()
            if code:
                code_list.append(code)
        return code_list",COT,"```python
import re
from bs4 import BeautifulSoup

class HtmlUtil:
    def __init__(self):
        self.SPACE_MARK = '-SPACE-'
        self.JSON_MARK = '-JSON-'
        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'
        self.URL_MARK = '-URL-'
        self.NUMBER_MARK = '-NUMBER-'
        self.TRACE_MARK = '-TRACE-'
        self.COMMAND_MARK = '-COMMAND-'
        self.COMMENT_MARK = '-COMMENT-'
        self.CODE_MARK = '-CODE-'

    @staticmethod
    def __format_line_feed(text):
        return re.sub(r'(\r\n|\r|\n)+', '\n', text)

    def format_line_html_text(self, html_text):
        soup = BeautifulSoup(html_text, 'html.parser')
        for code in soup.find_all(['code', 'pre']):
            code.replace_with(self.CODE_MARK)
        text = soup.get_text()
        return self.__format_line_feed(text)

    def extract_code_from_html_text(self, html_text):
        soup = BeautifulSoup(html_text, 'html.parser')
        code_list = []
        for code in soup.find_all(['code', 'pre']):
            code_list.append(code.get_text())
        return code_list
```",0.130187602,0.143664697,0.401709402,0.810344828,0.537142853,0.297674419,0.703296703,0.418300649,0.401709402,0.810344828,0.537142853,,,,,,,,,,,,
GPT,45,"from PIL import Image, ImageEnhance, ImageChops


class ImageProcessor:
    def __init__(self):
        self.image = None

    def load_image(self, image_path):
        self.image = Image.open(image_path)

    def save_image(self, save_path):
        if self.image:
            self.image.save(save_path)

    def resize_image(self, width, height):
        if self.image:
            self.image = self.image.resize((width, height))

    def rotate_image(self, degrees):
        if self.image:
            self.image = self.image.rotate(degrees)

    def adjust_brightness(self, factor):
        if self.image:
            enhancer = ImageEnhance.Brightness(self.image)
            self.image = enhancer.enhance(factor)",COT,"```python
from PIL import Image, ImageEnhance

class ImageProcessor:
    def __init__(self):
        self.image = None

    def load_image(self, image_path):
        self.image = Image.open(image_path)

    def save_image(self, save_path):
        if self.image:
            self.image.save(save_path)

    def resize_image(self, width, height):
        if self.image:
            self.image = self.image.resize((width, height))

    def rotate_image(self, degrees):
        if self.image:
            self.image = self.image.rotate(degrees)

    def adjust_brightness(self, factor):
        if self.image:
            enhancer = ImageEnhance.Brightness(self.image)
            self.image = enhancer.enhance(factor)
```",0.905660377,0.915132941,0.947368421,0.947368421,0.947368416,0.942307692,0.924528302,0.933333328,0.947368421,0.947368421,0.947368416,,,,,,,,,,,,
GPT,46,"class Interpolation:
    def __init__(self):
        pass

    @staticmethod
    def interpolate_1d(x, y, x_interp):
        y_interp = []
        for xi in x_interp:
            for i in range(len(x) - 1):
                if x[i] <= xi <= x[i+1]:
                    yi = y[i] + (y[i+1] - y[i]) * (xi - x[i]) / (x[i+1] - x[i])
                    y_interp.append(yi)
                    break
        return y_interp
    
    @staticmethod
    def interpolate_2d(x, y, z, x_interp, y_interp):
        z_interp = []
        for xi, yi in zip(x_interp, y_interp):
            for i in range(len(x) - 1):
                if x[i] <= xi <= x[i+1]:
                    for j in range(len(y) - 1):
                        if y[j] <= yi <= y[j+1]:
                            z00 = z[i][j]
                            z01 = z[i][j+1]
                            z10 = z[i+1][j]
                            z11 = z[i+1][j+1]
                            zi = (z00 * (x[i+1] - xi) * (y[j+1] - yi) +
                                  z10 * (xi - x[i]) * (y[j+1] - yi) +
                                  z01 * (x[i+1] - xi) * (yi - y[j]) +
                                  z11 * (xi - x[i]) * (yi - y[j])) / ((x[i+1] - x[i]) * (y[j+1] - y[j]))
                            z_interp.append(zi)
                            break
                    break
        return z_interp",COT,"```python
class Interpolation:
    def __init__(self):
        pass

    @staticmethod
    def interpolate_1d(x, y, x_interp):
        y_interp = []
        for xi in x_interp:
            for i in range(len(x) - 1):
                if x[i] <= xi <= x[i + 1]:
                    yi = y[i] + (y[i + 1] - y[i]) * (xi - x[i]) / (x[i + 1] - x[i])
                    y_interp.append(yi)
                    break
        return y_interp

    @staticmethod
    def interpolate_2d(x, y, z, x_interp, y_interp):
        z_interp = []
        for xi, yi in zip(x_interp, y_interp):
            for i in range(len(x) - 1):
                for j in range(len(y) - 1):
                    if x[i] <= xi <= x[i + 1] and y[j] <= yi <= y[j + 1]:
                        z00 = z[i][j]
                        z01 = z[i][j + 1]
                        z10 = z[i + 1][j]
                        z11 = z[i + 1][j + 1]

                        fxy1 = z00 + (z10 - z00) * (xi - x[i]) / (x[i + 1] - x[i])
                        fxy2 = z01 + (z11 - z01) * (xi - x[i]) / (x[i + 1] - x[i])
                        zi = fxy1 + (fxy2 - fxy1) * (yi - y[j]) / (y[j + 1] - y[j])
                        z_interp.append(zi)
                        break
        return z_interp
```",0.462427746,0.515772828,0.803030303,0.706666667,0.751773045,0.657894737,0.581395349,0.617283946,0.772727273,0.68,0.72340425,,,,,,,,,,,,
GPT,47,"class IPAddress:
    def __init__(self, ip_address):
        self.ip_address = ip_address

    def is_valid(self):
        octets = self.ip_address.split('.')
        if len(octets) != 4:
            return False
        for octet in octets:
            if not octet.isdigit() or int(octet) < 0 or int(octet) > 255:
                return False
        return True

    def get_octets(self):
        if self.is_valid():
            return self.ip_address.split('.')
        else:
            return []

    def get_binary(self):
        if self.is_valid():
            binary_octets = []
            for octet in self.get_octets():
                binary_octets.append(format(int(octet), '08b'))
            return '.'.join(binary_octets)
        else:
            return ''",COT,"```python
class IPAddress:
    def __init__(self, ip_address):
        self.ip_address = ip_address

    def is_valid(self):
        octets = self.ip_address.split('.')
        if len(octets) != 4:
            return False
        for octet in octets:
            if not octet.isdigit():
                return False
            num = int(octet)
            if num < 0 or num > 255:
                return False
        return True

    def get_octets(self):
        if self.is_valid():
            return self.ip_address.split('.')
        return []

    def get_binary(self):
        if not self.is_valid():
            return ''
        octets = self.get_octets()
        binary_octets = [format(int(octet), '08b') for octet in octets]
        return '.'.join(binary_octets)
```",0.535211268,0.593004395,0.88372093,0.826086957,0.853932579,0.746268657,0.694444444,0.719424455,0.88372093,0.826086957,0.853932579,,,,,,,,,,,,
GPT,48,"import socket


class IpUtil:

    @staticmethod
    def is_valid_ipv4(ip_address):
        try:
            socket.inet_pton(socket.AF_INET, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def is_valid_ipv6(ip_address):
        try:
            socket.inet_pton(socket.AF_INET6, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def get_hostname(ip_address):
        try:
            hostname = socket.gethostbyaddr(ip_address)[0]
            return hostname
        except socket.herror:
            return None",COT,"```python
import socket

class IpUtil:
    
    @staticmethod
    def is_valid_ipv4(ip_address):
        try:
            socket.inet_pton(socket.AF_INET, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def is_valid_ipv6(ip_address):
        try:
            socket.inet_pton(socket.AF_INET6, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def get_hostname(ip_address):
        try:
            return socket.gethostbyaddr(ip_address)[0]
        except socket.herror:
            return None
```",0.82131361,0.84576283,0.916666667,0.916666667,0.916666662,0.828571429,0.852941176,0.840579705,0.916666667,0.916666667,0.916666662,,,,,,,,,,,,
GPT,49,"class JobMarketplace:
    def __init__(self):
        self.job_listings = []
        self.resumes = []

    def post_job(self, job_title, company, requirements):
        # requirements = ['requirement1', 'requirement2']
        job = {""job_title"": job_title, ""company"": company, ""requirements"": requirements}
        self.job_listings.append(job)

    def remove_job(self, job):
        self.job_listings.remove(job)

    def submit_resume(self, name, skills, experience):
        resume = {""name"": name, ""skills"": skills, ""experience"": experience}
        self.resumes.append(resume)

    def withdraw_resume(self, resume):
        self.resumes.remove(resume)

    def search_jobs(self, criteria):
        matching_jobs = []
        for job_listing in self.job_listings:
            if criteria.lower() in job_listing[""job_title""].lower() or criteria.lower() in [r.lower() for r in job_listing[""requirements""]]:
                matching_jobs.append(job_listing)
        return matching_jobs

    def get_job_applicants(self, job):
        applicants = []
        for resume in self.resumes:
            if self.matches_requirements(resume, job[""requirements""]):
                applicants.append(resume)
        return applicants

    @staticmethod
    def matches_requirements(resume, requirements):
        for skill in resume[""skills""]:
            if skill not in requirements:
                return False
        return True",COT,"```python
class JobMarketplace:
    def __init__(self):
        self.job_listings = []
        self.resumes = []

    def post_job(self, job_title, company, requirements):
        job = {
            'job_title': job_title,
            'company': company,
            'requirements': requirements
        }
        self.job_listings.append(job)

    def remove_job(self, job):
        if job in self.job_listings:
            self.job_listings.remove(job)

    def submit_resume(self, name, skills, experience):
        resume = {
            'name': name,
            'skills': skills,
            'experience': experience
        }
        self.resumes.append(resume)

    def withdraw_resume(self, resume):
        if resume in self.resumes:
            self.resumes.remove(resume)

    def search_jobs(self, criteria):
        return [job for job in self.job_listings if criteria in job['requirements']]

    def get_job_applicants(self, job):
        def matches_requirements(resume, job_requirements):
            return all(req in resume['skills'] for req in job_requirements)

        return [resume for resume in self.resumes if matches_requirements(resume, job['requirements'])]
```",0.260147386,0.318175524,0.573529412,0.661016949,0.614173223,0.387931034,0.473684211,0.426540279,0.558823529,0.644067797,0.598425192,,,,,,,,,,,,
GPT,4,"class AssessmentSystem:
    def __init__(self):
        self.students = {}

    def add_student(self, name, grade, major):
        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}

    def add_course_score(self, name, course, score):
        if name in self.students:
            self.students[name]['courses'][course] = score

    def get_gpa(self, name):
        if name in self.students and self.students[name]['courses']:
            return sum(self.students[name]['courses'].values()) / len(self.students[name]['courses'])
        else:
            return None

    def get_all_students_with_fail_course(self):
        students = []
        for name, student in self.students.items():
            for course, score in student['courses'].items():
                if score < 60:
                    students.append(name)
                    break
        return students

    def get_course_average(self, course):
        total = 0
        count = 0
        for student in self.students.values():
            if course in student['courses']:
                score = student['courses'][course]
                if score is not None:
                    total += score
                    count += 1
        return total / count if count > 0 else None

    def get_top_student(self):
        top_student = None
        top_gpa = 0
        for name, student in self.students.items():
            gpa = self.get_gpa(name)
            if gpa is not None and gpa > top_gpa:
                top_gpa = gpa
                top_student = name
        return top_student",COT,"```python
class AssessmentSystem:
    def __init__(self):
        self.students = {}

    def add_student(self, name, grade, major):
        if name not in self.students:
            self.students[name] = {
                'name': name,
                'grade': grade,
                'major': major,
                'courses': {}
            }

    def add_course_score(self, name, course, score):
        if name in self.students:
            self.students[name]['courses'][course] = score

    def get_gpa(self, name):
        if name in self.students and self.students[name]['courses']:
            total_score = sum(self.students[name]['courses'].values())
            num_courses = len(self.students[name]['courses'])
            return total_score / num_courses
        return None

    def get_all_students_with_fail_course(self):
        students_with_fail = []
        for student in self.students.values():
            if any(score < 60 for score in student['courses'].values()):
                students_with_fail.append(student['name'])
        return students_with_fail

    def get_course_average(self, course):
        total_score = 0
        count = 0
        for student in self.students.values():
            if course in student['courses']:
                total_score += student['courses'][course]
                count += 1
        return total_score / count if count > 0 else None

    def get_top_student(self):
        top_student = None
        highest_gpa = 0
        for name in self.students:
            gpa = self.get_gpa(name)
            if gpa is not None and gpa > highest_gpa:
                highest_gpa = gpa
                top_student = name
        return top_student
```",0.517006803,0.578794649,0.849315068,0.815789474,0.83221476,0.657142857,0.666666667,0.661870499,0.835616438,0.802631579,0.818791941,,,,,,,,,,,,
GPT,50,"import json
import os


class JSONProcessor:
    def read_json(self, file_path):
        if not os.path.exists(file_path):
            return 0
        try:
            with open(file_path, 'r') as file:
                data = json.load(file)
            return data
        except:
            return -1

    def write_json(self, data, file_path):
        try:
            with open(file_path, 'w') as file:
                json.dump(data, file)
            return 1
        except:
            return -1

    def process_json(self, file_path, remove_key):
        data = self.read_json(file_path)
        if data == 0 or data == -1:
            return 0
        if remove_key in data:
            del data[remove_key]
            self.write_json(data, file_path)
            return 1
        else:
            return 0",COT,"```python
import json
import os

class JSONProcessor:
    def read_json(self, file_path):
        if not os.path.exists(file_path):
            return 0
        try:
            with open(file_path, 'r') as file:
                data = json.load(file)
            return data
        except Exception as e:
            return -1

    def write_json(self, data, file_path):
        try:
            with open(file_path, 'w') as file:
                json.dump(data, file, indent=4)
            return 1
        except Exception as e:
            return -1

    def process_json(self, file_path, remove_key):
        data = self.read_json(file_path)
        if data == 0 or data == -1:
            return 0
        if remove_key in data:
            del data[remove_key]
            write_result = self.write_json(data, file_path)
            if write_result == 1:
                return 1
        return 0
```",0.655172414,0.698962923,0.936170213,0.830188679,0.879999995,0.869565217,0.759493671,0.810810806,0.936170213,0.830188679,0.879999995,,,,,,,,,,,,
GPT,51,"import numpy as np


class KappaCalculator:

    @staticmethod
    def kappa(testData, k):
        dataMat = np.mat(testData)
        P0 = 0.0
        for i in range(k):
            P0 += dataMat[i, i] * 1.0
        xsum = np.sum(dataMat, axis=1)
        ysum = np.sum(dataMat, axis=0)
        sum = np.sum(dataMat)
        Pe = float(ysum * xsum) / sum / sum
        P0 = float(P0 / sum * 1.0)
        cohens_coefficient = float((P0 - Pe) / (1 - Pe))
        return cohens_coefficient

    @staticmethod
    def fleiss_kappa(testData, N, k, n):
        dataMat = np.mat(testData, float)
        oneMat = np.ones((k, 1))
        sum = 0.0
        P0 = 0.0
        for i in range(N):
            temp = 0.0
            for j in range(k):
                sum += dataMat[i, j]
                temp += 1.0 * dataMat[i, j] ** 2
            temp -= n
            temp /= (n - 1) * n
            P0 += temp
        P0 = 1.0 * P0 / N
        ysum = np.sum(dataMat, axis=0)
        for i in range(k):
            ysum[0, i] = (ysum[0, i] / sum) ** 2
        Pe = ysum * oneMat * 1.0
        ans = (P0 - Pe) / (1 - Pe)
        return ans[0, 0]",COT,"```python
import numpy as np

class KappaCalculator:
    @staticmethod
    def kappa(testData, k):
        matrix = np.array(testData)
        p_o = np.sum(np.diag(matrix)) / np.sum(matrix)
        p_e = np.sum(np.sum(matrix, axis=0) * np.sum(matrix, axis=1)) / (np.sum(matrix) ** 2)
        return (p_o - p_e) / (1 - p_e)

    @staticmethod
    def fleiss_kappa(testData, N, k, n):
        matrix = np.array(testData)
        p = np.sum(matrix, axis=0) / (N * n)
        P = (np.sum(matrix**2, axis=1) - n) / (n * (n - 1))
        P_bar = np.mean(P)
        P_e_bar = np.sum(p**2)
        return (P_bar - P_e_bar) / (1 - P_e_bar)
```",0.065168818,0.087453767,0.347222222,0.490196078,0.40650406,0.130769231,0.217948718,0.163461534,0.333333333,0.470588235,0.390243898,,,,,,,,,,,,
GPT,52,"import nltk
from nltk.stem import WordNetLemmatizer
from nltk import pos_tag, word_tokenize
import string

nltk.download('averaged_perceptron_tagger')
nltk.download('punkt')
nltk.download('wordnet')


class Lemmatization:
    def __init__(self):
        self.lemmatizer = WordNetLemmatizer()

    def lemmatize_sentence(self, sentence):
        lemmatized_words = []
        sentence = self.remove_punctuation(sentence)
        words = word_tokenize(sentence)
        tagged_words = pos_tag(words)
        for word, tag in tagged_words:
            if tag.startswith('V'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='v')
            elif tag.startswith('J'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='a')
            elif tag.startswith('R'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='r')
            else:
                lemmatized_word = self.lemmatizer.lemmatize(word)
            lemmatized_words.append(lemmatized_word)
        return lemmatized_words

    def get_pos_tag(self, sentence):
        pos_tags = []
        sentence = self.remove_punctuation(sentence)
        words = word_tokenize(sentence)
        tagged_words = pos_tag(words)
        for tagged_word in tagged_words:
            pos_tags.append(tagged_word[1])
        return pos_tags

    def remove_punctuation(self, sentence):
        return sentence.translate(str.maketrans('', '', string.punctuation))",COT,"```python
import nltk
from nltk.stem import WordNetLemmatizer
from nltk import pos_tag, word_tokenize
import string

nltk.download('averaged_perceptron_tagger')
nltk.download('punkt')
nltk.download('wordnet')

class Lemmatization:
    def __init__(self):
        self.lemmatizer = WordNetLemmatizer()

    def lemmatize_sentence(self, sentence):
        sentence = self.remove_punctuation(sentence)
        tokens = word_tokenize(sentence)
        pos_tags = pos_tag(tokens)
        lemmatized_words = []
        for word, tag in pos_tags:
            pos = self.get_wordnet_pos(tag)
            lemmatized_words.append(self.lemmatizer.lemmatize(word, pos))
        return lemmatized_words

    def get_pos_tag(self, sentence):
        sentence = self.remove_punctuation(sentence)
        tokens = word_tokenize(sentence)
        pos_tags = pos_tag(tokens)
        return [tag for word, tag in pos_tags]

    def remove_punctuation(self, sentence):
        return sentence.translate(str.maketrans('', '', string.punctuation))

    def get_wordnet_pos(self, treebank_tag):
        if treebank_tag.startswith('J'):
            return 'a'  # Adjective
        elif treebank_tag.startswith('V'):
            return 'v'  # Verb
        elif treebank_tag.startswith('N'):
            return 'n'  # Noun
        elif treebank_tag.startswith('R'):
            return 'r'  # Adverb
        else:
            return 'n'  # Default to noun
```",0.336363636,0.391321639,0.789473684,0.625,0.697674414,0.582417582,0.481818182,0.527363179,0.789473684,0.625,0.697674414,,,,,,,,,,,,
GPT,53,"import re
import string


class LongestWord:

    def __init__(self):
        self.word_list = []

    def add_word(self, word):
        self.word_list.append(word)

    def find_longest_word(self, sentence):
        longest_word = """"
        sentence = sentence.lower()
        sentence = re.sub('[%s]' % re.escape(string.punctuation), '', sentence)
        sentence = re.split(' ', sentence)
        for word in sentence:
            if word in self.word_list and len(word) > len(longest_word):
                longest_word = word
        return longest_word",COT,"```python
import re
import string

class LongestWord:
    def __init__(self):
        self.word_list = []

    def add_word(self, word: str):
        self.word_list.append(word)

    def find_longest_word(self, sentence: str) -> str:
        if not self.word_list:
            return ''
        
        # Remove punctuation and split the sentence into words
        sentence = sentence.translate(str.maketrans('', '', string.punctuation))
        words = sentence.split()
        
        # Find the longest word in the word list
        longest_word = ''
        for word in words:
            if word in self.word_list and len(word) > len(longest_word):
                longest_word = word
                
        return longest_word
```",0.328767123,0.374859512,0.710526316,0.519230769,0.599999995,0.574074074,0.402597403,0.473282438,0.710526316,0.519230769,0.599999995,,,,,,,,,,,,
GPT,54,"import random


class MahjongConnect:
    def __init__(self, BOARD_SIZE, ICONS):
        self.BOARD_SIZE = BOARD_SIZE
        self.ICONS = ICONS
        self.board = self.create_board()

    def create_board(self):
        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]
        return board

    def is_valid_move(self, pos1, pos2):
        x1, y1 = pos1
        x2, y2 = pos2

        # Check if positions are within the game board range
        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and 0 <= x2 < self.BOARD_SIZE[
            0] and 0 <= y2 <
                self.BOARD_SIZE[1]):
            return False

        # Check if the two positions are the same
        if pos1 == pos2:
            return False

        # Check if the two positions have the same icon
        if self.board[x1][y1] != self.board[x2][y2]:
            return False

        # Check if there is a valid path between the two positions
        if not self.has_path(pos1, pos2):
            return False

        return True

    def has_path(self, pos1, pos2):
        visited = set()
        stack = [pos1]

        while stack:
            current_pos = stack.pop()
            if current_pos == pos2:
                return True

            if current_pos in visited:
                continue

            visited.add(current_pos)
            x, y = current_pos

            # Check adjacent positions (up, down, left, right)
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                new_x, new_y = x + dx, y + dy
                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:
                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:
                        stack.append((new_x, new_y))

        return False

    def remove_icons(self, pos1, pos2):
        x1, y1 = pos1
        x2, y2 = pos2
        self.board[x1][y1] = ' '
        self.board[x2][y2] = ' '

    def is_game_over(self):
        for row in self.board:
            if any(icon != ' ' for icon in row):
                return False
        return True",COT,"```python
import random

class MahjongConnect:
    def __init__(self, BOARD_SIZE, ICONS):
        self.BOARD_SIZE = BOARD_SIZE
        self.ICONS = ICONS
        self.board = self.create_board()

    def create_board(self):
        num_pairs = (self.BOARD_SIZE[0] * self.BOARD_SIZE[1]) // 2
        icons = self.ICONS * (num_pairs // len(self.ICONS)) + self.ICONS[:num_pairs % len(self.ICONS)]
        icons = icons * 2
        random.shuffle(icons)
        
        board = []
        for i in range(self.BOARD_SIZE[0]):
            row = icons[i * self.BOARD_SIZE[1]:(i + 1) * self.BOARD_SIZE[1]]
            board.append(row)
        return board

    def is_valid_move(self, pos1, pos2):
        if pos1 == pos2:
            return False
        if not (0 <= pos1[0] < self.BOARD_SIZE[0] and 0 <= pos1[1] < self.BOARD_SIZE[1]):
            return False
        if not (0 <= pos2[0] < self.BOARD_SIZE[0] and 0 <= pos2[1] < self.BOARD_SIZE[1]):
            return False
        if self.board[pos1[0]][pos1[1]] != self.board[pos2[0]][pos2[1]]:
            return False
        return self.has_path(pos1, pos2)

    def has_path(self, pos1, pos2):
        if pos1[0] == pos2[0]:
            row = pos1[0]
            start = min(pos1[1], pos2[1]) + 1
            end = max(pos1[1], pos2[1])
            if all(self.board[row][col] == ' ' for col in range(start, end)):
                return True
        elif pos1[1] == pos2[1]:
            col = pos1[1]
            start = min(pos1[0], pos2[0]) + 1
            end = max(pos1[0], pos2[0])
            if all(self.board[row][col] == ' ' for row in range(start, end)):
                return True
        return False

    def remove_icons(self, pos1, pos2):
        self.board[pos1[0]][pos1[1]] = ' '
        self.board[pos2[0]][pos2[1]] = ' '

    def is_game_over(self):
        for row in self.board:
            for icon in row:
                if icon != ' ':
                    return False
        return True
```",0.206124126,0.252294895,0.37398374,0.474226804,0.418181813,0.301801802,0.366120219,0.330864193,0.37398374,0.474226804,0.418181813,,,,,,,,,,,,
GPT,55,"class Manacher:
    def __init__(self, input_string) -> None:
        self.input_string = input_string

    def palindromic_length(self, center, diff, string):
        if (center - diff == -1 or center + diff == len(string)
                or string[center - diff] != string[center + diff]):
            return 0
        return 1 + self.palindromic_length(center, diff + 1, string)


    def palindromic_string(self):
        max_length = 0

        new_input_string = """"
        output_string = """"

        for i in self.input_string[:len(self.input_string) - 1]:
            new_input_string += i + ""|""
        new_input_string += self.input_string[-1]

        for i in range(len(new_input_string)):

            length =self.palindromic_length(i, 1, new_input_string)

            if max_length < length:
                max_length = length
                start = i

        for i in new_input_string[start - max_length:start + max_length + 1]:
            if i != ""|"":
                output_string += i

        return output_string",COT,"```python
class Manacher:
    def __init__(self, input_string: str):
        self.input_string = input_string

    def palindromic_length(self, center: int, diff: int, string: str) -> int:
        while center - diff >= 0 and center + diff < len(string) and string[center - diff] == string[center + diff]:
            diff += 1
        return diff - 1

    def palindromic_string(self) -> str:
        if not self.input_string:
            return """"

        # Transform the original string to a new format with separators
        string = '|'.join(f'#{self.input_string}#')
        p = [0] * len(string)
        center = right = 0

        for i in range(1, len(string) - 1):
            mirror = 2 * center - i

            if i < right:
                p[i] = min(right - i, p[mirror])

            p[i] += self.palindromic_length(i, p[i] + 1, string)

            if i + p[i] > right:
                center, right = i, i + p[i]

        max_len, center_index = max((n, i) for i, n in enumerate(p))
        start = (center_index - max_len) // 2
        return self.input_string[start:start + max_len]
```",0.0625,0.094378566,0.551724138,0.363636364,0.43835616,0.223300971,0.157534247,0.184738951,0.465517241,0.306818182,0.369863009,,,,,,,,,,,,
GPT,56,"class MetricsCalculator:
    def __init__(self):
        self.true_positives = 0
        self.false_positives = 0
        self.false_negatives = 0
        self.true_negatives = 0

    def update(self, predicted_labels, true_labels):
        for predicted, true in zip(predicted_labels, true_labels):
            if predicted == 1 and true == 1:
                self.true_positives += 1
            elif predicted == 1 and true == 0:
                self.false_positives += 1
            elif predicted == 0 and true == 1:
                self.false_negatives += 1
            elif predicted == 0 and true == 0:
                self.true_negatives += 1

    def precision(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        if self.true_positives + self.false_positives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_positives)

    def recall(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        if self.true_positives + self.false_negatives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_negatives)

    def f1_score(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        precision = self.precision(predicted_labels, true_labels)
        recall = self.recall(predicted_labels, true_labels)
        if precision + recall == 0.0:
            return 0.0
        return (2 * precision * recall) / (precision + recall)

    def accuracy(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives
        if total == 0:
            return 0.0
        return (self.true_positives + self.true_negatives) / total",COT,"```python
class MetricsCalculator:
    def __init__(self):
        self.true_positives = 0
        self.false_positives = 0
        self.false_negatives = 0
        self.true_negatives = 0

    def update(self, predicted_labels, true_labels):
        for predicted, true in zip(predicted_labels, true_labels):
            if predicted == 1 and true == 1:
                self.true_positives += 1
            elif predicted == 1 and true == 0:
                self.false_positives += 1
            elif predicted == 0 and true == 1:
                self.false_negatives += 1
            elif predicted == 0 and true == 0:
                self.true_negatives += 1

    def precision(self):
        if (self.true_positives + self.false_positives) == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_positives)

    def recall(self):
        if (self.true_positives + self.false_negatives) == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_negatives)

    def f1_score(self):
        prec = self.precision()
        rec = self.recall()
        if (prec + rec) == 0:
            return 0.0
        return 2 * (prec * rec) / (prec + rec)

    def accuracy(self):
        total = self.true_positives + self.false_positives + self.false_negatives + self.true_negatives
        if total == 0:
            return 0.0
        return (self.true_positives + self.true_negatives) / total
```",0.614389608,0.647871656,0.74,0.74,0.739999995,0.623853211,0.673267327,0.647619043,0.74,0.74,0.739999995,,,,,,,,,,,,
GPT,57,"import numpy as np


class MetricsCalculator2:
    def __init__(self):
        pass

    @staticmethod
    def mrr(data):
        if type(data) != list and type(data) != tuple:
            raise Exception(""the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple"")

        if len(data) == 0:
            return 0.0, [0.0]
        if type(data) == tuple:
            (sub_list, total_num) = data
            sub_list = np.array(sub_list)
            if total_num == 0:
                return 0.0, [0.0]
            else:
                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                mr_np = sub_list * ranking_array

                mr = 0.0
                for team in mr_np:
                    if team > 0:
                        mr = team
                        break
                return mr, [mr]

        if type(data) == list:
            separate_result = []
            for (sub_list, total_num) in data:
                sub_list = np.array(sub_list)

                if total_num == 0:
                    mr = 0.0
                else:
                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                    mr_np = sub_list * ranking_array

                    mr = 0.0
                    for team in mr_np:
                        if team > 0:
                            mr = team
                            break

                separate_result.append(mr)
            return np.mean(separate_result), separate_result

    @staticmethod
    def map(data):
        if type(data) != list and type(data) != tuple:
            raise Exception(""the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple"")

        if len(data) == 0:
            return 0.0, [0.0]
        if type(data) == tuple:
            (sub_list, total_num) = data
            sub_list = np.array(sub_list)
            if total_num == 0:
                return 0.0, [0.0]
            else:
                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)

                right_ranking_list = []
                count = 1
                for t in sub_list:
                    if t == 0:
                        right_ranking_list.append(0)
                    else:
                        right_ranking_list.append(count)
                        count += 1

                ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num
                return ap, [ap]

        if type(data) == list:
            separate_result = []
            for (sub_list, total_num) in data:
                sub_list = np.array(sub_list)

                if total_num == 0:
                    ap = 0.0
                else:
                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)

                    right_ranking_list = []
                    count = 1
                    for t in sub_list:
                        if t == 0:
                            right_ranking_list.append(0)
                        else:
                            right_ranking_list.append(count)
                            count += 1

                    ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num

                separate_result.append(ap)
            return np.mean(separate_result), separate_result",COT,"```python
import numpy as np

class MetricsCalculator2:
    def __init__(self):
        pass

    @staticmethod
    def mrr(data):
        if isinstance(data[0], list):
            mrr_values = []
            for item in data:
                actual, ground_truth_num = item
                reciprocal_rank = 0
                for idx, val in enumerate(actual):
                    if val == 1:
                        reciprocal_rank = 1 / (idx + 1)
                        break
                mrr_values.append(reciprocal_rank)
            return np.mean(mrr_values), mrr_values
        else:
            actual, ground_truth_num = data
            for idx, val in enumerate(actual):
                if val == 1:
                    return 1 / (idx + 1), [1 / (idx + 1)]
            return 0, [0]

    @staticmethod
    def map(data):
        if isinstance(data[0], list):
            map_values = []
            for item in data:
                actual, ground_truth_num = item
                num_hits = 0
                sum_precisions = 0
                for idx, val in enumerate(actual):
                    if val == 1:
                        num_hits += 1
                        sum_precisions += num_hits / (idx + 1)
                average_precision = sum_precisions / ground_truth_num
                map_values.append(average_precision)
            return np.mean(map_values), map_values
        else:
            actual, ground_truth_num = data
            num_hits = 0
            sum_precisions = 0
            for idx, val in enumerate(actual):
                if val == 1:
                    num_hits += 1
                    sum_precisions += num_hits / (idx + 1)
            average_precision = sum_precisions / ground_truth_num
            return average_precision, [average_precision]
```",0.04312418,0.072174076,0.352941176,0.517241379,0.419580415,0.165517241,0.25,0.19917012,0.341176471,0.5,0.405594401,,,,,,,,,,,,
GPT,58,"import random

class MinesweeperGame:
    def __init__(self, n, k) -> None:
        self.n = n
        self.k = k
        self.minesweeper_map = self.generate_mine_sweeper_map()
        self.player_map = self.generate_playerMap()
        self.score = 0

    def generate_mine_sweeper_map(self):
        arr = [[0 for row in range(self.n)] for column in range(self.n)]
        for num in range(self.k):
            x = random.randint(0, self.n-1)
            y = random.randint(0, self.n-1)
            arr[y][x] = 'X'
            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-1):
                if arr[y][x+1] != 'X':
                    arr[y][x+1] += 1
            if (x >=1 and x <= self.n-1) and (y >= 0 and y <= self.n-1):
                if arr[y][x-1] != 'X':
                    arr[y][x-1] += 1
            if (x >= 1 and x <= self.n-1) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x-1] != 'X':
                    arr[y-1][x-1] += 1
    
            if (x >= 0 and x <= self.n-2) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x+1] != 'X':
                    arr[y-1][x+1] += 1 
            if (x >= 0 and x <= self.n-1) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x] != 'X':
                    arr[y-1][x] += 1
    
            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x+1] != 'X':
                    arr[y+1][x+1] += 1
            if (x >= 1 and x <= self.n-1) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x-1] != 'X':
                    arr[y+1][x-1] += 1
            if (x >= 0 and x <= self.n-1) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x] != 'X':
                    arr[y+1][x] += 1
        return arr
    
    def generate_playerMap(self):
        arr = [['-' for row in range(self.n)] for column in range(self.n)]
        return arr

    def check_won(self, map):
        for i in range(self.n):
            for j in range(self.n):
                if map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':
                    return False
        return True
    
    def sweep(self, x, y):

        if (self.minesweeper_map[x][y] == 'X'):
            return False
        else:
            self.player_map[x][y] = self.minesweeper_map[x][y]
            self.score += 1
            if self.check_won(self.player_map) == True:
                return True
            return self.player_map",COT,"```python
import random

class MinesweeperGame:
    def __init__(self, n, k):
        self.n = n
        self.k = k
        self.minesweeper_map = self.generate_mine_sweeper_map()
        self.player_map = self.generate_playerMap()
        self.score = 0

    def generate_mine_sweeper_map(self):
        minesweeper_map = [[0 for _ in range(self.n)] for _ in range(self.n)]
        mines = set()
        while len(mines) < self.k:
            x = random.randint(0, self.n - 1)
            y = random.randint(0, self.n - 1)
            mines.add((x, y))
        for x, y in mines:
            minesweeper_map[x][y] = 'X'
            for i in range(max(0, x-1), min(self.n, x+2)):
                for j in range(max(0, y-1), min(self.n, y+2)):
                    if minesweeper_map[i][j] != 'X':
                        minesweeper_map[i][j] += 1
        return minesweeper_map

    def generate_playerMap(self):
        return [['-' for _ in range(self.n)] for _ in range(self.n)]

    def check_won(self, map):
        for i in range(self.n):
            for j in range(self.n):
                if map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':
                    return False
        return True

    def sweep(self, x, y):
        if self.minesweeper_map[x][y] == 'X':
            return False
        self.player_map[x][y] = self.minesweeper_map[x][y]
        if self.check_won(self.player_map):
            return True
        return self.player_map
```",0.132009319,0.155064829,0.635294118,0.72,0.674999995,0.456140351,0.595419847,0.516556286,0.623529412,0.706666667,0.662499995,,,,,,,,,,,,
GPT,59,"from datetime import datetime
import numpy as np

class MovieBookingSystem:
    def __init__(self):
        self.movies = []

    def add_movie(self, name, price, start_time, end_time, n):
        movie = {
            'name': name,
            'price': price,
            'start_time': datetime.strptime(start_time, '%H:%M'),
            'end_time': datetime.strptime(end_time, '%H:%M'),
            'seats': np.zeros((n, n))
        }
        self.movies.append(movie)

    def book_ticket(self, name, seats_to_book):
        for movie in self.movies:
            if movie['name'] == name:
                for seat in seats_to_book:
                    if movie['seats'][seat[0]][seat[1]] == 0:
                        movie['seats'][seat[0]][seat[1]] = 1
                    else:
                        return ""Booking failed.""
                return ""Booking success.""
        return ""Movie not found.""


    def available_movies(self, start_time, end_time):
        start_time = datetime.strptime(start_time, '%H:%M')
        end_time = datetime.strptime(end_time, '%H:%M')

        available_movies = []
        for movie in self.movies:
            if start_time <= movie['start_time'] and movie['end_time'] <= end_time:
                available_movies.append(movie['name'])

        return available_movies",COT,"```python
from datetime import datetime
import numpy as np

class MovieBookingSystem:
    def __init__(self):
        self.movies = []

    def add_movie(self, name, price, start_time, end_time, n):
        movie = {
            'name': name,
            'price': price,
            'start_time': datetime.strptime(start_time, '%H:%M'),
            'end_time': datetime.strptime(end_time, '%H:%M'),
            'seats': np.zeros((n, n))
        }
        self.movies.append(movie)

    def book_ticket(self, name, seats_to_book):
        for movie in self.movies:
            if movie['name'].lower() == name.lower():
                for seat in seats_to_book:
                    row, col = seat
                    if movie['seats'][row][col] == 0:
                        movie['seats'][row][col] = 1
                    else:
                        return ""Booking failed.""
                return ""Booking success.""
        return ""Movie not found.""

    def available_movies(self, start_time, end_time):
        available = []
        start_time = datetime.strptime(start_time, '%H:%M')
        end_time = datetime.strptime(end_time, '%H:%M')
        for movie in self.movies:
            if movie['start_time'] >= start_time and movie['end_time'] <= end_time:
                available.append(movie['name'])
        return available
```",0.694444444,0.738598193,0.956521739,0.868421053,0.910344823,0.817307692,0.758928571,0.787037032,0.956521739,0.868421053,0.910344823,,,,,,,,,,,,
GPT,5,"class AutomaticGuitarSimulator:
    def __init__(self, text) -> None:
        self.play_text = text

    def interpret(self, display=False):
        if len(self.play_text) == 0:
            return
        else:
            play_list = []
            play_segs = self.play_text.split("" "")
            for play_seg in play_segs:
                pos = 0
                for ele in play_seg:
                    if ele.isalpha():
                        pos += 1
                        continue
                    break
                play_chord = play_seg[0:pos]
                play_value = play_seg[pos:]
                play_list.append({'Chord': play_chord, 'Tune': play_value})
                if display:
                    self.display(play_chord, play_value)
            return play_list

    def display(self, key, value):
        return ""Normal Guitar Playing -- Chord: %s, Play Tune: %s"" % (key, value)",COT,"```python
class AutomaticGuitarSimulator:
    def __init__(self, text) -> None:
        self.play_text = text

    def interpret(self, display=False):
        play_list = []
        parts = self.play_text.split()
        for part in parts:
            chord = ''.join(filter(str.isalpha, part))
            tune = ''.join(filter(str.isdigit, part))
            play_list.append({'Chord': chord, 'Tune': tune})
            if display:
                self.display(chord, tune)
        return play_list

    def display(self, key, value):
        return f""Normal Guitar Playing -- Chord: {key}, Play Tune: {value}""
```",0.243224256,0.289436471,0.484375,0.607843137,0.53913043,0.353658537,0.467741935,0.402777773,0.484375,0.607843137,0.53913043,,,,,,,,,,,,
GPT,60,"import sqlite3


class MovieTicketDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS tickets (
                id INTEGER PRIMARY KEY,
                movie_name TEXT,
                theater_name TEXT,
                seat_number TEXT,
                customer_name TEXT
            )
        ''')
        self.connection.commit()

    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):
        self.cursor.execute('''
            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)
            VALUES (?, ?, ?, ?)
        ''', (movie_name, theater_name, seat_number, customer_name))
        self.connection.commit()

    def search_tickets_by_customer(self, customer_name):
        self.cursor.execute('''
            SELECT * FROM tickets WHERE customer_name = ?
        ''', (customer_name,))
        tickets = self.cursor.fetchall()
        return tickets

    def delete_ticket(self, ticket_id):
        self.cursor.execute('''
            DELETE FROM tickets WHERE id = ?
        ''', (ticket_id,))
        self.connection.commit()",COT,"```python
import sqlite3

class MovieTicketDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute(""""""
            CREATE TABLE IF NOT EXISTS tickets (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                movie_name TEXT NOT NULL,
                theater_name TEXT NOT NULL,
                seat_number TEXT NOT NULL,
                customer_name TEXT NOT NULL
            )
        """""")
        self.connection.commit()

    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):
        self.cursor.execute(""""""
            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)
            VALUES (?, ?, ?, ?)
        """""", (movie_name, theater_name, seat_number, customer_name))
        self.connection.commit()

    def search_tickets_by_customer(self, customer_name):
        self.cursor.execute(""""""
            SELECT * FROM tickets WHERE customer_name = ?
        """""", (customer_name,))
        return self.cursor.fetchall()

    def delete_ticket(self, ticket_id):
        self.cursor.execute(""""""
            DELETE FROM tickets WHERE id = ?
        """""", (ticket_id,))
        self.connection.commit()
```",0.533980583,0.588683591,0.921875,0.867647059,0.893939389,0.723404255,0.693877551,0.708333328,0.90625,0.852941176,0.878787874,,,,,,,,,,,,
GPT,61,"class MusicPlayer:
    def __init__(self):
        self.playlist = []
        self.current_song = None
        self.volume = 50

    def add_song(self, song):
        self.playlist.append(song)

    def remove_song(self, song):
        if song in self.playlist:
            self.playlist.remove(song)
            if self.current_song == song:
                self.stop()

    def play(self):
        if self.playlist and self.current_song:
            return self.playlist[0]
        elif len(self.playlist): 
            return False

    def stop(self):
        if self.current_song:
            self.current_song = None
            return True
        else:
            return False

    def switch_song(self):
        if self.current_song:
            current_index = self.playlist.index(self.current_song)
            if current_index < len(self.playlist) - 1:
                self.current_song = self.playlist[current_index + 1]
                return True
            else:
                return False
        else:
            return False

    def previous_song(self):
        if self.current_song:
            current_index = self.playlist.index(self.current_song)
            if current_index > 0:
                self.current_song = self.playlist[current_index - 1]
                return True
            else:
                return False
        else:
            return False

    def set_volume(self, volume):
        if 0 <= volume <= 100:
            self.volume = volume
        else:
            return False

    def shuffle(self):
        if self.playlist:
            import random
            random.shuffle(self.playlist)
            return True
        else:
            return False",COT,"```python
class MusicPlayer:
    def __init__(self):
        self.playlist = []
        self.current_song = None
        self.volume = 50

    def add_song(self, song):
        self.playlist.append(song)

    def remove_song(self, song):
        if song in self.playlist:
            self.playlist.remove(song)

    def play(self):
        if self.current_song in self.playlist:
            return self.current_song
        return False

    def stop(self):
        if self.current_song:
            self.current_song = None
            return True
        return False

    def switch_song(self):
        if self.current_song in self.playlist:
            index = self.playlist.index(self.current_song)
            if index + 1 < len(self.playlist):
                self.current_song = self.playlist[index + 1]
                return True
        return False

    def previous_song(self):
        if self.current_song in self.playlist:
            index = self.playlist.index(self.current_song)
            if index > 0:
                self.current_song = self.playlist[index - 1]
                return True
        return False

    def set_volume(self, volume):
        if 0 <= volume <= 100:
            self.volume = volume
            return True
        return False

    def shuffle(self):
        if self.playlist:
            import random
            random.shuffle(self.playlist)
            return True
        return False
```",0.52610187,0.579139383,0.830508475,0.907407407,0.867256632,0.721153846,0.79787234,0.757575753,0.830508475,0.907407407,0.867256632,,,,,,,,,,,,
GPT,62,"class NLPDataProcessor:

    def construct_stop_word_list(self):
        stop_word_list = ['a', 'an', 'the']
        return stop_word_list

    def remove_stop_words(self, string_list, stop_word_list):
        answer = []
        for string in string_list:
            string_split = string.split()
            for word in string_split:
                if word in stop_word_list:
                    string_split.remove(word)
            answer.append(string_split)
        return answer

    def process(self, string_list):
        stop_word_list = self.construct_stop_word_list()
        words_list = self.remove_stop_words(string_list, stop_word_list)
        return words_list",COT,"```python
class NLPDataProcessor:
    
    def construct_stop_word_list(self):
        # Construct a stop word list including 'a', 'an', 'the'
        return ['a', 'an', 'the']
    
    def remove_stop_words(self, string_list, stop_word_list):
        # Remove all the stop words from the list of strings
        result = []
        for sentence in string_list:
            words = sentence.split()
            filtered_words = [word for word in words if word.lower() not in stop_word_list]
            result.append(filtered_words)
        return result
    
    def process(self, string_list):
        # Construct a stop word list and remove all the stop words from the list of strings
        stop_word_list = self.construct_stop_word_list()
        return self.remove_stop_words(string_list, stop_word_list)
```",0.107142857,0.122133436,0.764705882,0.490566038,0.597701145,0.42,0.272727273,0.330708657,0.764705882,0.490566038,0.597701145,,,,,,,,,,,,
GPT,63,"from collections import Counter
import re

class NLPDataProcessor2:

    def process_data(self, string_list):
        words_list = []
        for string in string_list:
            # Remove non-English letters and convert to lowercase
            processed_string = re.sub(r'[^a-zA-Z\s]', '', string.lower())
            # Split the string into words
            words = processed_string.split()
            words_list.append(words)
        return words_list

    def calculate_word_frequency(self, words_list):
        word_frequency = Counter()
        for words in words_list:
            word_frequency.update(words)
        sorted_word_frequency = dict(sorted(word_frequency.items(), key=lambda x: x[1], reverse=True))
        top_5_word_frequency = dict(list(sorted_word_frequency.items())[:5])
        return top_5_word_frequency

    def process(self, string_list):
        words_list = self.process_data(string_list)
        word_frequency_dict = self.calculate_word_frequency(words_list)
        return word_frequency_dict",COT,"```python
from collections import Counter
import re

class NLPDataProcessor2:
    def process_data(self, string_list):
        words_list = []
        for string in string_list:
            # Keep only English letters and spaces, convert to lowercase
            processed_string = re.sub(r'[^a-zA-Z\s]', '', string).lower()
            words = processed_string.split()
            words_list.append(words)
        return words_list

    def calculate_word_frequency(self, words_list):
        word_frequency = Counter()
        for words in words_list:
            word_frequency.update(words)
        # Return the top 5 most common words
        return dict(word_frequency.most_common(5))

    def process(self, string_list):
        words_list = self.process_data(string_list)
        return self.calculate_word_frequency(words_list)
```",0.545563737,0.589986952,0.719298246,0.732142857,0.725663712,0.609756098,0.666666667,0.63694267,0.719298246,0.732142857,0.725663712,,,,,,,,,,,,
GPT,64,"class NumberConverter:
    @staticmethod
    def decimal_to_binary(decimal_num):
        binary_num = bin(decimal_num)[2:]
        return binary_num

    @staticmethod
    def binary_to_decimal(binary_num):
        decimal_num = int(binary_num, 2)
        return decimal_num

    @staticmethod
    def decimal_to_octal(decimal_num):
        octal_num = oct(decimal_num)[2:]
        return octal_num

    @staticmethod
    def octal_to_decimal(octal_num):
        decimal_num = int(octal_num, 8)
        return decimal_num

    @staticmethod
    def decimal_to_hex(decimal_num):
        hex_num = hex(decimal_num)[2:]
        return hex_num

    @staticmethod
    def hex_to_decimal(hex_num):
        decimal_num = int(hex_num, 16)
        return decimal_num",COT,"```python
class NumberConverter:
    @staticmethod
    def decimal_to_binary(decimal_num):
        return bin(decimal_num)[2:]

    @staticmethod
    def binary_to_decimal(binary_num):
        return int(binary_num, 2)

    @staticmethod
    def decimal_to_octal(decimal_num):
        return oct(decimal_num)[2:]

    @staticmethod
    def octal_to_decimal(octal_num):
        return int(octal_num, 8)

    @staticmethod
    def decimal_to_hex(decimal_num):
        return hex(decimal_num)[2:]

    @staticmethod
    def hex_to_decimal(hex_num):
        return int(hex_num, 16)
```",0.14832656,0.180652269,0.8,0.909090909,0.851063825,0.285714286,0.387096774,0.328767118,0.68,0.772727273,0.72340425,,,,,,,,,,,,
GPT,65,"class NumberWordFormatter:
    def __init__(self):
        self.NUMBER = ["""", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""]
        self.NUMBER_TEEN = [""TEN"", ""ELEVEN"", ""TWELVE"", ""THIRTEEN"", ""FOURTEEN"", ""FIFTEEN"", ""SIXTEEN"", ""SEVENTEEN"",
                            ""EIGHTEEN"",
                            ""NINETEEN""]
        self.NUMBER_TEN = [""TEN"", ""TWENTY"", ""THIRTY"", ""FORTY"", ""FIFTY"", ""SIXTY"", ""SEVENTY"", ""EIGHTY"", ""NINETY""]
        self.NUMBER_MORE = ["""", ""THOUSAND"", ""MILLION"", ""BILLION""]
        self.NUMBER_SUFFIX = [""k"", ""w"", """", ""m"", """", """", ""b"", """", """", ""t"", """", """", ""p"", """", """", ""e""]

    def format(self, x):
        if x is not None:
            return self.format_string(str(x))
        else:
            return """"

    def format_string(self, x):
        lstr, rstr = (x.split('.') + [''])[:2]
        lstrrev = lstr[::-1]
        a = [''] * 5

        if len(lstrrev) % 3 == 1:
            lstrrev += ""00""
        elif len(lstrrev) % 3 == 2:
            lstrrev += ""0""

        lm = """"
        for i in range(len(lstrrev) // 3):
            a[i] = lstrrev[3 * i:3 * i + 3][::-1]
            if a[i] != ""000"":
                lm = self.trans_three(a[i]) + "" "" + self.parse_more(i) + "" "" + lm
            else:
                lm += self.trans_three(a[i])

        xs = f""AND CENTS {self.trans_two(rstr)} "" if rstr else """"
        if not lm.strip():
            return ""ZERO ONLY""
        else:
            return f""{lm.strip()} {xs}ONLY""

    def trans_two(self, s):
        s = s.zfill(2)
        if s[0] == ""0"":
            return self.NUMBER[int(s[-1])]
        elif s[0] == ""1"":
            return self.NUMBER_TEEN[int(s) - 10]
        elif s[1] == ""0"":
            return self.NUMBER_TEN[int(s[0]) - 1]
        else:
            return self.NUMBER_TEN[int(s[0]) - 1] + "" "" + self.NUMBER[int(s[-1])]

    def trans_three(self, s):
        if s[0] == ""0"":
            return self.trans_two(s[1:])
        elif s[1:] == ""00"":
            return f""{self.NUMBER[int(s[0])]} HUNDRED""
        else:
            return f""{self.NUMBER[int(s[0])]} HUNDRED AND {self.trans_two(s[1:])}""

    def parse_more(self, i):
        return self.NUMBER_MORE[i]",COT,"```python
class NumberWordFormatter:
    def __init__(self):
        self.NUMBER = ["""", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""]
        self.NUMBER_TEEN = [""TEN"", ""ELEVEN"", ""TWELVE"", ""THIRTEEN"", ""FOURTEEN"", ""FIFTEEN"", ""SIXTEEN"", ""SEVENTEEN"",
                            ""EIGHTEEN"", ""NINETEEN""]
        self.NUMBER_TEN = [""TEN"", ""TWENTY"", ""THIRTY"", ""FORTY"", ""FIFTY"", ""SIXTY"", ""SEVENTY"", ""EIGHTY"", ""NINETY""]
        self.NUMBER_MORE = ["""", ""THOUSAND"", ""MILLION"", ""BILLION""]
        self.NUMBER_SUFFIX = [""k"", ""w"", """", ""m"", """", """", ""b"", """", """", ""t"", """", """", ""p"", """", """", ""e""]

    def format(self, x):
        if isinstance(x, float):
            integer_part, decimal_part = str(x).split(""."")
            integer_part = self.format_string(integer_part)
            decimal_part = self.format_string(decimal_part)
            return f""{integer_part} POINT {decimal_part} ONLY""
        else:
            return f""{self.format_string(str(x))} ONLY""

    def format_string(self, x):
        if x == ""0"":
            return ""ZERO""
        parts = []
        length = len(x)
        num_groups = (length + 2) // 3
        x = x.zfill(num_groups * 3)
        for i in range(num_groups):
            start = i * 3
            end = start + 3
            group = x[start:end]
            if group != ""000"":
                part = self.trans_three(group)
                if i < len(self.NUMBER_MORE):
                    part += f"" {self.NUMBER_MORE[num_groups - i - 1]}""
                parts.append(part.strip())
        return "" "".join(parts)

    def trans_two(self, s):
        if s[0] == '0':
            return self.NUMBER[int(s[1])]
        elif s[0] == '1':
            return self.NUMBER_TEEN[int(s[1])]
        else:
            return f""{self.NUMBER_TEN[int(s[0]) - 1]} {self.NUMBER[int(s[1])]}"".strip()

    def trans_three(self, s):
        if s[0] == '0':
            return self.trans_two(s[1:])
        else:
            return f""{self.NUMBER[int(s[0])]} HUNDRED AND {self.trans_two(s[1:])}"".strip()

    def parse_more(self, i):
        if i < len(self.NUMBER_MORE):
            return self.NUMBER_MORE[i]
        return """"
```",0.344459304,0.39736024,0.635714286,0.644927536,0.640287765,0.452054795,0.485294118,0.468085101,0.621428571,0.630434783,0.625899276,,,,,,,,,,,,
GPT,66,"class NumericEntityUnescaper:
    def __init__(self):
        pass

    def replace(self, string):
        out = []
        pos = 0
        length = len(string)

        while pos < length - 2:
            if string[pos] == '&' and string[pos + 1] == '#':
                start = pos + 2
                is_hex = False
                first_char = string[start]

                if first_char == 'x' or first_char == 'X':
                    start += 1
                    is_hex = True

                if start == length:
                    return ''.join(out)

                end = start
                while end < length and self.is_hex_char(string[end]):
                    end += 1

                if end < length and string[end] == ';':
                    try:
                        entity_value = int(string[start:end], 16 if is_hex else 10)
                    except:
                        return ''.join(out)

                    out.append(chr(entity_value))
                    pos = end + 1
                    continue

            out.append(string[pos])
            pos += 1

        return ''.join(out)

    @staticmethod
    def is_hex_char(char):
        return char.isdigit() or ('a' <= char.lower() <= 'f')",COT,"```python
class NumericEntityUnescaper:
    
    def __init__(self):
        pass

    def replace(self, string):
        result = []
        i = 0
        length = len(string)
        while i < length:
            if string[i] == '&' and i + 1 < length and string[i + 1] == '#':
                is_hex = False
                start = i + 2
                if start < length and (string[start] == 'x' or string[start] == 'X'):
                    is_hex = True
                    start += 1
                end = start
                while end < length and (string[end].isdigit() or (is_hex and self.is_hex_char(string[end]))):
                    end += 1
                if end < length and string[end] == ';':
                    entity = string[start:end]
                    try:
                        if is_hex:
                            codepoint = int(entity, 16)
                        else:
                            codepoint = int(entity)
                        result.append(chr(codepoint))
                        i = end + 1
                        continue
                    except ValueError:
                        pass
            result.append(string[i])
            i += 1
        return ''.join(result)

    @staticmethod
    def is_hex_char(char):
        return char.isdigit() or ('a' <= char <= 'f') or ('A' <= char <= 'F')
```",0.313432836,0.375973876,0.712121212,0.643835616,0.676258988,0.50877193,0.467741935,0.487394953,0.636363636,0.575342466,0.604316542,,,,,,,,,,,,
GPT,67,"class Order:

    def __init__(self):
        self.menu = []
        # menu = [{""dish"": dish name, ""price"": price, ""count"": count}, ...]
        self.selected_dishes = []
        # selected_dish = {""dish"": dish name, ""count"": count, price: price}
        self.sales = {}
        # 


    def add_dish(self, dish):
        for menu_dish in self.menu:
            if dish[""dish""] == menu_dish[""dish""]:
                if menu_dish[""count""] < dish[""count""]:
                    return False
                else:
                    menu_dish[""count""] -= dish[""count""]
                    break
        self.selected_dishes.append(dish)
        return True

    def calculate_total(self):
        total = 0
        for dish in self.selected_dishes:
            total += dish[""price""] * dish[""count""] * self.sales[dish[""dish""]]
        return total

    def checkout(self):
        if len(self.selected_dishes) == 0:
            return False
        total = self.calculate_total()
        self.selected_dishes = []
        return total",COT,"```python
class Order:
    def __init__(self):
        self.menu = []
        self.selected_dishes = []
        self.sales = {}

    def add_dish(self, dish):
        for item in self.menu:
            if item[""dish""] == dish[""dish""] and item[""count""] >= dish[""count""]:
                self.selected_dishes.append(dish)
                item[""count""] -= dish[""count""]
                return True
        return False

    def calculate_total(self):
        total = 0.0
        for dish in self.selected_dishes:
            price = dish[""price""]
            count = dish[""count""]
            sales_multiplier = self.sales.get(dish[""dish""], 1)
            total += price * count * sales_multiplier
        return total

    def checkout(self):
        if not self.selected_dishes:
            return False
        total = self.calculate_total()
        self.selected_dishes.clear()
        return total
```",0.214821771,0.275087541,0.610169492,0.72,0.660550454,0.423913043,0.481481481,0.450867047,0.593220339,0.7,0.64220183,,,,,,,,,,,,
GPT,68,"class PageUtil:
    def __init__(self, data, page_size):
        self.data = data
        self.page_size = page_size
        self.total_items = len(data)
        self.total_pages = (self.total_items + page_size - 1) // page_size

    def get_page(self, page_number):
        if page_number < 1 or page_number > self.total_pages:
            return []

        start_index = (page_number - 1) * self.page_size
        end_index = start_index + self.page_size
        return self.data[start_index:end_index]

    def get_page_info(self, page_number):
        if page_number < 1 or page_number > self.total_pages:
            return {}

        start_index = (page_number - 1) * self.page_size
        end_index = min(start_index + self.page_size, self.total_items)
        page_data = self.data[start_index:end_index]

        page_info = {
            ""current_page"": page_number,
            ""per_page"": self.page_size,
            ""total_pages"": self.total_pages,
            ""total_items"": self.total_items,
            ""has_previous"": page_number > 1,
            ""has_next"": page_number < self.total_pages,
            ""data"": page_data
        }
        return page_info

    def search(self, keyword):
        results = [item for item in self.data if keyword in str(item)]
        num_results = len(results)
        num_pages = (num_results + self.page_size - 1) // self.page_size

        search_info = {
            ""keyword"": keyword,
            ""total_results"": num_results,
            ""total_pages"": num_pages,
            ""results"": results
        }
        return search_info",COT,"```python
class PageUtil:
    def __init__(self, data, page_size):
        self.data = data
        self.page_size = page_size
        self.total_items = len(data)
        self.total_pages = (self.total_items + page_size - 1) // page_size

    def get_page(self, page_number):
        if page_number < 1 or page_number > self.total_pages:
            return []
        start_index = (page_number - 1) * self.page_size
        end_index = start_index + self.page_size
        return self.data[start_index:end_index]

    def get_page_info(self, page_number):
        page_data = self.get_page(page_number)
        return {
            ""current_page"": page_number,
            ""per_page"": self.page_size,
            ""total_pages"": self.total_pages,
            ""total_items"": self.total_items,
            ""has_previous"": page_number > 1,
            ""has_next"": page_number < self.total_pages,
            ""data"": page_data
        }

    def search(self, keyword):
        results = [item for item in self.data if keyword in str(item)]
        total_results = len(results)
        total_pages = (total_results + self.page_size - 1) // self.page_size
        return {
            ""keyword"": keyword,
            ""total_results"": total_results,
            ""total_pages"": total_pages,
            ""results"": results
        }
```",0.6144271,0.64622409,0.864864865,0.914285714,0.888888884,0.795275591,0.863247863,0.827868847,0.864864865,0.914285714,0.888888884,,,,,,,,,,,,
GPT,69,"import PyPDF2


class PDFHandler:
    def __init__(self, filepaths):
        self.filepaths = filepaths
        # PdfFileReader is deprecated and was removed in PyPDF2 3.0.0. Use PdfReader instead.
        self.readers = [PyPDF2.PdfReader(fp) for fp in filepaths]

    def merge_pdfs(self, output_filepath):
        pdf_writer = PyPDF2.PdfWriter()

        for reader in self.readers:
            # reader.getNumPages is deprecated and was removed in PyPDF2 3.0.0. Use len(reader.pages) instead.
            for page_num in range(len(reader.pages)):
                # reader.getPage(pageNumber) is deprecated and was removed in PyPDF2 3.0.0. Use reader.pages[page_number] instead.
                page = reader.pages[page_num]
                # addPage is deprecated and was removed in PyPDF2 3.0.0. Use add_page instead.
                pdf_writer.add_page(page)

        with open(output_filepath, 'wb') as out:
            pdf_writer.write(out)
        return f""Merged PDFs saved at {output_filepath}""

    def extract_text_from_pdfs(self):
        pdf_texts = []
        for reader in self.readers:
            for page_num in range(len(reader.pages)):
                page = reader.pages[page_num]
                pdf_texts.append(page.extract_text())
        return pdf_texts",COT,"```python
import PyPDF2

class PDFHandler:
    def __init__(self, filepaths):
        self.filepaths = filepaths
        self.readers = [PyPDF2.PdfReader(fp) for fp in filepaths]

    def merge_pdfs(self, output_filepath):
        merger = PyPDF2.PdfWriter()
        for reader in self.readers:
            for page in range(len(reader.pages)):
                merger.add_page(reader.pages[page])
        with open(output_filepath, 'wb') as output_file:
            merger.write(output_file)
        return f""Merged PDFs saved at {output_filepath}""

    def extract_text_from_pdfs(self):
        pdf_texts = []
        for reader in self.readers:
            text = ''
            for page in range(len(reader.pages)):
                text += reader.pages[page].extract_text() or ''
            pdf_texts.append(text)
        return pdf_texts
```",0.266680744,0.299496384,0.584615385,0.730769231,0.649572645,0.455445545,0.613333333,0.522727268,0.584615385,0.730769231,0.649572645,,,,,,,,,,,,
GPT,6,"class AvgPartition:
    def __init__(self, lst, limit):
        self.lst = lst
        self.limit = limit

    def setNum(self):
        size = len(self.lst) // self.limit
        remainder = len(self.lst) % self.limit
        return size, remainder

        
    def get(self, index):
        size, remainder = self.setNum()
        start = index * size + min(index, remainder)
        end = start + size
        if index + 1 <= remainder:
            end += 1
        return self.lst[start:end]",COT,"```python
class AvgPartition:
    def __init__(self, lst, limit):
        self.lst = lst
        self.limit = limit

    def setNum(self):
        size = len(self.lst) // self.limit
        remainder = len(self.lst) % self.limit
        return size, remainder

    def get(self, index):
        size, remainder = self.setNum()
        start = index * size + min(index, remainder)
        end = start + size + (1 if index < remainder else 0)
        return self.lst[start:end]
```",0.789473684,0.820147038,0.885714286,0.837837838,0.861111106,0.847457627,0.847457627,0.847457622,0.885714286,0.837837838,0.861111106,,,,,,,,,,,,
GPT,70,"class PersonRequest:
    def __init__(self, name: str, sex: str, phoneNumber: str):
        self.name = self._validate_name(name)
        self.sex = self._validate_sex(sex)
        self.phoneNumber = self._validate_phoneNumber(phoneNumber)

    def _validate_name(self, name: str) -> str:
        if not name:
            return None
        if len(name) > 33:
            return None
        return name

    def _validate_sex(self, sex: str) -> str:
        if sex not in [""Man"", ""Woman"", ""UGM""]:
            return None
        return sex

    def _validate_phoneNumber(self, phoneNumber: str) -> str:
        if not phoneNumber:
            return None
        if len(phoneNumber) != 11 or not phoneNumber.isdigit():
            return None
        return phoneNumber",COT,"```python
class PersonRequest:
    def __init__(self, name: str, sex: str, phoneNumber: str):
        self.name = self._validate_name(name)
        self.sex = self._validate_sex(sex)
        self.phoneNumber = self._validate_phoneNumber(phoneNumber)
    
    def _validate_name(self, name: str) -> str:
        if not name or len(name) > 33:
            return None
        return name

    def _validate_sex(self, sex: str) -> str:
        if sex not in [""Man"", ""Woman"", ""UGM""]:
            return None
        return sex

    def _validate_phoneNumber(self, phoneNumber: str) -> str:
        if not phoneNumber or len(phoneNumber) != 11 or not phoneNumber.isdigit():
            return None
        return phoneNumber
```",0.84030414,0.853400583,1,0.951219512,0.974999995,0.895522388,0.895522388,0.895522383,1,0.951219512,0.974999995,,,,,,,,,,,,
GPT,71,"class PushBoxGame:
    def __init__(self, map):
        self.map = map
        self.player_row = 0
        self.player_col = 0
        self.targets = []
        self.boxes = []
        self.target_count = 0
        self.is_game_over = False

        self.init_game()

    def init_game(self):
        for row in range(len(self.map)):
            for col in range(len(self.map[row])):
                if self.map[row][col] == ""O"":
                    self.player_row = row
                    self.player_col = col
                elif self.map[row][col] == ""G"":
                    self.targets.append((row, col))
                    self.target_count += 1
                elif self.map[row][col] == ""X"":
                    self.boxes.append((row, col))

    def check_win(self):
        box_on_target_count = 0
        for box in self.boxes:
            if box in self.targets:
                box_on_target_count += 1
        if box_on_target_count == self.target_count:
            self.is_game_over = True
        return self.is_game_over

    def move(self, direction):
        new_player_row = self.player_row
        new_player_col = self.player_col

        if direction == ""w"":
            new_player_row -= 1
        elif direction == ""s"":
            new_player_row += 1
        elif direction == ""a"":
            new_player_col -= 1
        elif direction == ""d"":
            new_player_col += 1

        if self.map[new_player_row][new_player_col] != ""#"":
            if (new_player_row, new_player_col) in self.boxes:
                new_box_row = new_player_row + (new_player_row - self.player_row)
                new_box_col = new_player_col + (new_player_col - self.player_col)

                if self.map[new_box_row][new_box_col] != ""#"":
                    self.boxes.remove((new_player_row, new_player_col))
                    self.boxes.append((new_box_row, new_box_col))
                    self.player_row = new_player_row
                    self.player_col = new_player_col
            else:
                self.player_row = new_player_row
                self.player_col = new_player_col

        return self.check_win()",COT,"```python
class PushBoxGame:
    def __init__(self, map):
        self.map = map
        self.player_row = 0
        self.player_col = 0
        self.targets = []
        self.boxes = []
        self.target_count = 0
        self.is_game_over = False
        self.init_game()

    def init_game(self):
        for r, row in enumerate(self.map):
            for c, char in enumerate(row):
                if char == 'O':
                    self.player_row = r
                    self.player_col = c
                elif char == 'G':
                    self.targets.append((r, c))
                    self.target_count += 1
                elif char == 'X':
                    self.boxes.append((r, c))

    def check_win(self):
        for box in self.boxes:
            if box not in self.targets:
                self.is_game_over = False
                return False
        self.is_game_over = True
        return True

    def move(self, direction):
        if self.is_game_over:
            return True

        dir_map = {'w': (-1, 0), 's': (1, 0), 'a': (0, -1), 'd': (0, 1)}
        if direction not in dir_map:
            return False

        delta_row, delta_col = dir_map[direction]
        new_row = self.player_row + delta_row
        new_col = self.player_col + delta_col

        if self.map[new_row][new_col] == '#':
            return False

        if (new_row, new_col) in self.boxes:
            box_new_row = new_row + delta_row
            box_new_col = new_col + delta_col
            if self.map[box_new_row][box_new_col] == '#' or (box_new_row, box_new_col) in self.boxes:
                return False
            self.boxes.remove((new_row, new_col))
            self.boxes.append((box_new_row, box_new_col))

        self.player_row = new_row
        self.player_col = new_col

        return self.check_win()
```",0.216374269,0.287162964,0.506666667,0.436781609,0.469135797,0.356164384,0.333333333,0.344370856,0.506666667,0.436781609,0.469135797,,,,,,,,,,,,
GPT,72,"import re


class RegexUtils:

    def match(self, pattern, text):
        ans = re.match(pattern, text)
        if ans:
            return True
        else:
            return False

    def findall(self, pattern, text):
        return re.findall(pattern, text)

    def split(self, pattern, text):
        return re.split(pattern, text)

    def sub(self, pattern, replacement, text):
        return re.sub(pattern, replacement, text)

    def generate_email_pattern(self):
        pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        return pattern

    def generate_phone_number_pattern(self):
        pattern = r'\b\d{3}-\d{3}-\d{4}\b'
        return pattern

    def generate_split_sentences_pattern(self):
        pattern = r'[.!?][\s]{1,2}(?=[A-Z])'
        return pattern

    def split_sentences(self, text):
        pattern = self.generate_split_sentences_pattern()
        return self.split(pattern, text)

    def validate_phone_number(self, phone_number):
        pattern = self.generate_phone_number_pattern()
        return self.match(pattern, phone_number)

    def extract_email(self, text):
        pattern = self.generate_email_pattern()
        return self.findall(pattern, text)",COT,"```python
import re

class RegexUtils:
    
    def match(self, pattern, text):
        return bool(re.fullmatch(pattern, text))
    
    def findall(self, pattern, text):
        return re.findall(pattern, text)
    
    def split(self, pattern, text):
        return re.split(pattern, text)
    
    def sub(self, pattern, replacement, text):
        return re.sub(pattern, replacement, text)
    
    def generate_email_pattern(self):
        return r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
    
    def generate_phone_number_pattern(self):
        return r'\b\d{3}-\d{3}-\d{4}\b'
    
    def generate_split_sentences_pattern(self):
        return r'[.!?][\s]{1,2}(?=[A-Z])'
    
    def split_sentences(self, text):
        pattern = self.generate_split_sentences_pattern()
        return re.split(pattern, text)
    
    def validate_phone_number(self, phone_number):
        pattern = self.generate_phone_number_pattern()
        return bool(re.fullmatch(pattern, phone_number))
    
    def extract_email(self, text):
        pattern = self.generate_email_pattern()
        return re.findall(pattern, text)
```",0.50469704,0.557495905,0.822222222,0.860465116,0.840909086,0.615384615,0.738461538,0.671328666,0.8,0.837209302,0.818181813,,,,,,,,,,,,
GPT,73,"class RPGCharacter:
    def __init__(self, name, hp, attack_power, defense, level=1):
        self.name = name
        self.hp = hp
        self.attack_power = attack_power
        self.defense = defense
        self.level = level
        self.exp = 0

    def attack(self, other_character):
        damage = max(self.attack_power - other_character.defense, 1)
        other_character.hp -= damage

    def heal(self):
        self.hp += 10
        if self.hp > 100:
            self.hp = 100
        return self.hp

    def gain_exp(self, amount):
        while amount != 0:
            if self.exp + amount >= self.level * 100:
                amount -= (self.level * 100 - self.exp)
                self.level_up()
            else:
                self.exp += amount
                amount = 0

    def level_up(self):
        if self.level < 100:
            self.level += 1
            self.exp = 0
            self.hp += 20
            self.attack_power += 5
            self.defense += 5
        return self.level, self.hp, self.attack_power, self.defense

    def is_alive(self):
        return self.hp > 0",COT,"```python
class RPGCharacter:
    def __init__(self, name, hp, attack_power, defense, level=1):
        self.name = name
        self.hp = hp
        self.attack_power = attack_power
        self.defense = defense
        self.level = level
        self.exp = 0

    def attack(self, other_character):
        damage = self.attack_power - other_character.defense
        if damage > 0:
            other_character.hp -= damage

    def heal(self):
        self.hp = min(self.hp + 10, 100)
        return self.hp

    def gain_exp(self, amount):
        self.exp += amount
        while self.exp >= 100 * self.level and self.level < 100:
            self.exp -= 100 * self.level
            self.level_up()

    def level_up(self):
        if self.level < 100:
            self.level += 1
            self.hp += 20
            self.attack_power += 5
            self.defense += 5
        return self.level, self.hp, self.attack_power, self.defense

    def is_alive(self):
        return self.hp > 0
```",0.55608598,0.610833308,0.87037037,0.886792453,0.878504668,0.695652174,0.747663551,0.720720716,0.833333333,0.849056604,0.84112149,,,,,,,,,,,,
GPT,74,"class Server:

    def __init__(self):
        self.white_list = []
        self.send_struct = {}
        self.receive_struct = {}

    def add_white_list(self, addr):
        if addr in self.white_list:
            return False
        else:
            self.white_list.append(addr)
            return self.white_list

    def del_white_list(self, addr):
        if addr not in self.white_list:
            return False
        else:
            self.white_list.remove(addr)
            return self.white_list

    def recv(self, info):
        if not isinstance(info, dict) or ""addr"" not in info or ""content"" not in info:
            return -1
        addr = info[""addr""]
        content = info[""content""]
        if addr not in self.white_list:
            return False
        else:
            self.receive_struct = {""addr"": addr, ""content"": content}
            return self.receive_struct[""content""]

    def send(self, info):
        if not isinstance(info, dict) or ""addr"" not in info or ""content"" not in info:
            return ""info structure is not correct""
        self.send_struct = {""addr"": info[""addr""], ""content"": info[""content""]}

    def show(self, type):
        if type == ""send"":
            return self.send_struct
        elif type == ""receive"":
            return self.receive_struct
        else:
            return False",COT,"```python
class Server:
    def __init__(self):
        self.white_list = []
        self.send_struct = {}
        self.receive_struct = {}

    def add_white_list(self, addr):
        if addr not in self.white_list:
            self.white_list.append(addr)
            return self.white_list
        return False

    def del_white_list(self, addr):
        if addr in self.white_list:
            self.white_list.remove(addr)
            return self.white_list
        return False

    def recv(self, info):
        addr = info.get(""addr"")
        content = info.get(""content"")
        if addr in self.white_list:
            self.receive_struct = {""addr"": addr, ""content"": content}
            return content
        return False

    def send(self, info):
        addr = info.get(""addr"")
        content = info.get(""content"")
        self.send_struct = {""addr"": addr, ""content"": content}

    def show(self, type):
        if type == ""send"":
            return self.send_struct
        elif type == ""receive"":
            return self.receive_struct
        return False
```",0.357071116,0.418146122,0.696428571,0.906976744,0.787878783,0.593406593,0.771428571,0.670807449,0.696428571,0.906976744,0.787878783,,,,,,,,,,,,
GPT,75,"class ShoppingCart:
    def __init__(self):
        self.items = {}

    def add_item(self, item, price, quantity=1):
        if item in self.items:
            self.items[item] = {'price': price, 'quantity': quantity}
        else:
            self.items[item] = {'price': price, 'quantity': quantity}

    def remove_item(self, item, quantity=1):
        if item in self.items:
            self.items[item]['quantity'] -= quantity
        else:
            pass

    def view_items(self) -> dict:
        return self.items

    def total_price(self) -> float:
        return sum([item['quantity'] * item['price'] for item in self.items.values()])",COT,"```python
class ShoppingCart:
    def __init__(self):
        self.items = {}

    def add_item(self, item, price, quantity=1):
        if item in self.items:
            self.items[item]['quantity'] += quantity
        else:
            self.items[item] = {'price': price, 'quantity': quantity}

    def remove_item(self, item, quantity=1):
        if item in self.items:
            if self.items[item]['quantity'] > quantity:
                self.items[item]['quantity'] -= quantity
            else:
                del self.items[item]

    def view_items(self) -> dict:
        return self.items

    def total_price(self) -> float:
        total = 0.0
        for item in self.items.values():
            total += item['price'] * item['quantity']
        return total
```",0.573529412,0.612259181,0.918918919,0.772727273,0.839506168,0.826923077,0.632352941,0.716666662,0.891891892,0.75,0.81481481,,,,,,,,,,,,
GPT,76,"class SignInSystem:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username in self.users:
            return False
        else:
            self.users[username] = False
            return True

    def sign_in(self, username):
        if username not in self.users:
            return False
        else:
            self.users[username] = True
            return True

    def check_sign_in(self, username):
        if username not in self.users:
            return False
        else:
            if self.users[username]:
                return True
            else:
                return False

    def all_signed_in(self):
        if all(self.users.values()):
            return True
        else:
            return False

    def all_not_signed_in(self):
        not_signed_in_users = []
        for username, signed_in in self.users.items():
            if not signed_in:
                not_signed_in_users.append(username)
        return not_signed_in_users",COT,"```python
class SignInSystem:
    def __init__(self):
        self.users = {}
    
    def add_user(self, username):
        if username not in self.users:
            self.users[username] = False
            return True
        return False
    
    def sign_in(self, username):
        if username in self.users:
            self.users[username] = True
            return True
        return False
    
    def check_sign_in(self, username):
        if username in self.users and self.users[username]:
            return True
        return False
    
    def all_signed_in(self):
        return all(self.users.values())
    
    def all_not_signed_in(self):
        return [username for username, signed_in in self.users.items() if not signed_in]
```",0.411957565,0.471814527,0.8,0.8,0.799999995,0.629032258,0.722222222,0.672413788,0.8,0.8,0.799999995,,,,,,,,,,,,
GPT,77,"import random


class Snake:
    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):
        self.length = 1
        self.SCREEN_WIDTH = SCREEN_WIDTH
        self.SCREEN_HEIGHT = SCREEN_HEIGHT
        self.BLOCK_SIZE = BLOCK_SIZE
        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]
        self.score = 0
        self.food_position = food_position

    def move(self, direction):
        cur = self.positions[0]
        x, y = direction

        new = (
            ((cur[0] + (x * self.BLOCK_SIZE)) % self.SCREEN_WIDTH),
            (cur[1] + (y * self.BLOCK_SIZE)) % self.SCREEN_HEIGHT,
        )

        if new == self.food_position:
            self.eat_food()

        if len(self.positions) > 2 and new in self.positions[2:]:
            self.reset()
        else:
            self.positions.insert(0, new)
            if len(self.positions) > self.length:
                self.positions.pop()

    def random_food_position(self):
        while self.food_position in self.positions:
            self.food_position = (random.randint(0, self.SCREEN_WIDTH // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE,
                                  random.randint(0, self.SCREEN_HEIGHT // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE)

    def reset(self):
        self.length = 1
        self.positions = [((self.SCREEN_WIDTH / 2), (self.SCREEN_HEIGHT / 2))]
        self.score = 0
        self.random_food_position()

    def eat_food(self):
        self.length += 1
        self.score += 100
        self.random_food_position()",COT,"```python
import random

class Snake:
    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):
        self.length = 1
        self.SCREEN_WIDTH = SCREEN_WIDTH
        self.SCREEN_HEIGHT = SCREEN_HEIGHT
        self.BLOCK_SIZE = BLOCK_SIZE
        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]
        self.score = 0
        self.food_position = food_position

    def move(self, direction):
        head_x, head_y = self.positions[0]
        new_head_position = (head_x + direction[0] * self.BLOCK_SIZE, head_y + direction[1] * self.BLOCK_SIZE)
        
        if new_head_position == self.food_position:
            self.eat_food()
        else:
            self.positions.pop()

        if new_head_position in self.positions:
            self.reset()
        else:
            self.positions.insert(0, new_head_position)

    def random_food_position(self):
        while True:
            x = random.randint(0, (self.SCREEN_WIDTH // self.BLOCK_SIZE) - 1) * self.BLOCK_SIZE
            y = random.randint(0, (self.SCREEN_HEIGHT // self.BLOCK_SIZE) - 1) * self.BLOCK_SIZE
            food_position = (x, y)
            if food_position not in self.positions:
                self.food_position = food_position
                break

    def reset(self):
        self.length = 1
        self.positions = [((self.SCREEN_WIDTH / 2), (self.SCREEN_HEIGHT / 2))]
        self.score = 0
        self.random_food_position()

    def eat_food(self):
        self.length += 1
        self.score += 10
        self.positions.append(self.positions[-1])
        self.random_food_position()
```",0.492537313,0.555031573,0.705128205,0.753424658,0.728476816,0.627737226,0.65648855,0.64179104,0.705128205,0.753424658,0.728476816,,,,,,,,,,,,
GPT,78,"import re


class SplitSentence:

    def split_sentences(self, sentences_string):
        sentences = re.split(r'(?<!\w\.\w.)(?<![A-Z][a-z]\.)(?<=\.|\?)\s', sentences_string)
        return sentences

    def count_words(self, sentence):
        sentence = re.sub(r'[^a-zA-Z\s]', '', sentence)
        words = sentence.split()
        return len(words)

    def process_text_file(self, sentences_string):
        sentences = self.split_sentences(sentences_string)
        max_count = 0
        for sentence in sentences:
            count = self.count_words(sentence)
            if count > max_count:
                max_count = count

        return max_count",COT,"```python
import re

class SplitSentence:
    def split_sentences(self, sentences_string):
        sentences = re.split(r'(?<!\bMr)(?<!\bMrs)(?<!\bMs)(?<!\bDr)(?<!\bJr)\.\s|\?\s', sentences_string)
        sentences = [s.strip() for s in sentences if s]
        return sentences

    def count_words(self, sentence):
        words = re.findall(r'\b\w+\b', sentence)
        return len(words)

    def process_text_file(self, sentences_string):
        sentences = self.split_sentences(sentences_string)
        max_word_count = max(self.count_words(sentence) for sentence in sentences)
        return max_word_count
```",0.347174393,0.404446851,0.631578947,0.666666667,0.648648644,0.407407407,0.448979592,0.427184461,0.631578947,0.666666667,0.648648644,,,,,,,,,,,,
GPT,79,"class SQLGenerator:
    def __init__(self, table_name):
        self.table_name = table_name

    def select(self, fields=None, condition=None):
        if fields is None:
            fields = ""*""
        else:
            fields = "", "".join(fields)
        sql = f""SELECT {fields} FROM {self.table_name}""
        if condition is not None:
            sql += f"" WHERE {condition}""
        return sql + "";""

    def insert(self, data):
        fields = "", "".join(data.keys())
        values = "", "".join([f""'{value}'"" for value in data.values()])
        sql = f""INSERT INTO {self.table_name} ({fields}) VALUES ({values})""
        return sql + "";""

    def update(self, data, condition):
        set_clause = "", "".join([f""{field} = '{value}'"" for field, value in data.items()])
        sql = f""UPDATE {self.table_name} SET {set_clause} WHERE {condition}""
        return sql + "";""

    def delete(self, condition):
        sql = f""DELETE FROM {self.table_name} WHERE {condition}""
        return sql + "";""

    def select_female_under_age(self, age):
        condition = f""age < {age} AND gender = 'female'""
        return self.select(condition=condition)

    def select_by_age_range(self, min_age, max_age):
        condition = f""age BETWEEN {min_age} AND {max_age}""
        return self.select(condition=condition)",COT,"```python
class SQLGenerator:
    def __init__(self, table_name):
        self.table_name = table_name

    def select(self, fields=None, condition=None):
        fields_part = ', '.join(fields) if fields else '*'
        condition_part = f"" WHERE {condition}"" if condition else ''
        return f""SELECT {fields_part} FROM {self.table_name}{condition_part};""

    def insert(self, data):
        columns = ', '.join(data.keys())
        values = ', '.join(f""'{v}'"" for v in data.values())
        return f""INSERT INTO {self.table_name} ({columns}) VALUES ({values});""

    def update(self, data, condition):
        set_part = ', '.join(f""{k} = '{v}'"" for k, v in data.items())
        return f""UPDATE {self.table_name} SET {set_part} WHERE {condition};""

    def delete(self, condition):
        return f""DELETE FROM {self.table_name} WHERE {condition};""

    def select_female_under_age(self, age):
        return f""SELECT * FROM {self.table_name} WHERE age < {age} AND gender = 'female';""

    def select_by_age_range(self, min_age, max_age):
        return f""SELECT * FROM {self.table_name} WHERE age BETWEEN {min_age} AND {max_age};""
```",0.188073691,0.234301093,0.65,0.65,0.649999995,0.396551724,0.422018349,0.408888884,0.65,0.65,0.649999995,,,,,,,,,,,,
GPT,7,"class BalancedBrackets:
    def __init__(self, expr):
        self.stack = []
        self.left_brackets = [""("", ""{"", ""[""]
        self.right_brackets = ["")"", ""}"", ""]""]
        self.expr = expr

    def clear_expr(self):
        self.expr = ''.join(c for c in self.expr if (c in self.left_brackets or c in self.right_brackets))

    def check_balanced_brackets(self):
        self.clear_expr()
        for Brkt in self.expr:
            if Brkt in self.left_brackets:
                self.stack.append(Brkt)
            else:
                Current_Brkt = self.stack.pop()
                if Current_Brkt == ""("":
                    if Brkt != "")"":
                        return False
                if Current_Brkt == ""{"":
                    if Brkt != ""}"":
                        return False
                if Current_Brkt == ""["":
                    if Brkt != ""]"":
                        return False
        if self.stack:
            return False
        return True",COT,"```python
class BalancedBrackets:
    def __init__(self, expr):
        self.stack = []
        self.left_brackets = [""("", ""{"", ""[""]
        self.right_brackets = ["")"", ""}"", ""]""]
        self.expr = expr

    def clear_expr(self):
        self.expr = ''.join([char for char in self.expr if char in self.left_brackets or char in self.right_brackets])

    def check_balanced_brackets(self):
        for char in self.expr:
            if char in self.left_brackets:
                self.stack.append(char)
            elif char in self.right_brackets:
                if not self.stack:
                    return False
                top = self.stack.pop()
                if self.left_brackets.index(top) != self.right_brackets.index(char):
                    return False
        return not self.stack
```",0.322646039,0.370206287,0.653061224,0.727272727,0.688172038,0.55,0.628571429,0.586666662,0.653061224,0.727272727,0.688172038,,,,,,,,,,,,
GPT,80,"class SQLQueryBuilder:

    @staticmethod
    def select(table, columns='*', where=None):
        if columns != '*':
            columns = ', '.join(columns)
        query = f""SELECT {columns} FROM {table}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query

    @staticmethod
    def insert(table, data):
        keys = ', '.join(data.keys())
        values = ', '.join(f""'{v}'"" for v in data.values())
        return f""INSERT INTO {table} ({keys}) VALUES ({values})""

    @staticmethod
    def delete(table, where=None):
        query = f""DELETE FROM {table}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query

    @staticmethod
    def update(table, data, where=None):
        update_str = ', '.join(f""{k}='{v}'"" for k, v in data.items())
        query = f""UPDATE {table} SET {update_str}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query",COT,"```python
class SQLQueryBuilder:
    @staticmethod
    def select(table, columns='*', where=None):
        columns_part = ', '.join(columns) if isinstance(columns, list) else columns
        where_part = ''
        if where:
            where_conditions = [f""{key}='{value}'"" for key, value in where.items()]
            where_part = f"" WHERE {' AND '.join(where_conditions)}""
        return f""SELECT {columns_part} FROM {table}{where_part}""

    @staticmethod
    def insert(table, data):
        columns = ', '.join(data.keys())
        values = ', '.join(f""'{value}'"" for value in data.values())
        return f""INSERT INTO {table} ({columns}) VALUES ({values})""

    @staticmethod
    def delete(table, where=None):
        where_part = ''
        if where:
            where_conditions = [f""{key}='{value}'"" for key, value in where.items()]
            where_part = f"" WHERE {' AND '.join(where_conditions)}""
        return f""DELETE FROM {table}{where_part}""

    @staticmethod
    def update(table, data, where=None):
        set_part = ', '.join(f""{key}='{value}'"" for key, value in data.items())
        where_part = ''
        if where:
            where_conditions = [f""{key}='{value}'"" for key, value in where.items()]
            where_part = f"" WHERE {' AND '.join(where_conditions)}""
        return f""UPDATE {table} SET {set_part}{where_part}""
```",0.190839695,0.251764085,0.719298246,0.640625,0.677685945,0.45,0.428571429,0.439024385,0.701754386,0.625,0.66115702,,,,,,,,,,,,
GPT,81,"import math
class Statistics3:
    @staticmethod
    def median(data):
        sorted_data = sorted(data)
        n = len(sorted_data)
        if n % 2 == 1:
            return sorted_data[n // 2]
        else:
            return (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2

    @staticmethod
    def mode(data):
        counts = {}
        for value in data:
            counts[value] = counts.get(value, 0) + 1
        max_count = max(counts.values())
        mode_values = [value for value, count in counts.items() if count == max_count]
        return mode_values

    @staticmethod
    def correlation(x, y):
        n = len(x)
        mean_x = sum(x) / n
        mean_y = sum(y) / n
        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))
        denominator = math.sqrt(sum((xi - mean_x) ** 2 for xi in x) * sum((yi - mean_y) ** 2 for yi in y))
        if denominator == 0:
            return None
        return numerator / denominator

    @staticmethod
    def mean(data):
        if len(data) == 0:
            return None
        return sum(data) / len(data)

    @staticmethod
    def correlation_matrix(data):
        matrix = []
        for i in range(len(data[0])):
            row = []
            for j in range(len(data[0])):
                column1 = [row[i] for row in data]
                column2 = [row[j] for row in data]
                correlation = Statistics3.correlation(column1, column2)
                row.append(correlation)
            matrix.append(row)
        return matrix

    @staticmethod
    def standard_deviation(data):
        n = len(data)
        if n < 2:
            return None
        mean_value = Statistics3.mean(data)
        variance = sum((x - mean_value) ** 2 for x in data) / (n - 1)
        return math.sqrt(variance)

    @staticmethod
    def z_score(data):
        mean = Statistics3.mean(data)
        std_deviation = Statistics3.standard_deviation(data)
        if std_deviation is None or std_deviation == 0:
            return None
        return [(x - mean) / std_deviation for x in data]",COT,"```python
import math
from collections import Counter

class Statistics3:

    @staticmethod
    def median(data):
        sorted_data = sorted(data)
        n = len(sorted_data)
        mid = n // 2
        if n % 2 == 0:
            return (sorted_data[mid - 1] + sorted_data[mid]) / 2.0
        else:
            return sorted_data[mid]

    @staticmethod
    def mode(data):
        data_counter = Counter(data)
        max_count = max(data_counter.values())
        return [k for k, v in data_counter.items() if v == max_count]

    @staticmethod
    def correlation(x, y):
        n = len(x)
        mean_x = sum(x) / n
        mean_y = sum(y) / n
        covariance = sum((x[i] - mean_x) * (y[i] - mean_y) for i in range(n))
        stddev_x = math.sqrt(sum((x[i] - mean_x) ** 2 for i in range(n)))
        stddev_y = math.sqrt(sum((y[i] - mean_y) ** 2 for i in range(n)))
        return covariance / (stddev_x * stddev_y)

    @staticmethod
    def mean(data):
        return sum(data) / len(data)

    @staticmethod
    def correlation_matrix(data):
        size = len(data)
        corr_matrix = []
        for i in range(size):
            row = []
            for j in range(size):
                if i == j:
                    row.append(1.0)
                else:
                    row.append(Statistics3.correlation(data[i], data[j]))
            corr_matrix.append(row)
        return corr_matrix

    @staticmethod
    def standard_deviation(data):
        mean_value = Statistics3.mean(data)
        variance = sum((x - mean_value) ** 2 for x in data) / len(data)
        return math.sqrt(variance)

    @staticmethod
    def z_score(data):
        mean_value = Statistics3.mean(data)
        stddev = Statistics3.standard_deviation(data)
        return [(x - mean_value) / stddev for x in data]
```",0.285368342,0.341784648,0.573913043,0.647058824,0.608294926,0.395348837,0.480225989,0.433673464,0.565217391,0.637254902,0.599078336,,,,,,,,,,,,
GPT,82,"class StockPortfolioTracker:
    def __init__(self, cash_balance):
        self.portfolio = []
        self.cash_balance = cash_balance

    def add_stock(self, stock):
        for pf in self.portfolio:
            if pf['name'] == stock['name']:
                pf['quantity'] += stock['quantity']
                return

        self.portfolio.append(stock)

    def remove_stock(self, stock):
        for pf in self.portfolio:
            if pf['name'] == stock['name'] and pf['quantity'] >= stock['quantity']:
                pf['quantity'] -= stock['quantity']
                if pf['quantity'] == 0:
                    self.portfolio.remove(pf)
                return True
        return False

    def buy_stock(self, stock):
        if stock['price'] * stock['quantity'] > self.cash_balance:
            return False
        else:
            self.add_stock(stock)
            self.cash_balance -= stock['price'] * stock['quantity']
            return True

    def sell_stock(self, stock):
        if self.remove_stock(stock) == False:
            return False
        self.cash_balance += stock['price'] * stock['quantity']
        return True

    def calculate_portfolio_value(self):
        total_value = self.cash_balance
        for stock in self.portfolio:
            total_value += stock['price'] * stock['quantity']
        return total_value

    def get_portfolio_summary(self):
        summary = []
        for stock in self.portfolio:
            value = self.get_stock_value(stock)
            summary.append({""name"": stock[""name""], ""value"": value})
        portfolio_value = self.calculate_portfolio_value()
        return portfolio_value, summary

    def get_stock_value(self, stock):
        return stock['price'] * stock['quantity']",COT,"```python
class StockPortfolioTracker:
    def __init__(self, cash_balance):
        self.portfolio = []
        self.cash_balance = cash_balance

    def add_stock(self, stock):
        self.portfolio.append(stock)

    def remove_stock(self, stock):
        for s in self.portfolio:
            if s[""name""] == stock[""name""] and s[""price""] == stock[""price""] and s[""quantity""] == stock[""quantity""]:
                self.portfolio.remove(s)
                return True
        return False

    def buy_stock(self, stock):
        total_cost = stock[""price""] * stock[""quantity""]
        if self.cash_balance >= total_cost:
            self.cash_balance -= total_cost
            self.add_stock(stock)
            return True
        return False

    def sell_stock(self, stock):
        for s in self.portfolio:
            if s[""name""] == stock[""name""] and s[""price""] == stock[""price""]:
                if s[""quantity""] >= stock[""quantity""]:
                    s[""quantity""] -= stock[""quantity""]
                    self.cash_balance += stock[""price""] * stock[""quantity""]
                    if s[""quantity""] == 0:
                        self.remove_stock(s)
                    return True
        return False

    def calculate_portfolio_value(self):
        total_value = self.cash_balance
        for stock in self.portfolio:
            total_value += stock[""price""] * stock[""quantity""]
        return total_value

    def get_portfolio_summary(self):
        total_value = self.calculate_portfolio_value()
        summary = [{""name"": stock[""name""], ""value"": stock[""price""] * stock[""quantity""]} for stock in self.portfolio]
        return total_value, summary

    def get_stock_value(self, stock):
        return stock[""price""] * stock[""quantity""]
```",0.275362319,0.357750785,0.666666667,0.677966102,0.672268903,0.495575221,0.5,0.497777773,0.666666667,0.677966102,0.672268903,,,,,,,,,,,,
GPT,83,"import sqlite3


class StudentDatabaseProcessor:

    def __init__(self, database_name):
        self.database_name = database_name

    def create_student_table(self):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        create_table_query = """"""
        CREATE TABLE IF NOT EXISTS students (
            id INTEGER PRIMARY KEY,
            name TEXT,
            age INTEGER,
            gender TEXT,
            grade INTEGER
        )
        """"""
        cursor.execute(create_table_query)

        conn.commit()
        conn.close()

    def insert_student(self, student_data):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        insert_query = """"""
        INSERT INTO students (name, age, gender, grade)
        VALUES (?, ?, ?, ?)
        """"""
        cursor.execute(insert_query,
                       (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))

        conn.commit()
        conn.close()

    def search_student_by_name(self, name):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        select_query = ""SELECT * FROM students WHERE name = ?""
        cursor.execute(select_query, (name,))
        result = cursor.fetchall()

        conn.close()

        return result

    def delete_student_by_name(self, name):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        delete_query = ""DELETE FROM students WHERE name = ?""
        cursor.execute(delete_query, (name,))

        conn.commit()
        conn.close()",COT,"```python
import sqlite3

class StudentDatabaseProcessor:
    def __init__(self, database_name):
        self.database_name = database_name

    def create_student_table(self):
        connection = sqlite3.connect(self.database_name)
        cursor = connection.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS students (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                age INTEGER,
                gender TEXT,
                grade INTEGER
            )
        ''')
        connection.commit()
        connection.close()

    def insert_student(self, student_data):
        connection = sqlite3.connect(self.database_name)
        cursor = connection.cursor()
        cursor.execute('''
            INSERT INTO students (name, age, gender, grade) 
            VALUES (:name, :age, :gender, :grade)
        ''', student_data)
        connection.commit()
        connection.close()

    def search_student_by_name(self, name):
        connection = sqlite3.connect(self.database_name)
        cursor = connection.cursor()
        cursor.execute('''
            SELECT * FROM students WHERE name = ?
        ''', (name,))
        rows = cursor.fetchall()
        connection.close()
        return rows

    def delete_student_by_name(self, name):
        connection = sqlite3.connect(self.database_name)
        cursor = connection.cursor()
        cursor.execute('''
            DELETE FROM students WHERE name = ?
        ''', (name,))
        connection.commit()
        connection.close()
```",0.378879517,0.42288247,0.702702703,0.732394366,0.717241374,0.495412844,0.551020408,0.521739125,0.702702703,0.732394366,0.717241374,,,,,,,,,,,,
GPT,84,"import json


class TextFileProcessor:
    def __init__(self, file_path):
        self.file_path = file_path

    def read_file_as_json(self):
        with open(self.file_path, 'r') as file:
            data = json.load(file)

        return data

    def read_file(self):
        with open(self.file_path, 'r') as file:
            return file.read()

    def write_file(self, content):
        with open(self.file_path, 'w') as file:
            file.write(content)

    def process_file(self):
        content = self.read_file()
        content = ''.join([char for char in content if char.isalpha()])
        self.write_file(content)
        return content",COT,"```python
import sqlite3

class StudentDatabaseProcessor:
    def __init__(self, database_name):
        self.database_name = database_name

    def create_student_table(self):
        with sqlite3.connect(self.database_name) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS students (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    age INTEGER,
                    gender TEXT,
                    grade INTEGER
                )
            ''')
            conn.commit()

    def insert_student(self, student_data):
        with sqlite3.connect(self.database_name) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO students (name, age, gender, grade)
                VALUES (:name, :age, :gender, :grade)
            ''', student_data)
            conn.commit()

    def search_student_by_name(self, name):
        with sqlite3.connect(self.database_name) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT * FROM students WHERE name = ?
            ''', (name,))
            return cursor.fetchall()

    def delete_student_by_name(self, name):
        with sqlite3.connect(self.database_name) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                DELETE FROM students WHERE name = ?
            ''', (name,))
            conn.commit()
```",0.000869565,0.193431606,0.236842105,0.125,0.163636359,0.017241379,0.010752688,0.013245028,0.236842105,0.125,0.163636359,,,,,,,,,,,,
GPT,85,"import time

class Thermostat:
    def __init__(self, current_temperature, target_temperature, mode):
        self.current_temperature = current_temperature
        self.target_temperature = target_temperature
        self.mode = mode

    def get_target_temperature(self):
        return self.target_temperature

    def set_target_temperature(self, temperature):
        self.target_temperature = temperature

    def get_mode(self):
        return self.mode

    def set_mode(self, mode):
        if mode in ['heat', 'cool']:
            self.mode = mode
        else:
            return False

    def auto_set_mode(self):
        if self.current_temperature < self.target_temperature:
            self.mode = 'heat'
        else:
            self.mode = 'cool'

    def auto_check_conflict(self):
        if self.current_temperature > self.target_temperature:
            if self.mode == 'cool':
                return True
            else:
                self.auto_set_mode()
                return False
        else:
            if self.mode == 'heat':
                return True
            else:
                self.auto_set_mode()
                return False

    def simulate_operation(self):
        self.auto_set_mode()
        use_time = 0
        if self.mode == 'heat':
            while(self.current_temperature < self.target_temperature):
                self.current_temperature += 1
                use_time += 1
        else:
            while(self.current_temperature > self.target_temperature):
                self.current_temperature -= 1
                use_time += 1
        return use_time",COT,"```python
import time

class Thermostat:
    def __init__(self, current_temperature, target_temperature, mode):
        self.current_temperature = current_temperature
        self.target_temperature = target_temperature
        self.mode = mode

    def get_target_temperature(self):
        return self.target_temperature

    def set_target_temperature(self, temperature):
        self.target_temperature = temperature

    def get_mode(self):
        return self.mode

    def set_mode(self, mode):
        if mode in ['heat', 'cool']:
            self.mode = mode

    def auto_set_mode(self):
        if self.current_temperature < self.target_temperature:
            self.mode = 'heat'
        else:
            self.mode = 'cool'

    def auto_check_conflict(self):
        if (self.mode == 'heat' and self.current_temperature >= self.target_temperature) or \
           (self.mode == 'cool' and self.current_temperature <= self.target_temperature):
            self.auto_set_mode()
            return False
        return True

    def simulate_operation(self):
        self.auto_set_mode()
        time_elapsed = 0
        while True:
            if self.mode == 'heat' and self.current_temperature < self.target_temperature:
                self.current_temperature += 0.1
            elif self.mode == 'cool' and self.current_temperature > self.target_temperature:
                self.current_temperature -= 0.1
            else:
                break
            time.sleep(1)
            time_elapsed += 1
        return time_elapsed
```",0.508474576,0.565407484,0.914893617,0.74137931,0.819047614,0.77173913,0.669811321,0.717171712,0.914893617,0.74137931,0.819047614,,,,,,,,,,,,
GPT,86,"class TicTacToe:
    def __init__(self, N=3):
        self.board = [[' ' for _ in range(N)] for _ in range(3)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        else:
            return False

    def check_winner(self):
        for row in self.board:
            if row[0] == row[1] == row[2] != ' ':
                return row[0]
        for col in range(3):
            if self.board[0][col] == self.board[1][col] == self.board[2][col] != ' ':
                return self.board[0][col]
        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':
            return self.board[0][0]
        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':
            return self.board[0][2]
        return None

    def is_board_full(self):
        for row in self.board:
            if ' ' in row:
                return False
        return True",COT,"```python
class TicTacToe:
    def __init__(self, N=3):
        self.board = [[' ' for _ in range(N)] for _ in range(N)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        return False

    def check_winner(self):
        # Check rows
        for row in self.board:
            if row[0] == row[1] == row[2] != ' ':
                return row[0]
        # Check columns
        for col in range(3):
            if self.board[0][col] == self.board[1][col] == self.board[2][col] != ' ':
                return self.board[0][col]
        # Check diagonals
        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':
            return self.board[0][0]
        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':
            return self.board[0][2]
        return None

    def is_board_full(self):
        for row in self.board:
            if ' ' in row:
                return False
        return True
```",0.824,0.84295974,0.96,0.872727273,0.914285709,0.927835052,0.865384615,0.895522383,0.96,0.872727273,0.914285709,,,,,,,,,,,,
GPT,87,"import datetime
import time

class TimeUtils:

    def __init__(self):
        self.datetime = datetime.datetime.now()

    def get_current_time(self):
        format = ""%H:%M:%S""
        return self.datetime.strftime(format)

    def get_current_date(self):
        format = ""%Y-%m-%d""
        return self.datetime.strftime(format)

    def add_seconds(self, seconds):
        new_datetime = self.datetime + datetime.timedelta(seconds=seconds)
        format = ""%H:%M:%S""
        return new_datetime.strftime(format)

    def string_to_datetime(self, string):
        return datetime.datetime.strptime(string, ""%Y-%m-%d %H:%M:%S"")

    def datetime_to_string(self, datetime):
        return datetime.strftime(""%Y-%m-%d %H:%M:%S"")

    def get_minutes(self, string_time1, string_time2):
        time1 = self.string_to_datetime(string_time1)
        time2 = self.string_to_datetime(string_time2)
        return round((time2 - time1).seconds / 60)

    def get_format_time(self, year, month, day, hour, minute, second):
        format = ""%Y-%m-%d %H:%M:%S""
        time_item = datetime.datetime(year, month, day, hour, minute, second)
        return time_item.strftime(format)",COT,"```python
import datetime
import time

class TimeUtils:
    def __init__(self):
        self.datetime = datetime.datetime.now()

    def get_current_time(self):
        return self.datetime.strftime('%H:%M:%S')

    def get_current_date(self):
        return self.datetime.strftime('%Y-%m-%d')

    def add_seconds(self, seconds):
        new_time = self.datetime + datetime.timedelta(seconds=seconds)
        return new_time.strftime('%H:%M:%S')

    def string_to_datetime(self, string):
        return datetime.datetime.strptime(string, '%Y-%m-%d %H:%M:%S')

    def datetime_to_string(self, datetime_obj):
        return datetime_obj.strftime('%Y-%m-%d %H:%M:%S')

    def get_minutes(self, string_time1, string_time2):
        dt1 = self.string_to_datetime(string_time1)
        dt2 = self.string_to_datetime(string_time2)
        delta = dt2 - dt1
        return round(delta.total_seconds() / 60)

    def get_format_time(self, year, month, day, hour, minute, second):
        formatted_time = datetime.datetime(year, month, day, hour, minute, second)
        return formatted_time.strftime('%Y-%m-%d %H:%M:%S')
```",0.378747726,0.446174768,0.703703704,0.703703704,0.703703699,0.552941176,0.552941176,0.552941171,0.703703704,0.703703704,0.703703699,,,,,,,,,,,,
GPT,88,"from math import pi, fabs


class TriCalculator:

    def __init__(self):
        pass

    def cos(self, x):
        return round(self.taylor(x, 50), 10)

    def factorial(self, a):
        b = 1
        while a != 1:
            b *= a
            a -= 1
        return b

    def taylor(self, x, n):
        a = 1
        x = x / 180 * pi
        count = 1
        for k in range(1, n):
            if count % 2 != 0:
                a -= (x ** (2 * k)) / self.factorial(2 * k)
            else:
                a += (x ** (2 * k)) / self.factorial(2 * k)
            count += 1
        return a

    def sin(self, x):
        x = x / 180 * pi
        g = 0
        t = x
        n = 1

        while fabs(t) >= 1e-15:
            g += t
            n += 1
            t = -t * x * x / (2 * n - 1) / (2 * n - 2)
        return round(g, 10)

    def tan(self, x):
        if self.cos(x) != 0:
            result = self.sin(x) / self.cos(x)
            return round(result, 10)
        else:
            return False",COT,"```python
from math import pi, fabs

class TriCalculator:
    def __init__(self):
        pass

    def factorial(self, a):
        if a == 0 or a == 1:
            return 1
        else:
            result = 1
            for i in range(2, a + 1):
                result *= i
            return result

    def taylor(self, x, n):
        x_rad = x * pi / 180
        result = 0
        for i in range(n + 1):
            term = ((-1) ** i) * (x_rad ** (2 * i)) / self.factorial(2 * i)
            result += term
        return result

    def cos(self, x):
        return self.taylor(x, 50)

    def sin(self, x):
        x_rad = x * pi / 180
        result = 0
        for i in range(50):
            term = ((-1) ** i) * (x_rad ** (2 * i + 1)) / self.factorial(2 * i + 1)
            result += term
        return result

    def tan(self, x):
        cos_value = self.cos(x)
        sin_value = self.sin(x)
        if fabs(cos_value) < 1e-10:
            raise ValueError(""Tangent undefined for this angle."")
        return sin_value / cos_value
```",0.132784666,0.18544184,0.616438356,0.608108108,0.612244893,0.292307692,0.324786325,0.307692303,0.589041096,0.581081081,0.585034009,,,,,,,,,,,,
GPT,89,"import random


class TwentyFourPointGame:
    def __init__(self) -> None:
        self.nums = []

    def _generate_cards(self):
        for i in range(4):
            self.nums.append(random.randint(1, 9))
        assert len(self.nums) == 4

    def get_my_cards(self):
        self.nums = []
        self._generate_cards()
        return self.nums

    def answer(self, expression):
        if expression == 'pass':
            return self.get_my_cards()
        statistic = {}
        for c in expression:
            if c.isdigit() and int(c) in self.nums:
                statistic[c] = statistic.get(c, 0) + 1

        nums_used = statistic.copy()

        for num in self.nums:
            if nums_used.get(str(num), -100) != -100 and nums_used[str(num)] > 0:
                nums_used[str(num)] -= 1
            else:
                return False

        if all(count == 0 for count in nums_used.values()) == True:
            return self.evaluate_expression(expression)
        else:
            return False

    def evaluate_expression(self, expression):
        try:
            if eval(expression) == 24:
                return True
            else:
                return False
        except Exception as e:
            return False",COT,"```python
import random

class TwentyFourPointGame:
    def __init__(self):
        self.nums = []

    def _generate_cards(self):
        self.nums = [random.randint(1, 9) for _ in range(4)]

    def get_my_cards(self):
        self._generate_cards()
        return self.nums

    def answer(self, expression):
        try:
            if self.evaluate_expression(expression):
                return True
            return False
        except:
            return False

    def evaluate_expression(self, expression):
        try:
            result = eval(expression)
            return result == 24
        except:
            return False
```",0.09130162,0.116706307,0.333333333,0.694444444,0.450450446,0.206896552,0.470588235,0.287425145,0.32,0.666666667,0.432432428,,,,,,,,,,,,
GPT,8,"class BankAccount:
    def __init__(self, balance=0):
        self.balance = balance

    def deposit(self, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        self.balance += amount
        return self.balance

    def withdraw(self, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient balance."")
        self.balance -= amount
        return self.balance

    def view_balance(self):
        return self.balance

    def transfer(self, other_account, amount):
        self.withdraw(amount)
        other_account.deposit(amount)",COT,"```python
class BankAccount:
    def __init__(self, balance=0):
        self.balance = balance
    
    def deposit(self, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        self.balance += amount
        return self.balance
    
    def withdraw(self, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient funds"")
        self.balance -= amount
        return self.balance
    
    def view_balance(self):
        return self.balance
    
    def transfer(self, other_account, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient funds"")
        self.withdraw(amount)
        other_account.deposit(amount)
        return self.balance
```",0.676056338,0.694604856,0.967741935,0.909090909,0.937499995,0.911111111,0.891304348,0.901098896,0.967741935,0.909090909,0.937499995,,,,,,,,,,,,
GPT,90,"class URLHandler:
    def __init__(self, url):
        self.url = url

    def get_scheme(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            return self.url[:scheme_end]
        return None

    def get_host(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            url_without_scheme = self.url[scheme_end + 3:]
            host_end = url_without_scheme.find(""/"")
            if host_end != -1:
                return url_without_scheme[:host_end]
            return url_without_scheme
        return None

    def get_path(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            url_without_scheme = self.url[scheme_end + 3:]
            host_end = url_without_scheme.find(""/"")
            if host_end != -1:
                return url_without_scheme[host_end:]
        return None

    def get_query_params(self):
        query_start = self.url.find(""?"")
        fragment_start = self.url.find(""#"")
        if query_start != -1:
            query_string = self.url[query_start + 1:fragment_start]
            params = {}
            if len(query_string) > 0:
                param_pairs = query_string.split(""&"")
                for pair in param_pairs:
                    key_value = pair.split(""="")
                    if len(key_value) == 2:
                        key, value = key_value
                        params[key] = value
            return params
        return None

    def get_fragment(self):
        fragment_start = self.url.find(""#"")
        if fragment_start != -1:
            return self.url[fragment_start + 1:]
        return None",COT,"```python
class URLHandler:
    def __init__(self, url):
        self.url = url

    def get_scheme(self):
        return self.url.split(""://"")[0]

    def get_host(self):
        return self.url.split(""://"")[1].split(""/"")[0]

    def get_path(self):
        return '/' + '/'.join(self.url.split(""://"")[1].split(""/"")[1:]).split('?')[0]

    def get_query_params(self):
        query_string = self.url.split('?')[1].split('#')[0]
        params = query_string.split('&')
        return {param.split('=')[0]: param.split('=')[1] for param in params}

    def get_fragment(self):
        return self.url.split('#')[1]
```",0.021923919,0.034124932,0.333333333,0.513513514,0.404255314,0.18627451,0.351851852,0.243589739,0.333333333,0.513513514,0.404255314,,,,,,,,,,,,
GPT,91,"import urllib.parse


class UrlPath:
    def __init__(self):
        self.segments = []
        self.with_end_tag = False

    def add(self, segment):
        self.segments.append(self.fix_path(segment))

    def parse(self, path, charset):
        if path:
            if path.endswith('/'):
                self.with_end_tag = True

            path = self.fix_path(path)
            if path:
                split = path.split('/')
                for seg in split:
                    decoded_seg = urllib.parse.unquote(seg, encoding=charset)
                    self.segments.append(decoded_seg)

    @staticmethod
    def fix_path(path):
        if not path:
            return ''

        segment_str = path.strip('/')
        return segment_str",COT,"```python
import urllib.parse

class UrlPath:
    def __init__(self):
        self.segments = []
        self.with_end_tag = False

    def add(self, segment):
        self.segments.append(segment)

    def parse(self, path, charset='utf-8'):
        fixed_path = self.fix_path(path)
        self.segments = [urllib.parse.unquote(segment, encoding=charset) for segment in fixed_path.split('/') if segment]
        self.with_end_tag = path.endswith('/')

    @staticmethod
    def fix_path(path):
        return path.strip('/')
```",0.264185635,0.320681952,0.651162791,0.736842105,0.69135802,0.40625,0.52,0.456140346,0.651162791,0.736842105,0.69135802,,,,,,,,,,,,
GPT,92,"import sqlite3


class UserLoginDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()

    def insert_user(self, username, password):
        self.cursor.execute('''
            INSERT INTO users (username, password)
            VALUES (?, ?)
        ''', (username, password))
        self.connection.commit()

    def search_user_by_username(self, username):
        self.cursor.execute('''
            SELECT * FROM users WHERE username = ?
        ''', (username,))
        user = self.cursor.fetchone()
        return user

    def delete_user_by_username(self, username):
        self.cursor.execute('''
            DELETE FROM users WHERE username = ?
        ''', (username,))
        self.connection.commit()

    def validate_user_login(self, username, password):
        user = self.search_user_by_username(username)
        if user is not None and user[1] == password:
            return True
        return False",COT,"```python
import sqlite3

class UserLoginDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT NOT NULL UNIQUE,
                password TEXT NOT NULL
            )
        ''')
        self.connection.commit()

    def insert_user(self, username, password):
        self.cursor.execute('''
            INSERT INTO users (username, password) VALUES (?, ?)
        ''', (username, password))
        self.connection.commit()

    def search_user_by_username(self, username):
        self.cursor.execute('''
            SELECT * FROM users WHERE username = ?
        ''', (username,))
        return self.cursor.fetchall()

    def delete_user_by_username(self, username):
        self.cursor.execute('''
            DELETE FROM users WHERE username = ?
        ''', (username,))
        self.connection.commit()

    def validate_user_login(self, username, password):
        self.cursor.execute('''
            SELECT * FROM users WHERE username = ? AND password = ?
        ''', (username, password))
        return len(self.cursor.fetchall()) > 0
```",0.5,0.518303196,0.759259259,0.602941176,0.672131143,0.714285714,0.567010309,0.632183903,0.759259259,0.602941176,0.672131143,,,,,,,,,,,,
GPT,93,"import numpy as np
from gensim import matutils
from numpy import dot, array


class VectorUtil:
    @staticmethod
    def similarity(vector_1, vector_2):
        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))

    @staticmethod
    def cosine_similarities(vector_1, vectors_all):
        norm = np.linalg.norm(vector_1)
        all_norms = np.linalg.norm(vectors_all, axis=1)
        dot_products = dot(vectors_all, vector_1)
        similarities = dot_products / (norm * all_norms)
        return similarities

    @staticmethod
    def n_similarity(vector_list_1, vector_list_2):
        if not (len(vector_list_1) and len(vector_list_2)):
            raise ZeroDivisionError('At least one of the passed list is empty.')

        return dot(matutils.unitvec(array(vector_list_1).mean(axis=0)),
                   matutils.unitvec(array(vector_list_2).mean(axis=0)))

    @staticmethod
    def compute_idf_weight_dict(total_num, number_dict):
        index_2_key_map = {}

        index = 0

        count_list = []
        for key, count in number_dict.items():
            index_2_key_map[index] = key
            count_list.append(count)
            index = index + 1

        a = np.array(count_list)
        ## smooth, in case the divide by zero error
        a = np.log((total_num + 1) / (a + 1))
        result = {}

        for index, w in enumerate(a):
            key = index_2_key_map[index]
            result[key] = w

        return result",COT,"```python
import numpy as np
from gensim import matutils
from numpy import dot, array

class VectorUtil:

    @staticmethod
    def similarity(vector_1: np.ndarray, vector_2: np.ndarray) -> float:
        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))

    @staticmethod
    def cosine_similarities(vector_1: np.ndarray, vectors_all: list) -> np.ndarray:
        vector_1_norm = matutils.unitvec(vector_1)
        return np.array([dot(vector_1_norm, matutils.unitvec(vector)) for vector in vectors_all])

    @staticmethod
    def n_similarity(vector_list_1: list, vector_list_2: list) -> float:
        mean_vector_1 = matutils.unitvec(array(vector_list_1).mean(axis=0))
        mean_vector_2 = matutils.unitvec(array(vector_list_2).mean(axis=0))
        return dot(mean_vector_1, mean_vector_2)

    @staticmethod
    def compute_idf_weight_dict(total_num: int, number_dict: dict) -> dict:
        return {key: np.log((total_num + 1) / (count + 1)) for key, count in number_dict.items()}
```",0.152477333,0.183695968,0.315789474,0.46875,0.377358486,0.22962963,0.340659341,0.274336278,0.315789474,0.46875,0.377358486,,,,,,,,,,,,
GPT,94,"class VendingMachine:
    def __init__(self):
        self.inventory = {}
        self.balance = 0

    def add_item(self, item_name, price, quantity):
        if not self.restock_item(item_name, quantity):
            self.inventory[item_name] = {'price': price, 'quantity': quantity}

    def insert_coin(self, amount):
        self.balance += amount
        return self.balance

    def purchase_item(self, item_name):
        if item_name in self.inventory:
            item = self.inventory[item_name]
            if item['quantity'] > 0 and self.balance >= item['price']:
                self.balance -= item['price']
                item['quantity'] -= 1
                return self.balance
            else:
                return False
        else:
            return False

    def restock_item(self, item_name, quantity):
        if item_name in self.inventory:
            self.inventory[item_name]['quantity'] += quantity
            return True
        else:
            return False

    def display_items(self):
        if not self.inventory:
            return False
        else:
            items = []
            for item_name, item_info in self.inventory.items():
                items.append(f""{item_name} - ${item_info['price']} [{item_info['quantity']}]"")
            return ""\n"".join(items)",COT,"```python
class VendingMachine:
    def __init__(self):
        self.inventory = {}
        self.balance = 0

    def add_item(self, item_name, price, quantity):
        self.inventory[item_name] = {'price': price, 'quantity': quantity}

    def insert_coin(self, amount):
        self.balance += amount
        return self.balance

    def purchase_item(self, item_name):
        if item_name in self.inventory and self.inventory[item_name]['quantity'] > 0:
            if self.balance >= self.inventory[item_name]['price']:
                self.balance -= self.inventory[item_name]['price']
                self.inventory[item_name]['quantity'] -= 1
                return self.balance
        return False

    def restock_item(self, item_name, quantity):
        if item_name in self.inventory:
            self.inventory[item_name]['quantity'] += quantity
            return True
        return False

    def display_items(self):
        if not self.inventory:
            return False
        return [f""{item} - ${info['price']} [{info['quantity']}]"" for item, info in self.inventory.items()]
```",0.529502287,0.573166177,0.74137931,0.796296296,0.767857138,0.635416667,0.701149425,0.666666662,0.724137931,0.777777778,0.749999995,,,,,,,,,,,,
GPT,95,"class Warehouse:
    def __init__(self):
        self.inventory = {}  # Product ID: Product
        self.orders = {}  # Order ID: Order

    def add_product(self, product_id, name, quantity):
        if product_id not in self.inventory:
            self.inventory[product_id] = {'name': name, 'quantity': quantity}
        else:
            self.inventory[product_id]['quantity'] += quantity

    def update_product_quantity(self, product_id, quantity):
        if product_id in self.inventory:
            self.inventory[product_id]['quantity'] += quantity

    def get_product_quantity(self, product_id):
        if product_id in self.inventory:
            return self.inventory[product_id]['quantity']
        else:
            return False

    def create_order(self, order_id, product_id, quantity):
        if self.get_product_quantity(product_id) >= quantity:
            self.update_product_quantity(product_id, -quantity)
            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}
        else:
            return False

    def change_order_status(self, order_id, status):
        if order_id in self.orders:
            self.orders[order_id]['status'] = status
        else:
            return False

    def track_order(self, order_id):
        if order_id in self.orders:
            return self.orders[order_id]['status']
        else:
            return False",COT,"```python
class Warehouse:
    def __init__(self):
        self.inventory = {}  # Product ID: Product
        self.orders = {}  # Order ID: Order

    def add_product(self, product_id, name, quantity):
        if product_id in self.inventory:
            self.inventory[product_id]['quantity'] += quantity
        else:
            self.inventory[product_id] = {'name': name, 'quantity': quantity}

    def update_product_quantity(self, product_id, quantity):
        if product_id in self.inventory:
            self.inventory[product_id]['quantity'] += quantity

    def get_product_quantity(self, product_id):
        if product_id in self.inventory:
            return self.inventory[product_id]['quantity']
        return False

    def create_order(self, order_id, product_id, quantity):
        if product_id in self.inventory and self.inventory[product_id]['quantity'] >= quantity:
            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}
            self.inventory[product_id]['quantity'] -= quantity
            return True
        return False

    def change_order_status(self, order_id, status):
        if order_id in self.orders:
            self.orders[order_id]['status'] = status
            return True
        return False

    def track_order(self, order_id):
        if order_id in self.orders:
            return self.orders[order_id]['status']
        return False
```",0.690265487,0.737481646,0.927272727,0.910714286,0.918918914,0.846153846,0.827956989,0.836956517,0.927272727,0.910714286,0.918918914,,,,,,,,,,,,
GPT,96,"class WeatherSystem:
    def __init__(self, city) -> None:
        self.temperature = None
        self.weather = None
        self.city = city
        self.weather_list = {}
    
    def query(self, weather_list, tmp_units = 'celsius'):
        self.weather_list = weather_list
        if self.city not in weather_list:
            return False
        else:
            self.temperature = self.weather_list[self.city]['temperature']
            self.weather = self.weather_list[self.city]['weather']
        if self.weather_list[self.city]['temperature units'] != tmp_units:
            if tmp_units == 'celsius':
                return self.fahrenheit_to_celsius(), self.weather
            elif tmp_units == 'fahrenheit':
                return self.celsius_to_fahrenheit(), self.weather
        else:
            return self.temperature, self.weather
    
    def set_city(self, city):
        self.city = city

    def celsius_to_fahrenheit(self):
        return (self.temperature * 9/5) + 32

    def fahrenheit_to_celsius(self):
        return (self.temperature - 32) * 5/9",COT,"```python
class WeatherSystem:
    def __init__(self, city) -> None:
        self.temperature = None
        self.weather = None
        self.city = city
        self.weather_list = {}

    def query(self, weather_list, tmp_units='celsius'):
        self.weather_list = weather_list
        if self.city in self.weather_list:
            city_weather = self.weather_list[self.city]
            self.weather = city_weather['weather']
            self.temperature = city_weather['temperature']
            if city_weather['temperature units'] != tmp_units:
                if tmp_units == 'fahrenheit':
                    self.temperature = self.celsius_to_fahrenheit()
                else:
                    self.temperature = self.fahrenheit_to_celsius()
            return (self.temperature, self.weather)
        return None

    def set_city(self, city):
        self.city = city

    def celsius_to_fahrenheit(self):
        return (self.temperature * 9/5) + 32

    def fahrenheit_to_celsius(self):
        return (self.temperature - 32) * 5/9
```",0.576596113,0.615131845,0.807692308,0.79245283,0.799999995,0.647058824,0.670731707,0.65868263,0.807692308,0.79245283,0.799999995,,,,,,,,,,,,
GPT,97,"class Words2Numbers:

    def __init__(self):
        self.numwords = {}
        self.units = [
            ""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"",
            ""nine"", ""ten"", ""eleven"", ""twelve"", ""thirteen"", ""fourteen"", ""fifteen"",
            ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen"",
        ]
        self.tens = ["""", """", ""twenty"", ""thirty"", ""forty"", ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""]
        self.scales = [""hundred"", ""thousand"", ""million"", ""billion"", ""trillion""]

        self.numwords[""and""] = (1, 0)
        for idx, word in enumerate(self.units):
            self.numwords[word] = (1, idx)
        for idx, word in enumerate(self.tens):
            self.numwords[word] = (1, idx * 10)
        for idx, word in enumerate(self.scales):
            self.numwords[word] = (10 ** (idx * 3 or 2), 0)

        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}
        self.ordinal_endings = [('ieth', 'y'), ('th', '')]

    def text2int(self, textnum):
        textnum = textnum.replace('-', ' ')

        current = result = 0
        curstring = """"
        onnumber = False
        for word in textnum.split():
            if word in self.ordinal_words:
                scale, increment = (1, self.ordinal_words[word])
                current = current * scale + increment
                onnumber = True
            else:
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = ""%s%s"" % (word[:-len(ending)], replacement)

                if word not in self.numwords:
                    if onnumber:
                        curstring += repr(result + current) + "" ""
                    curstring += word + "" ""
                    result = current = 0
                    onnumber = False
                else:
                    scale, increment = self.numwords[word]
                    current = current * scale + increment
                    if scale > 100:
                        result += current
                        current = 0
                    onnumber = True

        if onnumber:
            curstring += repr(result + current)

        return curstring

    def is_valid_input(self, textnum):

        textnum = textnum.replace('-', ' ')

        for word in textnum.split():
            if word in self.ordinal_words:
                continue
            else:
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = ""%s%s"" % (word[:-len(ending)], replacement)

                if word not in self.numwords:
                    return False

        return True",COT,"```python
class Words2Numbers:
    def __init__(self) -> None:
        self.numwords = {}
        self.units = [
            ""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"",
            ""nine"", ""ten"", ""eleven"", ""twelve"", ""thirteen"", ""fourteen"", ""fifteen"",
            ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen"",
        ]
        self.tens = ["""", """", ""twenty"", ""thirty"", ""forty"", ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""]
        self.scales = [""hundred"", ""thousand"", ""million"", ""billion"", ""trillion""]

        self.numwords[""and""] = (1, 0)
        for idx, word in enumerate(self.units):
            self.numwords[word] = (1, idx)
        for idx, word in enumerate(self.tens):
            self.numwords[word] = (1, idx * 10)
        for idx, word in enumerate(self.scales):
            self.numwords[word] = (10 ** (idx * 3 or 2), 0)

        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}
        self.ordinal_endings = [('ieth', 'y'), ('th', '')]

    def text2int(self, textnum: str) -> str:
        current = result = 0
        for word in textnum.replace('-', ' ').split():
            if word in self.ordinal_words:
                scale, increment = (1, self.ordinal_words[word])
            else:
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = word[:-len(ending)] + replacement
                if word not in self.numwords:
                    raise ValueError(f""Invalid word found: {word}"")

                scale, increment = self.numwords[word]

            current = current * scale + increment
            if scale > 100:
                result += current
                current = 0

        return str(result + current)

    def is_valid_input(self, textnum: str) -> bool:
        try:
            for word in textnum.replace('-', ' ').split():
                if word in self.ordinal_words:
                    continue
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = word[:-len(ending)] + replacement
                if word not in self.numwords:
                    return False
            return True
        except Exception:
            return False
```",0.616388027,0.649354859,0.909774436,0.870503597,0.889705877,0.774038462,0.817258883,0.795061723,0.909774436,0.870503597,0.889705877,,,,,,,,,,,,
GPT,98,"import xml.etree.ElementTree as ET


class XMLProcessor:
    def __init__(self, file_name):
        self.file_name = file_name
        self.root = None

    def read_xml(self):
        try:
            tree = ET.parse(self.file_name)
            self.root = tree.getroot()
            return self.root
        except:
            return None

    def write_xml(self, file_name):
        try:
            tree = ET.ElementTree(self.root)
            tree.write(file_name)
            return True
        except:
            return False

    def process_xml_data(self, file_name):
        for element in self.root.iter('item'):
            text = element.text
            element.text = text.upper()
        return self.write_xml(file_name)

    def find_element(self, element_name):
        elements = self.root.findall(element_name)
        return elements",COT,"```python
import xml.etree.ElementTree as ET

class XMLProcessor:
    def __init__(self, file_name):
        self.file_name = file_name
        self.root = None

    def read_xml(self):
        try:
            tree = ET.parse(self.file_name)
            self.root = tree.getroot()
            return self.root
        except ET.ParseError as e:
            print(f""Error parsing XML: {e}"")
            return None

    def write_xml(self, file_name):
        try:
            tree = ET.ElementTree(self.root)
            tree.write(file_name)
            return True
        except Exception as e:
            print(f""Error writing XML: {e}"")
            return False

    def process_xml_data(self, file_name):
        try:
            # Example process: Change all 'item' elements' text to uppercase
            for item in self.root.iter('item'):
                item.text = item.text.upper()
            return self.write_xml(file_name)
        except Exception as e:
            print(f""Error processing XML data: {e}"")
            return False

    def find_element(self, element_name):
        try:
            return self.root.findall(f"".//{element_name}"")
        except Exception as e:
            print(f""Error finding elements: {e}"")
            return []
```",0.358490566,0.393053405,0.904761905,0.567164179,0.697247702,0.746478873,0.53,0.619883036,0.904761905,0.567164179,0.697247702,,,,,,,,,,,,
GPT,99,"import zipfile


class ZipFileProcessor:
    def __init__(self, file_name):
        self.file_name = file_name

    def read_zip_file(self):
        try:
            zip_file = zipfile.ZipFile(self.file_name, 'r')
            return zip_file
        except:
            return None

    def extract_all(self, output_path):
        try:
            with zipfile.ZipFile(self.file_name, 'r') as zip_file:
                zip_file.extractall(output_path)
            return True
        except:
            return False

    def extract_file(self, file_name, output_path):
        try:
            with zipfile.ZipFile(self.file_name, 'r') as zip_file:
                zip_file.extract(file_name, output_path)
            return True
        except:
            return False

    def create_zip_file(self, files, output_file_name):
        try:
            with zipfile.ZipFile(output_file_name, 'w') as zip_file:
                for file in files:
                    zip_file.write(file)
            return True
        except:
            return False",COT,"```python
import zipfile

class ZipFileProcessor:
    def __init__(self, file_name):
        self.file_name = file_name

    def read_zip_file(self):
        try:
            with zipfile.ZipFile(self.file_name, 'r') as zip_ref:
                return zip_ref
        except zipfile.BadZipFile:
            return None

    def extract_all(self, output_path):
        try:
            with zipfile.ZipFile(self.file_name, 'r') as zip_ref:
                zip_ref.extractall(output_path)
            return True
        except Exception:
            return False

    def extract_file(self, file_name, output_path):
        try:
            with zipfile.ZipFile(self.file_name, 'r') as zip_ref:
                zip_ref.extract(file_name, output_path)
            return True
        except Exception:
            return False

    def create_zip_file(self, files, output_file_name):
        try:
            with zipfile.ZipFile(output_file_name, 'w') as zip_ref:
                for file in files:
                    zip_ref.write(file)
            return True
        except Exception:
            return False
```",0.506329114,0.567721723,0.925,0.840909091,0.880952376,0.745762712,0.709677419,0.727272722,0.925,0.840909091,0.880952376,,,,,,,,,,,,
GPT,9,"class BigNumCalculator:
    @staticmethod
    def add(num1, num2):
        max_length = max(len(num1), len(num2))
        num1 = num1.zfill(max_length)
        num2 = num2.zfill(max_length)

        carry = 0
        result = []
        for i in range(max_length - 1, -1, -1):
            digit_sum = int(num1[i]) + int(num2[i]) + carry
            carry = digit_sum // 10
            digit = digit_sum % 10
            result.insert(0, str(digit))

        if carry > 0:
            result.insert(0, str(carry))

        return ''.join(result)

    @staticmethod
    def subtract(num1, num2):

        if len(num1) < len(num2):
            num1, num2 = num2, num1
            negative = True
        elif len(num1) > len(num2):
            negative = False
        else:
            if num1 < num2:
                num1, num2 = num2, num1
                negative = True
            else:
                negative = False

        max_length = max(len(num1), len(num2))
        num1 = num1.zfill(max_length)
        num2 = num2.zfill(max_length)

        borrow = 0
        result = []
        for i in range(max_length - 1, -1, -1):
            digit_diff = int(num1[i]) - int(num2[i]) - borrow

            if digit_diff < 0:
                digit_diff += 10
                borrow = 1
            else:
                borrow = 0

            result.insert(0, str(digit_diff))

        while len(result) > 1 and result[0] == '0':
            result.pop(0)

        if negative:
            result.insert(0, '-')

        return ''.join(result)

    @staticmethod
    def multiply(num1, num2):
        len1, len2 = len(num1), len(num2)
        result = [0] * (len1 + len2)

        for i in range(len1 - 1, -1, -1):
            for j in range(len2 - 1, -1, -1):
                mul = int(num1[i]) * int(num2[j])
                p1, p2 = i + j, i + j + 1
                total = mul + result[p2]

                result[p1] += total // 10
                result[p2] = total % 10

        start = 0
        while start < len(result) - 1 and result[start] == 0:
            start += 1

        return ''.join(map(str, result[start:]))",COT,"```python
class BigNumCalculator:

    @staticmethod
    def add(num1, num2):
        # Convert the input strings to integers, perform addition, and convert the result back to string
        return str(int(num1) + int(num2))

    @staticmethod
    def subtract(num1, num2):
        # Convert the input strings to integers, perform subtraction, and convert the result back to string
        return str(int(num1) - int(num2))

    @staticmethod
    def multiply(num1, num2):
        # Convert the input strings to integers, perform multiplication, and convert the result back to string
        return str(int(num1) * int(num2))
```",0.01233054,0.015680671,0.152173913,0.4375,0.225806448,0.048128342,0.225,0.079295151,0.130434783,0.375,0.193548383,,,,,,,,,,,,
GPT,0,"import logging
import datetime


class AccessGatewayFilter:

    def __init__(self):
        pass

    def filter(self, request):
        request_uri = request['path']
        method = request['method']

        if self.is_start_with(request_uri):
            return True

        try:
            token = self.get_jwt_user(request)
            user = token['user']
            if user['level'] > 2:
                self.set_current_user_info_and_log(user)
                return True
        except:
            return False

    def is_start_with(self, request_uri):
        start_with = [""/api"", '/login']
        for s in start_with:
            if request_uri.startswith(s):
                return True
        return False

    def get_jwt_user(self, request):
        token = request['headers']['Authorization']
        user = token['user']
        if token['jwt'].startswith(user['name']):
            jwt_str_date = token['jwt'].split(user['name'])[1]
            jwt_date = datetime.datetime.strptime(jwt_str_date, ""%Y-%m-%d"")
            if datetime.datetime.today() - jwt_date >= datetime.timedelta(days=3):
                return None
        return token

    def set_current_user_info_and_log(self, user):
        host = user['address']
        logging.log(msg=user['name'] + host + str(datetime.datetime.now()), level=1)",COTFewShot,"```python
import datetime

class AccessGatewayFilter:
    def __init__(self):
        pass

    def filter(self, request):
        if self.is_start_with(request.get('path', '')):
            return True
        user_info = self.get_jwt_user(request)
        if user_info:
            self.set_current_user_info_and_log(user_info)
            return True
        return False

    def is_start_with(self, request_uri):
        prefixes = ['/api', '/auth', '/public']
        return any(request_uri.startswith(prefix) for prefix in prefixes)

    def get_jwt_user(self, request):
        auth_header = request.get('headers', {}).get('Authorization', {})
        if isinstance(auth_header, dict) and 'user' in auth_header and 'jwt' in auth_header:
            expected_jwt = auth_header['user']['name'] + str(datetime.date.today())
            if auth_header['jwt'] == expected_jwt:
                return auth_header['user']
        return None

    def set_current_user_info_and_log(self, user):
        # Assuming there is a logging mechanism
        print(f""User {user['name']} accessed from {user.get('address', 'unknown')}"")
```",0.159372731,0.208765337,0.421875,0.36,0.388489204,0.24,0.24742268,0.243654817,0.40625,0.346666667,0.374100714,,,,,,,,,,,,
GPT,10,"class BinaryDataProcessor:
    def __init__(self, binary_string):
        self.binary_string = binary_string
        self.clean_non_binary_chars()

    def clean_non_binary_chars(self):
        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))

    def calculate_binary_info(self):
        zeroes_count = self.binary_string.count('0')
        ones_count = self.binary_string.count('1')
        total_length = len(self.binary_string)

        zeroes_percentage = (zeroes_count / total_length)
        ones_percentage = (ones_count / total_length)

        return {
            'Zeroes': zeroes_percentage,
            'Ones': ones_percentage,
            'Bit length': total_length
        }

    def convert_to_ascii(self):
        byte_array = bytearray()
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            decimal = int(byte, 2)
            byte_array.append(decimal)

        return byte_array.decode('ascii')

    def convert_to_utf8(self):
        byte_array = bytearray()
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            decimal = int(byte, 2)
            byte_array.append(decimal)

        return byte_array.decode('utf-8')",COTFewShot,"```python
class BinaryDataProcessor:
    def __init__(self, binary_string):
        self.binary_string = binary_string
        self.clean_non_binary_chars()

    def clean_non_binary_chars(self):
        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))

    def calculate_binary_info(self):
        length = len(self.binary_string)
        count_zeros = self.binary_string.count('0')
        count_ones = self.binary_string.count('1')
        return {
            'Zeroes': count_zeros / length if length > 0 else 0,
            'Ones': count_ones / length if length > 0 else 0,
            'Bit length': length
        }

    def convert_to_ascii(self):
        n = 8
        ascii_string = ''.join(chr(int(self.binary_string[i:i + n], 2)) for i in range(0, len(self.binary_string), n))
        return ascii_string

    def convert_to_utf8(self):
        n = 8
        utf8_bytes = bytes(int(self.binary_string[i:i + n], 2) for i in range(0, len(self.binary_string), n))
        return utf8_bytes.decode('utf-8', errors='ignore')
```",0.284210526,0.350341955,0.649122807,0.616666667,0.632478627,0.481481481,0.443181818,0.461538457,0.631578947,0.6,0.61538461,,,,,,,,,,,,
GPT,11,"class BitStatusUtil:
    @staticmethod
    def add(states, stat):
        BitStatusUtil.check([states, stat])
        return states | stat

    @staticmethod
    def has(states, stat):
        BitStatusUtil.check([states, stat])
        return (states & stat) == stat

    @staticmethod
    def remove(states, stat):
        BitStatusUtil.check([states, stat])
        if BitStatusUtil.has(states, stat):
            return states ^ stat
        return states

    @staticmethod
    def check(args):
        for arg in args:
            if arg < 0:
                raise ValueError(f""{arg} must be greater than or equal to 0"")
            if arg % 2 != 0:
                raise ValueError(f""{arg} not even"")",COTFewShot,"```python
class BitStatusUtil:
    @staticmethod
    def add(states, stat):
        BitStatusUtil.check([states, stat])
        return states | stat
    
    @staticmethod
    def has(states, stat):
        BitStatusUtil.check([states, stat])
        return (states & stat) == stat
    
    @staticmethod
    def remove(states, stat):
        BitStatusUtil.check([states, stat])
        return states & ~stat
    
    @staticmethod
    def check(args):
        for arg in args:
            if arg < 0 or arg % 2 != 0:
                raise ValueError(f""{arg} not even"")
```",0.622380744,0.649610387,0.813953488,0.897435897,0.853658532,0.678571429,0.826086957,0.745098034,0.813953488,0.897435897,0.853658532,,,,,,,,,,,,
GPT,12,"import random


class BlackjackGame:
    def __init__(self):
        self.deck = self.create_deck()
        self.player_hand = []
        self.dealer_hand = []

    def create_deck(self):
        deck = []
        suits = ['S', 'C', 'D', 'H']
        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
        for suit in suits:
            for rank in ranks:
                deck.append(rank + suit)
        random.shuffle(deck)
        return deck

    def calculate_hand_value(self, hand):
        value = 0
        num_aces = 0
        for card in hand:
            rank = card[:-1]
            if rank.isdigit():
                value += int(rank)
            elif rank in ['J', 'Q', 'K']:
                value += 10
            elif rank == 'A':
                value += 11
                num_aces += 1
        while value > 21 and num_aces > 0:
            value -= 10
            num_aces -= 1
        return value

    def check_winner(self, player_hand, dealer_hand):
        player_value = self.calculate_hand_value(player_hand)
        dealer_value = self.calculate_hand_value(dealer_hand)
        if player_value > 21 and dealer_value > 21:
            if player_value <= dealer_value:
                return 'Player wins'
            else:
                return 'Dealer wins'
        elif player_value > 21:
            return 'Dealer wins'
        elif dealer_value > 21:
            return 'Player wins'
        else:
            if player_value <= dealer_value:
                return 'Dealer wins'
            else:
                return 'Player wins'",COTFewShot,"```python
import random

class BlackjackGame:
    def __init__(self):
        self.deck = self.create_deck()
        self.player_hand = []
        self.dealer_hand = []

    def create_deck(self):
        suits = ['S', 'H', 'D', 'C']
        ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
        deck = [rank + suit for suit in suits for rank in ranks]
        random.shuffle(deck)
        return deck

    def calculate_hand_value(self, hand):
        value = 0
        aces = 0
        for card in hand:
            rank = card[:-1]
            if rank.isdigit():
                value += int(rank)
            elif rank in ['J', 'Q', 'K']:
                value += 10
            else:  # Ace
                value += 11
                aces += 1
        while value > 21 and aces:
            value -= 10
            aces -= 1
        return value

    def check_winner(self, player_hand, dealer_hand):
        player_value = self.calculate_hand_value(player_hand)
        dealer_value = self.calculate_hand_value(dealer_hand)
        if player_value > 21:
            return 'Dealer wins'
        elif dealer_value > 21:
            return 'Player wins'
        elif player_value > dealer_value:
            return 'Player wins'
        else:
            return 'Dealer wins'
```",0.574228462,0.613337071,0.833333333,0.843373494,0.838323348,0.728571429,0.755555556,0.741818177,0.833333333,0.843373494,0.838323348,,,,,,,,,,,,
GPT,13,"class BookManagement:
    def __init__(self):
        self.inventory = {}

    def add_book(self, title, quantity=1):
        if title in self.inventory:
            self.inventory[title] += quantity
        else:
            self.inventory[title] = quantity

    def remove_book(self, title, quantity):
        if title not in self.inventory or self.inventory[title] < quantity:
            raise False
        self.inventory[title] -= quantity
        if self.inventory[title] == 0:
            del (self.inventory[title])

    def view_inventory(self):
        return self.inventory

    def view_book_quantity(self, title):
        if title not in self.inventory:
            return 0
        return self.inventory[title]",COTFewShot,"```python
class BookManagement:
    def __init__(self):
        self.inventory = {}

    def add_book(self, title, quantity=1):
        if title in self.inventory:
            self.inventory[title] += quantity
        else:
            self.inventory[title] = quantity

    def remove_book(self, title, quantity):
        if title in self.inventory:
            if self.inventory[title] >= quantity:
                self.inventory[title] -= quantity
                if self.inventory[title] == 0:
                    del self.inventory[title]
                return True
            else:
                return False
        else:
            return False

    def view_inventory(self):
        return self.inventory

    def view_book_quantity(self, title):
        return self.inventory.get(title, 0)
```",0.606557377,0.658132942,0.815789474,0.837837838,0.826666662,0.724137931,0.711864407,0.717948713,0.815789474,0.837837838,0.826666662,,,,,,,,,,,,
GPT,14,"import sqlite3

class BookManagementDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS books (
                id INTEGER PRIMARY KEY,
                title TEXT,
                author TEXT,
                available INTEGER
            )
        ''')
        self.connection.commit()

    def add_book(self, title, author):
        self.cursor.execute('''
            INSERT INTO books (title, author, available)
            VALUES (?, ?, 1)
        ''', (title, author))
        self.connection.commit()

    def remove_book(self, book_id):
        self.cursor.execute('''
            DELETE FROM books WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def borrow_book(self, book_id):
        self.cursor.execute('''
            UPDATE books SET available = 0 WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def return_book(self, book_id):
        self.cursor.execute('''
            UPDATE books SET available = 1 WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def search_books(self):
        self.cursor.execute('''
            SELECT * FROM books
        ''')
        books = self.cursor.fetchall()
        return books",COTFewShot,"```python
import sqlite3

class BookManagementDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''CREATE TABLE IF NOT EXISTS books (
                                id INTEGER PRIMARY KEY AUTOINCREMENT,
                                title TEXT NOT NULL,
                                author TEXT NOT NULL,
                                available INTEGER NOT NULL)''')
        self.connection.commit()

    def add_book(self, title, author):
        self.cursor.execute('INSERT INTO books (title, author, available) VALUES (?, ?, 1)', (title, author))
        self.connection.commit()

    def remove_book(self, book_id):
        self.cursor.execute('DELETE FROM books WHERE id = ?', (book_id,))
        self.connection.commit()

    def borrow_book(self, book_id):
        self.cursor.execute('UPDATE books SET available = 0 WHERE id = ?', (book_id,))
        self.connection.commit()

    def return_book(self, book_id):
        self.cursor.execute('UPDATE books SET available = 1 WHERE id = ?', (book_id,))
        self.connection.commit()

    def search_books(self):
        self.cursor.execute('SELECT * FROM books')
        return self.cursor.fetchall()
```",0.495238248,0.546724951,0.803030303,0.779411765,0.791044771,0.686868687,0.686868687,0.686868682,0.803030303,0.779411765,0.791044771,,,,,,,,,,,,
GPT,15,"class BoyerMooreSearch:
    def __init__(self, text, pattern):
        self.text, self.pattern = text, pattern
        self.textLen, self.patLen = len(text), len(pattern)

    def match_in_pattern(self, char):
        for i in range(self.patLen - 1, -1, -1):
            if char == self.pattern[i]:
                return i
        return -1

    def mismatch_in_text(self, currentPos):
        for i in range(self.patLen - 1, -1, -1):
            if self.pattern[i] != self.text[currentPos + i]:
                return currentPos + i
        return -1

    def bad_character_heuristic(self):
        positions = []
        for i in range(self.textLen - self.patLen + 1):
            mismatch_index = self.mismatch_in_text(i)
            if mismatch_index == -1:
                positions.append(i)
            else:
                match_index = self.match_in_pattern(self.text[mismatch_index])
                i = (mismatch_index - match_index)
        return positions",COTFewShot,"```python
class BoyerMooreSearch:
    def __init__(self, text, pattern):
        self.text = text
        self.pattern = pattern
        self.textLen = len(text)
        self.patLen = len(pattern)

    def match_in_pattern(self, char):
        for i in range(self.patLen - 1, -1, -1):
            if self.pattern[i] == char:
                return i
        return -1

    def mismatch_in_text(self, currentPos):
        for i in range(self.patLen):
            if self.text[currentPos + i] != self.pattern[i]:
                return i
        return -1

    def bad_character_heuristic(self):
        occurrences = []
        shift = 0
        while shift <= self.textLen - self.patLen:
            mismatchPos = self.mismatch_in_text(shift)
            if mismatchPos == -1:
                occurrences.append(shift)
                shift += 1
            else:
                charShift = mismatchPos - self.match_in_pattern(self.text[shift + mismatchPos])
                shift += max(1, charShift)
        return occurrences
```",0.301075269,0.373809215,0.730769231,0.62295082,0.672566367,0.517241379,0.459183673,0.486486482,0.730769231,0.62295082,0.672566367,,,,,,,,,,,,
GPT,16,"class Calculator:
    def __init__(self):
        self.operators = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '/': lambda x, y: x / y,
            '^': lambda x, y: x ** y
        }

    def calculate(self, expression):
        operand_stack = []
        operator_stack = []
        num_buffer = ''

        for char in expression:
            if char.isdigit() or char == '.':
                num_buffer += char
            else:
                if num_buffer:
                    operand_stack.append(float(num_buffer))
                    num_buffer = ''

                if char in '+-*/^':
                    while (
                            operator_stack and
                            operator_stack[-1] != '(' and
                            self.precedence(operator_stack[-1]) >= self.precedence(char)
                    ):
                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

                    operator_stack.append(char)
                elif char == '(':
                    operator_stack.append(char)
                elif char == ')':
                    while operator_stack and operator_stack[-1] != '(':
                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

                    operator_stack.pop()

        if num_buffer:
            operand_stack.append(float(num_buffer))

        while operator_stack:
            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

        return operand_stack[-1] if operand_stack else None

    def precedence(self, operator):
        precedences = {
            '+': 1,
            '-': 1,
            '*': 2,
            '/': 2,
            '^': 3
        }
        return precedences.get(operator, 0)

    def apply_operator(self, operand_stack, operator_stack):
        operator = operator_stack.pop()
        if operator == '^':
            operand2 = operand_stack.pop()
            operand1 = operand_stack.pop()
            result = self.operators[operator](operand1, operand2)
            operand_stack.append(result)
        else:
            operand2 = operand_stack.pop()
            operand1 = operand_stack.pop()
            result = self.operators[operator](operand1, operand2)
            operand_stack.append(result)
        return operand_stack, operator_stack",COTFewShot,"```python
class Calculator:
    def __init__(self):
        self.operators = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '/': lambda x, y: x / y,
            '^': lambda x, y: x ** y
        }

    def calculate(self, expression):
        def precedence(operator):
            if operator in ('+', '-'):
                return 1
            if operator in ('*', '/'):
                return 2
            if operator == '^':
                return 3
            return 0

        def apply_operator(operand_stack, operator_stack):
            operator = operator_stack.pop()
            right = operand_stack.pop()
            left = operand_stack.pop()
            operand_stack.append(self.operators[operator](left, right))

        operand_stack = []
        operator_stack = []
        i = 0
        while i < len(expression):
            if expression[i].isdigit():
                num = 0
                while i < len(expression) and expression[i].isdigit():
                    num = num * 10 + int(expression[i])
                    i += 1
                operand_stack.append(float(num))
                i -= 1
            elif expression[i] in self.operators:
                while (operator_stack and
                       precedence(operator_stack[-1]) >= precedence(expression[i])):
                    apply_operator(operand_stack, operator_stack)
                operator_stack.append(expression[i])
            i += 1

        while operator_stack:
            apply_operator(operand_stack, operator_stack)

        return operand_stack[0]
```",0.265327927,0.307244222,0.540229885,0.602564103,0.569696965,0.344370861,0.40625,0.372759852,0.528735632,0.58974359,0.557575753,,,,,,,,,,,,
GPT,17,"from datetime import datetime, timedelta

class CalendarUtil:
    def __init__(self):
        self.events = []

    def add_event(self, event):
        self.events.append(event)

    def remove_event(self, event):
        if event in self.events:
            self.events.remove(event)

    def get_events(self, date):
        events_on_date = []
        for event in self.events:
            if event['date'].date() == date.date():
                events_on_date.append(event)
        return events_on_date

    def is_available(self, start_time, end_time):
        for event in self.events:
            if start_time < event['end_time'] and end_time > event['start_time']:
                return False
        return True

    def get_available_slots(self, date):
        available_slots = []
        start_time = datetime(date.year, date.month, date.day, 0, 0)
        end_time = datetime(date.year, date.month, date.day, 23, 59)

        while start_time < end_time:
            slot_end_time = start_time + timedelta(minutes=60)
            if self.is_available(start_time, slot_end_time):
                available_slots.append((start_time, slot_end_time))
            start_time += timedelta(minutes=60)


        return available_slots

    def get_upcoming_events(self, num_events):
        now = datetime.now()
        upcoming_events = []
        for event in self.events:
            if event['start_time'] >= now:
                upcoming_events.append(event)
            if len(upcoming_events) == num_events:
                break
        return upcoming_events",COTFewShot,"```python
from datetime import datetime, timedelta

class CalendarUtil:
    def __init__(self):
        self.events = []

    def add_event(self, event):
        self.events.append(event)

    def get_events(self, date):
        return [event for event in self.events if event['date'].date() == date.date()]

    def remove_event(self, event):
        self.events.remove(event)

    def is_available(self, start_time, end_time):
        for event in self.events:
            if event['start_time'] < end_time and event['end_time'] > start_time:
                return False
        return True

    def get_available_slots(self, date):
        slots = []
        start_of_day = datetime(date.year, date.month, date.day)
        end_of_day = start_of_day + timedelta(days=1)
        current_time = start_of_day

        for event in sorted(self.get_events(date), key=lambda e: e['start_time']):
            if current_time < event['start_time']:
                slots.append((current_time, event['start_time']))
            current_time = max(current_time, event['end_time'])

        if current_time < end_of_day:
            slots.append((current_time, end_of_day))

        return slots

    def get_upcoming_events(self, num_events):
        sorted_events = sorted(self.events, key=lambda e: e['start_time'])
        return sorted_events[:num_events]
```",0.282762826,0.335896713,0.653333333,0.653333333,0.653333328,0.425,0.467889908,0.445414842,0.626666667,0.626666667,0.626666662,,,,,,,,,,,,
GPT,18,"class CamelCaseMap:
    def __init__(self):
        self._data = {}

    def __getitem__(self, key):
        return self._data[self._convert_key(key)]

    def __setitem__(self, key, value):
        self._data[self._convert_key(key)] = value

    def __delitem__(self, key):
        del self._data[self._convert_key(key)]

    def __iter__(self):
        return iter(self._data)

    def __len__(self):
        return len(self._data)

    def _convert_key(self, key):
        if isinstance(key, str):
            return self._to_camel_case(key)
        return key

    @staticmethod
    def _to_camel_case(key):
        parts = key.split('_')
        return parts[0] + ''.join(part.title() for part in parts[1:])",COTFewShot,"```python
class CamelCaseMap:
    def __init__(self):
        self._data = {}

    def __getitem__(self, key):
        camel_key = self._convert_key(key)
        return self._data[camel_key]

    def __setitem__(self, key, value):
        camel_key = self._convert_key(key)
        self._data[camel_key] = value

    def __delitem__(self, key):
        camel_key = self._convert_key(key)
        del self._data[camel_key]

    def __iter__(self):
        return iter(self._data)

    def __len__(self):
        return len(self._data)

    def _convert_key(self, key):
        return self._to_camel_case(key)

    @staticmethod
    def _to_camel_case(key):
        parts = key.split('_')
        return parts[0] + ''.join(part.capitalize() for part in parts[1:])
```",0.516666667,0.570735446,0.860465116,0.860465116,0.860465111,0.754098361,0.741935484,0.747967475,0.860465116,0.860465116,0.860465111,,,,,,,,,,,,
GPT,19,"class ChandrasekharSieve:
    def __init__(self, n):
        self.n = n
        self.primes = self.generate_primes()

    def generate_primes(self):
        if self.n < 2:
            return []

        sieve = [True] * (self.n + 1)
        sieve[0] = sieve[1] = False

        p = 2
        while p * p <= self.n:
            if sieve[p]:
                for i in range(p * p, self.n + 1, p):
                    sieve[i] = False
            p += 1

        primes = []
        for i in range(2, self.n + 1):
            if sieve[i]:
                primes.append(i)

        return primes

    def get_primes(self):
        return self.primes",COTFewShot,"```python
class ChandrasekharSieve:
    def __init__(self, n):
        self.n = n
        self.primes = self.generate_primes()

    def generate_primes(self):
        if self.n < 2:
            return []
        is_prime = [True] * (self.n + 1)
        p = 2
        while p * p <= self.n:
            if is_prime[p]:
                for i in range(p * p, self.n + 1, p):
                    is_prime[i] = False
            p += 1
        return [p for p in range(2, self.n + 1) if is_prime[p]]

    def get_primes(self):
        return self.primes
```",0.585483035,0.626724169,0.826086957,0.844444444,0.83516483,0.72,0.76056338,0.739726022,0.826086957,0.844444444,0.83516483,,,,,,,,,,,,
GPT,1,"import math


class AreaCalculator:

    def __init__(self, radius):
        self.radius = radius

    def calculate_circle_area(self):
        return math.pi * self.radius ** 2

    def calculate_sphere_area(self):
        return 4 * math.pi * self.radius ** 2

    def calculate_cylinder_area(self, height):
        return 2 * math.pi * self.radius * (self.radius + height)

    def calculate_sector_area(self, angle):
        return self.radius ** 2 * angle / 2

    def calculate_annulus_area(self, inner_radius, outer_radius):
        return math.pi * (outer_radius ** 2 - inner_radius ** 2)",COTFewShot,"```python
import math

class AreaCalculator:
    def __init__(self, radius):
        self.radius = radius

    def calculate_circle_area(self):
        return math.pi * self.radius ** 2

    def calculate_sphere_area(self):
        return 4 * math.pi * self.radius ** 2

    def calculate_cylinder_area(self, height):
        return 2 * math.pi * self.radius * (self.radius + height)

    def calculate_sector_area(self, angle):
        return 0.5 * self.radius ** 2 * angle

    def calculate_annulus_area(self, inner_radius, outer_radius):
        return math.pi * (outer_radius ** 2 - inner_radius ** 2)
```",0.878787879,0.893438928,0.970588235,0.891891892,0.92957746,0.943396226,0.892857143,0.917431188,0.970588235,0.891891892,0.92957746,,,,,,,,,,,,
GPT,20,"from datetime import datetime

class Chat:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username in self.users:
            return False
        else:
            self.users[username] = []
            return True

    def remove_user(self, username):
        if username in self.users:
            del self.users[username]
            return True
        else:
            return False

    def send_message(self, sender, receiver, message):
        if sender not in self.users or receiver not in self.users:
            return False

        timestamp = datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
        message_info = {
            'sender': sender,
            'receiver': receiver,
            'message': message,
            'timestamp': timestamp
        }
        self.users[sender].append(message_info)
        self.users[receiver].append(message_info)
        return True

    def get_messages(self, username):
        if username not in self.users:
            return []
        return self.users[username]",COTFewShot,"```python
from datetime import datetime

class Chat:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username in self.users:
            return False
        self.users[username] = []
        return True

    def remove_user(self, username):
        if username in self.users:
            del self.users[username]
            return True
        return False

    def send_message(self, sender, receiver, message):
        if sender not in self.users or receiver not in self.users:
            return False
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        message_data = {
            'sender': sender,
            'receiver': receiver,
            'message': message,
            'timestamp': timestamp
        }
        self.users[sender].append(message_data)
        self.users[receiver].append(message_data)
        return True

    def get_messages(self, username):
        if username in self.users:
            return self.users[username]
        return []
```",0.758770294,0.797880757,0.897959184,0.88,0.888888884,0.833333333,0.844155844,0.838709672,0.897959184,0.88,0.888888884,,,,,,,,,,,,
GPT,21,"from datetime import datetime


class Classroom:
    def __init__(self, id):
        self.id = id
        self.courses = []

    def add_course(self, course):

        if course not in self.courses:
            self.courses.append(course)

    def remove_course(self, course):
        if course in self.courses:
            self.courses.remove(course)

    def is_free_at(self, check_time):
        check_time = datetime.strptime(check_time, '%H:%M')

        for course in self.courses:
            if datetime.strptime(course['start_time'], '%H:%M') <= check_time <= datetime.strptime(course['end_time'],
                                                                                                   '%H:%M'):
                return False
        return True

    def check_course_conflict(self, new_course):
        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M')
        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M')

        flag = True
        for course in self.courses:
            start_time = datetime.strptime(course['start_time'], '%H:%M')
            end_time = datetime.strptime(course['end_time'], '%H:%M')
            if start_time <= new_start_time and end_time >= new_start_time:
                flag = False
            if start_time <= new_end_time and end_time >= new_end_time:
                flag = False
        return flag",COTFewShot,"```python
class ClassRegistrationSystem:
    def __init__(self):
        self.students = []
        self.students_registration_classes = {}

    def register_student(self, student):
        if student in self.students:
            return 0
        else:
            self.students.append(student)
            self.students_registration_classes[student[""name""]] = []
            return 1

    def register_class(self, student_name, class_name):
        if student_name in self.students_registration_classes:
            self.students_registration_classes[student_name].append(class_name)
            return self.students_registration_classes[student_name]
        return []

    def get_students_by_major(self, major):
        return [student[""name""] for student in self.students if student[""major""] == major]

    def get_all_major(self):
        return list(set(student[""major""] for student in self.students))

    def get_most_popular_class_in_major(self, major):
        class_count = {}
        for student in self.students:
            if student[""major""] == major:
                for class_name in self.students_registration_classes[student[""name""]]:
                    if class_name in class_count:
                        class_count[class_name] += 1
                    else:
                        class_count[class_name] = 1
        if class_count:
            return max(class_count, key=class_count.get)
        return None
```",0.000969857,0.253209706,0.183673469,0.169811321,0.176470583,0.032608696,0.032258065,0.032432427,0.183673469,0.169811321,0.176470583,,,,,,,,,,,,
GPT,22,"class ClassRegistrationSystem:

    def __init__(self):
        self.students = []
        self.students_registration_classes = {}

    def register_student(self, student):
        if student in self.students:
            return 0
        else:
            self.students.append(student)
            return 1

    def register_class(self, student_name, class_name):
        if student_name in self.students_registration_classes:
            self.students_registration_classes[student_name].append(class_name)
        else:
            self.students_registration_classes[student_name] = [class_name]
        return self.students_registration_classes[student_name]

    def get_students_by_major(self, major):
        student_list = []
        for student in self.students:
            if student[""major""] == major:
                student_list.append(student[""name""])
        return student_list

    def get_all_major(self):
        major_list = []
        for student in self.students:
            if student[""major""] not in major_list:
                major_list.append(student[""major""])
        return major_list

    def get_most_popular_class_in_major(self, major):
        class_list = []
        for student in self.students:
            if student[""major""] == major:
                class_list += self.students_registration_classes[student[""name""]]
        most_popular_class = max(set(class_list), key=class_list.count)
        return most_popular_class",COTFewShot,"```python
from datetime import datetime

class Classroom:
    def __init__(self, id):
        self.id = id
        self.courses = []

    def add_course(self, course):
        if course not in self.courses:
            self.courses.append(course)

    def remove_course(self, course):
        if course in self.courses:
            self.courses.remove(course)

    def is_free_at(self, check_time):
        check_time = datetime.strptime(check_time, '%H:%M').time()
        for course in self.courses:
            start_time = datetime.strptime(course['start_time'], '%H:%M').time()
            end_time = datetime.strptime(course['end_time'], '%H:%M').time()
            if start_time <= check_time < end_time:
                return False
        return True

    def check_course_conflict(self, new_course):
        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M').time()
        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M').time()
        for course in self.courses:
            start_time = datetime.strptime(course['start_time'], '%H:%M').time()
            end_time = datetime.strptime(course['end_time'], '%H:%M').time()
            if not (new_end_time <= start_time or new_start_time >= end_time):
                return False
        return True
```",0.001030928,0.278062025,0.2,0.192307692,0.196078426,0.035714286,0.036144578,0.035928139,0.2,0.192307692,0.196078426,,,,,,,,,,,,
GPT,23,"import math
from typing import List

class CombinationCalculator:
    def __init__(self, datas: List[str]):
        self.datas = datas

    @staticmethod
    def count(n: int, m: int) -> int:
        if m == 0 or n == m:
            return 1
        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))

    @staticmethod
    def count_all(n: int) -> int:
        if n < 0 or n > 63:
            return False
        return (1 << n) - 1 if n != 63 else float(""inf"")

    def select(self, m: int) -> List[List[str]]:
        result = []
        self._select(0, [None] * m, 0, result)
        return result

    def select_all(self) -> List[List[str]]:
        result = []
        for i in range(1, len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):
        resultLen = len(resultList)
        resultCount = resultIndex + 1
        if resultCount > resultLen:
            result.append(resultList.copy())
            return

        for i in range(dataIndex, len(self.datas) + resultCount - resultLen):
            resultList[resultIndex] = self.datas[i]
            self._select(i + 1, resultList, resultIndex + 1, result)",COTFewShot,"```python
import math
from typing import List


class CombinationCalculator:
    def __init__(self, datas: List[str]):
        self.datas = datas

    @staticmethod
    def count(n: int, m: int) -> int:
        if m > n:
            return 0
        return math.comb(n, m)

    @staticmethod
    def count_all(n: int) -> int:
        total = 0
        for i in range(1, n + 1):
            total += math.comb(n, i)
        return total if total <= 2**63 - 1 else float(""inf"")

    def select(self, m: int) -> List[List[str]]:
        result = []
        self._select(0, [None] * m, 0, result)
        return result

    def select_all(self) -> List[List[str]]:
        result = []
        for i in range(1, len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):
        if resultIndex == len(resultList):
            result.append(resultList.copy())
            return
        if dataIndex >= len(self.datas):
            return
        resultList[resultIndex] = self.datas[dataIndex]
        self._select(dataIndex + 1, resultList, resultIndex + 1, result)
        self._select(dataIndex + 1, resultList, resultIndex, result)
```",0.529979617,0.581868262,0.755555556,0.80952381,0.78160919,0.583941606,0.62992126,0.606060601,0.755555556,0.80952381,0.78160919,,,,,,,,,,,,
GPT,24,"class ComplexCalculator:
    def __init__(self):
        pass

    @staticmethod
    def add(c1, c2):
        real = c1.real + c2.real
        imaginary = c1.imag + c2.imag
        answer = complex(real, imaginary)
        return answer
    
    @staticmethod
    def subtract(c1, c2):
        real = c1.real - c2.real
        imaginary = c1.imag - c2.imag
        return complex(real, imaginary)
    
    @staticmethod
    def multiply(c1, c2):
        real = c1.real * c2.real - c1.imag * c2.imag
        imaginary = c1.real * c2.imag + c1.imag * c2.real
        return complex(real, imaginary)
    
    @staticmethod
    def divide(c1, c2):
        denominator = c2.real**2 + c2.imag**2
        real = (c1.real * c2.real + c1.imag * c2.imag) / denominator
        imaginary = (c1.imag * c2.real - c1.real * c2.imag) / denominator
        return complex(real, imaginary)",COTFewShot,"```python
class ComplexCalculator:
    def __init__(self):
        pass

    @staticmethod
    def add(c1, c2):
        return c1 + c2

    @staticmethod
    def subtract(c1, c2):
        return c1 - c2

    @staticmethod
    def multiply(c1, c2):
        return c1 * c2

    @staticmethod
    def divide(c1, c2):
        return c1 / c2
```",0.071667913,0.084334101,0.6,0.9,0.719999995,0.278688525,0.62962963,0.386363632,0.6,0.9,0.719999995,,,,,,,,,,,,
GPT,25,"import json

class CookiesUtil:
    def __init__(self, cookies_file):
        self.cookies_file = cookies_file
        self.cookies = None

    def get_cookies(self, reponse):
        self.cookies = reponse['cookies']
        self._save_cookies()

    def load_cookies(self):
        try:
            with open(self.cookies_file, 'r') as file:
                cookies_data = json.load(file)
                return cookies_data
        except FileNotFoundError:
            return {}

    def _save_cookies(self):
        try:
            with open(self.cookies_file, 'w') as file:
                json.dump(self.cookies, file)
            return True
        except:
            return False

    def set_cookies(self, request):
        request['cookies'] = '; '.join([f'{key}={value}' for key, value in self.cookies.items()])",COTFewShot,"```python
import json

class CookiesUtil:
    def __init__(self, cookies_file):
        self.cookies_file = cookies_file
        self.cookies = None

    def get_cookies(self, response):
        self.cookies = response.get('cookies', {})
        self._save_cookies()

    def load_cookies(self):
        try:
            with open(self.cookies_file, 'r') as file:
                self.cookies = json.load(file)
        except (FileNotFoundError, json.JSONDecodeError):
            self.cookies = {}
        return self.cookies

    def _save_cookies(self):
        try:
            with open(self.cookies_file, 'w') as file:
                json.dump(self.cookies, file)
            return True
        except:
            return False
```",0.530660596,0.581219156,0.693877551,0.80952381,0.747252742,0.602941176,0.694915254,0.645669286,0.693877551,0.80952381,0.747252742,,,,,,,,,,,,
GPT,26,"import csv


class CSVProcessor:

    def __init__(self):
        pass

    def read_csv(self, file_name):
        data = []
        with open(file_name, 'r') as file:
            reader = csv.reader(file)
            title = next(reader)
            for row in reader:
                data.append(row)
        return title, data

    def write_csv(self, data, file_name):
        try:
            with open(file_name, 'w', newline='') as file:
                writer = csv.writer(file)
                writer.writerows(data)
            return 1
        except:
            return 0

    def process_csv_data(self, N, save_file_name):
        title, data = self.read_csv(save_file_name)
        column_data = [row[N] for row in data]
        column_data = [row.upper() for row in column_data]
        new_data = [title, column_data]
        return self.write_csv(new_data, save_file_name.split('.')[0] + '_process.csv')",COTFewShot,"```python
import csv

class CSVProcessor:
    def __init__(self):
        pass

    def read_csv(self, file_name):
        try:
            with open(file_name, mode='r', newline='') as file:
                csv_reader = csv.reader(file)
                title = next(csv_reader)
                data = [row for row in csv_reader]
            return title, data
        except:
            return None, None

    def write_csv(self, data, file_name):
        try:
            with open(file_name, mode='w', newline='') as file:
                csv_writer = csv.writer(file)
                for row in data:
                    csv_writer.writerow(row)
            return 1
        except:
            return 0

    def process_csv_data(self, N, save_file_name):
        try:
            title, data = self.read_csv(save_file_name)
            if title is None or data is None:
                return 0

            new_data = [[row[N].upper()] for row in data]
            new_file_name = save_file_name.replace('.csv', '_process.csv')
            self.write_csv([title] + new_data, new_file_name)
            return 1
        except:
            return 0
```",0.3,0.360783568,0.711864407,0.636363636,0.671999995,0.5,0.445652174,0.471264363,0.694915254,0.621212121,0.655999995,,,,,,,,,,,,
GPT,27,"class CurrencyConverter:
    def __init__(self):
        self.rates = {
            'USD': 1.0,
            'EUR': 0.85,
            'GBP': 0.72,
            'JPY': 110.15,
            'CAD': 1.23,
            'AUD': 1.34,
            'CNY': 6.40,
        }

    def convert(self, amount, from_currency, to_currency):
        if from_currency == to_currency:
            return amount

        if from_currency not in self.rates or to_currency not in self.rates:
            return False

        from_rate = self.rates[from_currency]
        to_rate = self.rates[to_currency]

        converted_amount = (amount / from_rate) * to_rate
        return converted_amount

    def get_supported_currencies(self):
        return list(self.rates.keys())

    def add_currency_rate(self, currency, rate):
        if currency in self.rates:
            return False
        self.rates[currency] = rate

    def update_currency_rate(self, currency, new_rate):
        if currency not in self.rates:
            return False
        self.rates[currency] = new_rate",COTFewShot,"```python
class CurrencyConverter:
    def __init__(self):
        self.rates = {
            'USD': 1.0,
            'EUR': 0.85,
            'GBP': 0.72,
            'JPY': 110.15,
            'CAD': 1.23,
            'AUD': 1.34,
            'CNY': 6.40,
        }

    def convert(self, amount, from_currency, to_currency):
        if from_currency not in self.rates or to_currency not in self.rates:
            return None
        usd_amount = amount / self.rates[from_currency]
        return usd_amount * self.rates[to_currency]

    def get_supported_currencies(self):
        return list(self.rates.keys())

    def add_currency_rate(self, currency, rate):
        if currency in self.rates:
            return False
        self.rates[currency] = rate

    def update_currency_rate(self, currency, new_rate):
        if currency not in self.rates:
            return False
        self.rates[currency] = new_rate
```",0.727226444,0.748354859,0.890625,0.93442623,0.911999995,0.777777778,0.843373494,0.80924855,0.875,0.918032787,0.895999995,,,,,,,,,,,,
GPT,28,"import sqlite3
import pandas as pd


class DatabaseProcessor:

    def __init__(self, database_name):
        self.database_name = database_name

    def create_table(self, table_name, key1, key2):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        create_table_query = f""CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)""
        cursor.execute(create_table_query)

        conn.commit()
        conn.close()

    def insert_into_database(self, table_name, data):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        for item in data:
            insert_query = f""INSERT INTO {table_name} (name, age) VALUES (?, ?)""
            cursor.execute(insert_query, (item['name'], item['age']))

        conn.commit()
        conn.close()

    def search_database(self, table_name, name):

        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        select_query = f""SELECT * FROM {table_name} WHERE name = ?""
        cursor.execute(select_query, (name,))
        result = cursor.fetchall()

        if result:
            return result
        else:
            return None

    def delete_from_database(self, table_name, name):

        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        delete_query = f""DELETE FROM {table_name} WHERE name = ?""
        cursor.execute(delete_query, (name,))

        conn.commit()
        conn.close()",COTFewShot,"```python
import sqlite3
import pandas as pd

class DatabaseProcessor:
    def __init__(self, database_name):
        self.database_name = database_name

    def create_table(self, table_name, key1, key2):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()
        cursor.execute(f'''
            CREATE TABLE IF NOT EXISTS {table_name} (
                id INTEGER PRIMARY KEY,
                {key1} TEXT,
                {key2} INTEGER
            )
        ''')
        conn.commit()
        conn.close()

    def insert_into_database(self, table_name, data):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()
        for row in data:
            keys = ', '.join(row.keys())
            placeholders = ', '.join('?' * len(row))
            values = tuple(row.values())
            cursor.execute(f'''
                INSERT INTO {table_name} ({keys})
                VALUES ({placeholders})
            ''', values)
        conn.commit()
        conn.close()

    def search_database(self, table_name, name):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()
        cursor.execute(f'''
            SELECT * FROM {table_name} WHERE name = ?
        ''', (name,))
        results = cursor.fetchall()
        conn.close()
        return results

    def delete_from_database(self, table_name, name):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()
        cursor.execute(f'''
            DELETE FROM {table_name} WHERE name = ?
        ''', (name,))
        conn.commit()
        conn.close()
```",0.507575758,0.557538663,0.658227848,0.641975309,0.649999995,0.553571429,0.543859649,0.548672561,0.658227848,0.641975309,0.649999995,,,,,,,,,,,,
GPT,29,"from collections import Counter


class DataStatistics:
    def mean(self, data):
        return round(sum(data) / len(data), 2)

    def median(self, data):
        sorted_data = sorted(data)
        n = len(sorted_data)
        if n % 2 == 0:
            middle = n // 2
            return round((sorted_data[middle - 1] + sorted_data[middle]) / 2, 2)
        else:
            middle = n // 2
            return sorted_data[middle]

    def mode(self, data):
        counter = Counter(data)
        mode_count = max(counter.values())
        mode = [x for x, count in counter.items() if count == mode_count]
        return mode",COTFewShot,"```python
from collections import Counter

class DataStatistics:
    def mean(self, data):
        return round(sum(data) / len(data), 2)

    def median(self, data):
        sorted_data = sorted(data)
        n = len(sorted_data)
        mid = n // 2
        if n % 2 == 0:
            return round((sorted_data[mid - 1] + sorted_data[mid]) / 2, 2)
        else:
            return round(sorted_data[mid], 2)

    def mode(self, data):
        data_count = Counter(data)
        max_count = max(data_count.values())
        mode = [k for k, v in data_count.items() if v == max_count]
        return mode
```",0.43072484,0.500828691,0.775510204,0.745098039,0.759999995,0.6,0.583333333,0.591549291,0.755102041,0.725490196,0.739999995,,,,,,,,,,,,
GPT,2,"class ArgumentParser:
    def __init__(self):
        self.arguments = {}
        self.required = set()
        self.types = {}

    def parse_arguments(self, command_string):
        args = command_string.split()[1:]
        for i in range(len(args)):
            arg = args[i]
            if arg.startswith('--'):
                key_value = arg[2:].split('=')
                if len(key_value) == 2:
                    self.arguments[key_value[0]] = self._convert_type(key_value[0], key_value[1])
                else:
                    self.arguments[key_value[0]] = True
            elif arg.startswith('-'):
                key = arg[1:]
                if i + 1 < len(args) and not args[i + 1].startswith('-'):
                    self.arguments[key] = self._convert_type(key, args[i + 1])
                else:
                    self.arguments[key] = True
        missing_args = self.required - set(self.arguments.keys())
        if missing_args:
            return False, missing_args

        return True, None

    def get_argument(self, key):
        return self.arguments.get(key)

    def add_argument(self, arg, required=False, arg_type=str):
        if required:
            self.required.add(arg)
        self.types[arg] = arg_type

    def _convert_type(self, arg, value):
        try:
            return self.types[arg](value)
        except (ValueError, KeyError):
            return value",COTFewShot,"```python
class ArgumentParser:
    def __init__(self):
        self.arguments = {}
        self.required = set()
        self.types = {}

    def parse_arguments(self, command_string):
        args = command_string.split()
        missing_args = set(self.required)
        for arg in args:
            if arg.startswith('--'):
                key, value = arg[2:].split('=')
                self.arguments[key] = self._convert_type(key, value)
                missing_args.discard(key)
            elif arg.startswith('-'):
                key = arg[1:]
                self.arguments[key] = True
                missing_args.discard(key)
        
        if missing_args:
            return False, missing_args
        return True, None

    def get_argument(self, key):
        return self.arguments.get(key)

    def add_argument(self, arg, required=False, arg_type=str):
        if required:
            self.required.add(arg)
        self.types[arg] = arg_type

    def _convert_type(self, arg, value):
        try:
            return self.types[arg](value)
        except (ValueError, KeyError):
            return value
```",0.492180445,0.532276994,0.705128205,0.873015873,0.780141839,0.627118644,0.778947368,0.694835676,0.692307692,0.857142857,0.765957442,,,,,,,,,,,,
GPT,30,"import numpy as np


class DataStatistics2:
    def __init__(self, data):
        self.data = np.array(data)

    def get_sum(self):
        return np.sum(self.data)

    def get_min(self):
        return np.min(self.data)

    def get_max(self):
        return np.max(self.data)

    def get_variance(self):
        return round(np.var(self.data), 2)

    def get_std_deviation(self):
        return round(np.std(self.data), 2)

    def get_correlation(self):
        return np.corrcoef(self.data, rowvar=False)",COTFewShot,"```python
import numpy as np

class DataStatistics2:
    def __init__(self, data):
        self.data = np.array(data)

    def get_sum(self):
        return float(np.sum(self.data))

    def get_min(self):
        return float(np.min(self.data))

    def get_max(self):
        return float(np.max(self.data))

    def get_variance(self):
        return float(np.var(self.data, ddof=0).round(2))

    def get_std_deviation(self):
        return float(np.std(self.data, ddof=0).round(2))

    def get_correlation(self):
        if len(self.data) < 2:
            return float('nan')
        return float(np.corrcoef(self.data, self.data)[0, 1])
```",0.369565217,0.416670213,0.875,0.682926829,0.767123283,0.590909091,0.472727273,0.52525252,0.875,0.682926829,0.767123283,,,,,,,,,,,,
GPT,31,"import math

class DataStatistics4:

    @staticmethod
    def correlation_coefficient(data1, data2):
        n = len(data1)
        mean1 = sum(data1) / n
        mean2 = sum(data2) / n

        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))
        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n))) * math.sqrt(sum((data2[i] - mean2) ** 2 for i in range(n)))

        return numerator / denominator if denominator != 0 else 0
    
    @staticmethod
    def skewness(data):
        n = len(data)
        mean = sum(data) / n
        variance = sum((x - mean) ** 2 for x in data) / n
        std_deviation = math.sqrt(variance)

        skewness = sum((x - mean) ** 3 for x in data) * n / ((n - 1) * (n - 2) * std_deviation ** 3) if std_deviation != 0 else 0

        return skewness
    
    @staticmethod
    def kurtosis(data):

        n = len(data)
        mean = sum(data) / n
        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / n)

        if std_dev == 0:
            return math.nan

        centered_data = [(x - mean) for x in data]
        fourth_moment = sum(x ** 4 for x in centered_data) / n

        kurtosis_value = (fourth_moment / std_dev ** 4) - 3

        return kurtosis_value
    
    @staticmethod
    def pdf(data, mu, sigma):
        pdf_values = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]
        return pdf_values",COTFewShot,"```python
import math

class DataStatistics4:
    @staticmethod
    def correlation_coefficient(data1, data2):
        n = len(data1)
        sum1 = sum(data1)
        sum2 = sum(data2)
        sum1_sq = sum([pow(val, 2) for val in data1])
        sum2_sq = sum([pow(val, 2) for val in data2])
        p_sum = sum([data1[i] * data2[i] for i in range(n)])
        num = p_sum - (sum1 * sum2 / n)
        den = math.sqrt((sum1_sq - pow(sum1, 2) / n) * (sum2_sq - pow(sum2, 2) / n))
        if den == 0:
            return 0
        return num / den

    @staticmethod
    def skewness(data):
        n = len(data)
        mean = sum(data) / n
        m3 = sum([(x - mean) ** 3 for x in data]) / n
        m2 = sum([(x - mean) ** 2 for x in data]) / n
        if m2 == 0:
            return 0
        return m3 / (m2 ** 1.5)

    @staticmethod
    def kurtosis(data):
        n = len(data)
        mean = sum(data) / n
        m4 = sum([(x - mean) ** 4 for x in data]) / n
        m2 = sum([(x - mean) ** 2 for x in data]) / n
        if m2 == 0:
            return 0
        return m4 / (m2 ** 2) - 3

    @staticmethod
    def pdf(data, mu, sigma):
        return [(1 / (sigma * math.sqrt(2 * math.pi))) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]
```",0.303468566,0.376173104,0.558139535,0.6,0.578313248,0.359281437,0.425531915,0.389610385,0.534883721,0.575,0.554216862,,,,,,,,,,,,
GPT,32,"class DecryptionUtils:
    def __init__(self, key):
        self.key = key
    
    def caesar_decipher(self, ciphertext, shift):
        plaintext = """"
        for char in ciphertext:
            if char.isalpha():
                if char.isupper():
                    ascii_offset = 65
                else:
                    ascii_offset = 97
                shifted_char = chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)
                plaintext += shifted_char
            else:
                plaintext += char
        return plaintext
    
    def vigenere_decipher(self, ciphertext):
        decrypted_text = """"
        key_index = 0
        for char in ciphertext:
            if char.isalpha():
                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')
                decrypted_char = chr((ord(char.lower()) - ord('a') - shift) % 26 + ord('a'))
                decrypted_text += decrypted_char.upper() if char.isupper() else decrypted_char
                key_index += 1
            else:
                decrypted_text += char
        return decrypted_text
    
    def rail_fence_decipher(self, encrypted_text, rails):
        fence = [['\n' for _ in range(len(encrypted_text))] for _ in range(rails)]
        direction = -1
        row, col = 0, 0

        for _ in range(len(encrypted_text)):
            if row == 0 or row == rails - 1:
                direction = -direction

            fence[row][col] = ''
            col += 1
            row += direction

        index = 0
        for i in range(rails):
            for j in range(len(encrypted_text)):
                if fence[i][j] == '':
                    fence[i][j] = encrypted_text[index]
                    index += 1

        plain_text = ''
        direction = -1
        row, col = 0, 0
        for _ in range(len(encrypted_text)):
            if row == 0 or row == rails - 1:
                direction = -direction

            plain_text += fence[row][col]
            col += 1
            row += direction

        return plain_text",COTFewShot,"```python
class DecryptionUtils:
    def __init__(self, key):
        self.key = key

    def caesar_decipher(self, ciphertext, shift):
        plaintext = ''
        for char in ciphertext:
            if char.isalpha():
                shift_amount = shift % 26
                shifted = ord(char) - shift_amount
                if char.islower():
                    if shifted < ord('a'):
                        shifted += 26
                elif char.isupper():
                    if shifted < ord('A'):
                        shifted += 26
                plaintext += chr(shifted)
            else:
                plaintext += char
        return plaintext

    def vigenere_decipher(self, ciphertext):
        plaintext = ''
        key_length = len(self.key)
        key_as_int = [ord(i) for i in self.key]
        ciphertext_int = [ord(i) for i in ciphertext]
        for i in range(len(ciphertext_int)):
            value = (ciphertext_int[i] - key_as_int[i % key_length]) % 26
            plaintext += chr(value + 65)
        return plaintext.lower()

    def rail_fence_decipher(self, encrypted_text, rails):
        if rails == 1:
            return encrypted_text
        rail = [['\n' for _ in range(len(encrypted_text))]
                for _ in range(rails)]
        dir_down = None
        row, col = 0, 0
        for i in range(len(encrypted_text)):
            if row == 0:
                dir_down = True
            if row == rails - 1:
                dir_down = False
            rail[row][col] = '*'
            col += 1
            if dir_down:
                row += 1
            else:
                row -= 1
        index = 0
        for i in range(rails):
            for j in range(len(encrypted_text)):
                if rail[i][j] == '*' and index < len(encrypted_text):
                    rail[i][j] = encrypted_text[index]
                    index += 1
        result = []
        row, col = 0, 0
        for i in range(len(encrypted_text)):
            if row == 0:
                dir_down = True
            if row == rails - 1:
                dir_down = False
            if rail[row][col] != '*':
                result.append(rail[row][col])
                col += 1
            if dir_down:
                row += 1
            else:
                row -= 1
        return ''.join(result)
```",0.291139241,0.350673869,0.638554217,0.535353535,0.582417577,0.441558442,0.379888268,0.408408403,0.626506024,0.525252525,0.571428566,,,,,,,,,,,,
GPT,33,"class DiscountStrategy:
    def __init__(self, customer, cart, promotion=None):
        self.customer = customer
        self.cart = cart
        self.promotion = promotion
        self.__total = self.total()

    def total(self):
        self.__total = sum(item['quantity'] * item['price'] for item in self.cart)
        return self.__total

    def due(self):
        if self.promotion is None:
            discount = 0
        else:
            discount = self.promotion(self)
        return self.__total - discount

    @staticmethod
    def FidelityPromo(order):
        return order.total() * 0.05 if order.customer['fidelity'] >= 1000 else 0

    @staticmethod
    def BulkItemPromo(order):
        discount = 0
        for item in order.cart:
            if item['quantity'] >= 20:
                discount += item['quantity'] * item['price'] * 0.1
        return discount

    @staticmethod
    def LargeOrderPromo(order):
        return order.total() * 0.07 if len({item['product'] for item in order.cart}) >= 10 else 0",COTFewShot,"```python
class DiscountStrategy:
    def __init__(self, customer, cart, promotion=None):
        self.customer = customer
        self.cart = cart
        self.promotion = promotion
        self.total()

    def total(self):
        return sum(item['quantity'] * item['price'] for item in self.cart)

    def due(self):
        if self.promotion is None:
            discount = 0
        else:
            discount = self.promotion(self)
        return self.total() - discount

    @staticmethod
    def FidelityPromo(order):
        return order.total() * 0.05 if order.customer['fidelity'] >= 1000 else 0

    @staticmethod
    def BulkItemPromo(order):
        discount = 0
        for item in order.cart:
            if item['quantity'] >= 20:
                discount += item['quantity'] * item['price'] * 0.1
        return discount

    @staticmethod
    def LargeOrderPromo(order):
        distinct_items = {item['product'] for item in order.cart}
        if len(distinct_items) >= 10:
            return order.total() * 0.07
        return 0
```",0.74,0.777910149,0.921568627,0.87037037,0.89523809,0.842105263,0.816326531,0.829015539,0.921568627,0.87037037,0.89523809,,,,,,,,,,,,
GPT,34,"from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT


class DocFileHandler:
    def __init__(self, file_path):
        self.file_path = file_path

    def read_text(self):
        doc = Document(self.file_path)
        text = []
        for paragraph in doc.paragraphs:
            text.append(paragraph.text)
        return ""\n"".join(text)

    def write_text(self, content, font_size=12, alignment='left'):
        try:
            doc = Document()
            paragraph = doc.add_paragraph()
            run = paragraph.add_run(content)
            font = run.font
            font.size = Pt(font_size)
            alignment_value = self._get_alignment_value(alignment)
            paragraph.alignment = alignment_value
            doc.save(self.file_path)
            return True
        except:
            return False

    def add_heading(self, heading, level=1):
        try:
            doc = Document(self.file_path)
            doc.add_heading(heading, level)
            doc.save(self.file_path)
            return True
        except:
            return False

    def add_table(self, data):
        try:
            doc = Document(self.file_path)
            table = doc.add_table(rows=len(data), cols=len(data[0]))
            for i, row in enumerate(data):
                for j, cell_value in enumerate(row):
                    table.cell(i, j).text = str(cell_value)
            doc.save(self.file_path)
            return True
        except:
            return False

    def _get_alignment_value(self, alignment):
        alignment_options = {
            'left': WD_PARAGRAPH_ALIGNMENT.LEFT,
            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,
            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT
        }
        return alignment_options.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)",COTFewShot,"```python
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT

class DocFileHandler:
    def __init__(self, file_path):
        self.file_path = file_path

    def read_text(self):
        try:
            doc = Document(self.file_path)
            return ""\n"".join([para.text for para in doc.paragraphs])
        except:
            return None

    def write_text(self, content, font_size=12, alignment='left'):
        try:
            doc = Document()
            paragraph = doc.add_paragraph(content)
            run = paragraph.runs[0]
            run.font.size = Pt(font_size)
            paragraph.alignment = self._get_alignment_value(alignment)
            doc.save(self.file_path)
            return True
        except:
            return False

    def add_heading(self, heading, level=1):
        try:
            doc = Document(self.file_path)
            doc.add_heading(heading, level=level)
            doc.save(self.file_path)
            return True
        except:
            return False

    def add_table(self, data):
        try:
            doc = Document(self.file_path)
            table = doc.add_table(rows=1, cols=len(data[0]))
            hdr_cells = table.rows[0].cells
            for i, heading in enumerate(data[0]):
                hdr_cells[i].text = heading
            for row_data in data[1:]:
                row_cells = table.add_row().cells
                for i, item in enumerate(row_data):
                    row_cells[i].text = str(item)
            doc.save(self.file_path)
            return True
        except:
            return False

    def _get_alignment_value(self, alignment):
        if alignment == 'center':
            return WD_PARAGRAPH_ALIGNMENT.CENTER
        elif alignment == 'right':
            return WD_PARAGRAPH_ALIGNMENT.RIGHT
        else:
            return WD_PARAGRAPH_ALIGNMENT.LEFT
```",0.45323741,0.513405269,0.674698795,0.651162791,0.662721888,0.537313433,0.533333333,0.53531598,0.674698795,0.651162791,0.662721888,,,,,,,,,,,,
GPT,35,"class EightPuzzle:
    def __init__(self, initial_state):
        self.initial_state = initial_state
        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

    def find_blank(self, state):
        for i in range(3):
            for j in range(3):
                if state[i][j] == 0:
                    return i, j

    def move(self, state, direction):
        i, j = self.find_blank(state)
        new_state = [row[:] for row in state]

        if direction == 'up':
            new_state[i][j], new_state[i - 1][j] = new_state[i - 1][j], new_state[i][j]
        elif direction == 'down':
            new_state[i][j], new_state[i + 1][j] = new_state[i + 1][j], new_state[i][j]
        elif direction == 'left':
            new_state[i][j], new_state[i][j - 1] = new_state[i][j - 1], new_state[i][j]
        elif direction == 'right':
            new_state[i][j], new_state[i][j + 1] = new_state[i][j + 1], new_state[i][j]

        return new_state

    def get_possible_moves(self, state):
        moves = []
        i, j = self.find_blank(state)

        if i > 0:
            moves.append('up')
        if i < 2:
            moves.append('down')
        if j > 0:
            moves.append('left')
        if j < 2:
            moves.append('right')

        return moves

    def solve(self):
        open_list = [(self.initial_state, [])]
        closed_list = []

        while open_list:
            current_state, path = open_list.pop(0)
            closed_list.append(current_state)

            if current_state == self.goal_state:
                return path

            for move in self.get_possible_moves(current_state):
                new_state = self.move(current_state, move)
                if new_state not in closed_list:
                    open_list.append((new_state, path + [move]))

        return None",COTFewShot,"```python
class EightPuzzle:
    def __init__(self, initial_state):
        self.initial_state = initial_state
        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

    def find_blank(self, state):
        for i in range(3):
            for j in range(3):
                if state[i][j] == 0:
                    return i, j

    def move(self, state, direction):
        i, j = self.find_blank(state)
        new_state = [row[:] for row in state]
        if direction == 'up' and i > 0:
            new_state[i][j], new_state[i-1][j] = new_state[i-1][j], new_state[i][j]
        elif direction == 'down' and i < 2:
            new_state[i][j], new_state[i+1][j] = new_state[i+1][j], new_state[i][j]
        elif direction == 'left' and j > 0:
            new_state[i][j], new_state[i][j-1] = new_state[i][j-1], new_state[i][j]
        elif direction == 'right' and j < 2:
            new_state[i][j], new_state[i][j+1] = new_state[i][j+1], new_state[i][j]
        return new_state

    def get_possible_moves(self, state):
        i, j = self.find_blank(state)
        moves = []
        if i > 0:
            moves.append('up')
        if i < 2:
            moves.append('down')
        if j > 0:
            moves.append('left')
        if j < 2:
            moves.append('right')
        return moves

    def solve(self):
        from collections import deque
        open_list = deque([(self.initial_state, [])])
        visited = set()
        while open_list:
            current_state, path = open_list.popleft()
            if current_state == self.goal_state:
                return path
            visited.add(tuple(map(tuple, current_state)))
            for move in self.get_possible_moves(current_state):
                new_state = self.move(current_state, move)
                if tuple(map(tuple, new_state)) not in visited:
                    open_list.append((new_state, path + [move]))
        return None
```",0.572972973,0.616455491,0.806818182,0.71,0.755319144,0.704402516,0.666666667,0.685015286,0.806818182,0.71,0.755319144,,,,,,,,,,,,
GPT,36,"from datetime import datetime

class EmailClient:
    def __init__(self, addr, capacity) -> None:
        self.addr = addr
        self.capacity = capacity
        self.inbox = []
    
    def send_to(self, recv, content, size):
        if not recv.is_full_with_one_more_email(size):
            timestamp = datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
            email = {
                ""sender"": self.addr,
                ""receiver"": recv.addr,
                ""content"": content,
                ""size"": size,
                ""time"": timestamp,
                ""state"": ""unread""
            }
            recv.inbox.append(email)
            return True
        else:
            self.clear_inbox(size)
            return False
    
    def fetch(self):
        if len(self.inbox) == 0:
            return None
        for i in range(len(self.inbox)):
            if self.inbox[i]['state'] == ""unread"":
                self.inbox[i]['state'] = ""read""
                return self.inbox[i]
        return None

    def is_full_with_one_more_email(self, size):
        occupied_size = self.get_occupied_size()
        return True if occupied_size + size > self.capacity else False
        
    def get_occupied_size(self):
        occupied_size = 0
        for email in self.inbox:
            occupied_size += email[""size""]
        return occupied_size

    def clear_inbox(self, size):
        if len(self.addr) == 0:
            return
        freed_space = 0
        while freed_space < size and self.inbox:
            email = self.inbox[0]
            freed_space += email['size']
            del self.inbox[0]",COTFewShot,"```python
from datetime import datetime

class EmailClient:
    def __init__(self, addr, capacity):
        self.addr = addr
        self.capacity = capacity
        self.inbox = []

    def send_to(self, recv, content, size):
        if recv.is_full_with_one_more_email(size):
            return False
        email = {
            'sender': self.addr,
            'receiver': recv.addr,
            'content': content,
            'size': size,
            'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'state': 'unread'
        }
        recv.inbox.append(email)
        return True

    def fetch(self):
        for email in self.inbox:
            if email['state'] == 'unread':
                email['state'] = 'read'
                return email
        return None

    def is_full_with_one_more_email(self, size):
        return self.get_occupied_size() + size > self.capacity

    def get_occupied_size(self):
        return sum(email['size'] for email in self.inbox)

    def clear_inbox(self, size):
        while self.is_full_with_one_more_email(size):
            self.inbox.pop(0)
```",0.216051495,0.262764458,0.542168675,0.725806452,0.62068965,0.382978723,0.534653465,0.446280987,0.542168675,0.725806452,0.62068965,,,,,,,,,,,,
GPT,37,"class EncryptionUtils:
    def __init__(self, key):
        self.key = key

    def caesar_cipher(self, plaintext, shift):
        ciphertext = """"
        for char in plaintext:
            if char.isalpha():
                if char.isupper():
                    ascii_offset = 65
                else:
                    ascii_offset = 97
                shifted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)
                ciphertext += shifted_char
            else:
                ciphertext += char
        return ciphertext
    
    def vigenere_cipher(self, plain_text):
        encrypted_text = """"
        key_index = 0
        for char in plain_text:
            if char.isalpha():
                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')
                encrypted_char = chr((ord(char.lower()) - ord('a') + shift) % 26 + ord('a'))
                encrypted_text += encrypted_char.upper() if char.isupper() else encrypted_char
                key_index += 1
            else:
                encrypted_text += char
        return encrypted_text

    def rail_fence_cipher(self, plain_text, rails):
        fence = [['\n' for _ in range(len(plain_text))] for _ in range(rails)]
        direction = -1
        row, col = 0, 0

        for char in plain_text:
            if row == 0 or row == rails-1:
                direction = -direction

            fence[row][col] = char
            col += 1
            row += direction

        encrypted_text = ''
        for i in range(rails):
            for j in range(len(plain_text)):
                if fence[i][j] != '\n':
                    encrypted_text += fence[i][j]

        return encrypted_text",COTFewShot,"```python
class EncryptionUtils:
    def __init__(self, key):
        self.key = key

    def caesar_cipher(self, plaintext, shift):
        ciphertext = """"
        for char in plaintext:
            if char.isalpha():
                shift_amount = shift % 26
                shifted_char = chr((ord(char.lower()) - ord('a') + shift_amount) % 26 + ord('a'))
                if char.isupper():
                    shifted_char = shifted_char.upper()
                ciphertext += shifted_char
            else:
                ciphertext += char
        return ciphertext

    def vigenere_cipher(self, plaintext):
        ciphertext = """"
        key_length = len(self.key)
        key_as_int = [ord(i) for i in self.key]
        plaintext_int = [ord(i) for i in plaintext]
        for i in range(len(plaintext_int)):
            value = (plaintext_int[i] + key_as_int[i % key_length]) % 26
            ciphertext += chr(value + 65)
        return ciphertext

    def rail_fence_cipher(self, plain_text, rails):
        if rails == 1:
            return plain_text
        rail = ['' for _ in range(rails)]
        direction_down = False
        row = 0
        for char in plain_text:
            rail[row] += char
            if row == 0 or row == rails - 1:
                direction_down = not direction_down
            row += 1 if direction_down else -1
        return ''.join(rail)
```",0.285252951,0.352067246,0.62962963,0.6375,0.633540368,0.409722222,0.437037037,0.422939063,0.580246914,0.5875,0.583850927,,,,,,,,,,,,
GPT,38,"import openpyxl


class ExcelProcessor:
    def __init__(self):
        pass

    def read_excel(self, file_name):
        data = []
        try:
            workbook = openpyxl.load_workbook(file_name)
            sheet = workbook.active
            for row in sheet.iter_rows(values_only=True):
                data.append(row)
            workbook.close()
            return data
        except:
            return None

    def write_excel(self, data, file_name):
        try:
            workbook = openpyxl.Workbook()
            sheet = workbook.active
            for row in data:
                sheet.append(row)
            workbook.save(file_name)
            workbook.close()
            return 1
        except:
            return 0

    def process_excel_data(self, N, save_file_name):
        data = self.read_excel(save_file_name)
        if data is None or N >= len(data[0]):
            return 0
        new_data = []
        for row in data:
            new_row = list(row[:])
            if not str(row[N]).isdigit():
                new_row.append(str(row[N]).upper())
            else:
                new_row.append(row[N])
            new_data.append(new_row)
        new_file_name = save_file_name.split('.')[0] + '_process.xlsx'
        success = self.write_excel(new_data, new_file_name)
        return success, new_file_name",COTFewShot,"```python
import openpyxl

class ExcelProcessor:
    def __init__(self):
        pass

    def read_excel(self, file_name):
        try:
            workbook = openpyxl.load_workbook(file_name)
            sheet = workbook.active
            data = []
            for row in sheet.iter_rows(values_only=True):
                data.append(row)
            return data
        except:
            return None

    def write_excel(self, data, file_name):
        try:
            workbook = openpyxl.Workbook()
            sheet = workbook.active
            for row in data:
                sheet.append(row)
            workbook.save(file_name)
            return 1
        except:
            return 0

    def process_excel_data(self, N, save_file_name):
        try:
            data = self.read_excel(save_file_name)
            if data is None:
                return 0, save_file_name
            processed_data = []
            for row in data:
                if len(row) > N:
                    row = list(row)
                    row[N] = str(row[N]).upper()
                processed_data.append(row)
            return self.write_excel(processed_data, save_file_name), save_file_name
        except:
            return 0, save_file_name
```",0.530472397,0.570945126,0.621212121,0.759259259,0.683333328,0.555555556,0.639534884,0.59459459,0.621212121,0.759259259,0.683333328,,,,,,,,,,,,
GPT,39,"import re
from collections import deque
from decimal import Decimal


class ExpressionCalculator:
    def __init__(self):
        self.postfix_stack = deque()
        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]

    def calculate(self, expression):
        self.prepare(self.transform(expression))

        result_stack = deque()
        self.postfix_stack.reverse()

        while self.postfix_stack:
            current_op = self.postfix_stack.pop()
            if not self.is_operator(current_op):
                current_op = current_op.replace(""~"", ""-"")
                result_stack.append(current_op)
            else:
                second_value = result_stack.pop()
                first_value = result_stack.pop()

                first_value = first_value.replace(""~"", ""-"")
                second_value = second_value.replace(""~"", ""-"")

                temp_result = self._calculate(first_value, second_value, current_op)
                result_stack.append(str(temp_result))

        return float(eval(""*"".join(result_stack)))

    def prepare(self, expression):
        op_stack = deque([','])
        arr = list(expression)
        current_index = 0
        count = 0

        for i, current_op in enumerate(arr):
            if self.is_operator(current_op):
                if count > 0:
                    self.postfix_stack.append("""".join(arr[current_index: current_index + count]))
                peek_op = op_stack[-1]
                if current_op == ')':
                    while op_stack[-1] != '(':
                        self.postfix_stack.append(str(op_stack.pop()))
                    op_stack.pop()
                else:
                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):
                        self.postfix_stack.append(str(op_stack.pop()))
                        peek_op = op_stack[-1]
                    op_stack.append(current_op)

                count = 0
                current_index = i + 1
            else:
                count += 1

        if count > 1 or (count == 1 and not self.is_operator(arr[current_index])):
            self.postfix_stack.append("""".join(arr[current_index: current_index + count]))

        while op_stack[-1] != ',':
            self.postfix_stack.append(str(op_stack.pop()))

    @staticmethod
    def is_operator(c):
        return c in {'+', '-', '*', '/', '(', ')', '%'}

    def compare(self, cur, peek):
        if cur == '%':
            cur = '/'
        if peek == '%':
            peek = '/'
        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]

    @staticmethod
    def _calculate(first_value, second_value, current_op):
        if current_op == '+':
            return Decimal(first_value) + Decimal(second_value)
        elif current_op == '-':
            return Decimal(first_value) - Decimal(second_value)
        elif current_op == '*':
            return Decimal(first_value) * Decimal(second_value)
        elif current_op == '/':
            return Decimal(first_value) / Decimal(second_value)
        elif current_op == '%':
            return Decimal(first_value) % Decimal(second_value)
        else:
            raise ValueError(""Unexpected operator: {}"".format(current_op))

    @staticmethod
    def transform(expression):
        expression = re.sub(r""\s+"", """", expression)
        expression = re.sub(r""=$"", """", expression)
        arr = list(expression)

        for i, c in enumerate(arr):
            if c == '-':
                if i == 0:
                    arr[i] = '~'
                else:
                    prev_c = arr[i - 1]
                    if prev_c in {'+', '-', '*', '/', '(', 'E', 'e'}:
                        arr[i] = '~'

        if arr[0] == '~' and (len(arr) > 1 and arr[1] == '('):
            arr[0] = '-'
            return ""0"" + """".join(arr)
        else:
            return """".join(arr)",COTFewShot,"```python
import re
from collections import deque
from decimal import Decimal


class ExpressionCalculator:
    def __init__(self):
        self.postfix_stack = deque()
        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]

    def calculate(self, expression):
        self.prepare(expression)
        calc_stack = deque()
        while self.postfix_stack:
            token = self.postfix_stack.popleft()
            if not self.is_operator(token):
                calc_stack.append(Decimal(token))
            else:
                second_value = calc_stack.pop()
                first_value = calc_stack.pop()
                result = self._calculate(first_value, second_value, token)
                calc_stack.append(result)
        return float(calc_stack.pop())

    def prepare(self, expression):
        expression = self.transform(expression)
        operator_stack = deque()
        i = 0
        while i < len(expression):
            if expression[i].isdigit() or expression[i] == '.':
                j = i
                while j < len(expression) and (expression[j].isdigit() or expression[j] == '.'):
                    j += 1
                self.postfix_stack.append(expression[i:j])
                i = j
            elif self.is_operator(expression[i]):
                while (operator_stack and operator_stack[-1] != '(' and
                       self.compare(expression[i], operator_stack[-1])):
                    self.postfix_stack.append(operator_stack.pop())
                operator_stack.append(expression[i])
                i += 1
            elif expression[i] == '(':
                operator_stack.append(expression[i])
                i += 1
            elif expression[i] == ')':
                while operator_stack and operator_stack[-1] != '(':
                    self.postfix_stack.append(operator_stack.pop())
                operator_stack.pop()
                i += 1

        while operator_stack:
            self.postfix_stack.append(operator_stack.pop())

    @staticmethod
    def is_operator(c):
        return c in {'+', '-', '*', '/', '(', ')', '%'}

    def compare(self, cur, peek):
        cur_priority = self.operat_priority['+-*/()'.index(cur)]
        peek_priority = self.operat_priority['+-*/()'.index(peek)]
        return cur_priority <= peek_priority

    @staticmethod
    def _calculate(first_value, second_value, current_op):
        if current_op == '+':
            return first_value + second_value
        elif current_op == '-':
            return first_value - second_value
        elif current_op == '*':
            return first_value * second_value
        elif current_op == '/':
            return first_value / second_value
        elif current_op == '%':
            return first_value % second_value

    @staticmethod
    def transform(expression):
        return re.sub(r'\s+', '', expression)
```",0.197610907,0.240624327,0.530612245,0.644628099,0.582089547,0.309027778,0.425837321,0.358148888,0.523809524,0.636363636,0.574626861,,,,,,,,,,,,
GPT,3,"import itertools


class ArrangementCalculator:
    def __init__(self, datas):
        self.datas = datas

    @staticmethod
    def count(n, m=None):
        if m is None or n == m:
            return ArrangementCalculator.factorial(n)
        else:
            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)

    @staticmethod
    def count_all(n):
        total = 0
        for i in range(1, n + 1):
            total += ArrangementCalculator.count(n, i)
        return total

    def select(self, m=None):
        if m is None:
            m = len(self.datas)
        result = []
        for permutation in itertools.permutations(self.datas, m):
            result.append(list(permutation))
        return result

    def select_all(self):
        result = []
        for i in range(1, len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    @staticmethod
    def factorial(n):
        result = 1
        for i in range(2, n + 1):
            result *= i
        return result",COTFewShot,"```python
class ArrangementCalculator:
    def __init__(self, datas):
        self.datas = datas

    @staticmethod
    def count(n, m=None):
        if m is None:
            m = n
        return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)

    @staticmethod
    def count_all(n):
        count = 0
        for i in range(1, n + 1):
            count += ArrangementCalculator.count(n, i)
        return count

    def select(self, m=None):
        if m is None:
            m = len(self.datas)
        return self._permute(self.datas, m)

    def select_all(self):
        all_selections = []
        for i in range(1, len(self.datas) + 1):
            all_selections.extend(self._permute(self.datas, i))
        return all_selections

    @staticmethod
    def factorial(n):
        if n == 0:
            return 1
        result = 1
        for i in range(1, n + 1):
            result *= i
        return result

    def _permute(self, elements, m):
        if m == 0:
            return [[]]
        permutations = []
        for i in range(len(elements)):
            elem = elements[i]
            rest_elems = elements[:i] + elements[i+1:]
            for p in self._permute(rest_elems, m - 1):
                permutations.append([elem] + p)
        return permutations
```",0.425373134,0.46560528,0.793103448,0.686567164,0.735999995,0.641304348,0.487603306,0.553990605,0.775862069,0.671641791,0.719999995,,,,,,,,,,,,
GPT,40,"class FitnessTracker:
    def __init__(self, height, weight, age, sex) -> None:
        self.height = height
        self.weight = weight
        self.age = age
        self.sex = sex
        self.BMI_std = [
            {""male"": [20, 25]},
            {""female"": [19, 24]}
        ]

    def get_BMI(self):
        return self.weight / self.height ** 2

    def condition_judge(self):
        BMI = self.get_BMI()
        if self.sex == ""male"":
            BMI_range = self.BMI_std[0][""male""]
        else:
            BMI_range = self.BMI_std[1][""female""]
        if BMI > BMI_range[1]:
            # too fat
            return 1
        elif BMI < BMI_range[0]:
            # too thin
            return -1
        else:
            # normal
            return 0

    def calculate_calorie_intake(self):
        if self.sex == ""male"":
            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5
        else:
            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161
        if self.condition_judge() == 1:
            calorie_intake = BMR * 1.2  # Sedentary lifestyle
        elif self.condition_judge() == -1:
            calorie_intake = BMR * 1.6  # Active lifestyle
        else:
            calorie_intake = BMR * 1.4  # Moderate lifestyle
        return calorie_intake",COTFewShot,"```python
class FitnessTracker:
    def __init__(self, height, weight, age, sex):
        self.height = height
        self.weight = weight
        self.age = age
        self.sex = sex
        self.BMI_std = {
            ""male"": [20, 25],
            ""female"": [19, 24]
        }

    def get_BMI(self):
        return self.weight / (self.height ** 2)

    def condition_judge(self):
        BMI = self.get_BMI()
        if self.sex not in self.BMI_std:
            return None
        lower, upper = self.BMI_std[self.sex]
        if BMI < lower:
            return -1
        elif BMI > upper:
            return 1
        else:
            return 0

    def calculate_calorie_intake(self):
        if self.sex == ""male"":
            BMR = 10 * self.weight + 6.25 * self.height * 100 - 5 * self.age + 5
        elif self.sex == ""female"":
            BMR = 10 * self.weight + 6.25 * self.height * 100 - 5 * self.age - 161
        else:
            return None

        condition = self.condition_judge()
        if condition == 1:
            return BMR * 1.2
        elif condition == -1:
            return BMR * 1.6
        elif condition == 0:
            return BMR * 1.4
        else:
            return None
```",0.389288766,0.463055246,0.666666667,0.676056338,0.671328666,0.545454545,0.558139535,0.551724133,0.625,0.633802817,0.629370624,,,,,,,,,,,,
GPT,41,"class GomokuGame:
    def __init__(self, board_size):
        self.board_size = board_size
        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        return False

    def check_winner(self):
        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]
        for row in range(self.board_size):
            for col in range(self.board_size):
                if self.board[row][col] != ' ':
                    for direction in directions:
                        if self._check_five_in_a_row(row, col, direction):
                            return self.board[row][col]
        return None

    def _check_five_in_a_row(self, row, col, direction):
        dx, dy = direction
        count = 1
        symbol = self.board[row][col]
        for i in range(1, 5):
            new_row = row + dx * i
            new_col = col + dy * i
            if not (0 <= new_row < self.board_size and 0 <= new_col < self.board_size):
                return False
            if self.board[new_row][new_col] != symbol:
                return False
            count += 1
        return count == 5",COTFewShot,"```python
class GomokuGame:
    def __init__(self, board_size):
        self.board_size = board_size
        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if 0 <= row < self.board_size and 0 <= col < self.board_size and self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        return False

    def check_winner(self):
        for row in range(self.board_size):
            for col in range(self.board_size):
                if self.board[row][col] != ' ':
                    if self._check_five_in_a_row(row, col, (0, 1)) or \
                       self._check_five_in_a_row(row, col, (1, 0)) or \
                       self._check_five_in_a_row(row, col, (1, 1)) or \
                       self._check_five_in_a_row(row, col, (1, -1)):
                        return self.board[row][col]
        return None

    def _check_five_in_a_row(self, row, col, direction):
        dx, dy = direction
        count = 0
        player = self.board[row][col]
        for i in range(5):
            if 0 <= row < self.board_size and 0 <= col < self.board_size and self.board[row][col] == player:
                count += 1
                row += dx
                col += dy
            else:
                break
        return count == 5
```",0.526315789,0.563679646,0.757142857,0.803030303,0.77941176,0.627737226,0.699186992,0.661538457,0.757142857,0.803030303,0.77941176,,,,,,,,,,,,
GPT,42,"class Hotel:
    def __init__(self, name, rooms):
        self.name = name
        self.available_rooms = rooms
        # available_rooms = {room_type1: room_number1, room_type2: room_number2, ...}
        # available_rooms = {'single': 5, 'double': 3}
        self.booked_rooms = {}
        # booked_rooms = {room_type1: {name1: room_number1, name2: room_number2, ...}, room_type2: {...}, ...}
        # booked_rooms = {'single': {'name1': 2, 'name2':1}, 'double': {}}

    def book_room(self, room_type, room_number, name):
        # Check if there are any rooms of the specified type available
        if room_type not in self.available_rooms.keys():
            return False

        if room_number <= self.available_rooms[room_type]:
            # Book the room by adding it to the booked_rooms dictionary
            if room_type not in self.booked_rooms.keys():
                self.booked_rooms[room_type] = {}
            self.booked_rooms[room_type][name] = room_number
            self.available_rooms[room_type] -= room_number
            return ""Success!""
        elif self.available_rooms[room_type] != 0:
            return self.available_rooms[room_type]
        else:
            return False

    def check_in(self, room_type, room_number, name):
        # Check if the room of the specified type and number is booked
        if room_type not in self.booked_rooms.keys():
            return False
        if name in self.booked_rooms[room_type]:
            if room_number > self.booked_rooms[room_type][name]:
                return False
            elif room_number == self.booked_rooms[room_type][name]:
                # Check in the room by removing it from the booked_rooms dictionary
                self.booked_rooms[room_type].pop(name)
            else:
                self.booked_rooms[room_type][name] -= room_number


    def check_out(self, room_type, room_number):
        if room_type in self.available_rooms:
            self.available_rooms[room_type] += room_number
        else:
            self.available_rooms[room_type] = room_number

    def get_available_rooms(self, room_type):
        return self.available_rooms[room_type]",COTFewShot,"```python
class Hotel:
    def __init__(self, name, rooms):
        self.name = name
        self.available_rooms = rooms
        self.booked_rooms = {}

    def book_room(self, room_type, room_number, name):
        if room_type not in self.available_rooms or self.available_rooms[room_type] == 0:
            return False
        if self.available_rooms[room_type] >= room_number:
            self.available_rooms[room_type] -= room_number
            if room_type not in self.booked_rooms:
                self.booked_rooms[room_type] = {}
            if name in self.booked_rooms[room_type]:
                self.booked_rooms[room_type][name] += room_number
            else:
                self.booked_rooms[room_type][name] = room_number
            return 'Success!'
        else:
            return self.available_rooms[room_type]

    def check_in(self, room_type, room_number, name):
        if room_type not in self.booked_rooms or name not in self.booked_rooms[room_type]:
            return False
        if self.booked_rooms[room_type][name] < room_number:
            return False
        self.booked_rooms[room_type][name] -= room_number
        if self.booked_rooms[room_type][name] == 0:
            del self.booked_rooms[room_type][name]
        return True

    def check_out(self, room_type, room_number):
        if room_type in self.available_rooms:
            self.available_rooms[room_type] += room_number
        else:
            self.available_rooms[room_type] = room_number

    def get_available_rooms(self, room_type):
        return self.available_rooms.get(room_type, 0)
```",0.224021121,0.262414114,0.443181818,0.764705882,0.561151074,0.379746835,0.612244898,0.468749995,0.443181818,0.764705882,0.561151074,,,,,,,,,,,,
GPT,43,"class HRManagementSystem:
    def __init__(self):
        self.employees = {}

    def add_employee(self, employee_id, name, position, department, salary):
        if employee_id in self.employees:
            return False
        else:
            self.employees[employee_id] = {
                'name': name,
                'position': position,
                'department': department,
                'salary': salary
            }
            return True

    def remove_employee(self, employee_id):
        if employee_id in self.employees:
            del self.employees[employee_id]
            return True
        else:
            return False

    def update_employee(self, employee_id: int, employee_info: dict):
        employee = self.get_employee(employee_id)
        if employee == False:
            return False
        else:
            for key, value in employee_info.items():
                if key not in employee:
                    return False
            for key, value in employee_info.items():
                employee[key] = value
            return True

    def get_employee(self, employee_id):
        if employee_id in self.employees:
            return self.employees[employee_id]
        else:
            return False

    def list_employees(self):
        employee_data = {}
        if self.employees:
            for employee_id, employee_info in self.employees.items():
                employee_details = {}
                employee_details[""employee_ID""] = employee_id
                for key, value in employee_info.items():
                    employee_details[key] = value
                employee_data[employee_id] = employee_details
        return employee_data",COTFewShot,"```python
class HRManagementSystem:
    def __init__(self):
        self.employees = {}

    def add_employee(self, employee_id, name, position, department, salary):
        if employee_id in self.employees:
            return False
        self.employees[employee_id] = {
            'name': name,
            'position': position,
            'department': department,
            'salary': salary
        }
        return True

    def remove_employee(self, employee_id):
        if employee_id not in self.employees:
            return False
        del self.employees[employee_id]
        return True

    def update_employee(self, employee_id, employee_info):
        if employee_id not in self.employees:
            return False
        self.employees[employee_id] = employee_info
        return True

    def get_employee(self, employee_id):
        return self.employees.get(employee_id, False)

    def list_employees(self):
        return self.employees
```",0.272254131,0.317956577,0.637931034,0.880952381,0.739999995,0.447619048,0.758064516,0.562874247,0.637931034,0.880952381,0.739999995,,,,,,,,,,,,
GPT,44,"import re
import string
import gensim
from bs4 import BeautifulSoup


class HtmlUtil:

    def __init__(self):
        self.SPACE_MARK = '-SPACE-'
        self.JSON_MARK = '-JSON-'
        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'
        self.URL_MARK = '-URL-'
        self.NUMBER_MARK = '-NUMBER-'
        self.TRACE_MARK = '-TRACE-'
        self.COMMAND_MARK = '-COMMAND-'
        self.COMMENT_MARK = '-COMMENT-'
        self.CODE_MARK = '-CODE-'

    @staticmethod
    def __format_line_feed(text):
        return re.sub(re.compile(r'\n+'), '\n', text)

    def format_line_html_text(self, html_text):
        if html_text is None or len(html_text) == 0:
            return ''
        soup = BeautifulSoup(html_text, 'lxml')

        code_tag = soup.find_all(name=['pre', 'blockquote'])
        for tag in code_tag:
            tag.string = self.CODE_MARK

        ul_ol_group = soup.find_all(name=['ul', 'ol'])
        for ul_ol_item in ul_ol_group:
            li_group = ul_ol_item.find_all('li')
            for li_item in li_group:
                li_item_text = li_item.get_text().strip()
                if len(li_item_text) == 0:
                    continue
                if li_item_text[-1] in string.punctuation:
                    li_item.string = '[{0}]{1}'.format('-', li_item_text)
                    continue
                li_item.string = '[{0}]{1}.'.format('-', li_item_text)

        p_group = soup.find_all(name=['p'])
        for p_item in p_group:
            p_item_text = p_item.get_text().strip()
            if p_item_text:
                if p_item_text[-1] in string.punctuation:
                    p_item.string = p_item_text
                    continue
                next_sibling = p_item.find_next_sibling()
                if next_sibling and self.CODE_MARK in next_sibling.get_text():
                    p_item.string = p_item_text + ':'
                    continue
                p_item.string = p_item_text + '.'

        clean_text = gensim.utils.decode_htmlentities(soup.get_text())
        return self.__format_line_feed(clean_text)

    def extract_code_from_html_text(self, html_text):
        text_with_code_tag = self.format_line_html_text(html_text)

        if self.CODE_MARK not in text_with_code_tag:
            return []

        code_index_start = 0
        soup = BeautifulSoup(html_text, 'lxml')
        code_tag = soup.find_all(name=['pre', 'blockquote'])
        code_count = text_with_code_tag.count(self.CODE_MARK)
        code_list = []
        for code_index in range(code_index_start, code_index_start + code_count):
            code = code_tag[code_index].get_text()
            if code:
                code_list.append(code)
        return code_list",COTFewShot,"```python
import re
from bs4 import BeautifulSoup


class HtmlUtil:
    def __init__(self):
        self.SPACE_MARK = '-SPACE-'
        self.JSON_MARK = '-JSON-'
        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'
        self.URL_MARK = '-URL-'
        self.NUMBER_MARK = '-NUMBER-'
        self.TRACE_MARK = '-TRACE-'
        self.COMMAND_MARK = '-COMMAND-'
        self.COMMENT_MARK = '-COMMENT-'
        self.CODE_MARK = '-CODE-'

    @staticmethod
    def __format_line_feed(text):
        return re.sub(r'\n+', '\n', text)

    def format_line_html_text(self, html_text):
        soup = BeautifulSoup(html_text, 'html.parser')
        for code in soup.find_all(['pre', 'code']):
            code.replace_with(self.CODE_MARK)
        text = soup.get_text()
        return self.__format_line_feed(text)

    def extract_code_from_html_text(self, html_text):
        soup = BeautifulSoup(html_text, 'html.parser')
        codes = [code.get_text() for code in soup.find_all(['pre', 'code'])]
        return codes
```",0.122202607,0.134376077,0.376068376,0.771929825,0.505747122,0.274418605,0.655555556,0.386885242,0.376068376,0.771929825,0.505747122,,,,,,,,,,,,
GPT,45,"from PIL import Image, ImageEnhance, ImageChops


class ImageProcessor:
    def __init__(self):
        self.image = None

    def load_image(self, image_path):
        self.image = Image.open(image_path)

    def save_image(self, save_path):
        if self.image:
            self.image.save(save_path)

    def resize_image(self, width, height):
        if self.image:
            self.image = self.image.resize((width, height))

    def rotate_image(self, degrees):
        if self.image:
            self.image = self.image.rotate(degrees)

    def adjust_brightness(self, factor):
        if self.image:
            enhancer = ImageEnhance.Brightness(self.image)
            self.image = enhancer.enhance(factor)",COTFewShot,"```python
from PIL import Image, ImageEnhance

class ImageProcessor:
    def __init__(self):
        self.image = None

    def load_image(self, image_path):
        self.image = Image.open(image_path)

    def save_image(self, save_path):
        if self.image:
            self.image.save(save_path)

    def resize_image(self, width, height):
        if self.image:
            self.image = self.image.resize((width, height))

    def rotate_image(self, degrees):
        if self.image:
            self.image = self.image.rotate(degrees)

    def adjust_brightness(self, factor):
        if self.image:
            enhancer = ImageEnhance.Brightness(self.image)
            self.image = enhancer.enhance(factor)
```",0.905660377,0.915132941,0.947368421,0.947368421,0.947368416,0.942307692,0.924528302,0.933333328,0.947368421,0.947368421,0.947368416,,,,,,,,,,,,
GPT,46,"class Interpolation:
    def __init__(self):
        pass

    @staticmethod
    def interpolate_1d(x, y, x_interp):
        y_interp = []
        for xi in x_interp:
            for i in range(len(x) - 1):
                if x[i] <= xi <= x[i+1]:
                    yi = y[i] + (y[i+1] - y[i]) * (xi - x[i]) / (x[i+1] - x[i])
                    y_interp.append(yi)
                    break
        return y_interp
    
    @staticmethod
    def interpolate_2d(x, y, z, x_interp, y_interp):
        z_interp = []
        for xi, yi in zip(x_interp, y_interp):
            for i in range(len(x) - 1):
                if x[i] <= xi <= x[i+1]:
                    for j in range(len(y) - 1):
                        if y[j] <= yi <= y[j+1]:
                            z00 = z[i][j]
                            z01 = z[i][j+1]
                            z10 = z[i+1][j]
                            z11 = z[i+1][j+1]
                            zi = (z00 * (x[i+1] - xi) * (y[j+1] - yi) +
                                  z10 * (xi - x[i]) * (y[j+1] - yi) +
                                  z01 * (x[i+1] - xi) * (yi - y[j]) +
                                  z11 * (xi - x[i]) * (yi - y[j])) / ((x[i+1] - x[i]) * (y[j+1] - y[j]))
                            z_interp.append(zi)
                            break
                    break
        return z_interp",COTFewShot,"```python
class Interpolation:
    def __init__(self):
        pass

    @staticmethod
    def interpolate_1d(x, y, x_interp):
        y_interp = []
        for xi in x_interp:
            for i in range(len(x) - 1):
                if x[i] <= xi <= x[i + 1]:
                    yi = y[i] + (y[i + 1] - y[i]) * (xi - x[i]) / (x[i + 1] - x[i])
                    y_interp.append(yi)
                    break
        return y_interp

    @staticmethod
    def interpolate_2d(x, y, z, x_interp, y_interp):
        z_interp = []
        for xi, yi in zip(x_interp, y_interp):
            for i in range(len(x) - 1):
                for j in range(len(y) - 1):
                    if x[i] <= xi <= x[i + 1] and y[j] <= yi <= y[j + 1]:
                        z11 = z[i][j]
                        z12 = z[i][j + 1]
                        z21 = z[i + 1][j]
                        z22 = z[i + 1][j + 1]
                        fxy1 = z11 + (z21 - z11) * (xi - x[i]) / (x[i + 1] - x[i])
                        fxy2 = z12 + (z22 - z12) * (xi - x[i]) / (x[i + 1] - x[i])
                        zi = fxy1 + (fxy2 - fxy1) * (yi - y[j]) / (y[j + 1] - y[j])
                        z_interp.append(zi)
                        break
        return z_interp
```",0.445086705,0.49861849,0.757575758,0.666666667,0.709219853,0.622807018,0.550387597,0.584362135,0.712121212,0.626666667,0.666666662,,,,,,,,,,,,
GPT,47,"class IPAddress:
    def __init__(self, ip_address):
        self.ip_address = ip_address

    def is_valid(self):
        octets = self.ip_address.split('.')
        if len(octets) != 4:
            return False
        for octet in octets:
            if not octet.isdigit() or int(octet) < 0 or int(octet) > 255:
                return False
        return True

    def get_octets(self):
        if self.is_valid():
            return self.ip_address.split('.')
        else:
            return []

    def get_binary(self):
        if self.is_valid():
            binary_octets = []
            for octet in self.get_octets():
                binary_octets.append(format(int(octet), '08b'))
            return '.'.join(binary_octets)
        else:
            return ''",COTFewShot,"```python
class IPAddress:
    def __init__(self, ip_address):
        self.ip_address = ip_address

    def is_valid(self):
        octets = self.ip_address.split('.')
        if len(octets) != 4:
            return False
        for octet in octets:
            if not octet.isdigit() or not 0 <= int(octet) <= 255:
                return False
        return True

    def get_octets(self):
        if self.is_valid():
            return self.ip_address.split('.')
        return []

    def get_binary(self):
        if self.is_valid():
            octets = self.get_octets()
            return '.'.join(format(int(octet), '08b') for octet in octets)
        return ''
```",0.619366406,0.665464422,0.813953488,0.833333333,0.823529407,0.701492537,0.734375,0.717557247,0.813953488,0.833333333,0.823529407,,,,,,,,,,,,
GPT,48,"import socket


class IpUtil:

    @staticmethod
    def is_valid_ipv4(ip_address):
        try:
            socket.inet_pton(socket.AF_INET, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def is_valid_ipv6(ip_address):
        try:
            socket.inet_pton(socket.AF_INET6, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def get_hostname(ip_address):
        try:
            hostname = socket.gethostbyaddr(ip_address)[0]
            return hostname
        except socket.herror:
            return None",COTFewShot,"```python
import socket


class IpUtil:
    @staticmethod
    def is_valid_ipv4(ip_address):
        try:
            socket.inet_pton(socket.AF_INET, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def is_valid_ipv6(ip_address):
        try:
            socket.inet_pton(socket.AF_INET6, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def get_hostname(ip_address):
        try:
            return socket.gethostbyaddr(ip_address)[0]
        except socket.herror:
            return None

    @staticmethod
    def get_binary(ip_address):
        try:
            if IpUtil.is_valid_ipv4(ip_address):
                return bin(int.from_bytes(socket.inet_pton(socket.AF_INET, ip_address), 'big'))
            elif IpUtil.is_valid_ipv6(ip_address):
                return bin(int.from_bytes(socket.inet_pton(socket.AF_INET6, ip_address), 'big'))
            else:
                return None
        except socket.error:
            return None
```",0.524590164,0.542725348,0.916666667,0.666666667,0.77192982,0.828571429,0.537037037,0.651685388,0.916666667,0.666666667,0.77192982,,,,,,,,,,,,
GPT,49,"class JobMarketplace:
    def __init__(self):
        self.job_listings = []
        self.resumes = []

    def post_job(self, job_title, company, requirements):
        # requirements = ['requirement1', 'requirement2']
        job = {""job_title"": job_title, ""company"": company, ""requirements"": requirements}
        self.job_listings.append(job)

    def remove_job(self, job):
        self.job_listings.remove(job)

    def submit_resume(self, name, skills, experience):
        resume = {""name"": name, ""skills"": skills, ""experience"": experience}
        self.resumes.append(resume)

    def withdraw_resume(self, resume):
        self.resumes.remove(resume)

    def search_jobs(self, criteria):
        matching_jobs = []
        for job_listing in self.job_listings:
            if criteria.lower() in job_listing[""job_title""].lower() or criteria.lower() in [r.lower() for r in job_listing[""requirements""]]:
                matching_jobs.append(job_listing)
        return matching_jobs

    def get_job_applicants(self, job):
        applicants = []
        for resume in self.resumes:
            if self.matches_requirements(resume, job[""requirements""]):
                applicants.append(resume)
        return applicants

    @staticmethod
    def matches_requirements(resume, requirements):
        for skill in resume[""skills""]:
            if skill not in requirements:
                return False
        return True",COTFewShot,"```python
class JobMarketplace:
    def __init__(self):
        self.job_listings = []
        self.resumes = []

    def post_job(self, job_title, company, requirements):
        job = {
            'job_title': job_title,
            'company': company,
            'requirements': requirements
        }
        self.job_listings.append(job)

    def remove_job(self, job):
        if job in self.job_listings:
            self.job_listings.remove(job)

    def submit_resume(self, name, skills, experience):
        resume = {
            'name': name,
            'skills': skills,
            'experience': experience
        }
        self.resumes.append(resume)

    def withdraw_resume(self, resume):
        if resume in self.resumes:
            self.resumes.remove(resume)

    def search_jobs(self, criteria):
        return [job for job in self.job_listings if criteria in job['requirements']]

    def get_job_applicants(self, job):
        return [resume for resume in self.resumes if self.matches_requirements(job, resume)]

    def matches_requirements(self, job, resume):
        return all(req in resume['skills'] for req in job['requirements'])
```",0.260439752,0.315228168,0.558823529,0.633333333,0.593749995,0.387931034,0.463917526,0.422535206,0.544117647,0.616666667,0.578124995,,,,,,,,,,,,
GPT,4,"class AssessmentSystem:
    def __init__(self):
        self.students = {}

    def add_student(self, name, grade, major):
        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}

    def add_course_score(self, name, course, score):
        if name in self.students:
            self.students[name]['courses'][course] = score

    def get_gpa(self, name):
        if name in self.students and self.students[name]['courses']:
            return sum(self.students[name]['courses'].values()) / len(self.students[name]['courses'])
        else:
            return None

    def get_all_students_with_fail_course(self):
        students = []
        for name, student in self.students.items():
            for course, score in student['courses'].items():
                if score < 60:
                    students.append(name)
                    break
        return students

    def get_course_average(self, course):
        total = 0
        count = 0
        for student in self.students.values():
            if course in student['courses']:
                score = student['courses'][course]
                if score is not None:
                    total += score
                    count += 1
        return total / count if count > 0 else None

    def get_top_student(self):
        top_student = None
        top_gpa = 0
        for name, student in self.students.items():
            gpa = self.get_gpa(name)
            if gpa is not None and gpa > top_gpa:
                top_gpa = gpa
                top_student = name
        return top_student",COTFewShot,"```python
class AssessmentSystem:
    def __init__(self):
        self.students = {}

    def add_student(self, name, grade, major):
        self.students[name] = {
            'name': name,
            'grade': grade,
            'major': major,
            'courses': {}
        }

    def add_course_score(self, name, course, score):
        if name in self.students:
            self.students[name]['courses'][course] = score

    def get_gpa(self, name):
        if name in self.students:
            courses = self.students[name]['courses']
            if courses:
                return sum(courses.values()) / len(courses)
        return None

    def get_all_students_with_fail_course(self):
        failed_students = []
        for student in self.students.values():
            if any(score < 60 for score in student['courses'].values()):
                failed_students.append(student['name'])
        return failed_students

    def get_course_average(self, course):
        total_score = 0
        count = 0
        for student in self.students.values():
            if course in student['courses']:
                total_score += student['courses'][course]
                count += 1
        return total_score / count if count > 0 else None

    def get_top_student(self):
        top_student = None
        highest_gpa = 0
        for student in self.students.values():
            gpa = self.get_gpa(student['name'])
            if gpa is not None and gpa > highest_gpa:
                highest_gpa = gpa
                top_student = student['name']
        return top_student
```",0.47572248,0.540174819,0.780821918,0.75,0.765100666,0.6,0.636363636,0.617647054,0.767123288,0.736842105,0.751677847,,,,,,,,,,,,
GPT,50,"import json
import os


class JSONProcessor:
    def read_json(self, file_path):
        if not os.path.exists(file_path):
            return 0
        try:
            with open(file_path, 'r') as file:
                data = json.load(file)
            return data
        except:
            return -1

    def write_json(self, data, file_path):
        try:
            with open(file_path, 'w') as file:
                json.dump(data, file)
            return 1
        except:
            return -1

    def process_json(self, file_path, remove_key):
        data = self.read_json(file_path)
        if data == 0 or data == -1:
            return 0
        if remove_key in data:
            del data[remove_key]
            self.write_json(data, file_path)
            return 1
        else:
            return 0",COTFewShot,"```python
import json
import os

class JSONProcessor:
    def read_json(self, file_path):
        if not os.path.exists(file_path):
            return 0
        try:
            with open(file_path, 'r') as file:
                data = json.load(file)
            return data
        except:
            return -1

    def write_json(self, data, file_path):
        try:
            with open(file_path, 'w') as file:
                json.dump(data, file)
            return 1
        except:
            return -1

    def process_json(self, file_path, remove_key):
        data = self.read_json(file_path)
        if data == 0 or data == -1:
            return 0
        if remove_key in data:
            del data[remove_key]
            result = self.write_json(data, file_path)
            return result
        else:
            return 0
```",0.883116883,0.895821707,1,0.94,0.96907216,0.971014493,0.917808219,0.943661967,1,0.94,0.96907216,,,,,,,,,,,,
GPT,51,"import numpy as np


class KappaCalculator:

    @staticmethod
    def kappa(testData, k):
        dataMat = np.mat(testData)
        P0 = 0.0
        for i in range(k):
            P0 += dataMat[i, i] * 1.0
        xsum = np.sum(dataMat, axis=1)
        ysum = np.sum(dataMat, axis=0)
        sum = np.sum(dataMat)
        Pe = float(ysum * xsum) / sum / sum
        P0 = float(P0 / sum * 1.0)
        cohens_coefficient = float((P0 - Pe) / (1 - Pe))
        return cohens_coefficient

    @staticmethod
    def fleiss_kappa(testData, N, k, n):
        dataMat = np.mat(testData, float)
        oneMat = np.ones((k, 1))
        sum = 0.0
        P0 = 0.0
        for i in range(N):
            temp = 0.0
            for j in range(k):
                sum += dataMat[i, j]
                temp += 1.0 * dataMat[i, j] ** 2
            temp -= n
            temp /= (n - 1) * n
            P0 += temp
        P0 = 1.0 * P0 / N
        ysum = np.sum(dataMat, axis=0)
        for i in range(k):
            ysum[0, i] = (ysum[0, i] / sum) ** 2
        Pe = ysum * oneMat * 1.0
        ans = (P0 - Pe) / (1 - Pe)
        return ans[0, 0]",COTFewShot,"```python
import numpy as np

class KappaCalculator:
    @staticmethod
    def kappa(testData, k):
        testData = np.array(testData)
        num_raters = testData.shape[0]
        num_items = testData.shape[1]

        # Calculate the proportion of agreement
        p0 = np.sum(np.diag(testData)) / np.sum(testData)

        # Calculate the expected proportion of agreement by chance
        pe = np.sum(np.dot(np.sum(testData, axis=0), np.sum(testData, axis=1))) / (np.sum(testData) ** 2)

        # Calculate kappa
        kappa_value = (p0 - pe) / (1 - pe)
        return kappa_value

    @staticmethod
    def fleiss_kappa(testData, N, k, n):
        testData = np.array(testData)

        # Calculate proportion of ratings in each category
        p = np.sum(testData, axis=0) / (N * n)

        # Calculate the degree of agreement for each subject
        P = (np.sum(testData ** 2, axis=1) - n) / (n * (n - 1))

        # Calculate the mean of P
        Pbar = np.mean(P)

        # Calculate the mean of p squared
        PbarE = np.sum(p ** 2)

        # Calculate Fleiss' kappa
        kappa_value = (Pbar - PbarE) / (1 - PbarE)
        return kappa_value
```",0.086697087,0.119592416,0.375,0.341772152,0.357615889,0.130769231,0.134920635,0.132812495,0.361111111,0.329113924,0.344370856,,,,,,,,,,,,
GPT,52,"import nltk
from nltk.stem import WordNetLemmatizer
from nltk import pos_tag, word_tokenize
import string

nltk.download('averaged_perceptron_tagger')
nltk.download('punkt')
nltk.download('wordnet')


class Lemmatization:
    def __init__(self):
        self.lemmatizer = WordNetLemmatizer()

    def lemmatize_sentence(self, sentence):
        lemmatized_words = []
        sentence = self.remove_punctuation(sentence)
        words = word_tokenize(sentence)
        tagged_words = pos_tag(words)
        for word, tag in tagged_words:
            if tag.startswith('V'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='v')
            elif tag.startswith('J'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='a')
            elif tag.startswith('R'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='r')
            else:
                lemmatized_word = self.lemmatizer.lemmatize(word)
            lemmatized_words.append(lemmatized_word)
        return lemmatized_words

    def get_pos_tag(self, sentence):
        pos_tags = []
        sentence = self.remove_punctuation(sentence)
        words = word_tokenize(sentence)
        tagged_words = pos_tag(words)
        for tagged_word in tagged_words:
            pos_tags.append(tagged_word[1])
        return pos_tags

    def remove_punctuation(self, sentence):
        return sentence.translate(str.maketrans('', '', string.punctuation))",COTFewShot,"```python
import nltk
from nltk.stem import WordNetLemmatizer
from nltk import pos_tag, word_tokenize
import string

nltk.download('averaged_perceptron_tagger')
nltk.download('punkt')
nltk.download('wordnet')

class Lemmatization:
    def __init__(self):
        self.lemmatizer = WordNetLemmatizer()

    def lemmatize_sentence(self, sentence):
        sentence = self.remove_punctuation(sentence)
        words = word_tokenize(sentence)
        pos_tags = pos_tag(words)
        lemmatized_words = []
        for word, tag in pos_tags:
            pos = self.get_wordnet_pos(tag)
            if pos:
                lemmatized_words.append(self.lemmatizer.lemmatize(word, pos))
            else:
                lemmatized_words.append(word)
        return lemmatized_words

    def get_pos_tag(self, sentence):
        sentence = self.remove_punctuation(sentence)
        words = word_tokenize(sentence)
        pos_tags = pos_tag(words)
        return [tag for word, tag in pos_tags]

    def remove_punctuation(self, sentence):
        return sentence.translate(str.maketrans('', '', string.punctuation))

    def get_wordnet_pos(self, treebank_tag):
        if treebank_tag.startswith('J'):
            return nltk.corpus.wordnet.ADJ
        elif treebank_tag.startswith('V'):
            return nltk.corpus.wordnet.VERB
        elif treebank_tag.startswith('N'):
            return nltk.corpus.wordnet.NOUN
        elif treebank_tag.startswith('R'):
            return nltk.corpus.wordnet.ADV
        else:
            return None
```",0.421568627,0.479322997,0.824561404,0.68115942,0.746031741,0.615384615,0.518518519,0.562814065,0.824561404,0.68115942,0.746031741,,,,,,,,,,,,
GPT,53,"import re
import string


class LongestWord:

    def __init__(self):
        self.word_list = []

    def add_word(self, word):
        self.word_list.append(word)

    def find_longest_word(self, sentence):
        longest_word = """"
        sentence = sentence.lower()
        sentence = re.sub('[%s]' % re.escape(string.punctuation), '', sentence)
        sentence = re.split(' ', sentence)
        for word in sentence:
            if word in self.word_list and len(word) > len(longest_word):
                longest_word = word
        return longest_word",COTFewShot,"```python
import re
import string

class LongestWord:
    def __init__(self):
        self.word_list = []

    def add_word(self, word):
        self.word_list.append(word)

    def find_longest_word(self, sentence):
        words = re.findall(r'\b\w+\b', sentence)
        longest_word = ''
        for word in words:
            if word in self.word_list and len(word) > len(longest_word):
                longest_word = word
        return longest_word
```",0.54334513,0.582688399,0.710526316,0.818181818,0.760563375,0.611111111,0.75,0.673469383,0.710526316,0.818181818,0.760563375,,,,,,,,,,,,
GPT,54,"import random


class MahjongConnect:
    def __init__(self, BOARD_SIZE, ICONS):
        self.BOARD_SIZE = BOARD_SIZE
        self.ICONS = ICONS
        self.board = self.create_board()

    def create_board(self):
        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]
        return board

    def is_valid_move(self, pos1, pos2):
        x1, y1 = pos1
        x2, y2 = pos2

        # Check if positions are within the game board range
        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and 0 <= x2 < self.BOARD_SIZE[
            0] and 0 <= y2 <
                self.BOARD_SIZE[1]):
            return False

        # Check if the two positions are the same
        if pos1 == pos2:
            return False

        # Check if the two positions have the same icon
        if self.board[x1][y1] != self.board[x2][y2]:
            return False

        # Check if there is a valid path between the two positions
        if not self.has_path(pos1, pos2):
            return False

        return True

    def has_path(self, pos1, pos2):
        visited = set()
        stack = [pos1]

        while stack:
            current_pos = stack.pop()
            if current_pos == pos2:
                return True

            if current_pos in visited:
                continue

            visited.add(current_pos)
            x, y = current_pos

            # Check adjacent positions (up, down, left, right)
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                new_x, new_y = x + dx, y + dy
                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:
                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:
                        stack.append((new_x, new_y))

        return False

    def remove_icons(self, pos1, pos2):
        x1, y1 = pos1
        x2, y2 = pos2
        self.board[x1][y1] = ' '
        self.board[x2][y2] = ' '

    def is_game_over(self):
        for row in self.board:
            if any(icon != ' ' for icon in row):
                return False
        return True",COTFewShot,"```python
import random

class MahjongConnect:
    def __init__(self, BOARD_SIZE, ICONS):
        self.BOARD_SIZE = BOARD_SIZE
        self.ICONS = ICONS
        self.board = self.create_board()

    def create_board(self):
        rows, cols = self.BOARD_SIZE
        total_icons = rows * cols
        icons_needed = total_icons // 2
        icons_list = (self.ICONS * (icons_needed // len(self.ICONS) + 1))[:icons_needed] * 2
        random.shuffle(icons_list)
        return [icons_list[i * cols:(i + 1) * cols] for i in range(rows)]

    def is_valid_move(self, pos1, pos2):
        if pos1 == pos2:
            return False
        if not self.is_within_bounds(pos1) or not self.is_within_bounds(pos2):
            return False
        if self.board[pos1[0]][pos1[1]] != self.board[pos2[0]][pos2[1]]:
            return False
        if not self.has_path(pos1, pos2):
            return False
        return True

    def is_within_bounds(self, pos):
        return 0 <= pos[0] < self.BOARD_SIZE[0] and 0 <= pos[1] < self.BOARD_SIZE[1]

    def has_path(self, pos1, pos2):
        # This is a simplified placeholder for path checking logic
        return True

    def remove_icons(self, pos1, pos2):
        if self.is_valid_move(pos1, pos2):
            self.board[pos1[0]][pos1[1]] = ' '
            self.board[pos2[0]][pos2[1]] = ' '

    def is_game_over(self):
        return all(icon == ' ' for row in self.board for icon in row)
```",0.146048856,0.180097144,0.390243902,0.545454545,0.454976298,0.279279279,0.421768707,0.336043356,0.382113821,0.534090909,0.445497625,,,,,,,,,,,,
GPT,55,"class Manacher:
    def __init__(self, input_string) -> None:
        self.input_string = input_string

    def palindromic_length(self, center, diff, string):
        if (center - diff == -1 or center + diff == len(string)
                or string[center - diff] != string[center + diff]):
            return 0
        return 1 + self.palindromic_length(center, diff + 1, string)


    def palindromic_string(self):
        max_length = 0

        new_input_string = """"
        output_string = """"

        for i in self.input_string[:len(self.input_string) - 1]:
            new_input_string += i + ""|""
        new_input_string += self.input_string[-1]

        for i in range(len(new_input_string)):

            length =self.palindromic_length(i, 1, new_input_string)

            if max_length < length:
                max_length = length
                start = i

        for i in new_input_string[start - max_length:start + max_length + 1]:
            if i != ""|"":
                output_string += i

        return output_string",COTFewShot,"```python
class Manacher:
    def __init__(self, input_string):
        self.input_string = input_string

    def palindromic_length(self, center, diff, string):
        while center - diff >= 0 and center + diff < len(string) and string[center - diff] == string[center + diff]:
            diff += 1
        return diff - 1

    def palindromic_string(self):
        if not self.input_string:
            return """"

        # Transform the input string to avoid even/odd length issues
        string = '|' + '|'.join(self.input_string) + '|'
        n = len(string)
        P = [0] * n
        C = R = 0  # Center and right boundary of the current palindrome

        for i in range(n):
            mirror = 2 * C - i
            if i < R:
                P[i] = min(R - i, P[mirror])

            P[i] = self.palindromic_length(i, P[i] + 1, string)

            if i + P[i] > R:
                C, R = i, i + P[i]

        # Find the maximum element in P
        max_len, center_index = max((n, i) for i, n in enumerate(P))
        start = (center_index - max_len) // 2
        return self.input_string[start:start + max_len]
```",0.077419355,0.118939826,0.620689655,0.395604396,0.483221472,0.252427184,0.166666667,0.200772196,0.568965517,0.362637363,0.442953015,,,,,,,,,,,,
GPT,56,"class MetricsCalculator:
    def __init__(self):
        self.true_positives = 0
        self.false_positives = 0
        self.false_negatives = 0
        self.true_negatives = 0

    def update(self, predicted_labels, true_labels):
        for predicted, true in zip(predicted_labels, true_labels):
            if predicted == 1 and true == 1:
                self.true_positives += 1
            elif predicted == 1 and true == 0:
                self.false_positives += 1
            elif predicted == 0 and true == 1:
                self.false_negatives += 1
            elif predicted == 0 and true == 0:
                self.true_negatives += 1

    def precision(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        if self.true_positives + self.false_positives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_positives)

    def recall(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        if self.true_positives + self.false_negatives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_negatives)

    def f1_score(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        precision = self.precision(predicted_labels, true_labels)
        recall = self.recall(predicted_labels, true_labels)
        if precision + recall == 0.0:
            return 0.0
        return (2 * precision * recall) / (precision + recall)

    def accuracy(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives
        if total == 0:
            return 0.0
        return (self.true_positives + self.true_negatives) / total",COTFewShot,"```python
class MetricsCalculator:
    def __init__(self):
        self.true_positives = 0
        self.false_positives = 0
        self.false_negatives = 0
        self.true_negatives = 0

    def update(self, predicted_labels, true_labels):
        for pred, true in zip(predicted_labels, true_labels):
            if pred == 1 and true == 1:
                self.true_positives += 1
            elif pred == 1 and true == 0:
                self.false_positives += 1
            elif pred == 0 and true == 1:
                self.false_negatives += 1
            elif pred == 0 and true == 0:
                self.true_negatives += 1

    def precision(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        if self.true_positives + self.false_positives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_positives)

    def recall(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        if self.true_positives + self.false_negatives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_negatives)

    def f1_score(self, predicted_labels, true_labels):
        precision = self.precision(predicted_labels, true_labels)
        recall = self.recall(predicted_labels, true_labels)
        if precision + recall == 0:
            return 0.0
        return 2 * (precision * recall) / (precision + recall)

    def accuracy(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        total = self.true_positives + self.false_positives + self.false_negatives + self.true_negatives
        if total == 0:
            return 0.0
        return (self.true_positives + self.true_negatives) / total
```",0.808383234,0.839677163,0.94,0.903846154,0.921568622,0.880733945,0.872727273,0.876712324,0.94,0.903846154,0.921568622,,,,,,,,,,,,
GPT,57,"import numpy as np


class MetricsCalculator2:
    def __init__(self):
        pass

    @staticmethod
    def mrr(data):
        if type(data) != list and type(data) != tuple:
            raise Exception(""the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple"")

        if len(data) == 0:
            return 0.0, [0.0]
        if type(data) == tuple:
            (sub_list, total_num) = data
            sub_list = np.array(sub_list)
            if total_num == 0:
                return 0.0, [0.0]
            else:
                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                mr_np = sub_list * ranking_array

                mr = 0.0
                for team in mr_np:
                    if team > 0:
                        mr = team
                        break
                return mr, [mr]

        if type(data) == list:
            separate_result = []
            for (sub_list, total_num) in data:
                sub_list = np.array(sub_list)

                if total_num == 0:
                    mr = 0.0
                else:
                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                    mr_np = sub_list * ranking_array

                    mr = 0.0
                    for team in mr_np:
                        if team > 0:
                            mr = team
                            break

                separate_result.append(mr)
            return np.mean(separate_result), separate_result

    @staticmethod
    def map(data):
        if type(data) != list and type(data) != tuple:
            raise Exception(""the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple"")

        if len(data) == 0:
            return 0.0, [0.0]
        if type(data) == tuple:
            (sub_list, total_num) = data
            sub_list = np.array(sub_list)
            if total_num == 0:
                return 0.0, [0.0]
            else:
                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)

                right_ranking_list = []
                count = 1
                for t in sub_list:
                    if t == 0:
                        right_ranking_list.append(0)
                    else:
                        right_ranking_list.append(count)
                        count += 1

                ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num
                return ap, [ap]

        if type(data) == list:
            separate_result = []
            for (sub_list, total_num) in data:
                sub_list = np.array(sub_list)

                if total_num == 0:
                    ap = 0.0
                else:
                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)

                    right_ranking_list = []
                    count = 1
                    for t in sub_list:
                        if t == 0:
                            right_ranking_list.append(0)
                        else:
                            right_ranking_list.append(count)
                            count += 1

                    ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num

                separate_result.append(ap)
            return np.mean(separate_result), separate_result",COTFewShot,"```python
import numpy as np

class MetricsCalculator2:
    def __init__(self):
        pass

    @staticmethod
    def mrr(data):
        if isinstance(data[0], list):
            mrr_list = []
            for d in data:
                actual, _ = d
                for rank, value in enumerate(actual, start=1):
                    if value == 1:
                        mrr_list.append(1 / rank)
                        break
            return np.mean(mrr_list), mrr_list
        else:
            actual, _ = data
            for rank, value in enumerate(actual, start=1):
                if value == 1:
                    return 1 / rank, [1 / rank]
            return 0.0, [0.0]

    @staticmethod
    def map(data):
        if isinstance(data[0], list):
            ap_list = []
            for d in data:
                actual, ground_truth_num = d
                correct = 0
                precision_sum = 0.0
                for rank, value in enumerate(actual, start=1):
                    if value == 1:
                        correct += 1
                        precision_sum += correct / rank
                ap_list.append(precision_sum / ground_truth_num)
            return np.mean(ap_list), ap_list
        else:
            actual, ground_truth_num = data
            correct = 0
            precision_sum = 0.0
            for rank, value in enumerate(actual, start=1):
                if value == 1:
                    correct += 1
                    precision_sum += correct / rank
            return precision_sum / ground_truth_num, [precision_sum / ground_truth_num]
```",0.047742144,0.069640638,0.352941176,0.508474576,0.416666662,0.193103448,0.28,0.228571424,0.352941176,0.508474576,0.416666662,,,,,,,,,,,,
GPT,58,"import random

class MinesweeperGame:
    def __init__(self, n, k) -> None:
        self.n = n
        self.k = k
        self.minesweeper_map = self.generate_mine_sweeper_map()
        self.player_map = self.generate_playerMap()
        self.score = 0

    def generate_mine_sweeper_map(self):
        arr = [[0 for row in range(self.n)] for column in range(self.n)]
        for num in range(self.k):
            x = random.randint(0, self.n-1)
            y = random.randint(0, self.n-1)
            arr[y][x] = 'X'
            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-1):
                if arr[y][x+1] != 'X':
                    arr[y][x+1] += 1
            if (x >=1 and x <= self.n-1) and (y >= 0 and y <= self.n-1):
                if arr[y][x-1] != 'X':
                    arr[y][x-1] += 1
            if (x >= 1 and x <= self.n-1) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x-1] != 'X':
                    arr[y-1][x-1] += 1
    
            if (x >= 0 and x <= self.n-2) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x+1] != 'X':
                    arr[y-1][x+1] += 1 
            if (x >= 0 and x <= self.n-1) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x] != 'X':
                    arr[y-1][x] += 1
    
            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x+1] != 'X':
                    arr[y+1][x+1] += 1
            if (x >= 1 and x <= self.n-1) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x-1] != 'X':
                    arr[y+1][x-1] += 1
            if (x >= 0 and x <= self.n-1) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x] != 'X':
                    arr[y+1][x] += 1
        return arr
    
    def generate_playerMap(self):
        arr = [['-' for row in range(self.n)] for column in range(self.n)]
        return arr

    def check_won(self, map):
        for i in range(self.n):
            for j in range(self.n):
                if map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':
                    return False
        return True
    
    def sweep(self, x, y):

        if (self.minesweeper_map[x][y] == 'X'):
            return False
        else:
            self.player_map[x][y] = self.minesweeper_map[x][y]
            self.score += 1
            if self.check_won(self.player_map) == True:
                return True
            return self.player_map",COTFewShot,"```python
import random

class MinesweeperGame:
    def __init__(self, n, k):
        self.n = n
        self.k = k
        self.minesweeper_map = self.generate_mine_sweeper_map()
        self.player_map = self.generate_playerMap()
        self.score = 0

    def generate_mine_sweeper_map(self):
        # Initialize the board
        board = [[0 for _ in range(self.n)] for _ in range(self.n)]
        
        # Place mines randomly
        mine_positions = random.sample(range(self.n * self.n), self.k)
        for pos in mine_positions:
            x, y = divmod(pos, self.n)
            board[x][y] = 'X'
        
        # Calculate numbers for non-mine cells
        for x in range(self.n):
            for y in range(self.n):
                if board[x][y] == 'X':
                    continue
                # Count surrounding mines
                count = 0
                for dx in [-1, 0, 1]:
                    for dy in [-1, 0, 1]:
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < self.n and 0 <= ny < self.n and board[nx][ny] == 'X':
                            count += 1
                board[x][y] = count
        return board

    def generate_playerMap(self):
        return [['-' for _ in range(self.n)] for _ in range(self.n)]

    def check_won(self, map):
        for x in range(self.n):
            for y in range(self.n):
                if map[x][y] == '-' and self.minesweeper_map[x][y] != 'X':
                    return False
        return True

    def sweep(self, x, y):
        if self.minesweeper_map[x][y] == 'X':
            self.player_map[x][y] = 'X'
            return False
        else:
            self.player_map[x][y] = self.minesweeper_map[x][y]
            if self.check_won(self.player_map):
                return True
            return self.player_map
```",0.129990214,0.164806976,0.611764706,0.559139785,0.584269658,0.397660819,0.393063584,0.395348832,0.6,0.548387097,0.573033703,,,,,,,,,,,,
GPT,59,"from datetime import datetime
import numpy as np

class MovieBookingSystem:
    def __init__(self):
        self.movies = []

    def add_movie(self, name, price, start_time, end_time, n):
        movie = {
            'name': name,
            'price': price,
            'start_time': datetime.strptime(start_time, '%H:%M'),
            'end_time': datetime.strptime(end_time, '%H:%M'),
            'seats': np.zeros((n, n))
        }
        self.movies.append(movie)

    def book_ticket(self, name, seats_to_book):
        for movie in self.movies:
            if movie['name'] == name:
                for seat in seats_to_book:
                    if movie['seats'][seat[0]][seat[1]] == 0:
                        movie['seats'][seat[0]][seat[1]] = 1
                    else:
                        return ""Booking failed.""
                return ""Booking success.""
        return ""Movie not found.""


    def available_movies(self, start_time, end_time):
        start_time = datetime.strptime(start_time, '%H:%M')
        end_time = datetime.strptime(end_time, '%H:%M')

        available_movies = []
        for movie in self.movies:
            if start_time <= movie['start_time'] and movie['end_time'] <= end_time:
                available_movies.append(movie['name'])

        return available_movies",COTFewShot,"```python
from datetime import datetime
import numpy as np

class MovieBookingSystem:
    def __init__(self):
        self.movies = []

    def add_movie(self, name, price, start_time, end_time, n):
        start_time = datetime.strptime(start_time, '%H:%M')
        end_time = datetime.strptime(end_time, '%H:%M')
        seats = np.zeros((n, n))
        movie = {
            'name': name,
            'price': price,
            'start_time': start_time,
            'end_time': end_time,
            'seats': seats
        }
        self.movies.append(movie)

    def book_ticket(self, name, seats_to_book):
        for movie in self.movies:
            if movie['name'].lower() == name.lower():
                for seat in seats_to_book:
                    if movie['seats'][seat] == 1:
                        return ""Booking failed.""
                for seat in seats_to_book:
                    movie['seats'][seat] = 1
                return ""Booking success.""
        return ""Movie not found.""

    def available_movies(self, start_time, end_time):
        start_time = datetime.strptime(start_time, '%H:%M')
        end_time = datetime.strptime(end_time, '%H:%M')
        available = []
        for movie in self.movies:
            if movie['start_time'] >= start_time and movie['end_time'] <= end_time:
                available.append(movie['name'])
        return available
```",0.543103448,0.596207667,0.913043478,0.863013699,0.887323939,0.730769231,0.684684685,0.706976739,0.913043478,0.863013699,0.887323939,,,,,,,,,,,,
GPT,5,"class AutomaticGuitarSimulator:
    def __init__(self, text) -> None:
        self.play_text = text

    def interpret(self, display=False):
        if len(self.play_text) == 0:
            return
        else:
            play_list = []
            play_segs = self.play_text.split("" "")
            for play_seg in play_segs:
                pos = 0
                for ele in play_seg:
                    if ele.isalpha():
                        pos += 1
                        continue
                    break
                play_chord = play_seg[0:pos]
                play_value = play_seg[pos:]
                play_list.append({'Chord': play_chord, 'Tune': play_value})
                if display:
                    self.display(play_chord, play_value)
            return play_list

    def display(self, key, value):
        return ""Normal Guitar Playing -- Chord: %s, Play Tune: %s"" % (key, value)",COTFewShot,"```python
class AutomaticGuitarSimulator:
    def __init__(self, text):
        self.play_text = text

    def interpret(self, display=False):
        score = self.play_text.split()
        interpreted_score = []

        for chord in score:
            chord_name = ''.join(filter(str.isalpha, chord))
            tune = ''.join(filter(str.isdigit, chord))
            interpreted_score.append({'Chord': chord_name, 'Tune': tune})
            if display:
                self.display(chord_name, tune)

        return interpreted_score

    def display(self, key, value):
        return f""Normal Guitar Playing -- Chord: {key}, Play Tune: {value}""
```",0.139123028,0.181866033,0.421875,0.551020408,0.477876101,0.256097561,0.35,0.295774643,0.421875,0.551020408,0.477876101,,,,,,,,,,,,
GPT,60,"import sqlite3


class MovieTicketDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS tickets (
                id INTEGER PRIMARY KEY,
                movie_name TEXT,
                theater_name TEXT,
                seat_number TEXT,
                customer_name TEXT
            )
        ''')
        self.connection.commit()

    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):
        self.cursor.execute('''
            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)
            VALUES (?, ?, ?, ?)
        ''', (movie_name, theater_name, seat_number, customer_name))
        self.connection.commit()

    def search_tickets_by_customer(self, customer_name):
        self.cursor.execute('''
            SELECT * FROM tickets WHERE customer_name = ?
        ''', (customer_name,))
        tickets = self.cursor.fetchall()
        return tickets

    def delete_ticket(self, ticket_id):
        self.cursor.execute('''
            DELETE FROM tickets WHERE id = ?
        ''', (ticket_id,))
        self.connection.commit()",COTFewShot,"```python
import sqlite3

class MovieTicketDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS tickets (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                movie_name TEXT NOT NULL,
                theater_name TEXT NOT NULL,
                seat_number TEXT NOT NULL,
                customer_name TEXT NOT NULL
            )
        ''')
        self.connection.commit()

    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):
        self.cursor.execute('''
            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)
            VALUES (?, ?, ?, ?)
        ''', (movie_name, theater_name, seat_number, customer_name))
        self.connection.commit()

    def search_tickets_by_customer(self, customer_name):
        self.cursor.execute('''
            SELECT * FROM tickets WHERE customer_name = ?
        ''', (customer_name,))
        return self.cursor.fetchall()

    def delete_ticket(self, ticket_id):
        self.cursor.execute('''
            DELETE FROM tickets WHERE id = ?
        ''', (ticket_id,))
        self.connection.commit()

    def __del__(self):
        self.connection.close()
```",0.726415094,0.753853263,0.96875,0.885714286,0.925373129,0.85106383,0.792079208,0.820512816,0.953125,0.871428571,0.910447756,,,,,,,,,,,,
GPT,61,"class MusicPlayer:
    def __init__(self):
        self.playlist = []
        self.current_song = None
        self.volume = 50

    def add_song(self, song):
        self.playlist.append(song)

    def remove_song(self, song):
        if song in self.playlist:
            self.playlist.remove(song)
            if self.current_song == song:
                self.stop()

    def play(self):
        if self.playlist and self.current_song:
            return self.playlist[0]
        elif len(self.playlist): 
            return False

    def stop(self):
        if self.current_song:
            self.current_song = None
            return True
        else:
            return False

    def switch_song(self):
        if self.current_song:
            current_index = self.playlist.index(self.current_song)
            if current_index < len(self.playlist) - 1:
                self.current_song = self.playlist[current_index + 1]
                return True
            else:
                return False
        else:
            return False

    def previous_song(self):
        if self.current_song:
            current_index = self.playlist.index(self.current_song)
            if current_index > 0:
                self.current_song = self.playlist[current_index - 1]
                return True
            else:
                return False
        else:
            return False

    def set_volume(self, volume):
        if 0 <= volume <= 100:
            self.volume = volume
        else:
            return False

    def shuffle(self):
        if self.playlist:
            import random
            random.shuffle(self.playlist)
            return True
        else:
            return False",COTFewShot,"```python
class MusicPlayer:
    def __init__(self):
        self.playlist = []
        self.current_song = None
        self.volume = 50

    def add_song(self, song):
        self.playlist.append(song)

    def remove_song(self, song):
        if song in self.playlist:
            self.playlist.remove(song)

    def play(self):
        if self.current_song in self.playlist:
            return self.current_song
        return False

    def stop(self):
        if self.current_song:
            self.current_song = None
            return True
        return False

    def switch_song(self):
        if self.current_song in self.playlist:
            index = self.playlist.index(self.current_song)
            if index + 1 < len(self.playlist):
                self.current_song = self.playlist[index + 1]
                return True
        return False

    def previous_song(self):
        if self.current_song in self.playlist:
            index = self.playlist.index(self.current_song)
            if index > 0:
                self.current_song = self.playlist[index - 1]
                return True
        return False

    def set_volume(self, volume):
        if 0 <= volume <= 100:
            self.volume = volume
            return True
        return False

    def shuffle(self):
        if self.playlist:
            import random
            random.shuffle(self.playlist)
            return True
        return False
```",0.52610187,0.579139383,0.830508475,0.907407407,0.867256632,0.721153846,0.79787234,0.757575753,0.830508475,0.907407407,0.867256632,,,,,,,,,,,,
GPT,62,"class NLPDataProcessor:

    def construct_stop_word_list(self):
        stop_word_list = ['a', 'an', 'the']
        return stop_word_list

    def remove_stop_words(self, string_list, stop_word_list):
        answer = []
        for string in string_list:
            string_split = string.split()
            for word in string_split:
                if word in stop_word_list:
                    string_split.remove(word)
            answer.append(string_split)
        return answer

    def process(self, string_list):
        stop_word_list = self.construct_stop_word_list()
        words_list = self.remove_stop_words(string_list, stop_word_list)
        return words_list",COTFewShot,"```python
class NLPDataProcessor:
    def construct_stop_word_list(self):
        return ['a', 'an', 'the']

    def remove_stop_words(self, string_list, stop_word_list):
        result = []
        for string in string_list:
            words = string.split()
            filtered_words = [word for word in words if word.lower() not in stop_word_list]
            result.append(filtered_words)
        return result

    def process(self, string_list):
        stop_word_list = self.construct_stop_word_list()
        return self.remove_stop_words(string_list, stop_word_list)
```",0.298072838,0.363588919,0.794117647,0.72972973,0.760563375,0.52,0.5,0.509803917,0.794117647,0.72972973,0.760563375,,,,,,,,,,,,
GPT,63,"from collections import Counter
import re

class NLPDataProcessor2:

    def process_data(self, string_list):
        words_list = []
        for string in string_list:
            # Remove non-English letters and convert to lowercase
            processed_string = re.sub(r'[^a-zA-Z\s]', '', string.lower())
            # Split the string into words
            words = processed_string.split()
            words_list.append(words)
        return words_list

    def calculate_word_frequency(self, words_list):
        word_frequency = Counter()
        for words in words_list:
            word_frequency.update(words)
        sorted_word_frequency = dict(sorted(word_frequency.items(), key=lambda x: x[1], reverse=True))
        top_5_word_frequency = dict(list(sorted_word_frequency.items())[:5])
        return top_5_word_frequency

    def process(self, string_list):
        words_list = self.process_data(string_list)
        word_frequency_dict = self.calculate_word_frequency(words_list)
        return word_frequency_dict",COTFewShot,"```python
from collections import Counter
import re

class NLPDataProcessor:
    def process_data(self, string_list):
        words_list = []
        for string in string_list:
            processed_string = re.sub(r'[^a-zA-Z\s]', '', string).lower()
            words = processed_string.split()
            words_list.append(words)
        return words_list

    def calculate_word_frequency(self, words_list):
        frequency = Counter()
        for words in words_list:
            frequency.update(words)
        return dict(frequency.most_common(5))

    def process(self, string_list):
        words_list = self.process_data(string_list)
        return self.calculate_word_frequency(words_list)
```",0.370984553,0.402468183,0.561403509,0.8,0.65979381,0.475609756,0.684210526,0.561151074,0.561403509,0.8,0.65979381,,,,,,,,,,,,
GPT,64,"class NumberConverter:
    @staticmethod
    def decimal_to_binary(decimal_num):
        binary_num = bin(decimal_num)[2:]
        return binary_num

    @staticmethod
    def binary_to_decimal(binary_num):
        decimal_num = int(binary_num, 2)
        return decimal_num

    @staticmethod
    def decimal_to_octal(decimal_num):
        octal_num = oct(decimal_num)[2:]
        return octal_num

    @staticmethod
    def octal_to_decimal(octal_num):
        decimal_num = int(octal_num, 8)
        return decimal_num

    @staticmethod
    def decimal_to_hex(decimal_num):
        hex_num = hex(decimal_num)[2:]
        return hex_num

    @staticmethod
    def hex_to_decimal(hex_num):
        decimal_num = int(hex_num, 16)
        return decimal_num",COTFewShot,"```python
class NumberConverter:
    @staticmethod
    def decimal_to_binary(decimal_num):
        return bin(decimal_num)[2:]

    @staticmethod
    def binary_to_decimal(binary_num):
        return int(binary_num, 2)

    @staticmethod
    def decimal_to_octal(decimal_num):
        return oct(decimal_num)[2:]

    @staticmethod
    def octal_to_decimal(octal_num):
        return int(octal_num, 8)

    @staticmethod
    def decimal_to_hex(decimal_num):
        return hex(decimal_num)[2:]

    @staticmethod
    def hex_to_decimal(hex_num):
        return int(hex_num, 16)
```",0.14832656,0.180652269,0.8,0.909090909,0.851063825,0.285714286,0.387096774,0.328767118,0.68,0.772727273,0.72340425,,,,,,,,,,,,
GPT,65,"class NumberWordFormatter:
    def __init__(self):
        self.NUMBER = ["""", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""]
        self.NUMBER_TEEN = [""TEN"", ""ELEVEN"", ""TWELVE"", ""THIRTEEN"", ""FOURTEEN"", ""FIFTEEN"", ""SIXTEEN"", ""SEVENTEEN"",
                            ""EIGHTEEN"",
                            ""NINETEEN""]
        self.NUMBER_TEN = [""TEN"", ""TWENTY"", ""THIRTY"", ""FORTY"", ""FIFTY"", ""SIXTY"", ""SEVENTY"", ""EIGHTY"", ""NINETY""]
        self.NUMBER_MORE = ["""", ""THOUSAND"", ""MILLION"", ""BILLION""]
        self.NUMBER_SUFFIX = [""k"", ""w"", """", ""m"", """", """", ""b"", """", """", ""t"", """", """", ""p"", """", """", ""e""]

    def format(self, x):
        if x is not None:
            return self.format_string(str(x))
        else:
            return """"

    def format_string(self, x):
        lstr, rstr = (x.split('.') + [''])[:2]
        lstrrev = lstr[::-1]
        a = [''] * 5

        if len(lstrrev) % 3 == 1:
            lstrrev += ""00""
        elif len(lstrrev) % 3 == 2:
            lstrrev += ""0""

        lm = """"
        for i in range(len(lstrrev) // 3):
            a[i] = lstrrev[3 * i:3 * i + 3][::-1]
            if a[i] != ""000"":
                lm = self.trans_three(a[i]) + "" "" + self.parse_more(i) + "" "" + lm
            else:
                lm += self.trans_three(a[i])

        xs = f""AND CENTS {self.trans_two(rstr)} "" if rstr else """"
        if not lm.strip():
            return ""ZERO ONLY""
        else:
            return f""{lm.strip()} {xs}ONLY""

    def trans_two(self, s):
        s = s.zfill(2)
        if s[0] == ""0"":
            return self.NUMBER[int(s[-1])]
        elif s[0] == ""1"":
            return self.NUMBER_TEEN[int(s) - 10]
        elif s[1] == ""0"":
            return self.NUMBER_TEN[int(s[0]) - 1]
        else:
            return self.NUMBER_TEN[int(s[0]) - 1] + "" "" + self.NUMBER[int(s[-1])]

    def trans_three(self, s):
        if s[0] == ""0"":
            return self.trans_two(s[1:])
        elif s[1:] == ""00"":
            return f""{self.NUMBER[int(s[0])]} HUNDRED""
        else:
            return f""{self.NUMBER[int(s[0])]} HUNDRED AND {self.trans_two(s[1:])}""

    def parse_more(self, i):
        return self.NUMBER_MORE[i]",COTFewShot,"```python
class NumberWordFormatter:
    def __init__(self):
        self.NUMBER = ["""", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""]
        self.NUMBER_TEEN = [""TEN"", ""ELEVEN"", ""TWELVE"", ""THIRTEEN"", ""FOURTEEN"", ""FIFTEEN"", ""SIXTEEN"", ""SEVENTEEN"",
                            ""EIGHTEEN"", ""NINETEEN""]
        self.NUMBER_TEN = [""TEN"", ""TWENTY"", ""THIRTY"", ""FORTY"", ""FIFTY"", ""SIXTY"", ""SEVENTY"", ""EIGHTY"", ""NINETY""]
        self.NUMBER_MORE = ["""", ""THOUSAND"", ""MILLION"", ""BILLION""]
        self.NUMBER_SUFFIX = [""k"", ""w"", """", ""m"", """", """", ""b"", """", """", ""t"", """", """", ""p"", """", """", ""e""]

    def format(self, x):
        if isinstance(x, float):
            integer_part = int(x)
            decimal_part = round((x - integer_part) * 100)
            words = self.format_string(str(integer_part))
            if decimal_part > 0:
                words += "" POINT "" + "" "".join(self.NUMBER[int(d)] for d in str(decimal_part))
            return words + "" ONLY""
        elif isinstance(x, int):
            return self.format_string(str(x)) + "" ONLY""
        else:
            raise ValueError(""Input must be an integer or float"")

    def format_string(self, x):
        length = len(x)
        if length == 0:
            return """"
        elif length <= 3:
            return self.trans_three(x)
        else:
            num_chunks = (length + 2) // 3
            words = []
            for i in range(num_chunks):
                start = max(0, length - 3 * (i + 1))
                end = length - 3 * i
                chunk_words = self.trans_three(x[start:end])
                if chunk_words:
                    words.append(chunk_words + "" "" + self.parse_more(i))
            return "" "".join(reversed(words)).strip()

    def trans_two(self, s):
        if len(s) == 1:
            return self.NUMBER[int(s)]
        elif s[0] == '1':
            return self.NUMBER_TEEN[int(s[1])]
        else:
            ten = self.NUMBER_TEN[int(s[0]) - 1]
            one = self.NUMBER[int(s[1])]
            return ten + ("" "" + one if one else """")

    def trans_three(self, s):
        if len(s) == 3 and s[0] != '0':
            return self.NUMBER[int(s[0])] + "" HUNDRED"" + ("" AND "" + self.trans_two(s[1:]) if s[1:] != ""00"" else """")
        else:
            return self.trans_two(s)

    def parse_more(self, i):
        return self.NUMBER_MORE[i] if i < len(self.NUMBER_MORE) else """"
```",0.295019157,0.363648322,0.628571429,0.571428571,0.598639451,0.447488584,0.388888889,0.416135876,0.614285714,0.558441558,0.585034009,,,,,,,,,,,,
GPT,66,"class NumericEntityUnescaper:
    def __init__(self):
        pass

    def replace(self, string):
        out = []
        pos = 0
        length = len(string)

        while pos < length - 2:
            if string[pos] == '&' and string[pos + 1] == '#':
                start = pos + 2
                is_hex = False
                first_char = string[start]

                if first_char == 'x' or first_char == 'X':
                    start += 1
                    is_hex = True

                if start == length:
                    return ''.join(out)

                end = start
                while end < length and self.is_hex_char(string[end]):
                    end += 1

                if end < length and string[end] == ';':
                    try:
                        entity_value = int(string[start:end], 16 if is_hex else 10)
                    except:
                        return ''.join(out)

                    out.append(chr(entity_value))
                    pos = end + 1
                    continue

            out.append(string[pos])
            pos += 1

        return ''.join(out)

    @staticmethod
    def is_hex_char(char):
        return char.isdigit() or ('a' <= char.lower() <= 'f')",COTFewShot,"```python
class NumericEntityUnescaper:
    def __init__(self):
        pass

    def replace(self, string):
        result = []
        i = 0
        while i < len(string):
            if string[i] == '&' and i + 1 < len(string) and string[i + 1] == '#':
                i += 2
                is_hex = False
                if i < len(string) and (string[i] == 'x' or string[i] == 'X'):
                    is_hex = True
                    i += 1

                num_str = []
                while i < len(string) and (string[i].isdigit() or (is_hex and self.is_hex_char(string[i]))):
                    num_str.append(string[i])
                    i += 1

                if i < len(string) and string[i] == ';':
                    i += 1
                    try:
                        if is_hex:
                            char = chr(int(''.join(num_str), 16))
                        else:
                            char = chr(int(''.join(num_str), 10))
                        result.append(char)
                    except (ValueError, OverflowError):
                        result.append('&#' + ''.join(num_str) + ';')
                else:
                    result.append('&#' + ''.join(num_str))
            else:
                result.append(string[i])
                i += 1

        return ''.join(result)

    @staticmethod
    def is_hex_char(char):
        return char.isdigit() or ('a' <= char.lower() <= 'f')
```",0.186046512,0.240702286,0.621212121,0.594202899,0.607407402,0.342105263,0.348214286,0.345132738,0.606060606,0.579710145,0.592592588,,,,,,,,,,,,
GPT,67,"class Order:

    def __init__(self):
        self.menu = []
        # menu = [{""dish"": dish name, ""price"": price, ""count"": count}, ...]
        self.selected_dishes = []
        # selected_dish = {""dish"": dish name, ""count"": count, price: price}
        self.sales = {}
        # 


    def add_dish(self, dish):
        for menu_dish in self.menu:
            if dish[""dish""] == menu_dish[""dish""]:
                if menu_dish[""count""] < dish[""count""]:
                    return False
                else:
                    menu_dish[""count""] -= dish[""count""]
                    break
        self.selected_dishes.append(dish)
        return True

    def calculate_total(self):
        total = 0
        for dish in self.selected_dishes:
            total += dish[""price""] * dish[""count""] * self.sales[dish[""dish""]]
        return total

    def checkout(self):
        if len(self.selected_dishes) == 0:
            return False
        total = self.calculate_total()
        self.selected_dishes = []
        return total",COTFewShot,"```python
class Order:
    def __init__(self):
        self.menu = []
        self.selected_dishes = []
        self.sales = {}

    def add_dish(self, dish):
        for menu_item in self.menu:
            if menu_item[""dish""] == dish[""dish""] and menu_item[""count""] >= dish[""count""]:
                self.selected_dishes.append(dish)
                menu_item[""count""] -= dish[""count""]
                return True
        return False

    def calculate_total(self):
        total = 0.0
        for dish in self.selected_dishes:
            sales_factor = self.sales.get(dish[""dish""], 1)
            total += dish[""count""] * dish[""price""] * sales_factor
        return total

    def checkout(self):
        if not self.selected_dishes:
            return False
        return self.calculate_total()
```",0.17661234,0.233863009,0.610169492,0.765957447,0.679245278,0.423913043,0.534246575,0.472727268,0.576271186,0.723404255,0.641509429,,,,,,,,,,,,
GPT,68,"class PageUtil:
    def __init__(self, data, page_size):
        self.data = data
        self.page_size = page_size
        self.total_items = len(data)
        self.total_pages = (self.total_items + page_size - 1) // page_size

    def get_page(self, page_number):
        if page_number < 1 or page_number > self.total_pages:
            return []

        start_index = (page_number - 1) * self.page_size
        end_index = start_index + self.page_size
        return self.data[start_index:end_index]

    def get_page_info(self, page_number):
        if page_number < 1 or page_number > self.total_pages:
            return {}

        start_index = (page_number - 1) * self.page_size
        end_index = min(start_index + self.page_size, self.total_items)
        page_data = self.data[start_index:end_index]

        page_info = {
            ""current_page"": page_number,
            ""per_page"": self.page_size,
            ""total_pages"": self.total_pages,
            ""total_items"": self.total_items,
            ""has_previous"": page_number > 1,
            ""has_next"": page_number < self.total_pages,
            ""data"": page_data
        }
        return page_info

    def search(self, keyword):
        results = [item for item in self.data if keyword in str(item)]
        num_results = len(results)
        num_pages = (num_results + self.page_size - 1) // self.page_size

        search_info = {
            ""keyword"": keyword,
            ""total_results"": num_results,
            ""total_pages"": num_pages,
            ""results"": results
        }
        return search_info",COTFewShot,"```python
class PageUtil:
    def __init__(self, data, page_size):
        self.data = data
        self.page_size = page_size
        self.total_items = len(data)
        self.total_pages = (self.total_items + page_size - 1) // page_size

    def get_page(self, page_number):
        start_index = (page_number - 1) * self.page_size
        end_index = start_index + self.page_size
        return self.data[start_index:end_index]

    def get_page_info(self, page_number):
        page_data = self.get_page(page_number)
        return {
            ""current_page"": page_number,
            ""per_page"": self.page_size,
            ""total_pages"": self.total_pages,
            ""total_items"": self.total_items,
            ""has_previous"": page_number > 1,
            ""has_next"": page_number < self.total_pages,
            ""data"": page_data
        }

    def search(self, keyword):
        results = [item for item in self.data if keyword in str(item)]
        total_results = len(results)
        total_pages = (total_results + self.page_size - 1) // self.page_size
        return {
            ""keyword"": keyword,
            ""total_results"": total_results,
            ""total_pages"": total_pages,
            ""results"": results
        }
```",0.518949179,0.55211041,0.810810811,0.909090909,0.857142852,0.716535433,0.842592593,0.77446808,0.810810811,0.909090909,0.857142852,,,,,,,,,,,,
GPT,69,"import PyPDF2


class PDFHandler:
    def __init__(self, filepaths):
        self.filepaths = filepaths
        # PdfFileReader is deprecated and was removed in PyPDF2 3.0.0. Use PdfReader instead.
        self.readers = [PyPDF2.PdfReader(fp) for fp in filepaths]

    def merge_pdfs(self, output_filepath):
        pdf_writer = PyPDF2.PdfWriter()

        for reader in self.readers:
            # reader.getNumPages is deprecated and was removed in PyPDF2 3.0.0. Use len(reader.pages) instead.
            for page_num in range(len(reader.pages)):
                # reader.getPage(pageNumber) is deprecated and was removed in PyPDF2 3.0.0. Use reader.pages[page_number] instead.
                page = reader.pages[page_num]
                # addPage is deprecated and was removed in PyPDF2 3.0.0. Use add_page instead.
                pdf_writer.add_page(page)

        with open(output_filepath, 'wb') as out:
            pdf_writer.write(out)
        return f""Merged PDFs saved at {output_filepath}""

    def extract_text_from_pdfs(self):
        pdf_texts = []
        for reader in self.readers:
            for page_num in range(len(reader.pages)):
                page = reader.pages[page_num]
                pdf_texts.append(page.extract_text())
        return pdf_texts",COTFewShot,"```python
import PyPDF2

class PDFHandler:
    def __init__(self, filepaths):
        self.filepaths = filepaths
        self.readers = [PyPDF2.PdfReader(fp) for fp in filepaths]

    def merge_pdfs(self, output_filepath):
        try:
            writer = PyPDF2.PdfWriter()
            for reader in self.readers:
                for page_num in range(len(reader.pages)):
                    writer.add_page(reader.pages[page_num])
            with open(output_filepath, 'wb') as output_file:
                writer.write(output_file)
            return f""Merged PDFs saved at {output_filepath}""
        except Exception as e:
            return f""An error occurred: {str(e)}""

    def extract_text_from_pdfs(self):
        pdf_texts = []
        for reader in self.readers:
            text = ''
            for page in reader.pages:
                text += page.extract_text() or ''
            pdf_texts.append(text)
        return pdf_texts
```",0.294996758,0.323391958,0.6,0.639344262,0.619047614,0.465346535,0.534090909,0.497354492,0.6,0.639344262,0.619047614,,,,,,,,,,,,
GPT,6,"class AvgPartition:
    def __init__(self, lst, limit):
        self.lst = lst
        self.limit = limit

    def setNum(self):
        size = len(self.lst) // self.limit
        remainder = len(self.lst) % self.limit
        return size, remainder

        
    def get(self, index):
        size, remainder = self.setNum()
        start = index * size + min(index, remainder)
        end = start + size
        if index + 1 <= remainder:
            end += 1
        return self.lst[start:end]",COTFewShot,"```python
class AvgPartition:
    def __init__(self, lst, limit):
        if limit <= 0:
            raise ValueError(""Number of partitions must be greater than 0."")
        self.lst = lst
        self.limit = limit

    def setNum(self):
        length = len(self.lst)
        size = length // self.limit
        remainder = length % self.limit
        return size, remainder

    def get(self, index):
        size, remainder = self.setNum()
        start = index * size + min(index, remainder)
        end = start + size + (1 if index < remainder else 0)
        return self.lst[start:end]
```",0.479452055,0.537017328,0.914285714,0.64,0.752941172,0.779661017,0.605263158,0.681481477,0.914285714,0.64,0.752941172,,,,,,,,,,,,
GPT,70,"class PersonRequest:
    def __init__(self, name: str, sex: str, phoneNumber: str):
        self.name = self._validate_name(name)
        self.sex = self._validate_sex(sex)
        self.phoneNumber = self._validate_phoneNumber(phoneNumber)

    def _validate_name(self, name: str) -> str:
        if not name:
            return None
        if len(name) > 33:
            return None
        return name

    def _validate_sex(self, sex: str) -> str:
        if sex not in [""Man"", ""Woman"", ""UGM""]:
            return None
        return sex

    def _validate_phoneNumber(self, phoneNumber: str) -> str:
        if not phoneNumber:
            return None
        if len(phoneNumber) != 11 or not phoneNumber.isdigit():
            return None
        return phoneNumber",COTFewShot,"```python
class PersonRequest:
    def __init__(self, name: str, sex: str, phoneNumber: str):
        self.name = self._validate_name(name)
        self.sex = self._validate_sex(sex)
        self.phoneNumber = self._validate_phoneNumber(phoneNumber)

    def _validate_name(self, name: str) -> str:
        if not name or len(name) > 33:
            return None
        return name

    def _validate_sex(self, sex: str) -> str:
        if sex not in [""Man"", ""Woman"", ""UGM""]:
            return None
        return sex

    def _validate_phoneNumber(self, phoneNumber: str) -> str:
        if not phoneNumber.isdigit() or len(phoneNumber) != 11:
            return None
        return phoneNumber
```",0.759656882,0.785220743,0.948717949,0.902439024,0.924999995,0.820895522,0.846153846,0.833333328,0.871794872,0.829268293,0.849999995,,,,,,,,,,,,
GPT,71,"class PushBoxGame:
    def __init__(self, map):
        self.map = map
        self.player_row = 0
        self.player_col = 0
        self.targets = []
        self.boxes = []
        self.target_count = 0
        self.is_game_over = False

        self.init_game()

    def init_game(self):
        for row in range(len(self.map)):
            for col in range(len(self.map[row])):
                if self.map[row][col] == ""O"":
                    self.player_row = row
                    self.player_col = col
                elif self.map[row][col] == ""G"":
                    self.targets.append((row, col))
                    self.target_count += 1
                elif self.map[row][col] == ""X"":
                    self.boxes.append((row, col))

    def check_win(self):
        box_on_target_count = 0
        for box in self.boxes:
            if box in self.targets:
                box_on_target_count += 1
        if box_on_target_count == self.target_count:
            self.is_game_over = True
        return self.is_game_over

    def move(self, direction):
        new_player_row = self.player_row
        new_player_col = self.player_col

        if direction == ""w"":
            new_player_row -= 1
        elif direction == ""s"":
            new_player_row += 1
        elif direction == ""a"":
            new_player_col -= 1
        elif direction == ""d"":
            new_player_col += 1

        if self.map[new_player_row][new_player_col] != ""#"":
            if (new_player_row, new_player_col) in self.boxes:
                new_box_row = new_player_row + (new_player_row - self.player_row)
                new_box_col = new_player_col + (new_player_col - self.player_col)

                if self.map[new_box_row][new_box_col] != ""#"":
                    self.boxes.remove((new_player_row, new_player_col))
                    self.boxes.append((new_box_row, new_box_col))
                    self.player_row = new_player_row
                    self.player_col = new_player_col
            else:
                self.player_row = new_player_row
                self.player_col = new_player_col

        return self.check_win()",COTFewShot,"```python
class PushBoxGame:
    def __init__(self, map):
        self.map = map
        self.player_row = 0
        self.player_col = 0
        self.targets = []
        self.boxes = []
        self.target_count = 0
        self.is_game_over = False
        self.init_game()

    def init_game(self):
        for r, row in enumerate(self.map):
            for c, char in enumerate(row):
                if char == 'O':
                    self.player_row = r
                    self.player_col = c
                elif char == 'G':
                    self.targets.append((r, c))
                    self.target_count += 1
                elif char == 'X':
                    self.boxes.append((r, c))

    def check_win(self):
        for box in self.boxes:
            if box not in self.targets:
                self.is_game_over = False
                return False
        self.is_game_over = True
        return True

    def move(self, direction):
        if self.is_game_over:
            return True

        move_delta = {'w': (-1, 0), 's': (1, 0), 'a': (0, -1), 'd': (0, 1)}
        if direction not in move_delta:
            return False

        dr, dc = move_delta[direction]
        new_player_row = self.player_row + dr
        new_player_col = self.player_col + dc

        # Check if the player is moving into a wall
        if self.map[new_player_row][new_player_col] == '#':
            return False

        # Check if the player is moving into a box
        if (new_player_row, new_player_col) in self.boxes:
            new_box_row = new_player_row + dr
            new_box_col = new_player_col + dc

            # Check if the box can be moved (i.e., not moving into a wall or another box)
            if self.map[new_box_row][new_box_col] == '#' or (new_box_row, new_box_col) in self.boxes:
                return False

            # Move the box
            self.boxes.remove((new_player_row, new_player_col))
            self.boxes.append((new_box_row, new_box_col))

        # Move the player
        self.player_row = new_player_row
        self.player_col = new_player_col

        return self.check_win()
```",0.259259259,0.310469742,0.666666667,0.476190476,0.555555551,0.5,0.394594595,0.441087608,0.666666667,0.476190476,0.555555551,,,,,,,,,,,,
GPT,72,"import re


class RegexUtils:

    def match(self, pattern, text):
        ans = re.match(pattern, text)
        if ans:
            return True
        else:
            return False

    def findall(self, pattern, text):
        return re.findall(pattern, text)

    def split(self, pattern, text):
        return re.split(pattern, text)

    def sub(self, pattern, replacement, text):
        return re.sub(pattern, replacement, text)

    def generate_email_pattern(self):
        pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        return pattern

    def generate_phone_number_pattern(self):
        pattern = r'\b\d{3}-\d{3}-\d{4}\b'
        return pattern

    def generate_split_sentences_pattern(self):
        pattern = r'[.!?][\s]{1,2}(?=[A-Z])'
        return pattern

    def split_sentences(self, text):
        pattern = self.generate_split_sentences_pattern()
        return self.split(pattern, text)

    def validate_phone_number(self, phone_number):
        pattern = self.generate_phone_number_pattern()
        return self.match(pattern, phone_number)

    def extract_email(self, text):
        pattern = self.generate_email_pattern()
        return self.findall(pattern, text)",COTFewShot,"```python
import re


class RegexUtils:
    def match(self, pattern, text):
        return bool(re.match(pattern, text))

    def findall(self, pattern, text):
        return re.findall(pattern, text)

    def split(self, pattern, text):
        return re.split(pattern, text)

    def sub(self, pattern, replacement, text):
        return re.sub(pattern, replacement, text)

    def generate_email_pattern(self):
        return r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'

    def generate_phone_number_pattern(self):
        return r'\b\d{3}-\d{3}-\d{4}\b'

    def generate_split_sentences_pattern(self):
        return r'[.!?][\s]{1,2}(?=[A-Z])'

    def split_sentences(self, text):
        pattern = self.generate_split_sentences_pattern()
        return re.split(pattern, text)

    def validate_phone_number(self, phone_number):
        pattern = self.generate_phone_number_pattern()
        return bool(re.match(pattern, phone_number))

    def extract_email(self, text):
        pattern = self.generate_email_pattern()
        return re.findall(pattern, text)
```",0.50469704,0.557495905,0.844444444,0.88372093,0.863636359,0.615384615,0.738461538,0.671328666,0.822222222,0.860465116,0.840909086,,,,,,,,,,,,
GPT,73,"class RPGCharacter:
    def __init__(self, name, hp, attack_power, defense, level=1):
        self.name = name
        self.hp = hp
        self.attack_power = attack_power
        self.defense = defense
        self.level = level
        self.exp = 0

    def attack(self, other_character):
        damage = max(self.attack_power - other_character.defense, 1)
        other_character.hp -= damage

    def heal(self):
        self.hp += 10
        if self.hp > 100:
            self.hp = 100
        return self.hp

    def gain_exp(self, amount):
        while amount != 0:
            if self.exp + amount >= self.level * 100:
                amount -= (self.level * 100 - self.exp)
                self.level_up()
            else:
                self.exp += amount
                amount = 0

    def level_up(self):
        if self.level < 100:
            self.level += 1
            self.exp = 0
            self.hp += 20
            self.attack_power += 5
            self.defense += 5
        return self.level, self.hp, self.attack_power, self.defense

    def is_alive(self):
        return self.hp > 0",COTFewShot,"```python
class RPGCharacter:
    def __init__(self, name, hp, attack_power, defense, level=1):
        self.name = name
        self.hp = hp
        self.attack_power = attack_power
        self.defense = defense
        self.level = level
        self.exp = 0

    def attack(self, other_character):
        damage = max(0, self.attack_power - other_character.defense)
        other_character.hp = max(0, other_character.hp - damage)

    def heal(self):
        self.hp = min(100, self.hp + 10)
        return self.hp

    def gain_exp(self, amount):
        self.exp += amount
        while self.exp >= 100 * self.level:
            self.exp -= 100 * self.level
            self.level_up()

    def level_up(self):
        if self.level < 100:
            self.level += 1
            self.hp += 20
            self.attack_power += 5
            self.defense += 5
        return self.level, self.hp, self.attack_power, self.defense

    def is_alive(self):
        return self.hp > 0
```",0.527614619,0.58172896,0.851851852,0.851851852,0.851851847,0.669565217,0.740384615,0.703196342,0.833333333,0.833333333,0.833333328,,,,,,,,,,,,
GPT,74,"class Server:

    def __init__(self):
        self.white_list = []
        self.send_struct = {}
        self.receive_struct = {}

    def add_white_list(self, addr):
        if addr in self.white_list:
            return False
        else:
            self.white_list.append(addr)
            return self.white_list

    def del_white_list(self, addr):
        if addr not in self.white_list:
            return False
        else:
            self.white_list.remove(addr)
            return self.white_list

    def recv(self, info):
        if not isinstance(info, dict) or ""addr"" not in info or ""content"" not in info:
            return -1
        addr = info[""addr""]
        content = info[""content""]
        if addr not in self.white_list:
            return False
        else:
            self.receive_struct = {""addr"": addr, ""content"": content}
            return self.receive_struct[""content""]

    def send(self, info):
        if not isinstance(info, dict) or ""addr"" not in info or ""content"" not in info:
            return ""info structure is not correct""
        self.send_struct = {""addr"": info[""addr""], ""content"": info[""content""]}

    def show(self, type):
        if type == ""send"":
            return self.send_struct
        elif type == ""receive"":
            return self.receive_struct
        else:
            return False",COTFewShot,"```python
class Server:
    def __init__(self):
        self.white_list = []
        self.send_struct = {}
        self.receive_struct = {}

    def add_white_list(self, addr):
        if addr not in self.white_list:
            self.white_list.append(addr)
            return self.white_list
        return False

    def del_white_list(self, addr):
        if addr in self.white_list:
            self.white_list.remove(addr)
            return self.white_list
        return False

    def recv(self, info):
        addr = info.get('addr')
        content = info.get('content')
        if addr in self.white_list:
            self.receive_struct = {""addr"": addr, ""content"": content}
            return content
        return False

    def send(self, info):
        try:
            addr = info.get('addr')
            content = info.get('content')
            self.send_struct = {""addr"": addr, ""content"": content}
        except:
            return ""Error in sending information""

    def show(self, type):
        if type == 'send':
            return self.send_struct
        elif type == 'receive':
            return self.receive_struct
        return False
```",0.317746914,0.385643453,0.660714286,0.770833333,0.711538457,0.549450549,0.641025641,0.591715971,0.660714286,0.770833333,0.711538457,,,,,,,,,,,,
GPT,75,"class ShoppingCart:
    def __init__(self):
        self.items = {}

    def add_item(self, item, price, quantity=1):
        if item in self.items:
            self.items[item] = {'price': price, 'quantity': quantity}
        else:
            self.items[item] = {'price': price, 'quantity': quantity}

    def remove_item(self, item, quantity=1):
        if item in self.items:
            self.items[item]['quantity'] -= quantity
        else:
            pass

    def view_items(self) -> dict:
        return self.items

    def total_price(self) -> float:
        return sum([item['quantity'] * item['price'] for item in self.items.values()])",COTFewShot,"```python
class ShoppingCart:
    def __init__(self):
        self.items = {}

    def add_item(self, item, price, quantity=1):
        if item in self.items:
            self.items[item]['quantity'] += quantity
        else:
            self.items[item] = {'price': price, 'quantity': quantity}

    def remove_item(self, item, quantity=1):
        if item in self.items:
            self.items[item]['quantity'] -= quantity
            if self.items[item]['quantity'] <= 0:
                del self.items[item]

    def view_items(self):
        return self.items

    def total_price(self):
        total = 0.0
        for item in self.items.values():
            total += item['price'] * item['quantity']
        return total
```",0.507936508,0.553490918,0.783783784,0.707317073,0.743589739,0.692307692,0.571428571,0.626086952,0.756756757,0.682926829,0.717948713,,,,,,,,,,,,
GPT,76,"class SignInSystem:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username in self.users:
            return False
        else:
            self.users[username] = False
            return True

    def sign_in(self, username):
        if username not in self.users:
            return False
        else:
            self.users[username] = True
            return True

    def check_sign_in(self, username):
        if username not in self.users:
            return False
        else:
            if self.users[username]:
                return True
            else:
                return False

    def all_signed_in(self):
        if all(self.users.values()):
            return True
        else:
            return False

    def all_not_signed_in(self):
        not_signed_in_users = []
        for username, signed_in in self.users.items():
            if not signed_in:
                not_signed_in_users.append(username)
        return not_signed_in_users",COTFewShot,"```python
class SignInSystem:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username not in self.users:
            self.users[username] = False
            return True
        return False

    def sign_in(self, username):
        if username in self.users:
            self.users[username] = True
            return True
        return False

    def check_sign_in(self, username):
        return self.users.get(username, False)

    def all_signed_in(self):
        return all(self.users.values())

    def all_not_signed_in(self):
        return [username for username, signed_in in self.users.items() if not signed_in]
```",0.352344045,0.40419465,0.771428571,0.771428571,0.771428566,0.596774194,0.672727273,0.632478627,0.771428571,0.771428571,0.771428566,,,,,,,,,,,,
GPT,77,"import random


class Snake:
    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):
        self.length = 1
        self.SCREEN_WIDTH = SCREEN_WIDTH
        self.SCREEN_HEIGHT = SCREEN_HEIGHT
        self.BLOCK_SIZE = BLOCK_SIZE
        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]
        self.score = 0
        self.food_position = food_position

    def move(self, direction):
        cur = self.positions[0]
        x, y = direction

        new = (
            ((cur[0] + (x * self.BLOCK_SIZE)) % self.SCREEN_WIDTH),
            (cur[1] + (y * self.BLOCK_SIZE)) % self.SCREEN_HEIGHT,
        )

        if new == self.food_position:
            self.eat_food()

        if len(self.positions) > 2 and new in self.positions[2:]:
            self.reset()
        else:
            self.positions.insert(0, new)
            if len(self.positions) > self.length:
                self.positions.pop()

    def random_food_position(self):
        while self.food_position in self.positions:
            self.food_position = (random.randint(0, self.SCREEN_WIDTH // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE,
                                  random.randint(0, self.SCREEN_HEIGHT // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE)

    def reset(self):
        self.length = 1
        self.positions = [((self.SCREEN_WIDTH / 2), (self.SCREEN_HEIGHT / 2))]
        self.score = 0
        self.random_food_position()

    def eat_food(self):
        self.length += 1
        self.score += 100
        self.random_food_position()",COTFewShot,"```python
import random

class Snake:
    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):
        self.length = 1
        self.SCREEN_WIDTH = SCREEN_WIDTH
        self.SCREEN_HEIGHT = SCREEN_HEIGHT
        self.BLOCK_SIZE = BLOCK_SIZE
        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]
        self.score = 0
        self.food_position = food_position

    def move(self, direction):
        current_head = self.positions[0]
        new_head = (current_head[0] + direction[0] * self.BLOCK_SIZE,
                    current_head[1] + direction[1] * self.BLOCK_SIZE)
        
        if new_head == self.food_position:
            self.eat_food()
        else:
            if new_head in self.positions:
                self.reset()
                return
            self.positions = [new_head] + self.positions[:-1]

    def random_food_position(self):
        while True:
            new_position = (random.randint(0, (self.SCREEN_WIDTH // self.BLOCK_SIZE) - 1) * self.BLOCK_SIZE,
                            random.randint(0, (self.SCREEN_HEIGHT // self.BLOCK_SIZE) - 1) * self.BLOCK_SIZE)
            if new_position not in self.positions:
                self.food_position = new_position
                break

    def reset(self):
        self.length = 1
        self.positions = [((self.SCREEN_WIDTH / 2), (self.SCREEN_HEIGHT / 2))]
        self.score = 0
        self.random_food_position()

    def eat_food(self):
        self.length += 1
        self.score += 10
        self.positions.append(self.positions[-1])
        self.random_food_position()
```",0.507391371,0.558795192,0.679487179,0.746478873,0.711409391,0.613138686,0.65625,0.633962259,0.679487179,0.746478873,0.711409391,,,,,,,,,,,,
GPT,78,"import re


class SplitSentence:

    def split_sentences(self, sentences_string):
        sentences = re.split(r'(?<!\w\.\w.)(?<![A-Z][a-z]\.)(?<=\.|\?)\s', sentences_string)
        return sentences

    def count_words(self, sentence):
        sentence = re.sub(r'[^a-zA-Z\s]', '', sentence)
        words = sentence.split()
        return len(words)

    def process_text_file(self, sentences_string):
        sentences = self.split_sentences(sentences_string)
        max_count = 0
        for sentence in sentences:
            count = self.count_words(sentence)
            if count > max_count:
                max_count = count

        return max_count",COTFewShot,"```python
import re

class SplitSentence:
    def split_sentences(self, sentences_string):
        sentences = re.split(r'(?<=[.?\s])\s+', sentences_string.strip())
        return [sentence.strip() for sentence in sentences if sentence]

    def count_words(self, sentence):
        words = re.findall(r'\b\w+\b', sentence)
        return len(words)

    def process_text_file(self, sentences_string):
        sentences = self.split_sentences(sentences_string)
        max_word_count = 0
        for sentence in sentences:
            word_count = self.count_words(sentence)
            if word_count > max_word_count:
                max_word_count = word_count
        return max_word_count
```",0.358490566,0.419172126,0.684210526,0.666666667,0.67532467,0.462962963,0.462962963,0.462962958,0.684210526,0.666666667,0.67532467,,,,,,,,,,,,
GPT,79,"class SQLGenerator:
    def __init__(self, table_name):
        self.table_name = table_name

    def select(self, fields=None, condition=None):
        if fields is None:
            fields = ""*""
        else:
            fields = "", "".join(fields)
        sql = f""SELECT {fields} FROM {self.table_name}""
        if condition is not None:
            sql += f"" WHERE {condition}""
        return sql + "";""

    def insert(self, data):
        fields = "", "".join(data.keys())
        values = "", "".join([f""'{value}'"" for value in data.values()])
        sql = f""INSERT INTO {self.table_name} ({fields}) VALUES ({values})""
        return sql + "";""

    def update(self, data, condition):
        set_clause = "", "".join([f""{field} = '{value}'"" for field, value in data.items()])
        sql = f""UPDATE {self.table_name} SET {set_clause} WHERE {condition}""
        return sql + "";""

    def delete(self, condition):
        sql = f""DELETE FROM {self.table_name} WHERE {condition}""
        return sql + "";""

    def select_female_under_age(self, age):
        condition = f""age < {age} AND gender = 'female'""
        return self.select(condition=condition)

    def select_by_age_range(self, min_age, max_age):
        condition = f""age BETWEEN {min_age} AND {max_age}""
        return self.select(condition=condition)",COTFewShot,"```python
class SQLGenerator:
    def __init__(self, table_name):
        self.table_name = table_name

    def select(self, fields=None, condition=None):
        fields_part = ', '.join(fields) if fields else '*'
        condition_part = f"" WHERE {condition}"" if condition else ''
        return f""SELECT {fields_part} FROM {self.table_name}{condition_part};""

    def insert(self, data):
        keys = ', '.join(data.keys())
        values = ', '.join(f""'{value}'"" for value in data.values())
        return f""INSERT INTO {self.table_name} ({keys}) VALUES ({values});""

    def update(self, data, condition):
        set_clause = ', '.join(f""{key} = '{value}'"" for key, value in data.items())
        return f""UPDATE {self.table_name} SET {set_clause} WHERE {condition};""

    def delete(self, condition):
        return f""DELETE FROM {self.table_name} WHERE {condition};""

    def select_female_under_age(self, age):
        return f""SELECT * FROM {self.table_name} WHERE age < {age} AND gender = 'female';""

    def select_by_age_range(self, min_age, max_age):
        return f""SELECT * FROM {self.table_name} WHERE age BETWEEN {min_age} AND {max_age};""
```",0.231475312,0.280645645,0.7,0.7,0.699999995,0.465517241,0.495412844,0.479999995,0.7,0.7,0.699999995,,,,,,,,,,,,
GPT,7,"class BalancedBrackets:
    def __init__(self, expr):
        self.stack = []
        self.left_brackets = [""("", ""{"", ""[""]
        self.right_brackets = ["")"", ""}"", ""]""]
        self.expr = expr

    def clear_expr(self):
        self.expr = ''.join(c for c in self.expr if (c in self.left_brackets or c in self.right_brackets))

    def check_balanced_brackets(self):
        self.clear_expr()
        for Brkt in self.expr:
            if Brkt in self.left_brackets:
                self.stack.append(Brkt)
            else:
                Current_Brkt = self.stack.pop()
                if Current_Brkt == ""("":
                    if Brkt != "")"":
                        return False
                if Current_Brkt == ""{"":
                    if Brkt != ""}"":
                        return False
                if Current_Brkt == ""["":
                    if Brkt != ""]"":
                        return False
        if self.stack:
            return False
        return True",COTFewShot,"```python
class BalancedBrackets:
    def __init__(self, expr):
        self.stack = []
        self.left_brackets = [""("", ""{"", ""[""]
        self.right_brackets = ["")"", ""}"", ""]""]
        self.expr = expr

    def clear_expr(self):
        self.expr = ''.join([c for c in self.expr if c in self.left_brackets + self.right_brackets])

    def check_balanced_brackets(self):
        for char in self.expr:
            if char in self.left_brackets:
                self.stack.append(char)
            elif char in self.right_brackets:
                if not self.stack:
                    return False
                top = self.stack.pop()
                if self.left_brackets.index(top) != self.right_brackets.index(char):
                    return False
        return not self.stack
```",0.3315341,0.385656131,0.653061224,0.711111111,0.680851059,0.5625,0.616438356,0.588235289,0.653061224,0.711111111,0.680851059,,,,,,,,,,,,
GPT,80,"class SQLQueryBuilder:

    @staticmethod
    def select(table, columns='*', where=None):
        if columns != '*':
            columns = ', '.join(columns)
        query = f""SELECT {columns} FROM {table}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query

    @staticmethod
    def insert(table, data):
        keys = ', '.join(data.keys())
        values = ', '.join(f""'{v}'"" for v in data.values())
        return f""INSERT INTO {table} ({keys}) VALUES ({values})""

    @staticmethod
    def delete(table, where=None):
        query = f""DELETE FROM {table}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query

    @staticmethod
    def update(table, data, where=None):
        update_str = ', '.join(f""{k}='{v}'"" for k, v in data.items())
        query = f""UPDATE {table} SET {update_str}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query",COTFewShot,"```python
class SQLQueryBuilder:
    @staticmethod
    def select(table, columns='*', where=None):
        if isinstance(columns, list):
            columns = ', '.join(columns)
        query = f""SELECT {columns} FROM {table}""
        if where:
            conditions = ' AND '.join([f""{key}='{value}'"" for key, value in where.items()])
            query += f"" WHERE {conditions}""
        return query

    @staticmethod
    def insert(table, data):
        columns = ', '.join(data.keys())
        values = ', '.join([f""'{value}'"" for value in data.values()])
        query = f""INSERT INTO {table} ({columns}) VALUES ({values})""
        return query

    @staticmethod
    def delete(table, where=None):
        query = f""DELETE FROM {table}""
        if where:
            conditions = ' AND '.join([f""{key}='{value}'"" for key, value in where.items()])
            query += f"" WHERE {conditions}""
        return query

    @staticmethod
    def update(table, data, where=None):
        set_clause = ', '.join([f""{key}='{value}'"" for key, value in data.items()])
        query = f""UPDATE {table} SET {set_clause}""
        if where:
            conditions = ' AND '.join([f""{key}='{value}'"" for key, value in where.items()])
            query += f"" WHERE {conditions}""
        return query
```",0.318181818,0.400996133,0.754385965,0.728813559,0.741379305,0.575,0.575,0.574999995,0.754385965,0.728813559,0.741379305,,,,,,,,,,,,
GPT,81,"import math
class Statistics3:
    @staticmethod
    def median(data):
        sorted_data = sorted(data)
        n = len(sorted_data)
        if n % 2 == 1:
            return sorted_data[n // 2]
        else:
            return (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2

    @staticmethod
    def mode(data):
        counts = {}
        for value in data:
            counts[value] = counts.get(value, 0) + 1
        max_count = max(counts.values())
        mode_values = [value for value, count in counts.items() if count == max_count]
        return mode_values

    @staticmethod
    def correlation(x, y):
        n = len(x)
        mean_x = sum(x) / n
        mean_y = sum(y) / n
        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))
        denominator = math.sqrt(sum((xi - mean_x) ** 2 for xi in x) * sum((yi - mean_y) ** 2 for yi in y))
        if denominator == 0:
            return None
        return numerator / denominator

    @staticmethod
    def mean(data):
        if len(data) == 0:
            return None
        return sum(data) / len(data)

    @staticmethod
    def correlation_matrix(data):
        matrix = []
        for i in range(len(data[0])):
            row = []
            for j in range(len(data[0])):
                column1 = [row[i] for row in data]
                column2 = [row[j] for row in data]
                correlation = Statistics3.correlation(column1, column2)
                row.append(correlation)
            matrix.append(row)
        return matrix

    @staticmethod
    def standard_deviation(data):
        n = len(data)
        if n < 2:
            return None
        mean_value = Statistics3.mean(data)
        variance = sum((x - mean_value) ** 2 for x in data) / (n - 1)
        return math.sqrt(variance)

    @staticmethod
    def z_score(data):
        mean = Statistics3.mean(data)
        std_deviation = Statistics3.standard_deviation(data)
        if std_deviation is None or std_deviation == 0:
            return None
        return [(x - mean) / std_deviation for x in data]",COTFewShot,"```python
import math
from collections import Counter

class Statistics3:
    @staticmethod
    def median(data):
        sorted_data = sorted(data)
        n = len(sorted_data)
        mid = n // 2
        if n % 2 == 0:
            return (sorted_data[mid - 1] + sorted_data[mid]) / 2.0
        else:
            return sorted_data[mid]

    @staticmethod
    def mode(data):
        count = Counter(data)
        max_count = max(count.values())
        return [k for k, v in count.items() if v == max_count]

    @staticmethod
    def correlation(x, y):
        n = len(x)
        mean_x = sum(x) / n
        mean_y = sum(y) / n
        covariance = sum((x[i] - mean_x) * (y[i] - mean_y) for i in range(n))
        std_x = math.sqrt(sum((xi - mean_x) ** 2 for xi in x))
        std_y = math.sqrt(sum((yi - mean_y) ** 2 for yi in y))
        return covariance / (std_x * std_y)

    @staticmethod
    def mean(data):
        return sum(data) / len(data)

    @staticmethod
    def correlation_matrix(data):
        n = len(data)
        matrix = [[0] * n for _ in range(n)]
        for i in range(n):
            for j in range(n):
                matrix[i][j] = Statistics3.correlation(data[i], data[j])
        return matrix

    @staticmethod
    def standard_deviation(data):
        mean = Statistics3.mean(data)
        variance = sum((x - mean) ** 2 for x in data) / len(data)
        return math.sqrt(variance)

    @staticmethod
    def z_score(data):
        mean = Statistics3.mean(data)
        std_dev = Statistics3.standard_deviation(data)
        return [(x - mean) / std_dev for x in data]
```",0.308727884,0.363646968,0.591304348,0.673267327,0.629629625,0.427906977,0.522727273,0.47058823,0.565217391,0.643564356,0.601851847,,,,,,,,,,,,
GPT,82,"class StockPortfolioTracker:
    def __init__(self, cash_balance):
        self.portfolio = []
        self.cash_balance = cash_balance

    def add_stock(self, stock):
        for pf in self.portfolio:
            if pf['name'] == stock['name']:
                pf['quantity'] += stock['quantity']
                return

        self.portfolio.append(stock)

    def remove_stock(self, stock):
        for pf in self.portfolio:
            if pf['name'] == stock['name'] and pf['quantity'] >= stock['quantity']:
                pf['quantity'] -= stock['quantity']
                if pf['quantity'] == 0:
                    self.portfolio.remove(pf)
                return True
        return False

    def buy_stock(self, stock):
        if stock['price'] * stock['quantity'] > self.cash_balance:
            return False
        else:
            self.add_stock(stock)
            self.cash_balance -= stock['price'] * stock['quantity']
            return True

    def sell_stock(self, stock):
        if self.remove_stock(stock) == False:
            return False
        self.cash_balance += stock['price'] * stock['quantity']
        return True

    def calculate_portfolio_value(self):
        total_value = self.cash_balance
        for stock in self.portfolio:
            total_value += stock['price'] * stock['quantity']
        return total_value

    def get_portfolio_summary(self):
        summary = []
        for stock in self.portfolio:
            value = self.get_stock_value(stock)
            summary.append({""name"": stock[""name""], ""value"": value})
        portfolio_value = self.calculate_portfolio_value()
        return portfolio_value, summary

    def get_stock_value(self, stock):
        return stock['price'] * stock['quantity']",COTFewShot,"```python
class StockPortfolioTracker:
    def __init__(self, cash_balance):
        self.portfolio = []
        self.cash_balance = cash_balance

    def add_stock(self, stock):
        self.portfolio.append(stock)

    def remove_stock(self, stock):
        if stock in self.portfolio:
            self.portfolio.remove(stock)
            return True
        return False

    def buy_stock(self, stock):
        total_cost = stock['price'] * stock['quantity']
        if self.cash_balance >= total_cost:
            self.add_stock(stock)
            self.cash_balance -= total_cost
            return True
        return False

    def sell_stock(self, stock):
        for s in self.portfolio:
            if s['name'] == stock['name'] and s['quantity'] >= stock['quantity']:
                s['quantity'] -= stock['quantity']
                self.cash_balance += stock['price'] * stock['quantity']
                if s['quantity'] == 0:
                    self.portfolio.remove(s)
                return True
        return False

    def calculate_portfolio_value(self):
        total_value = self.cash_balance
        for stock in self.portfolio:
            total_value += stock['price'] * stock['quantity']
        return total_value

    def get_portfolio_summary(self):
        total_value = self.calculate_portfolio_value()
        summary = [{'name': stock['name'], 'value': stock['price'] * stock['quantity']} for stock in self.portfolio]
        return total_value, summary

    def get_stock_value(self, stock):
        return stock['price'] * stock['quantity']
```",0.38254649,0.465101523,0.7,0.736842105,0.717948713,0.592920354,0.626168224,0.609090904,0.7,0.736842105,0.717948713,,,,,,,,,,,,
GPT,83,"import sqlite3


class StudentDatabaseProcessor:

    def __init__(self, database_name):
        self.database_name = database_name

    def create_student_table(self):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        create_table_query = """"""
        CREATE TABLE IF NOT EXISTS students (
            id INTEGER PRIMARY KEY,
            name TEXT,
            age INTEGER,
            gender TEXT,
            grade INTEGER
        )
        """"""
        cursor.execute(create_table_query)

        conn.commit()
        conn.close()

    def insert_student(self, student_data):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        insert_query = """"""
        INSERT INTO students (name, age, gender, grade)
        VALUES (?, ?, ?, ?)
        """"""
        cursor.execute(insert_query,
                       (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))

        conn.commit()
        conn.close()

    def search_student_by_name(self, name):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        select_query = ""SELECT * FROM students WHERE name = ?""
        cursor.execute(select_query, (name,))
        result = cursor.fetchall()

        conn.close()

        return result

    def delete_student_by_name(self, name):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        delete_query = ""DELETE FROM students WHERE name = ?""
        cursor.execute(delete_query, (name,))

        conn.commit()
        conn.close()",COTFewShot,"```python
import sqlite3

class StudentDatabaseProcessor:
    def __init__(self, database_name):
        self.database_name = database_name

    def create_student_table(self):
        with sqlite3.connect(self.database_name) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS students (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    age INTEGER NOT NULL,
                    gender TEXT NOT NULL,
                    grade INTEGER NOT NULL
                )
            ''')
            conn.commit()

    def insert_student(self, student_data):
        with sqlite3.connect(self.database_name) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO students (name, age, gender, grade)
                VALUES (:name, :age, :gender, :grade)
            ''', student_data)
            conn.commit()

    def search_student_by_name(self, name):
        with sqlite3.connect(self.database_name) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT * FROM students WHERE name = ?
            ''', (name,))
            return cursor.fetchall()

    def delete_student_by_name(self, name):
        with sqlite3.connect(self.database_name) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                DELETE FROM students WHERE name = ?
            ''', (name,))
            conn.commit()
```",0.306482497,0.360534149,0.675675676,0.704225352,0.689655167,0.440366972,0.505263158,0.47058823,0.662162162,0.690140845,0.675862064,,,,,,,,,,,,
GPT,84,"import json


class TextFileProcessor:
    def __init__(self, file_path):
        self.file_path = file_path

    def read_file_as_json(self):
        with open(self.file_path, 'r') as file:
            data = json.load(file)

        return data

    def read_file(self):
        with open(self.file_path, 'r') as file:
            return file.read()

    def write_file(self, content):
        with open(self.file_path, 'w') as file:
            file.write(content)

    def process_file(self):
        content = self.read_file()
        content = ''.join([char for char in content if char.isalpha()])
        self.write_file(content)
        return content",COTFewShot,"```python
import sqlite3

class StudentDatabaseProcessor:
    def __init__(self, database_name):
        self.database_name = database_name

    def create_student_table(self):
        try:
            conn = sqlite3.connect(self.database_name)
            cursor = conn.cursor()
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS students (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    age INTEGER,
                    gender TEXT,
                    grade INTEGER
                )
            ''')
            conn.commit()
        finally:
            conn.close()

    def insert_student(self, student_data):
        try:
            conn = sqlite3.connect(self.database_name)
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO students (name, age, gender, grade)
                VALUES (?, ?, ?, ?)
            ''', (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))
            conn.commit()
        finally:
            conn.close()

    def search_student_by_name(self, name):
        try:
            conn = sqlite3.connect(self.database_name)
            cursor = conn.cursor()
            cursor.execute('''
                SELECT * FROM students WHERE name = ?
            ''', (name,))
            results = cursor.fetchall()
            return results
        finally:
            conn.close()

    def delete_student_by_name(self, name):
        try:
            conn = sqlite3.connect(self.database_name)
            cursor = conn.cursor()
            cursor.execute('''
                DELETE FROM students WHERE name = ?
            ''', (name,))
            conn.commit()
        finally:
            conn.close()
```",0.000775194,0.166219578,0.184210526,0.093333333,0.123893801,0.017241379,0.009803922,0.012499995,0.184210526,0.093333333,0.123893801,,,,,,,,,,,,
GPT,85,"import time

class Thermostat:
    def __init__(self, current_temperature, target_temperature, mode):
        self.current_temperature = current_temperature
        self.target_temperature = target_temperature
        self.mode = mode

    def get_target_temperature(self):
        return self.target_temperature

    def set_target_temperature(self, temperature):
        self.target_temperature = temperature

    def get_mode(self):
        return self.mode

    def set_mode(self, mode):
        if mode in ['heat', 'cool']:
            self.mode = mode
        else:
            return False

    def auto_set_mode(self):
        if self.current_temperature < self.target_temperature:
            self.mode = 'heat'
        else:
            self.mode = 'cool'

    def auto_check_conflict(self):
        if self.current_temperature > self.target_temperature:
            if self.mode == 'cool':
                return True
            else:
                self.auto_set_mode()
                return False
        else:
            if self.mode == 'heat':
                return True
            else:
                self.auto_set_mode()
                return False

    def simulate_operation(self):
        self.auto_set_mode()
        use_time = 0
        if self.mode == 'heat':
            while(self.current_temperature < self.target_temperature):
                self.current_temperature += 1
                use_time += 1
        else:
            while(self.current_temperature > self.target_temperature):
                self.current_temperature -= 1
                use_time += 1
        return use_time",COTFewShot,"```python
import time

class Thermostat:
    def __init__(self, current_temperature, target_temperature, mode):
        self.current_temperature = current_temperature
        self.target_temperature = target_temperature
        self.mode = mode

    def get_target_temperature(self):
        return self.target_temperature

    def set_target_temperature(self, temperature):
        self.target_temperature = temperature

    def get_mode(self):
        return self.mode

    def set_mode(self, mode):
        if mode in ['heat', 'cool']:
            self.mode = mode

    def auto_set_mode(self):
        if self.current_temperature < self.target_temperature:
            self.mode = 'heat'
        else:
            self.mode = 'cool'

    def auto_check_conflict(self):
        if (self.mode == 'heat' and self.current_temperature >= self.target_temperature) or \
           (self.mode == 'cool' and self.current_temperature <= self.target_temperature):
            self.auto_set_mode()
            return False
        return True

    def simulate_operation(self):
        self.auto_set_mode()
        time_elapsed = 0
        while not self.auto_check_conflict():
            if self.mode == 'heat':
                self.current_temperature += 1
            elif self.mode == 'cool':
                self.current_temperature -= 1
            time.sleep(1)
            time_elapsed += 1
        return time_elapsed
```",0.547568774,0.593601949,0.936170213,0.745762712,0.830188674,0.77173913,0.669811321,0.717171712,0.936170213,0.745762712,0.830188674,,,,,,,,,,,,
GPT,86,"class TicTacToe:
    def __init__(self, N=3):
        self.board = [[' ' for _ in range(N)] for _ in range(3)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        else:
            return False

    def check_winner(self):
        for row in self.board:
            if row[0] == row[1] == row[2] != ' ':
                return row[0]
        for col in range(3):
            if self.board[0][col] == self.board[1][col] == self.board[2][col] != ' ':
                return self.board[0][col]
        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':
            return self.board[0][0]
        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':
            return self.board[0][2]
        return None

    def is_board_full(self):
        for row in self.board:
            if ' ' in row:
                return False
        return True",COTFewShot,"```python
class TicTacToe:
    def __init__(self, N=3):
        self.board = [[' ' for _ in range(N)] for _ in range(N)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        return False

    def check_winner(self):
        lines = self.board + [list(col) for col in zip(*self.board)] + [[self.board[i][i] for i in range(3)], [self.board[i][2-i] for i in range(3)]]
        for line in lines:
            if line.count(line[0]) == 3 and line[0] != ' ':
                return line[0]
        return None

    def is_board_full(self):
        return all(cell != ' ' for row in self.board for cell in row)
```",0.396573337,0.438191317,0.68,0.596491228,0.635514014,0.546391753,0.552083333,0.549222793,0.68,0.596491228,0.635514014,,,,,,,,,,,,
GPT,87,"import datetime
import time

class TimeUtils:

    def __init__(self):
        self.datetime = datetime.datetime.now()

    def get_current_time(self):
        format = ""%H:%M:%S""
        return self.datetime.strftime(format)

    def get_current_date(self):
        format = ""%Y-%m-%d""
        return self.datetime.strftime(format)

    def add_seconds(self, seconds):
        new_datetime = self.datetime + datetime.timedelta(seconds=seconds)
        format = ""%H:%M:%S""
        return new_datetime.strftime(format)

    def string_to_datetime(self, string):
        return datetime.datetime.strptime(string, ""%Y-%m-%d %H:%M:%S"")

    def datetime_to_string(self, datetime):
        return datetime.strftime(""%Y-%m-%d %H:%M:%S"")

    def get_minutes(self, string_time1, string_time2):
        time1 = self.string_to_datetime(string_time1)
        time2 = self.string_to_datetime(string_time2)
        return round((time2 - time1).seconds / 60)

    def get_format_time(self, year, month, day, hour, minute, second):
        format = ""%Y-%m-%d %H:%M:%S""
        time_item = datetime.datetime(year, month, day, hour, minute, second)
        return time_item.strftime(format)",COTFewShot,"```python
import datetime
import time

class TimeUtils:
    def __init__(self):
        self.datetime = datetime.datetime.now()

    def get_current_time(self):
        return self.datetime.strftime('%H:%M:%S')

    def get_current_date(self):
        return self.datetime.strftime('%Y-%m-%d')

    def add_seconds(self, seconds):
        new_time = self.datetime + datetime.timedelta(seconds=seconds)
        return new_time.strftime('%H:%M:%S')

    def string_to_datetime(self, string):
        return datetime.datetime.strptime(string, '%Y-%m-%d %H:%M:%S')

    def datetime_to_string(self, dt):
        return dt.strftime('%Y-%m-%d %H:%M:%S')

    def get_minutes(self, string_time1, string_time2):
        time1 = self.string_to_datetime(string_time1)
        time2 = self.string_to_datetime(string_time2)
        delta = time2 - time1
        return round(delta.total_seconds() / 60)

    def get_format_time(self, year, month, day, hour, minute, second):
        dt = datetime.datetime(year, month, day, hour, minute, second)
        return dt.strftime('%Y-%m-%d %H:%M:%S')
```",0.447610949,0.50475548,0.740740741,0.754716981,0.747663546,0.6,0.614457831,0.607142852,0.740740741,0.754716981,0.747663546,,,,,,,,,,,,
GPT,88,"from math import pi, fabs


class TriCalculator:

    def __init__(self):
        pass

    def cos(self, x):
        return round(self.taylor(x, 50), 10)

    def factorial(self, a):
        b = 1
        while a != 1:
            b *= a
            a -= 1
        return b

    def taylor(self, x, n):
        a = 1
        x = x / 180 * pi
        count = 1
        for k in range(1, n):
            if count % 2 != 0:
                a -= (x ** (2 * k)) / self.factorial(2 * k)
            else:
                a += (x ** (2 * k)) / self.factorial(2 * k)
            count += 1
        return a

    def sin(self, x):
        x = x / 180 * pi
        g = 0
        t = x
        n = 1

        while fabs(t) >= 1e-15:
            g += t
            n += 1
            t = -t * x * x / (2 * n - 1) / (2 * n - 2)
        return round(g, 10)

    def tan(self, x):
        if self.cos(x) != 0:
            result = self.sin(x) / self.cos(x)
            return round(result, 10)
        else:
            return False",COTFewShot,"```python
from math import pi, fabs

class TriCalculator:
    def __init__(self):
        pass

    def cos(self, x):
        return self.taylor(x, 50)

    def factorial(self, a):
        if a == 0:
            return 1
        else:
            return a * self.factorial(a - 1)

    def taylor(self, x, n):
        x = x * pi / 180
        result = 0
        for i in range(n):
            result += ((-1) ** i) * (x ** (2 * i)) / self.factorial(2 * i)
        return result

    def sin(self, x):
        return self.taylor(x - 90, 50)

    def tan(self, x):
        cos_x = self.cos(x)
        if fabs(cos_x) < 1e-10:
            raise ValueError(""Tangent is undefined for this angle."")
        return self.sin(x) / cos_x
```",0.116195773,0.160119025,0.630136986,0.666666667,0.647887319,0.323076923,0.42,0.365217386,0.602739726,0.637681159,0.619718305,,,,,,,,,,,,
GPT,89,"import random


class TwentyFourPointGame:
    def __init__(self) -> None:
        self.nums = []

    def _generate_cards(self):
        for i in range(4):
            self.nums.append(random.randint(1, 9))
        assert len(self.nums) == 4

    def get_my_cards(self):
        self.nums = []
        self._generate_cards()
        return self.nums

    def answer(self, expression):
        if expression == 'pass':
            return self.get_my_cards()
        statistic = {}
        for c in expression:
            if c.isdigit() and int(c) in self.nums:
                statistic[c] = statistic.get(c, 0) + 1

        nums_used = statistic.copy()

        for num in self.nums:
            if nums_used.get(str(num), -100) != -100 and nums_used[str(num)] > 0:
                nums_used[str(num)] -= 1
            else:
                return False

        if all(count == 0 for count in nums_used.values()) == True:
            return self.evaluate_expression(expression)
        else:
            return False

    def evaluate_expression(self, expression):
        try:
            if eval(expression) == 24:
                return True
            else:
                return False
        except Exception as e:
            return False",COTFewShot,"```python
import random

class TwentyFourPointGame:
    def __init__(self):
        self.nums = []

    def _generate_cards(self):
        self.nums = [random.randint(1, 9) for _ in range(4)]

    def get_my_cards(self):
        self._generate_cards()
        return self.nums

    def answer(self, expression):
        try:
            result = eval(expression)
            return result == 24
        except:
            return False

    def evaluate_expression(self, expression):
        return self.answer(expression)
```",0.063812492,0.080912854,0.306666667,0.676470588,0.422018344,0.189655172,0.47826087,0.271604934,0.293333333,0.647058824,0.40366972,,,,,,,,,,,,
GPT,8,"class BankAccount:
    def __init__(self, balance=0):
        self.balance = balance

    def deposit(self, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        self.balance += amount
        return self.balance

    def withdraw(self, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient balance."")
        self.balance -= amount
        return self.balance

    def view_balance(self):
        return self.balance

    def transfer(self, other_account, amount):
        self.withdraw(amount)
        other_account.deposit(amount)",COTFewShot,"```python
class BankAccount:
    def __init__(self, balance=0):
        self.balance = balance

    def deposit(self, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        self.balance += amount
        return self.balance

    def withdraw(self, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient funds"")
        self.balance -= amount
        return self.balance

    def view_balance(self):
        return self.balance

    def transfer(self, other_account, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient funds"")
        self.withdraw(amount)
        other_account.deposit(amount)
```",0.695652174,0.714598587,0.967741935,0.909090909,0.937499995,0.911111111,0.911111111,0.911111106,0.967741935,0.909090909,0.937499995,,,,,,,,,,,,
GPT,90,"class URLHandler:
    def __init__(self, url):
        self.url = url

    def get_scheme(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            return self.url[:scheme_end]
        return None

    def get_host(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            url_without_scheme = self.url[scheme_end + 3:]
            host_end = url_without_scheme.find(""/"")
            if host_end != -1:
                return url_without_scheme[:host_end]
            return url_without_scheme
        return None

    def get_path(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            url_without_scheme = self.url[scheme_end + 3:]
            host_end = url_without_scheme.find(""/"")
            if host_end != -1:
                return url_without_scheme[host_end:]
        return None

    def get_query_params(self):
        query_start = self.url.find(""?"")
        fragment_start = self.url.find(""#"")
        if query_start != -1:
            query_string = self.url[query_start + 1:fragment_start]
            params = {}
            if len(query_string) > 0:
                param_pairs = query_string.split(""&"")
                for pair in param_pairs:
                    key_value = pair.split(""="")
                    if len(key_value) == 2:
                        key, value = key_value
                        params[key] = value
            return params
        return None

    def get_fragment(self):
        fragment_start = self.url.find(""#"")
        if fragment_start != -1:
            return self.url[fragment_start + 1:]
        return None",COTFewShot,"```python
class URLHandler:
    def __init__(self, url):
        self.url = url

    def get_scheme(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            return self.url[:scheme_end]
        return """"

    def get_host(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            host_start = scheme_end + 3
            host_end = self.url.find(""/"", host_start)
            if host_end == -1:
                host_end = len(self.url)
            return self.url[host_start:host_end]
        return """"

    def get_path(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            host_start = scheme_end + 3
            path_start = self.url.find(""/"", host_start)
            if path_start != -1:
                return self.url[path_start:]
        return """"

    def get_query_params(self):
        query_start = self.url.find(""?"")
        fragment_start = self.url.find(""#"")
        if query_start != -1:
            query_end = fragment_start if fragment_start != -1 else len(self.url)
            query_string = self.url[query_start + 1:query_end]
            params = {}
            for param in query_string.split(""&""):
                key_value = param.split(""="")
                if len(key_value) == 2:
                    params[key_value[0]] = key_value[1]
            return params
        return {}

    def get_fragment(self):
        fragment_start = self.url.find(""#"")
        if fragment_start != -1:
            return self.url[fragment_start + 1:]
        return """"
```",0.442028986,0.507986325,0.684210526,0.661016949,0.672413788,0.568627451,0.532110092,0.549763028,0.684210526,0.661016949,0.672413788,,,,,,,,,,,,
GPT,91,"import urllib.parse


class UrlPath:
    def __init__(self):
        self.segments = []
        self.with_end_tag = False

    def add(self, segment):
        self.segments.append(self.fix_path(segment))

    def parse(self, path, charset):
        if path:
            if path.endswith('/'):
                self.with_end_tag = True

            path = self.fix_path(path)
            if path:
                split = path.split('/')
                for seg in split:
                    decoded_seg = urllib.parse.unquote(seg, encoding=charset)
                    self.segments.append(decoded_seg)

    @staticmethod
    def fix_path(path):
        if not path:
            return ''

        segment_str = path.strip('/')
        return segment_str",COTFewShot,"```python
import urllib.parse

class UrlPath:
    def __init__(self):
        self.segments = []
        self.with_end_tag = False

    def add(self, segment):
        self.segments.append(segment)

    def parse(self, path, charset):
        path = self.fix_path(path)
        self.segments = [urllib.parse.unquote(segment, encoding=charset) for segment in path.split('/') if segment]

    @staticmethod
    def fix_path(path):
        return path.strip('/')
```",0.292475957,0.336069223,0.674418605,0.805555556,0.73417721,0.4375,0.595744681,0.5045045,0.674418605,0.805555556,0.73417721,,,,,,,,,,,,
GPT,92,"import sqlite3


class UserLoginDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()

    def insert_user(self, username, password):
        self.cursor.execute('''
            INSERT INTO users (username, password)
            VALUES (?, ?)
        ''', (username, password))
        self.connection.commit()

    def search_user_by_username(self, username):
        self.cursor.execute('''
            SELECT * FROM users WHERE username = ?
        ''', (username,))
        user = self.cursor.fetchone()
        return user

    def delete_user_by_username(self, username):
        self.cursor.execute('''
            DELETE FROM users WHERE username = ?
        ''', (username,))
        self.connection.commit()

    def validate_user_login(self, username, password):
        user = self.search_user_by_username(username)
        if user is not None and user[1] == password:
            return True
        return False",COTFewShot,"```python
import sqlite3

class UserLoginDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''CREATE TABLE IF NOT EXISTS users (
                               username TEXT PRIMARY KEY,
                               password TEXT NOT NULL)''')
        self.connection.commit()

    def insert_user(self, username, password):
        self.cursor.execute(""INSERT INTO users (username, password) VALUES (?, ?)"", (username, password))
        self.connection.commit()

    def search_user_by_username(self, username):
        self.cursor.execute(""SELECT * FROM users WHERE username = ?"", (username,))
        return self.cursor.fetchall()

    def delete_user_by_username(self, username):
        self.cursor.execute(""DELETE FROM users WHERE username = ?"", (username,))
        self.connection.commit()

    def validate_user_login(self, username, password):
        self.cursor.execute(""SELECT * FROM users WHERE username = ? AND password = ?"", (username, password))
        return bool(self.cursor.fetchone())

    def __del__(self):
        self.connection.close()
```",0.354166667,0.391758023,0.648148148,0.573770492,0.608695647,0.558441558,0.467391304,0.508875735,0.648148148,0.573770492,0.608695647,,,,,,,,,,,,
GPT,93,"import numpy as np
from gensim import matutils
from numpy import dot, array


class VectorUtil:
    @staticmethod
    def similarity(vector_1, vector_2):
        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))

    @staticmethod
    def cosine_similarities(vector_1, vectors_all):
        norm = np.linalg.norm(vector_1)
        all_norms = np.linalg.norm(vectors_all, axis=1)
        dot_products = dot(vectors_all, vector_1)
        similarities = dot_products / (norm * all_norms)
        return similarities

    @staticmethod
    def n_similarity(vector_list_1, vector_list_2):
        if not (len(vector_list_1) and len(vector_list_2)):
            raise ZeroDivisionError('At least one of the passed list is empty.')

        return dot(matutils.unitvec(array(vector_list_1).mean(axis=0)),
                   matutils.unitvec(array(vector_list_2).mean(axis=0)))

    @staticmethod
    def compute_idf_weight_dict(total_num, number_dict):
        index_2_key_map = {}

        index = 0

        count_list = []
        for key, count in number_dict.items():
            index_2_key_map[index] = key
            count_list.append(count)
            index = index + 1

        a = np.array(count_list)
        ## smooth, in case the divide by zero error
        a = np.log((total_num + 1) / (a + 1))
        result = {}

        for index, w in enumerate(a):
            key = index_2_key_map[index]
            result[key] = w

        return result",COTFewShot,"```python
import numpy as np
from gensim import matutils
from numpy import dot, array

class VectorUtil:
    @staticmethod
    def similarity(vector_1, vector_2):
        return dot(matutils.unitvec(array(vector_1)), matutils.unitvec(array(vector_2)))

    @staticmethod
    def cosine_similarities(vector_1, vectors_all):
        return [dot(matutils.unitvec(array(vector_1)), matutils.unitvec(array(vector_2))) for vector_2 in vectors_all]

    @staticmethod
    def n_similarity(vector_list_1, vector_list_2):
        mean_vector_1 = matutils.unitvec(array(vector_list_1).mean(axis=0))
        mean_vector_2 = matutils.unitvec(array(vector_list_2).mean(axis=0))
        return dot(mean_vector_1, mean_vector_2)

    @staticmethod
    def compute_idf_weight_dict(total_num, number_dict):
        return {key: np.log((total_num + 1) / (count + 1)) for key, count in number_dict.items()}
```",0.160947256,0.182882552,0.378947368,0.705882353,0.49315068,0.266666667,0.52173913,0.352941172,0.378947368,0.705882353,0.49315068,,,,,,,,,,,,
GPT,94,"class VendingMachine:
    def __init__(self):
        self.inventory = {}
        self.balance = 0

    def add_item(self, item_name, price, quantity):
        if not self.restock_item(item_name, quantity):
            self.inventory[item_name] = {'price': price, 'quantity': quantity}

    def insert_coin(self, amount):
        self.balance += amount
        return self.balance

    def purchase_item(self, item_name):
        if item_name in self.inventory:
            item = self.inventory[item_name]
            if item['quantity'] > 0 and self.balance >= item['price']:
                self.balance -= item['price']
                item['quantity'] -= 1
                return self.balance
            else:
                return False
        else:
            return False

    def restock_item(self, item_name, quantity):
        if item_name in self.inventory:
            self.inventory[item_name]['quantity'] += quantity
            return True
        else:
            return False

    def display_items(self):
        if not self.inventory:
            return False
        else:
            items = []
            for item_name, item_info in self.inventory.items():
                items.append(f""{item_name} - ${item_info['price']} [{item_info['quantity']}]"")
            return ""\n"".join(items)",COTFewShot,"```python
class VendingMachine:
    def __init__(self):
        self.inventory = {}
        self.balance = 0

    def add_item(self, item_name, price, quantity):
        self.inventory[item_name] = {'price': price, 'quantity': quantity}

    def insert_coin(self, amount):
        self.balance += amount
        return self.balance

    def purchase_item(self, item_name):
        if item_name in self.inventory and self.inventory[item_name]['quantity'] > 0:
            item_price = self.inventory[item_name]['price']
            if self.balance >= item_price:
                self.inventory[item_name]['quantity'] -= 1
                self.balance -= item_price
                return self.balance
        return False

    def restock_item(self, item_name, quantity):
        if item_name in self.inventory:
            self.inventory[item_name]['quantity'] += quantity
            return True
        return False

    def display_items(self):
        if not self.inventory:
            return False
        return [f""{item} - ${info['price']} [{info['quantity']}]"" for item, info in self.inventory.items()]
```",0.512086981,0.566964056,0.74137931,0.781818182,0.761061942,0.635416667,0.685393258,0.659459454,0.724137931,0.763636364,0.743362827,,,,,,,,,,,,
GPT,95,"class Warehouse:
    def __init__(self):
        self.inventory = {}  # Product ID: Product
        self.orders = {}  # Order ID: Order

    def add_product(self, product_id, name, quantity):
        if product_id not in self.inventory:
            self.inventory[product_id] = {'name': name, 'quantity': quantity}
        else:
            self.inventory[product_id]['quantity'] += quantity

    def update_product_quantity(self, product_id, quantity):
        if product_id in self.inventory:
            self.inventory[product_id]['quantity'] += quantity

    def get_product_quantity(self, product_id):
        if product_id in self.inventory:
            return self.inventory[product_id]['quantity']
        else:
            return False

    def create_order(self, order_id, product_id, quantity):
        if self.get_product_quantity(product_id) >= quantity:
            self.update_product_quantity(product_id, -quantity)
            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}
        else:
            return False

    def change_order_status(self, order_id, status):
        if order_id in self.orders:
            self.orders[order_id]['status'] = status
        else:
            return False

    def track_order(self, order_id):
        if order_id in self.orders:
            return self.orders[order_id]['status']
        else:
            return False",COTFewShot,"```python
class Warehouse:
    def __init__(self):
        self.inventory = {}
        self.orders = {}

    def add_product(self, product_id, name, quantity):
        if product_id in self.inventory:
            self.inventory[product_id]['quantity'] += quantity
        else:
            self.inventory[product_id] = {'name': name, 'quantity': quantity}

    def update_product_quantity(self, product_id, quantity):
        if product_id in self.inventory:
            self.inventory[product_id]['quantity'] += quantity

    def get_product_quantity(self, product_id):
        if product_id in self.inventory:
            return self.inventory[product_id]['quantity']
        return False

    def create_order(self, order_id, product_id, quantity):
        if product_id in self.inventory and self.inventory[product_id]['quantity'] >= quantity:
            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}
            self.inventory[product_id]['quantity'] -= quantity
            return True
        return False

    def change_order_status(self, order_id, status):
        if order_id in self.orders:
            self.orders[order_id]['status'] = status
            return True
        return False

    def track_order(self, order_id):
        if order_id in self.orders:
            return self.orders[order_id]['status']
        return False
```",0.616931553,0.671606323,0.854545455,0.903846154,0.878504668,0.747252747,0.790697674,0.768361577,0.854545455,0.903846154,0.878504668,,,,,,,,,,,,
GPT,96,"class WeatherSystem:
    def __init__(self, city) -> None:
        self.temperature = None
        self.weather = None
        self.city = city
        self.weather_list = {}
    
    def query(self, weather_list, tmp_units = 'celsius'):
        self.weather_list = weather_list
        if self.city not in weather_list:
            return False
        else:
            self.temperature = self.weather_list[self.city]['temperature']
            self.weather = self.weather_list[self.city]['weather']
        if self.weather_list[self.city]['temperature units'] != tmp_units:
            if tmp_units == 'celsius':
                return self.fahrenheit_to_celsius(), self.weather
            elif tmp_units == 'fahrenheit':
                return self.celsius_to_fahrenheit(), self.weather
        else:
            return self.temperature, self.weather
    
    def set_city(self, city):
        self.city = city

    def celsius_to_fahrenheit(self):
        return (self.temperature * 9/5) + 32

    def fahrenheit_to_celsius(self):
        return (self.temperature - 32) * 5/9",COTFewShot,"```python
class WeatherSystem:
    def __init__(self, city):
        self.temperature = None
        self.weather = None
        self.city = city
        self.weather_list = {}

    def query(self, weather_list, tmp_units='celsius'):
        self.weather_list = weather_list
        if self.city in weather_list:
            self.weather = weather_list[self.city]['weather']
            self.temperature = weather_list[self.city]['temperature']
            if tmp_units == 'fahrenheit' and weather_list[self.city]['temperature units'] == 'celsius':
                self.temperature = self.celsius_to_fahrenheit()
            elif tmp_units == 'celsius' and weather_list[self.city]['temperature units'] == 'fahrenheit':
                self.temperature = self.fahrenheit_to_celsius()
            return (self.temperature, self.weather)
        else:
            return None

    def set_city(self, city):
        self.city = city

    def celsius_to_fahrenheit(self):
        return (self.temperature * 9/5) + 32

    def fahrenheit_to_celsius(self):
        return (self.temperature - 32) * 5/9
```",0.465116279,0.535345402,0.807692308,0.823529412,0.815533976,0.635294118,0.666666667,0.650602405,0.807692308,0.823529412,0.815533976,,,,,,,,,,,,
GPT,97,"class Words2Numbers:

    def __init__(self):
        self.numwords = {}
        self.units = [
            ""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"",
            ""nine"", ""ten"", ""eleven"", ""twelve"", ""thirteen"", ""fourteen"", ""fifteen"",
            ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen"",
        ]
        self.tens = ["""", """", ""twenty"", ""thirty"", ""forty"", ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""]
        self.scales = [""hundred"", ""thousand"", ""million"", ""billion"", ""trillion""]

        self.numwords[""and""] = (1, 0)
        for idx, word in enumerate(self.units):
            self.numwords[word] = (1, idx)
        for idx, word in enumerate(self.tens):
            self.numwords[word] = (1, idx * 10)
        for idx, word in enumerate(self.scales):
            self.numwords[word] = (10 ** (idx * 3 or 2), 0)

        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}
        self.ordinal_endings = [('ieth', 'y'), ('th', '')]

    def text2int(self, textnum):
        textnum = textnum.replace('-', ' ')

        current = result = 0
        curstring = """"
        onnumber = False
        for word in textnum.split():
            if word in self.ordinal_words:
                scale, increment = (1, self.ordinal_words[word])
                current = current * scale + increment
                onnumber = True
            else:
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = ""%s%s"" % (word[:-len(ending)], replacement)

                if word not in self.numwords:
                    if onnumber:
                        curstring += repr(result + current) + "" ""
                    curstring += word + "" ""
                    result = current = 0
                    onnumber = False
                else:
                    scale, increment = self.numwords[word]
                    current = current * scale + increment
                    if scale > 100:
                        result += current
                        current = 0
                    onnumber = True

        if onnumber:
            curstring += repr(result + current)

        return curstring

    def is_valid_input(self, textnum):

        textnum = textnum.replace('-', ' ')

        for word in textnum.split():
            if word in self.ordinal_words:
                continue
            else:
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = ""%s%s"" % (word[:-len(ending)], replacement)

                if word not in self.numwords:
                    return False

        return True",COTFewShot,"```python
class Words2Numbers:
    def __init__(self):
        self.numwords = {}
        self.units = [
            ""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"",
            ""nine"", ""ten"", ""eleven"", ""twelve"", ""thirteen"", ""fourteen"", ""fifteen"",
            ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen"",
        ]
        self.tens = ["""", """", ""twenty"", ""thirty"", ""forty"", ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""]
        self.scales = [""hundred"", ""thousand"", ""million"", ""billion"", ""trillion""]

        self.numwords[""and""] = (1, 0)
        for idx, word in enumerate(self.units):
            self.numwords[word] = (1, idx)
        for idx, word in enumerate(self.tens):
            self.numwords[word] = (1, idx * 10)
        for idx, word in enumerate(self.scales):
            self.numwords[word] = (10 ** (idx * 3 or 2), 0)

        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}
        self.ordinal_endings = [('ieth', 'y'), ('th', '')]

    def text2int(self, textnum):
        current = result = 0
        words = textnum.replace('-', ' ').split()

        for word in words:
            if word in self.ordinal_words:
                scale, increment = (1, self.ordinal_words[word])
            else:
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = word[:-len(ending)] + replacement

                if word not in self.numwords:
                    raise ValueError(f""Invalid word: {word}"")

                scale, increment = self.numwords[word]

            current = current * scale + increment
            if scale > 100:
                result += current
                current = 0

        return str(result + current)

    def is_valid_input(self, textnum):
        words = textnum.replace('-', ' ').split()
        for word in words:
            if word not in self.numwords and word not in self.ordinal_words:
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = word[:-len(ending)] + replacement
                if word not in self.numwords:
                    return False
        return True
```",0.629817136,0.660897867,0.909774436,0.909774436,0.909774431,0.783653846,0.857894737,0.819095472,0.909774436,0.909774436,0.909774431,,,,,,,,,,,,
GPT,98,"import xml.etree.ElementTree as ET


class XMLProcessor:
    def __init__(self, file_name):
        self.file_name = file_name
        self.root = None

    def read_xml(self):
        try:
            tree = ET.parse(self.file_name)
            self.root = tree.getroot()
            return self.root
        except:
            return None

    def write_xml(self, file_name):
        try:
            tree = ET.ElementTree(self.root)
            tree.write(file_name)
            return True
        except:
            return False

    def process_xml_data(self, file_name):
        for element in self.root.iter('item'):
            text = element.text
            element.text = text.upper()
        return self.write_xml(file_name)

    def find_element(self, element_name):
        elements = self.root.findall(element_name)
        return elements",COTFewShot,"```python
import xml.etree.ElementTree as ET

class XMLProcessor:
    def __init__(self, file_name):
        self.file_name = file_name
        self.root = None

    def read_xml(self):
        try:
            tree = ET.parse(self.file_name)
            self.root = tree.getroot()
            return self.root
        except:
            return None

    def write_xml(self, output_file_name):
        try:
            tree = ET.ElementTree(self.root)
            tree.write(output_file_name)
            return True
        except:
            return False

    def process_xml_data(self, output_file_name):
        try:
            # Example modification: append a new element
            new_element = ET.Element('new_element')
            new_element.text = 'new_value'
            self.root.append(new_element)
            return self.write_xml(output_file_name)
        except:
            return False

    def find_element(self, element_name):
        try:
            return self.root.findall(element_name)
        except:
            return []
```",0.5,0.536611611,0.833333333,0.68627451,0.752688167,0.661971831,0.618421053,0.639455777,0.833333333,0.68627451,0.752688167,,,,,,,,,,,,
GPT,99,"import zipfile


class ZipFileProcessor:
    def __init__(self, file_name):
        self.file_name = file_name

    def read_zip_file(self):
        try:
            zip_file = zipfile.ZipFile(self.file_name, 'r')
            return zip_file
        except:
            return None

    def extract_all(self, output_path):
        try:
            with zipfile.ZipFile(self.file_name, 'r') as zip_file:
                zip_file.extractall(output_path)
            return True
        except:
            return False

    def extract_file(self, file_name, output_path):
        try:
            with zipfile.ZipFile(self.file_name, 'r') as zip_file:
                zip_file.extract(file_name, output_path)
            return True
        except:
            return False

    def create_zip_file(self, files, output_file_name):
        try:
            with zipfile.ZipFile(output_file_name, 'w') as zip_file:
                for file in files:
                    zip_file.write(file)
            return True
        except:
            return False",COTFewShot,"```python
import zipfile


class ZipFileProcessor:
    def __init__(self, file_name):
        self.file_name = file_name

    def read_zip_file(self):
        try:
            zip_file = zipfile.ZipFile(self.file_name, 'r')
            return zip_file
        except:
            return None

    def extract_all(self, output_path):
        try:
            with zipfile.ZipFile(self.file_name, 'r') as zip_file:
                zip_file.extractall(output_path)
            return True
        except:
            return False

    def extract_file(self, file_name, output_path):
        try:
            with zipfile.ZipFile(self.file_name, 'r') as zip_file:
                zip_file.extract(file_name, output_path)
            return True
        except:
            return False

    def create_zip_file(self, files, output_file_name):
        try:
            with zipfile.ZipFile(output_file_name, 'w') as zip_file:
                for file in files:
                    zip_file.write(file)
            return True
        except:
            return False
```",0.972972973,0.973148231,1,0.952380952,0.975609751,1,0.967213115,0.983333328,1,0.952380952,0.975609751,,,,,,,,,,,,
GPT,9,"class BigNumCalculator:
    @staticmethod
    def add(num1, num2):
        max_length = max(len(num1), len(num2))
        num1 = num1.zfill(max_length)
        num2 = num2.zfill(max_length)

        carry = 0
        result = []
        for i in range(max_length - 1, -1, -1):
            digit_sum = int(num1[i]) + int(num2[i]) + carry
            carry = digit_sum // 10
            digit = digit_sum % 10
            result.insert(0, str(digit))

        if carry > 0:
            result.insert(0, str(carry))

        return ''.join(result)

    @staticmethod
    def subtract(num1, num2):

        if len(num1) < len(num2):
            num1, num2 = num2, num1
            negative = True
        elif len(num1) > len(num2):
            negative = False
        else:
            if num1 < num2:
                num1, num2 = num2, num1
                negative = True
            else:
                negative = False

        max_length = max(len(num1), len(num2))
        num1 = num1.zfill(max_length)
        num2 = num2.zfill(max_length)

        borrow = 0
        result = []
        for i in range(max_length - 1, -1, -1):
            digit_diff = int(num1[i]) - int(num2[i]) - borrow

            if digit_diff < 0:
                digit_diff += 10
                borrow = 1
            else:
                borrow = 0

            result.insert(0, str(digit_diff))

        while len(result) > 1 and result[0] == '0':
            result.pop(0)

        if negative:
            result.insert(0, '-')

        return ''.join(result)

    @staticmethod
    def multiply(num1, num2):
        len1, len2 = len(num1), len(num2)
        result = [0] * (len1 + len2)

        for i in range(len1 - 1, -1, -1):
            for j in range(len2 - 1, -1, -1):
                mul = int(num1[i]) * int(num2[j])
                p1, p2 = i + j, i + j + 1
                total = mul + result[p2]

                result[p1] += total // 10
                result[p2] = total % 10

        start = 0
        while start < len(result) - 1 and result[start] == 0:
            start += 1

        return ''.join(map(str, result[start:]))",COTFewShot,"```python
class BigNumCalculator:
    @staticmethod
    def add(num1, num2):
        return str(int(num1) + int(num2))

    @staticmethod
    def subtract(num1, num2):
        return str(int(num1) - int(num2))

    @staticmethod
    def multiply(num1, num2):
        return str(int(num1) * int(num2))
```",0.000152889,0.00018177,0.130434783,0.75,0.22222222,0.048128342,0.45,0.08695652,0.108695652,0.625,0.185185183,,,,,,,,,,,,
GPT,0,"import logging
import datetime


class AccessGatewayFilter:

    def __init__(self):
        pass

    def filter(self, request):
        request_uri = request['path']
        method = request['method']

        if self.is_start_with(request_uri):
            return True

        try:
            token = self.get_jwt_user(request)
            user = token['user']
            if user['level'] > 2:
                self.set_current_user_info_and_log(user)
                return True
        except:
            return False

    def is_start_with(self, request_uri):
        start_with = [""/api"", '/login']
        for s in start_with:
            if request_uri.startswith(s):
                return True
        return False

    def get_jwt_user(self, request):
        token = request['headers']['Authorization']
        user = token['user']
        if token['jwt'].startswith(user['name']):
            jwt_str_date = token['jwt'].split(user['name'])[1]
            jwt_date = datetime.datetime.strptime(jwt_str_date, ""%Y-%m-%d"")
            if datetime.datetime.today() - jwt_date >= datetime.timedelta(days=3):
                return None
        return token

    def set_current_user_info_and_log(self, user):
        host = user['address']
        logging.log(msg=user['name'] + host + str(datetime.datetime.now()), level=1)",ZeroShot,"```python
import logging
import datetime
import jwt  # Assuming JWT is used for token parsing

class AccessGatewayFilter:
    def __init__(self):
        self.logger = logging.getLogger('AccessGatewayFilter')
        self.allowed_prefixes = ['/api', '/public']  # Example allowed prefixes

    def filter(self, request):
        """"""
        Filter the incoming request based on certain rules and conditions.
        :param request: The incoming request object
        :return: bool, True if the request is allowed, False otherwise
        """"""
        request_uri = request.get('uri', '')
        
        # Check if the request URI starts with allowed prefixes
        if not self.is_start_with(request_uri):
            self.logger.warning(f""Request URI {request_uri} not allowed."")
            return False
        
        # Extract and validate JWT token
        user_info = self.get_jwt_user(request)
        if user_info is None:
            self.logger.warning(""Invalid or missing JWT token."")
            return False
        
        # Set the user info and log the access
        self.set_current_user_info_and_log(user_info)
        
        return True

    def is_start_with(self, request_uri):
        """"""
        Check if the request URI starts with certain prefixes.
        :param request_uri: The URI of the request
        :return: bool, True if the URI starts with certain prefixes, False otherwise
        """"""
        for prefix in self.allowed_prefixes:
            if request_uri.startswith(prefix):
                return True
        return False

    def get_jwt_user(self, request):
        """"""
        Get the user information from the JWT token in the request.
        :param request: The incoming request object
        :return: dict or None, the user information if the token is valid, None otherwise
        """"""
        token = request.get('headers', {}).get('Authorization', '').replace('Bearer ', '')
        if not token:
            return None
        
        try:
            # Decode the JWT token (assuming a secret key is used for encoding)
            decoded_token = jwt.decode(token, 'your-secret-key', algorithms=['HS256'])
            return decoded_token.get('user')
        except jwt.ExpiredSignatureError:
            self.logger.warning(""JWT token has expired."")
        except jwt.InvalidTokenError:
            self.logger.warning(""Invalid JWT token."")
        
        return None

    def set_current_user_info_and_log(self, user):
        """"""
        Set the current user information and log the access.
        :param user: The user information dictionary
        :return: None
        """"""
        # Example: setting user info in a session or context
        self.logger.info(f""User {user.get('username')} accessed the system at {datetime.datetime.now()}."")
```",0.042857143,0.062596088,0.453125,0.211678832,0.28855721,0.25,0.099601594,0.142450138,0.453125,0.211678832,0.28855721,,,,,,,,,,,,
GPT,1,"import math


class AreaCalculator:

    def __init__(self, radius):
        self.radius = radius

    def calculate_circle_area(self):
        return math.pi * self.radius ** 2

    def calculate_sphere_area(self):
        return 4 * math.pi * self.radius ** 2

    def calculate_cylinder_area(self, height):
        return 2 * math.pi * self.radius * (self.radius + height)

    def calculate_sector_area(self, angle):
        return self.radius ** 2 * angle / 2

    def calculate_annulus_area(self, inner_radius, outer_radius):
        return math.pi * (outer_radius ** 2 - inner_radius ** 2)",ZeroShot,"```python
import math

class AreaCalculator:

    def __init__(self, radius):
        """"""
        Initialize the radius for shapes.
        """"""
        self.radius = radius

    def calculate_circle_area(self):
        """"""
        Calculate the area of a circle based on self.radius.
        :return: area of circle, float
        """"""
        return math.pi * self.radius ** 2

    def calculate_sphere_area(self):
        """"""
        Calculate the surface area of a sphere based on self.radius.
        :return: area of sphere, float
        """"""
        return 4 * math.pi * self.radius ** 2

    def calculate_cylinder_area(self, height):
        """"""
        Calculate the surface area of a cylinder based on self.radius and height.
        :return: area of cylinder, float
        """"""
        base_area = math.pi * self.radius ** 2
        lateral_surface_area = 2 * math.pi * self.radius * height
        return 2 * base_area + lateral_surface_area

    def calculate_sector_area(self, angle):
        """"""
        Calculate the area of a sector based on self.radius and angle (in radians).
        :return: area of sector, float
        """"""
        return 0.5 * self.radius ** 2 * angle

    def calculate_annulus_area(self, inner_radius, outer_radius):
        """"""
        Calculate the area of an annulus based on inner_radius and outer_radius.
        :return: area of annulus, float
        """"""
        outer_area = math.pi * outer_radius ** 2
        inner_area = math.pi * inner_radius ** 2
        return outer_area - inner_area
```",0.18579235,0.212991519,0.852941176,0.432835821,0.574257421,0.641509434,0.280991736,0.390804593,0.852941176,0.432835821,0.574257421,,,,,,,,,,,,
GPT,2,"class ArgumentParser:
    def __init__(self):
        self.arguments = {}
        self.required = set()
        self.types = {}

    def parse_arguments(self, command_string):
        args = command_string.split()[1:]
        for i in range(len(args)):
            arg = args[i]
            if arg.startswith('--'):
                key_value = arg[2:].split('=')
                if len(key_value) == 2:
                    self.arguments[key_value[0]] = self._convert_type(key_value[0], key_value[1])
                else:
                    self.arguments[key_value[0]] = True
            elif arg.startswith('-'):
                key = arg[1:]
                if i + 1 < len(args) and not args[i + 1].startswith('-'):
                    self.arguments[key] = self._convert_type(key, args[i + 1])
                else:
                    self.arguments[key] = True
        missing_args = self.required - set(self.arguments.keys())
        if missing_args:
            return False, missing_args

        return True, None

    def get_argument(self, key):
        return self.arguments.get(key)

    def add_argument(self, arg, required=False, arg_type=str):
        if required:
            self.required.add(arg)
        self.types[arg] = arg_type

    def _convert_type(self, arg, value):
        try:
            return self.types[arg](value)
        except (ValueError, KeyError):
            return value",ZeroShot,"```python
class ArgumentParser:
    def __init__(self):
        """"""
        Initialize the fields.
        """"""
        # Dictionary to store argument types
        self.types = {}
        # Set to store required arguments
        self.required = set()
        # Dictionary to store parsed arguments and their values
        self.arguments = {}

    def parse_arguments(self, command_string):
        """"""
        Parses the given command line argument string and stores the parsed result in specific type 
        in the arguments dictionary. Checks for missing required arguments, if any, and returns False 
        with the missing argument names, otherwise returns True.
        :return tuple: (True, None) if parsing is successful, (False, missing_args) if parsing fails,
            where missing_args is a set of the missing argument names which are str.
        """"""
        # Split the command string into arguments
        tokens = command_string.split()
        
        # Iterate over tokens and parse them
        for token in tokens:
            if token.startswith('--'):
                key = token[2:]
                # Attempt to get the value associated with the key
                value_index = tokens.index(token) + 1
                if value_index < len(tokens):
                    value = tokens[value_index]
                    # Convert the value to the appropriate type
                    self.arguments[key] = self._convert_type(key, value)
        
        # Check for missing required arguments
        missing_args = self.required - self.arguments.keys()
        if missing_args:
            return False, missing_args
        return True, None

    def get_argument(self, key):
        """"""
        Retrieves the value of the specified argument from the arguments dictionary and returns it.
        :return: The value of the argument, or None if the argument does not exist.
        """"""
        return self.arguments.get(key, None)

    def add_argument(self, arg, required=False, arg_type=str):
        """"""
        Adds an argument to self.types and self.required.
        Check if it is a required argument and store the argument type.
        If the argument is set as required, it will be added to the required set.
        The argument type and name are stored in the types dictionary as key-value pairs.
        """"""
        # Store the type of the argument
        self.types[arg] = arg_type
        # If the argument is required, add it to the required set
        if required:
            self.required.add(arg)

    def _convert_type(self, arg, value):
        """"""
        Try to convert the type of input value by searching in self.types.
        :return: return corresponding value in self.types if convert successfully, or the input value otherwise
        """"""
        # Get the type for the argument
        arg_type = self.types.get(arg, str)
        try:
            # Convert the value to the specified type
            return arg_type(value)
        except ValueError:
            # Return the original value if conversion fails
            return value
```",0.073369565,0.089420854,0.628205128,0.296969697,0.403292177,0.406779661,0.145015106,0.213808459,0.628205128,0.296969697,0.403292177,,,,,,,,,,,,
GPT,3,"import itertools


class ArrangementCalculator:
    def __init__(self, datas):
        self.datas = datas

    @staticmethod
    def count(n, m=None):
        if m is None or n == m:
            return ArrangementCalculator.factorial(n)
        else:
            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)

    @staticmethod
    def count_all(n):
        total = 0
        for i in range(1, n + 1):
            total += ArrangementCalculator.count(n, i)
        return total

    def select(self, m=None):
        if m is None:
            m = len(self.datas)
        result = []
        for permutation in itertools.permutations(self.datas, m):
            result.append(list(permutation))
        return result

    def select_all(self):
        result = []
        for i in range(1, len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    @staticmethod
    def factorial(n):
        result = 1
        for i in range(2, n + 1):
            result *= i
        return result",ZeroShot,"```python
import itertools
import math

class ArrangementCalculator:
    def __init__(self, datas):
        """"""
        Initializes the ArrangementCalculator object with a list of datas.
        """"""
        self.datas = datas

    @staticmethod
    def count(n, m=None):
        """"""
        Counts the number of arrangements by choosing m items from n items (permutations).
        If m is not provided or n equals m, returns factorial(n).
        :return: int, the count of arrangements.
        """"""
        if m is None or n == m:
            return ArrangementCalculator.factorial(n)
        return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)

    @staticmethod
    def count_all(n):
        """"""
        Counts the total number of all possible arrangements by choosing at least 1 item and at most n items from n items.
        :return: int, the count of all arrangements.
        """"""
        total = 0
        for m in range(1, n + 1):
            total += ArrangementCalculator.count(n, m)
        return total

    def select(self, m=None):
        """"""
        Generates a list of arrangements by selecting m items from the internal datas.
        :return: List, a list of arrangements.
        """"""
        if m is None:
            m = len(self.datas)
        return list(itertools.permutations(self.datas, m))

    def select_all(self):
        """"""
        Generates a list of all arrangements by selecting at least 1 item and at most the number of internal datas.
        :return: List, a list of all arrangements.
        """"""
        all_arrangements = []
        for m in range(1, len(self.datas) + 1):
            all_arrangements.extend(self.select(m))
        return all_arrangements

    @staticmethod
    def factorial(n):
        """"""
        Calculates the factorial of a given number.
        :return: int, the factorial of the given number.
        """"""
        return math.factorial(n)
```

- The `__init__` method initializes the class with a list of data elements.
- The `count` method calculates the number of permutations for choosing `m` items from `n` items.
- The `count_all` method calculates the total number of permutations for choosing any number of items from 1 to `n`.
- The `select` method generates permutations of `m` items from the internal data list.
- The `select_all` method generates all permutations for selecting at least 1 item and at most the number of internal data items.
- The `factorial` method computes the factorial of a given number using Python's `math.factorial` function.",0.135384615,0.154359946,0.827586207,0.406779661,0.545454541,0.608695652,0.251121076,0.355555551,0.827586207,0.406779661,0.545454541,,,,,,,,,,,,
GPT,4,"class AssessmentSystem:
    def __init__(self):
        self.students = {}

    def add_student(self, name, grade, major):
        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}

    def add_course_score(self, name, course, score):
        if name in self.students:
            self.students[name]['courses'][course] = score

    def get_gpa(self, name):
        if name in self.students and self.students[name]['courses']:
            return sum(self.students[name]['courses'].values()) / len(self.students[name]['courses'])
        else:
            return None

    def get_all_students_with_fail_course(self):
        students = []
        for name, student in self.students.items():
            for course, score in student['courses'].items():
                if score < 60:
                    students.append(name)
                    break
        return students

    def get_course_average(self, course):
        total = 0
        count = 0
        for student in self.students.values():
            if course in student['courses']:
                score = student['courses'][course]
                if score is not None:
                    total += score
                    count += 1
        return total / count if count > 0 else None

    def get_top_student(self):
        top_student = None
        top_gpa = 0
        for name, student in self.students.items():
            gpa = self.get_gpa(name)
            if gpa is not None and gpa > top_gpa:
                top_gpa = gpa
                top_student = name
        return top_student",ZeroShot,"```python
class AssessmentSystem:
    def __init__(self):
        """"""
        Initialize the students dict in assessment system.
        The dictionary will hold student names as keys, and each value will be another dictionary 
        containing 'grade', 'major', and 'courses' (which is a dictionary of course scores).
        """"""
        self.students = {}

    def add_student(self, name, grade, major):
        """"""
        Add a new student into self.students dict.
        :param name: str, the student's name
        :param grade: str, the student's grade level
        :param major: str, the student's major
        """"""
        if name not in self.students:
            self.students[name] = {'grade': grade, 'major': major, 'courses': {}}

    def add_course_score(self, name, course, score):
        """"""
        Add score of specific course for student in self.students
        :param name: str, the student's name
        :param course: str, the course name
        :param score: float, the score achieved in the course
        """"""
        if name in self.students:
            self.students[name]['courses'][course] = score

    def get_gpa(self, name):
        """"""
        Get average grade of one student.
        :param name: str, the student's name
        :return: float, the average grade if the student exists and has course grades, or None otherwise
        """"""
        if name in self.students:
            courses = self.students[name]['courses']
            if courses:
                return sum(courses.values()) / len(courses)
        return None

    def get_all_students_with_fail_course(self):
        """"""
        Get all students who have any score below 60.
        :return: list of str, student names
        """"""
        failing_students = []
        for name, data in self.students.items():
            if any(score < 60 for score in data['courses'].values()):
                failing_students.append(name)
        return failing_students

    def get_course_average(self, course):
        """"""
        Get the average score of a specific course.
        :param course: str, the course name
        :return: float, average scores of this course if anyone has a score for this course, or None if no records exist.
        """"""
        total_score = 0
        count = 0
        for data in self.students.values():
            if course in data['courses']:
                total_score += data['courses'][course]
                count += 1
        return total_score / count if count > 0 else None

    def get_top_student(self):
        """"""
        Calculate every student's GPA with get_gpa method, and find the student with the highest GPA.
        :return: str, name of the student whose GPA is highest
        """"""
        top_student = None
        highest_gpa = 0
        for name in self.students:
            gpa = self.get_gpa(name)
            if gpa is not None and gpa > highest_gpa:
                highest_gpa = gpa
                top_student = name
        return top_student
```",0.183908046,0.215750169,0.780821918,0.387755102,0.518181814,0.6,0.279069767,0.380952377,0.780821918,0.387755102,0.518181814,,,,,,,,,,,,
GPT,5,"class AutomaticGuitarSimulator:
    def __init__(self, text) -> None:
        self.play_text = text

    def interpret(self, display=False):
        if len(self.play_text) == 0:
            return
        else:
            play_list = []
            play_segs = self.play_text.split("" "")
            for play_seg in play_segs:
                pos = 0
                for ele in play_seg:
                    if ele.isalpha():
                        pos += 1
                        continue
                    break
                play_chord = play_seg[0:pos]
                play_value = play_seg[pos:]
                play_list.append({'Chord': play_chord, 'Tune': play_value})
                if display:
                    self.display(play_chord, play_value)
            return play_list

    def display(self, key, value):
        return ""Normal Guitar Playing -- Chord: %s, Play Tune: %s"" % (key, value)",ZeroShot,"```python
class AutomaticGuitarSimulator:
    def __init__(self, text) -> None:
        """"""
        Initialize the score to be played
        """"""
        self.play_text = text

    def interpret(self, display=False):
        """"""
        Interpret the music score to be played
        :return: list of dict, The dict includes two fields, Chord and Tune, which are letters and numbers, respectively
        """"""
        # Split the input text by spaces to separate chords and tunes
        elements = self.play_text.split()
        
        # Initialize a list to store the interpreted chords and tunes
        interpreted_music = []
        
        # Iterate over each element to determine if it's a chord or a tune
        for element in elements:
            # Assume chords are alphabetical and tunes are numerical
            if element.isalpha():
                interpreted_music.append({'Chord': element, 'Tune': None})
            elif element.isdigit():
                # In case the tune follows a chord, update the last chord with this tune
                if interpreted_music and interpreted_music[-1]['Tune'] is None:
                    interpreted_music[-1]['Tune'] = element
                else:
                    interpreted_music.append({'Chord': None, 'Tune': element})
        
        # If display is True, print out each chord and tune using the display method
        if display:
            for music in interpreted_music:
                self.display(music['Chord'], music['Tune'])
        
        return interpreted_music

    def display(self, chord, tune):
        """"""
        Print out chord and play tune with following format: Normal Guitar Playing -- Chord: %s, Play Tune: %s
        :return: str
        """"""
        # Format the output string based on the presence of chord and tune
        chord_str = f""Chord: {chord}"" if chord else ""Chord: None""
        tune_str = f""Play Tune: {tune}"" if tune else ""Play Tune: None""
        
        # Print the formatted string
        print(f""Normal Guitar Playing -- {chord_str}, {tune_str}"")
```

# Comments:
- The `interpret` method processes the input text to distinguish between chords (alphabetical) and tunes (numerical) and stores them in a list of dictionaries.
- The `display` method formats and prints the chord and tune information in a specified format.",0.050359712,0.066847032,0.484375,0.197452229,0.280542982,0.268292683,0.083333333,0.127167626,0.46875,0.191082803,0.271493209,,,,,,,,,,,,
GPT,6,"class AvgPartition:
    def __init__(self, lst, limit):
        self.lst = lst
        self.limit = limit

    def setNum(self):
        size = len(self.lst) // self.limit
        remainder = len(self.lst) % self.limit
        return size, remainder

        
    def get(self, index):
        size, remainder = self.setNum()
        start = index * size + min(index, remainder)
        end = start + size
        if index + 1 <= remainder:
            end += 1
        return self.lst[start:end]",ZeroShot,"```python
class AvgPartition:
    def __init__(self, lst, limit):
        """"""
        Initialize the class with the given list and the number of partitions.
        Check if the number of partitions is greater than 0.
        """"""
        if limit <= 0:
            raise ValueError(""Number of partitions must be greater than 0."")
        self.lst = lst
        self.limit = limit

    def setNum(self):
        """"""
        Calculate the size of each block and the remainder of the division.
        :return: the size of each block and the remainder of the division, tuple.
        """"""
        n = len(self.lst)
        block_size = n // self.limit  # Integer division to get the base size of each block
        remainder = n % self.limit    # Remainder to distribute among the first few blocks
        return block_size, remainder

    def get(self, index):
        """"""
        Calculate the size of each block and the remainder of the division.
        Calculate the corresponding start and end positions based on the index of the partition.
        :return: the corresponding block, list.
        """"""
        if index < 0 or index >= self.limit:
            raise IndexError(""Index out of range for the number of partitions."")
        
        block_size, remainder = self.setNum()

        # Calculate the start position
        start = index * block_size + min(index, remainder)
        # Calculate the end position
        end = start + block_size + (1 if index < remainder else 0)

        return self.lst[start:end]
```

- The `__init__` method initializes the list and the number of partitions, ensuring the number of partitions is greater than 0.
- The `setNum` method calculates the base size of each partition and how many partitions need an additional element due to the remainder.
- The `get` method computes the start and end indices for the requested partition and returns the appropriate sublist.",0.067164179,0.088096517,0.885714286,0.267241379,0.410596023,0.593220339,0.170731707,0.265151512,0.885714286,0.267241379,0.410596023,,,,,,,,,,,,
GPT,7,"class BalancedBrackets:
    def __init__(self, expr):
        self.stack = []
        self.left_brackets = [""("", ""{"", ""[""]
        self.right_brackets = ["")"", ""}"", ""]""]
        self.expr = expr

    def clear_expr(self):
        self.expr = ''.join(c for c in self.expr if (c in self.left_brackets or c in self.right_brackets))

    def check_balanced_brackets(self):
        self.clear_expr()
        for Brkt in self.expr:
            if Brkt in self.left_brackets:
                self.stack.append(Brkt)
            else:
                Current_Brkt = self.stack.pop()
                if Current_Brkt == ""("":
                    if Brkt != "")"":
                        return False
                if Current_Brkt == ""{"":
                    if Brkt != ""}"":
                        return False
                if Current_Brkt == ""["":
                    if Brkt != ""]"":
                        return False
        if self.stack:
            return False
        return True",ZeroShot,"```python
class BalancedBrackets:
    def __init__(self, expr):
        """"""
        Initializes the class with an expression.
        :param expr: The input expression string to be checked for balanced brackets.
        """"""
        self.expr = expr

    def clear_expr(self):
        """"""
        Clears the expression of all characters that are not brackets.
        Retains only '()', '{}', and '[]' characters in the expression.
        """"""
        brackets = set(""(){}[]"")
        self.expr = ''.join([char for char in self.expr if char in brackets])

    def check_balanced_brackets(self):
        """"""
        Checks if the expression has balanced brackets.
        :return: True if the expression has balanced brackets, False otherwise.
        """"""
        stack = []
        # Dictionary to hold matching pairs of brackets
        bracket_map = {')': '(', '}': '{', ']': '['}
        
        for char in self.expr:
            if char in bracket_map.values():
                # If the character is an opening bracket, push it onto the stack
                stack.append(char)
            elif char in bracket_map:
                # If the character is a closing bracket, check for balance
                if stack and stack[-1] == bracket_map[char]:
                    stack.pop()  # Pop the matching opening bracket
                else:
                    return False  # Unbalanced due to mismatch or empty stack

        # If stack is empty, all brackets were matched; otherwise, unbalanced
        return not stack
```",0.044198895,0.065911941,0.489795918,0.230769231,0.313725486,0.2375,0.113095238,0.153225802,0.489795918,0.230769231,0.313725486,,,,,,,,,,,,
GPT,8,"class BankAccount:
    def __init__(self, balance=0):
        self.balance = balance

    def deposit(self, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        self.balance += amount
        return self.balance

    def withdraw(self, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient balance."")
        self.balance -= amount
        return self.balance

    def view_balance(self):
        return self.balance

    def transfer(self, other_account, amount):
        self.withdraw(amount)
        other_account.deposit(amount)",ZeroShot,"```python
class BankAccount:
    def __init__(self, balance=0):
        """"""
        Initializes a bank account object with an attribute balance, default value is 0.
        """"""
        # Set the initial balance
        self.balance = balance

    def deposit(self, amount):
        """"""
        Deposits a certain amount into the account, increasing the account balance, return the current account balance.
        If amount is negative, raise a ValueError(""Invalid amount"").
        """"""
        if amount < 0:
            raise ValueError(""Invalid amount"")
        # Increase balance by the deposit amount
        self.balance += amount
        return self.balance

    def withdraw(self, amount):
        """"""
        Withdraws a certain amount from the account, decreasing the account balance, return the current account balance.
        If amount is negative, raise a ValueError(""Invalid amount"").
        If the withdrawal amount is greater than the account balance, raise a ValueError(""Insufficient balance."").
        """"""
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient balance."")
        # Decrease balance by the withdrawal amount
        self.balance -= amount
        return self.balance

    def view_balance(self):
        """"""
        Return the account balance.
        """"""
        return self.balance

    def transfer(self, other_account, amount):
        """"""
        Transfers a certain amount from the current account to another account.
        """"""
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient balance."")
        # Withdraw the amount from the current account
        self.withdraw(amount)
        # Deposit the amount to the other account
        other_account.deposit(amount)
```",0.191176471,0.20613273,1,0.407894737,0.579439248,0.844444444,0.277372263,0.417582414,1,0.407894737,0.579439248,,,,,,,,,,,,
GPT,9,"class BigNumCalculator:
    @staticmethod
    def add(num1, num2):
        max_length = max(len(num1), len(num2))
        num1 = num1.zfill(max_length)
        num2 = num2.zfill(max_length)

        carry = 0
        result = []
        for i in range(max_length - 1, -1, -1):
            digit_sum = int(num1[i]) + int(num2[i]) + carry
            carry = digit_sum // 10
            digit = digit_sum % 10
            result.insert(0, str(digit))

        if carry > 0:
            result.insert(0, str(carry))

        return ''.join(result)

    @staticmethod
    def subtract(num1, num2):

        if len(num1) < len(num2):
            num1, num2 = num2, num1
            negative = True
        elif len(num1) > len(num2):
            negative = False
        else:
            if num1 < num2:
                num1, num2 = num2, num1
                negative = True
            else:
                negative = False

        max_length = max(len(num1), len(num2))
        num1 = num1.zfill(max_length)
        num2 = num2.zfill(max_length)

        borrow = 0
        result = []
        for i in range(max_length - 1, -1, -1):
            digit_diff = int(num1[i]) - int(num2[i]) - borrow

            if digit_diff < 0:
                digit_diff += 10
                borrow = 1
            else:
                borrow = 0

            result.insert(0, str(digit_diff))

        while len(result) > 1 and result[0] == '0':
            result.pop(0)

        if negative:
            result.insert(0, '-')

        return ''.join(result)

    @staticmethod
    def multiply(num1, num2):
        len1, len2 = len(num1), len(num2)
        result = [0] * (len1 + len2)

        for i in range(len1 - 1, -1, -1):
            for j in range(len2 - 1, -1, -1):
                mul = int(num1[i]) * int(num2[j])
                p1, p2 = i + j, i + j + 1
                total = mul + result[p2]

                result[p1] += total // 10
                result[p2] = total % 10

        start = 0
        while start < len(result) - 1 and result[start] == 0:
            start += 1

        return ''.join(map(str, result[start:]))",ZeroShot,"```python
class BigNumCalculator:
    @staticmethod
    def add(num1, num2):
        """"""
        Adds two big numbers.
        :return: The sum of the two numbers, str.
        """"""
        # Convert the input strings to integers, add them, and convert the result back to a string
        return str(int(num1) + int(num2))

    @staticmethod
    def subtract(num1, num2):
        """"""
        Subtracts two big numbers.
        :return: The difference of the two numbers, str.
        """"""
        # Convert the input strings to integers, subtract them, and convert the result back to a string
        return str(int(num1) - int(num2))

    @staticmethod
    def multiply(num1, num2):
        """"""
        Multiplies two big numbers.
        :return: The product of the two numbers, str.
        """"""
        # Convert the input strings to integers, multiply them, and convert the result back to a string
        return str(int(num1) * int(num2))
```",0.02493663,0.031790254,0.152173913,0.291666667,0.199999995,0.048128342,0.142857143,0.071999996,0.141304348,0.270833333,0.185714281,,,,,,,,,,,,
GPT,10,"class BinaryDataProcessor:
    def __init__(self, binary_string):
        self.binary_string = binary_string
        self.clean_non_binary_chars()

    def clean_non_binary_chars(self):
        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))

    def calculate_binary_info(self):
        zeroes_count = self.binary_string.count('0')
        ones_count = self.binary_string.count('1')
        total_length = len(self.binary_string)

        zeroes_percentage = (zeroes_count / total_length)
        ones_percentage = (ones_count / total_length)

        return {
            'Zeroes': zeroes_percentage,
            'Ones': ones_percentage,
            'Bit length': total_length
        }

    def convert_to_ascii(self):
        byte_array = bytearray()
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            decimal = int(byte, 2)
            byte_array.append(decimal)

        return byte_array.decode('ascii')

    def convert_to_utf8(self):
        byte_array = bytearray()
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            decimal = int(byte, 2)
            byte_array.append(decimal)

        return byte_array.decode('utf-8')",ZeroShot,"```python
class BinaryDataProcessor:
    def __init__(self, binary_string):
        """"""
        Initialize the class with a binary string and clean it by removing all non 0 or 1 characters.
        """"""
        self.original_string = binary_string
        self.binary_string = self.clean_non_binary_chars()

    def clean_non_binary_chars(self):
        """"""
        Clean the binary string by removing all non 0 or 1 characters.
        """"""
        # Use a list comprehension to filter out non-binary characters
        return ''.join([char for char in self.original_string if char in '01'])

    def calculate_binary_info(self):
        """"""
        Calculate the binary string information, including the percentage of 0 and 1, and the total length of the binary string.
        """"""
        length = len(self.binary_string)
        if length == 0:
            return {'length': 0, 'percentage_0': 0, 'percentage_1': 0}
        
        count_0 = self.binary_string.count('0')
        count_1 = self.binary_string.count('1')
        percentage_0 = (count_0 / length) * 100
        percentage_1 = (count_1 / length) * 100
        
        return {'length': length, 'percentage_0': percentage_0, 'percentage_1': percentage_1}

    def convert_to_ascii(self):
        """"""
        Convert the binary string to ascii string.
        """"""
        ascii_string = ''
        # Process the binary string in chunks of 8 bits
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            if len(byte) == 8:
                ascii_string += chr(int(byte, 2))
        return ascii_string

    def convert_to_utf8(self):
        """"""
        Convert the binary string to utf-8 string.
        """"""
        utf8_string = ''
        # Process the binary string in chunks of 8 bits
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            if len(byte) == 8:
                utf8_string += chr(int(byte, 2))
        return utf8_string
```

- The `__init__` method initializes the class with a binary string and cleans it using the `clean_non_binary_chars` method.
- The `clean_non_binary_chars` method filters out any characters that are not '0' or '1'.
- The `calculate_binary_info` method calculates the length of the binary string and the percentage of '0's and '1's.
- The `convert_to_ascii` and `convert_to_utf8` methods convert the binary string into ASCII and UTF-8 strings, respectively, by processing the string in chunks of 8 bits.",0.061433447,0.085315184,0.49122807,0.212121212,0.296296292,0.358024691,0.132420091,0.193333329,0.49122807,0.212121212,0.296296292,,,,,,,,,,,,
GPT,11,"class BitStatusUtil:
    @staticmethod
    def add(states, stat):
        BitStatusUtil.check([states, stat])
        return states | stat

    @staticmethod
    def has(states, stat):
        BitStatusUtil.check([states, stat])
        return (states & stat) == stat

    @staticmethod
    def remove(states, stat):
        BitStatusUtil.check([states, stat])
        if BitStatusUtil.has(states, stat):
            return states ^ stat
        return states

    @staticmethod
    def check(args):
        for arg in args:
            if arg < 0:
                raise ValueError(f""{arg} must be greater than or equal to 0"")
            if arg % 2 != 0:
                raise ValueError(f""{arg} not even"")",ZeroShot,"```python
class BitStatusUtil:
    @staticmethod
    def add(states, stat):
        """"""
        Add a status to the current status, and check the parameters whether they are legal.
        :return: The status after adding the status, int.
        """"""
        BitStatusUtil.check(states)
        BitStatusUtil.check(stat)
        # Use bitwise OR to add the status
        return states | stat

    @staticmethod
    def has(states, stat):
        """"""
        Check if the current status contains the specified status, and check the parameters whether they are legal.
        :return: True if the current status contains the specified status, otherwise False, bool.
        """"""
        BitStatusUtil.check(states)
        BitStatusUtil.check(stat)
        # Use bitwise AND to check if the status contains the specified status
        return (states & stat) == stat

    @staticmethod
    def remove(states, stat):
        """"""
        Remove the specified status from the current status, and check the parameters whether they are legal.
        :return: The status after removing the specified status, int.
        """"""
        BitStatusUtil.check(states)
        BitStatusUtil.check(stat)
        # Use bitwise AND with NOT to remove the status
        return states & ~stat

    @staticmethod
    def check(args):
        """"""
        Check if the parameters are legal, args must be greater than or equal to 0 and must be even, if not, raise ValueError.
        :return: None.
        """"""
        if args < 0 or args % 2 != 0:
            raise ValueError(""Argument must be a non-negative even integer."")
```

# Explanation:
1. **add**: Uses bitwise OR (`|`) to add a status to the current state.
2. **has**: Uses bitwise AND (`&`) to check if the current state contains the specified status.
3. **remove**: Uses bitwise AND with NOT (`~`) to remove the specified status from the current state.
4. **check**: Validates that the arguments are non-negative even integers, raising a `ValueError` if not.",0.103448276,0.117351117,0.76744186,0.308411215,0.439999996,0.517857143,0.173652695,0.260089682,0.76744186,0.308411215,0.439999996,,,,,,,,,,,,
GPT,12,"import random


class BlackjackGame:
    def __init__(self):
        self.deck = self.create_deck()
        self.player_hand = []
        self.dealer_hand = []

    def create_deck(self):
        deck = []
        suits = ['S', 'C', 'D', 'H']
        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
        for suit in suits:
            for rank in ranks:
                deck.append(rank + suit)
        random.shuffle(deck)
        return deck

    def calculate_hand_value(self, hand):
        value = 0
        num_aces = 0
        for card in hand:
            rank = card[:-1]
            if rank.isdigit():
                value += int(rank)
            elif rank in ['J', 'Q', 'K']:
                value += 10
            elif rank == 'A':
                value += 11
                num_aces += 1
        while value > 21 and num_aces > 0:
            value -= 10
            num_aces -= 1
        return value

    def check_winner(self, player_hand, dealer_hand):
        player_value = self.calculate_hand_value(player_hand)
        dealer_value = self.calculate_hand_value(dealer_hand)
        if player_value > 21 and dealer_value > 21:
            if player_value <= dealer_value:
                return 'Player wins'
            else:
                return 'Dealer wins'
        elif player_value > 21:
            return 'Dealer wins'
        elif dealer_value > 21:
            return 'Player wins'
        else:
            if player_value <= dealer_value:
                return 'Dealer wins'
            else:
                return 'Player wins'",ZeroShot,"```python
import random

class BlackjackGame:
    def __init__(self):
        """"""
        Initialize the Blackjack Game with the attribute deck, player_hand and dealer_hand.
        While initializing deck attribute, call the create_deck method to generate.
        The deck stores 52 random order poker with the Jokers removed, format is ['AS', '2S', ...].
        player_hand is a list which stores player's hand cards.
        dealer_hand is a list which stores dealer's hand cards.
        """"""
        self.deck = self.create_deck()
        self.player_hand = []
        self.dealer_hand = []

    def create_deck(self):
        """"""
        Create a deck of 52 cards, which stores 52 random order poker with the Jokers removed.
        :return: a list of 52 random order poker with the Jokers removed, format is ['AS', '2S', ...].
        """"""
        suits = ['S', 'H', 'D', 'C']  # Spades, Hearts, Diamonds, Clubs
        values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
        deck = [value + suit for suit in suits for value in values]
        random.shuffle(deck)
        return deck

    def calculate_hand_value(self, hand):
        """"""
        Calculate the value of the poker cards stored in hand list according to the rules of the Blackjack Game.
        If the card is a digit, its value is added to the total hand value.
        Value of J, Q, or K is 10, while Aces are worth 11.
        If the total hand value exceeds 21 and there are Aces present, one Ace is treated as having a value of 1 instead of 11,
        until the hand value is less than or equal to 21, or all Aces have been counted as value of 1.
        :return: the value of the poker cards stored in hand list, a number.
        """"""
        value = 0
        aces = 0
        for card in hand:
            rank = card[:-1]  # Get the rank of the card
            if rank.isdigit():
                value += int(rank)
            elif rank in ['J', 'Q', 'K']:
                value += 10
            elif rank == 'A':
                value += 11
                aces += 1

        # Adjust for Aces if value exceeds 21
        while value > 21 and aces:
            value -= 10
            aces -= 1

        return value

    def check_winner(self, player_hand, dealer_hand):
        """"""
        Determines the winner of a game by comparing the hand values of the player and dealer.
        rule:
        If both players have hand values that are equal to or less than 21, the winner is the one whose hand value is closer to 21.
        Otherwise, the winner is the one with the lower hand value.
        """"""
        player_value = self.calculate_hand_value(player_hand)
        dealer_value = self.calculate_hand_value(dealer_hand)

        if player_value > 21:
            return ""Dealer wins""
        elif dealer_value > 21:
            return ""Player wins""
        elif player_value > dealer_value:
            return ""Player wins""
        elif dealer_value > player_value:
            return ""Dealer wins""
        else:
            return ""Tie""
```",0.181176471,0.205501277,0.80952381,0.365591398,0.503703699,0.664285714,0.268786127,0.382716045,0.797619048,0.360215054,0.496296292,,,,,,,,,,,,
GPT,13,"class BookManagement:
    def __init__(self):
        self.inventory = {}

    def add_book(self, title, quantity=1):
        if title in self.inventory:
            self.inventory[title] += quantity
        else:
            self.inventory[title] = quantity

    def remove_book(self, title, quantity):
        if title not in self.inventory or self.inventory[title] < quantity:
            raise False
        self.inventory[title] -= quantity
        if self.inventory[title] == 0:
            del (self.inventory[title])

    def view_inventory(self):
        return self.inventory

    def view_book_quantity(self, title):
        if title not in self.inventory:
            return 0
        return self.inventory[title]",ZeroShot,"```python
class BookManagement:
    def __init__(self):
        """"""
        Initialize the inventory of Book Manager.
        """"""
        self.inventory = {}  # Dictionary to hold book titles and their quantities

    def add_book(self, title, quantity=1):
        """"""
        Add one or several books to inventory which is sorted by book title.
        """"""
        if title in self.inventory:
            self.inventory[title] += quantity  # Increase quantity if book already exists
        else:
            self.inventory[title] = quantity  # Add new book with specified quantity

    def remove_book(self, title, quantity):
        """"""
        Remove one or several books from inventory which is sorted by book title.
        Raise False while get invalid input.
        """"""
        if title in self.inventory:
            if self.inventory[title] >= quantity:
                self.inventory[title] -= quantity  # Decrease quantity if sufficient stock exists
                if self.inventory[title] == 0:
                    del self.inventory[title]  # Remove book from inventory if quantity is zero
            else:
                raise ValueError(""Not enough books in inventory to remove the specified quantity."")  # Raise error if insufficient stock
        else:
            raise ValueError(""Book not found in inventory."")  # Raise error if book does not exist

    def view_inventory(self):
        """"""
        Get the inventory of the Book Management.
        :return self.inventory: dictionary, {title(str): quantity(int), ...}
        """"""
        return self.inventory  # Return the entire inventory dictionary

    def view_book_quantity(self, title):
        """"""
        Get the quantity of a book.
        :return quantity: the quantity of this book title. return 0 when the title does not exist in self.inventory
        """"""
        return self.inventory.get(title, 0)  # Return quantity if book exists, otherwise return 0
```",0.088888889,0.116433486,0.921052632,0.333333333,0.489510486,0.620689655,0.189473684,0.290322577,0.921052632,0.333333333,0.489510486,,,,,,,,,,,,
GPT,14,"import sqlite3

class BookManagementDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS books (
                id INTEGER PRIMARY KEY,
                title TEXT,
                author TEXT,
                available INTEGER
            )
        ''')
        self.connection.commit()

    def add_book(self, title, author):
        self.cursor.execute('''
            INSERT INTO books (title, author, available)
            VALUES (?, ?, 1)
        ''', (title, author))
        self.connection.commit()

    def remove_book(self, book_id):
        self.cursor.execute('''
            DELETE FROM books WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def borrow_book(self, book_id):
        self.cursor.execute('''
            UPDATE books SET available = 0 WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def return_book(self, book_id):
        self.cursor.execute('''
            UPDATE books SET available = 1 WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def search_books(self):
        self.cursor.execute('''
            SELECT * FROM books
        ''')
        books = self.cursor.fetchall()
        return books",ZeroShot,"```python
import sqlite3

class BookManagementDB:

    def __init__(self, db_name):
        """"""
        Initializes the class by creating a database connection and cursor, 
        and creates the book table if it does not already exist
        """"""
        self.conn = sqlite3.connect(db_name)  # Connect to the database
        self.cursor = self.conn.cursor()  # Create a cursor object
        self.create_table()  # Ensure the book table exists

    def create_table(self):
        """"""
        Creates the book table in the database if it does not already exist.
        """"""
        self.cursor.execute(""""""
            CREATE TABLE IF NOT EXISTS books (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                author TEXT NOT NULL,
                available INTEGER NOT NULL
            )
        """""")
        self.conn.commit()  # Save the changes

    def add_book(self, title, author):
        """"""
        Adds a book to the database with the specified title and author, 
        setting its availability to 1 as free to borrow.
        """"""
        self.cursor.execute(""""""
            INSERT INTO books (title, author, available) 
            VALUES (?, ?, 1)
        """""", (title, author))
        self.conn.commit()  # Save the changes

    def remove_book(self, book_id):
        """"""
        Removes a book from the database based on the given book ID.
        """"""
        self.cursor.execute(""""""
            DELETE FROM books WHERE id = ?
        """""", (book_id,))
        self.conn.commit()  # Save the changes

    def borrow_book(self, book_id):
        """"""
        Marks a book as borrowed in the database based on the given book ID.
        """"""
        self.cursor.execute(""""""
            UPDATE books SET available = 0 WHERE id = ?
        """""", (book_id,))
        self.conn.commit()  # Save the changes

    def return_book(self, book_id):
        """"""
        Marks a book as returned in the database based on the given book ID.
        """"""
        self.cursor.execute(""""""
            UPDATE books SET available = 1 WHERE id = ?
        """""", (book_id,))
        self.conn.commit()  # Save the changes

    def search_books(self):
        """"""
        Retrieves all books from the database and returns their information.
        return books: list[tuple], the information of all books in database
        """"""
        self.cursor.execute(""""""
            SELECT * FROM books
        """""")
        books = self.cursor.fetchall()  # Fetch all results
        return books  # Return the list of books
```",0.16722408,0.198352543,0.924242424,0.465648855,0.619289336,0.646464646,0.293577982,0.403785485,0.924242424,0.465648855,0.619289336,,,,,,,,,,,,
GPT,15,"class BoyerMooreSearch:
    def __init__(self, text, pattern):
        self.text, self.pattern = text, pattern
        self.textLen, self.patLen = len(text), len(pattern)

    def match_in_pattern(self, char):
        for i in range(self.patLen - 1, -1, -1):
            if char == self.pattern[i]:
                return i
        return -1

    def mismatch_in_text(self, currentPos):
        for i in range(self.patLen - 1, -1, -1):
            if self.pattern[i] != self.text[currentPos + i]:
                return currentPos + i
        return -1

    def bad_character_heuristic(self):
        positions = []
        for i in range(self.textLen - self.patLen + 1):
            mismatch_index = self.mismatch_in_text(i)
            if mismatch_index == -1:
                positions.append(i)
            else:
                match_index = self.match_in_pattern(self.text[mismatch_index])
                i = (mismatch_index - match_index)
        return positions",ZeroShot,"```python
class BoyerMooreSearch:
    def __init__(self, text, pattern):
        """"""
        Initializes the BoyerMooreSearch class with the given text and pattern.
        """"""
        self.text = text
        self.pattern = pattern
        self.pattern_length = len(pattern)
        self.text_length = len(text)
        self.bad_char_table = self.create_bad_char_table()

    def match_in_pattern(self, char):
        """"""
        Finds the rightmost occurrence of a character in the pattern.
        :return: The index of the rightmost occurrence of the character in the pattern, int.
        """"""
        for i in range(self.pattern_length - 1, -1, -1):
            if self.pattern[i] == char:
                return i
        return -1

    def mismatch_in_text(self, currentPos):
        """"""
        Determines the position of the first mismatch between the pattern and the text.
        :return: The position of the first mismatch between the pattern and the text, int, otherwise -1.
        """"""
        for i in range(self.pattern_length):
            if self.pattern[i] != self.text[currentPos + i]:
                return i
        return -1

    def create_bad_char_table(self):
        """"""
        Creates the bad character table used in the Boyer-Moore algorithm.
        :return: A dictionary with the rightmost occurrence of each character in the pattern.
        """"""
        bad_char_table = {}
        for i in range(self.pattern_length):
            bad_char_table[self.pattern[i]] = i
        return bad_char_table

    def bad_character_heuristic(self):
        """"""
        Finds all occurrences of the pattern in the text using the bad character heuristic.
        :return: A list of all positions of the pattern in the text, list.
        """"""
        results = []
        shift = 0

        while shift <= self.text_length - self.pattern_length:
            mismatch_index = self.mismatch_in_text(shift)

            if mismatch_index == -1:  # No mismatch found
                results.append(shift)
                shift += self.pattern_length
            else:
                # Calculate the shift using the bad character heuristic
                bad_char_index = self.match_in_pattern(self.text[shift + mismatch_index])
                if bad_char_index == -1:
                    shift += mismatch_index + 1
                else:
                    shift += max(1, mismatch_index - bad_char_index)

        return results
```

- The `__init__` method initializes the class with the given text and pattern and creates the bad character table.
- The `match_in_pattern` method finds the rightmost occurrence of a character in the pattern.
- The `mismatch_in_text` method determines the position of the first mismatch between the pattern and the text.
- The `create_bad_char_table` method creates a table for the bad character rule, storing the last occurrence of each character in the pattern.
- The `bad_character_heuristic` method finds all occurrences of the pattern in the text using the Boyer-Moore algorithm's bad character heuristic.",0.074712644,0.092996406,0.730769231,0.306451613,0.431818178,0.459770115,0.16194332,0.239520954,0.730769231,0.306451613,0.431818178,,,,,,,,,,,,
GPT,16,"class Calculator:
    def __init__(self):
        self.operators = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '/': lambda x, y: x / y,
            '^': lambda x, y: x ** y
        }

    def calculate(self, expression):
        operand_stack = []
        operator_stack = []
        num_buffer = ''

        for char in expression:
            if char.isdigit() or char == '.':
                num_buffer += char
            else:
                if num_buffer:
                    operand_stack.append(float(num_buffer))
                    num_buffer = ''

                if char in '+-*/^':
                    while (
                            operator_stack and
                            operator_stack[-1] != '(' and
                            self.precedence(operator_stack[-1]) >= self.precedence(char)
                    ):
                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

                    operator_stack.append(char)
                elif char == '(':
                    operator_stack.append(char)
                elif char == ')':
                    while operator_stack and operator_stack[-1] != '(':
                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

                    operator_stack.pop()

        if num_buffer:
            operand_stack.append(float(num_buffer))

        while operator_stack:
            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

        return operand_stack[-1] if operand_stack else None

    def precedence(self, operator):
        precedences = {
            '+': 1,
            '-': 1,
            '*': 2,
            '/': 2,
            '^': 3
        }
        return precedences.get(operator, 0)

    def apply_operator(self, operand_stack, operator_stack):
        operator = operator_stack.pop()
        if operator == '^':
            operand2 = operand_stack.pop()
            operand1 = operand_stack.pop()
            result = self.operators[operator](operand1, operand2)
            operand_stack.append(result)
        else:
            operand2 = operand_stack.pop()
            operand1 = operand_stack.pop()
            result = self.operators[operator](operand1, operand2)
            operand_stack.append(result)
        return operand_stack, operator_stack",ZeroShot,na,0,3.05E-83,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,
GPT,17,"from datetime import datetime, timedelta

class CalendarUtil:
    def __init__(self):
        self.events = []

    def add_event(self, event):
        self.events.append(event)

    def remove_event(self, event):
        if event in self.events:
            self.events.remove(event)

    def get_events(self, date):
        events_on_date = []
        for event in self.events:
            if event['date'].date() == date.date():
                events_on_date.append(event)
        return events_on_date

    def is_available(self, start_time, end_time):
        for event in self.events:
            if start_time < event['end_time'] and end_time > event['start_time']:
                return False
        return True

    def get_available_slots(self, date):
        available_slots = []
        start_time = datetime(date.year, date.month, date.day, 0, 0)
        end_time = datetime(date.year, date.month, date.day, 23, 59)

        while start_time < end_time:
            slot_end_time = start_time + timedelta(minutes=60)
            if self.is_available(start_time, slot_end_time):
                available_slots.append((start_time, slot_end_time))
            start_time += timedelta(minutes=60)


        return available_slots

    def get_upcoming_events(self, num_events):
        now = datetime.now()
        upcoming_events = []
        for event in self.events:
            if event['start_time'] >= now:
                upcoming_events.append(event)
            if len(upcoming_events) == num_events:
                break
        return upcoming_events",ZeroShot,"```python
from datetime import datetime, timedelta

class CalendarUtil:
    def __init__(self):
        """"""
        Initialize the calendar with an empty list of events.
        """"""
        self.events = []

    def add_event(self, event):
        """"""
        Add an event to the calendar.
        :param event: A dictionary with 'start' and 'end' datetime objects.
        """"""
        self.events.append(event)

    def remove_event(self, event):
        """"""
        Remove an event from the calendar.
        :param event: A dictionary with 'start' and 'end' datetime objects.
        """"""
        self.events.remove(event)

    def get_events(self, date):
        """"""
        Get all events on a given date.
        :param date: A datetime.date object.
        :return: A list of events on the given date.
        """"""
        return [event for event in self.events if event['start'].date() == date]

    def is_available(self, start_time, end_time):
        """"""
        Check if the calendar is available for a given time slot.
        :param start_time: A datetime object for the start of the time slot.
        :param end_time: A datetime object for the end of the time slot.
        :return: True if the calendar is available for the given time slot, False otherwise.
        """"""
        for event in self.events:
            if not (end_time <= event['start'] or start_time >= event['end']):
                return False
        return True

    def get_available_slots(self, date):
        """"""
        Get all available time slots on a given date.
        :param date: A datetime.date object.
        :return: A list of available time slots on the given date.
        """"""
        events_on_date = self.get_events(date)
        events_on_date.sort(key=lambda x: x['start'])

        available_slots = []
        start_of_day = datetime.combine(date, datetime.min.time())
        end_of_day = datetime.combine(date, datetime.max.time())

        current_time = start_of_day

        for event in events_on_date:
            if current_time < event['start']:
                available_slots.append({'start': current_time, 'end': event['start']})
            current_time = max(current_time, event['end'])

        if current_time < end_of_day:
            available_slots.append({'start': current_time, 'end': end_of_day})

        return available_slots

    def get_upcoming_events(self, num_events):
        """"""
        Get the next n upcoming events from the current date and time.
        :param num_events: Number of upcoming events to retrieve.
        :return: A list of the next n upcoming events.
        """"""
        now = datetime.now()
        future_events = [event for event in self.events if event['start'] >= now]
        future_events.sort(key=lambda x: x['start'])
        return future_events[:num_events]
```

- The `add_event` and `remove_event` methods manage the list of events.
- The `get_events` method filters events by a specific date.
- The `is_available` method checks for conflicts in a given time slot.
- The `get_available_slots` method calculates free time slots in a day.
- The `get_upcoming_events` method retrieves the next `n` events from the current time.",0.088642659,0.108027668,0.626666667,0.321917808,0.425339362,0.383333333,0.172932331,0.238341965,0.626666667,0.321917808,0.425339362,,,,,,,,,,,,
GPT,18,"class CamelCaseMap:
    def __init__(self):
        self._data = {}

    def __getitem__(self, key):
        return self._data[self._convert_key(key)]

    def __setitem__(self, key, value):
        self._data[self._convert_key(key)] = value

    def __delitem__(self, key):
        del self._data[self._convert_key(key)]

    def __iter__(self):
        return iter(self._data)

    def __len__(self):
        return len(self._data)

    def _convert_key(self, key):
        if isinstance(key, str):
            return self._to_camel_case(key)
        return key

    @staticmethod
    def _to_camel_case(key):
        parts = key.split('_')
        return parts[0] + ''.join(part.title() for part in parts[1:])",ZeroShot,"```python
class CamelCaseMap:
    def __init__(self):
        """"""
        Initialize data to an empty dictionary
        """"""
        self.data = {}

    def __getitem__(self, key):
        """"""
        Return the value corresponding to the key
        :return: str, the value corresponding to the key
        """"""
        camel_case_key = self._convert_key(key)
        return self.data[camel_case_key]

    def __setitem__(self, key, value):
        """"""
        Set the value corresponding to the key to the specified value
        :return: None
        """"""
        camel_case_key = self._convert_key(key)
        self.data[camel_case_key] = value

    def __delitem__(self, key):
        """"""
        Delete the value corresponding to the key
        :return: None
        """"""
        camel_case_key = self._convert_key(key)
        del self.data[camel_case_key]

    def __iter__(self):
        """"""
        Returning Iterable Objects with Own Data
        :return: Iterator
        """"""
        return iter(self.data)

    def __len__(self):
        """"""
        Returns the length of the own data
        :return: int, length of data
        """"""
        return len(self.data)

    def _convert_key(self, key):
        """"""
        Convert key string into camel case
        :return: str, converted key string
        """"""
        return self._to_camel_case(key)

    @staticmethod
    def _to_camel_case(key):
        """"""
        Convert key string into camel case
        :return: str, converted key string
        """"""
        parts = key.split('_')
        return parts[0] + ''.join(word.capitalize() for word in parts[1:])
```

- `__init__`: Initializes an empty dictionary to store data.
- `__getitem__`: Retrieves a value using a camel case key.
- `__setitem__`: Sets a value for a camel case key.
- `__delitem__`: Deletes an entry using a camel case key.
- `__iter__`: Provides an iterator for the dictionary keys.
- `__len__`: Returns the number of items in the dictionary.
- `_convert_key`: Converts a key to camel case using `_to_camel_case`.
- `_to_camel_case`: Converts a snake_case string to camelCase.",0.067510549,0.085631969,0.76744186,0.323529412,0.45517241,0.540983607,0.181318681,0.271604935,0.76744186,0.323529412,0.45517241,,,,,,,,,,,,
GPT,19,"class ChandrasekharSieve:
    def __init__(self, n):
        self.n = n
        self.primes = self.generate_primes()

    def generate_primes(self):
        if self.n < 2:
            return []

        sieve = [True] * (self.n + 1)
        sieve[0] = sieve[1] = False

        p = 2
        while p * p <= self.n:
            if sieve[p]:
                for i in range(p * p, self.n + 1, p):
                    sieve[i] = False
            p += 1

        primes = []
        for i in range(2, self.n + 1):
            if sieve[i]:
                primes.append(i)

        return primes

    def get_primes(self):
        return self.primes",ZeroShot,"```python
class ChandrasekharSieve:
    def __init__(self, n):
        """"""
        Initialize the ChandrasekharSieve class with the given limit.
        :param n: int, the upper limit to find prime numbers
        """"""
        self.n = n  # Store the upper limit
        self.primes = []  # Initialize an empty list to store prime numbers

    def generate_primes(self):
        """"""
        Generate prime numbers up to the specified limit using the Chandrasekhar sieve algorithm.
        :return: list, a list of prime numbers
        """"""
        if self.n < 2:
            self.primes = []  # No primes less than 2
            return self.primes

        # Initialize a list to track prime status of numbers
        is_prime = [True] * (self.n + 1)
        is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers

        # Implementing the sieve
        for start in range(2, int(self.n**0.5) + 1):
            if is_prime[start]:
                # Mark all multiples of start as non-prime
                for multiple in range(start * start, self.n + 1, start):
                    is_prime[multiple] = False

        # Collecting all prime numbers
        self.primes = [num for num, prime in enumerate(is_prime) if prime]
        return self.primes

    def get_primes(self):
        """"""
        Get the list of generated prime numbers.
        :return: list, a list of prime numbers
        """"""
        return self.primes
```

- The `__init__` method initializes the class with an upper limit `n` and prepares an empty list for storing primes.
- The `generate_primes` method uses a sieve algorithm to mark non-prime numbers and collects primes into the list.
- The `get_primes` method returns the list of generated prime numbers.",0.051282051,0.076388718,0.673913043,0.274336283,0.389937103,0.373333333,0.141414141,0.205128201,0.673913043,0.274336283,0.389937103,,,,,,,,,,,,
GPT,20,"from datetime import datetime

class Chat:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username in self.users:
            return False
        else:
            self.users[username] = []
            return True

    def remove_user(self, username):
        if username in self.users:
            del self.users[username]
            return True
        else:
            return False

    def send_message(self, sender, receiver, message):
        if sender not in self.users or receiver not in self.users:
            return False

        timestamp = datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
        message_info = {
            'sender': sender,
            'receiver': receiver,
            'message': message,
            'timestamp': timestamp
        }
        self.users[sender].append(message_info)
        self.users[receiver].append(message_info)
        return True

    def get_messages(self, username):
        if username not in self.users:
            return []
        return self.users[username]",ZeroShot,"```python
from datetime import datetime

class Chat:
    def __init__(self):
        """"""
        Initialize the Chat with an attribute users, which is an empty dictionary.
        The dictionary will store usernames as keys and a list of messages as values.
        """"""
        self.users = {}

    def add_user(self, username):
        """"""
        Add a new user to the Chat.
        :param username: The username of the user to add.
        :return: If the user is already in the Chat, returns False, otherwise, returns True.
        """"""
        if username in self.users:
            return False
        else:
            self.users[username] = []  # Initialize the user's message list
            return True

    def remove_user(self, username):
        """"""
        Remove a user from the Chat.
        :param username: The username of the user to remove.
        :return: If the user is already in the Chat, returns True, otherwise, returns False.
        """"""
        if username in self.users:
            del self.users[username]  # Remove the user from the dictionary
            return True
        else:
            return False

    def send_message(self, sender, receiver, message):
        """"""
        Send a message from a user to another user.
        :param sender: The username of the sender.
        :param receiver: The username of the receiver.
        :param message: The content of the message.
        :return: If the sender or the receiver is not in the Chat, returns False, otherwise, returns True.
        """"""
        if sender not in self.users or receiver not in self.users:
            return False
        else:
            # Create a message dictionary with sender, receiver, message, and timestamp
            msg = {
                'sender': sender,
                'receiver': receiver,
                'message': message,
                'timestamp': datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
            }
            # Append the message to the sender's message list
            self.users[sender].append(msg)
            # Append the message to the receiver's message list
            self.users[receiver].append(msg)
            return True

    def get_messages(self, username):
        """"""
        Get all the messages of a user from the Chat.
        :param username: The username of the user whose messages are to be retrieved.
        :return: A list of messages, each message is a dictionary with keys 'sender', 'receiver', 'message', 'timestamp'.
        """"""
        if username in self.users:
            return self.users[username]  # Return the list of messages for the user
        else:
            return []  # Return an empty list if the user is not found
```",0.163636364,0.18432096,0.959183673,0.388429752,0.552941172,0.769230769,0.256410256,0.384615381,0.959183673,0.388429752,0.552941172,,,,,,,,,,,,
GPT,21,"from datetime import datetime


class Classroom:
    def __init__(self, id):
        self.id = id
        self.courses = []

    def add_course(self, course):

        if course not in self.courses:
            self.courses.append(course)

    def remove_course(self, course):
        if course in self.courses:
            self.courses.remove(course)

    def is_free_at(self, check_time):
        check_time = datetime.strptime(check_time, '%H:%M')

        for course in self.courses:
            if datetime.strptime(course['start_time'], '%H:%M') <= check_time <= datetime.strptime(course['end_time'],
                                                                                                   '%H:%M'):
                return False
        return True

    def check_course_conflict(self, new_course):
        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M')
        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M')

        flag = True
        for course in self.courses:
            start_time = datetime.strptime(course['start_time'], '%H:%M')
            end_time = datetime.strptime(course['end_time'], '%H:%M')
            if start_time <= new_start_time and end_time >= new_start_time:
                flag = False
            if start_time <= new_end_time and end_time >= new_end_time:
                flag = False
        return flag",ZeroShot,"```python
from datetime import datetime

class Classroom:
    def __init__(self, id):
        """"""
        Initialize the classroom management system.
        """"""
        self.id = id
        # Initialize an empty list to store the courses scheduled in this classroom
        self.courses = []

    def add_course(self, course):
        """"""
        Add course to self.courses list if the course wasn't in it.
        """"""
        # Check if the course is not already in the list
        if course not in self.courses:
            # Add the course to the list
            self.courses.append(course)

    def remove_course(self, course):
        """"""
        Remove course from self.courses list if the course was in it.
        """"""
        # Check if the course is in the list
        if course in self.courses:
            # Remove the course from the list
            self.courses.remove(course)

    def is_free_at(self, check_time):
        """"""
        Check if the classroom is free at the given time.
        :param check_time: Time to check in '%H:%M' format.
        :return: True if the check_time does not conflict with any course time, or False otherwise.
        """"""
        # Convert check_time to datetime object for comparison
        check_time = datetime.strptime(check_time, '%H:%M').time()
        
        # Iterate through the courses to check for time conflicts
        for course in self.courses:
            # Assuming each course has 'start_time' and 'end_time' attributes
            start_time = datetime.strptime(course['start_time'], '%H:%M').time()
            end_time = datetime.strptime(course['end_time'], '%H:%M').time()
            
            # Check if the check_time falls within the course time
            if start_time <= check_time < end_time:
                return False
        
        # Return True if no conflict is found
        return True

    def check_course_conflict(self, new_course):
        """"""
        Check if the new course time conflicts with any other course.
        :param new_course: A dictionary with 'start_time' and 'end_time' in '%H:%M' format.
        :return: False if the new course time conflicts with other courses, or True otherwise.
        """"""
        # Convert new course times to datetime objects for comparison
        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M').time()
        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M').time()
        
        # Iterate through the existing courses to check for time conflicts
        for course in self.courses:
            # Assuming each course has 'start_time' and 'end_time' attributes
            start_time = datetime.strptime(course['start_time'], '%H:%M').time()
            end_time = datetime.strptime(course['end_time'], '%H:%M').time()
            
            # Check for overlap in course times
            if (new_start_time < end_time and new_end_time > start_time):
                return False
        
        # Return True if no conflict is found
        return True
```

**Comments:**
- The `Classroom` class manages courses by providing methods to add, remove, and check time conflicts.
- `add_course` and `remove_course` manage the list of courses.
- `is_free_at` checks if a specific time is available in the classroom.
- `check_course_conflict` ensures no time overlap occurs when scheduling new courses.",0.087628866,0.104887161,0.897959184,0.307692308,0.45833333,0.619565217,0.204301075,0.307277624,0.897959184,0.307692308,0.45833333,,,,,,,,,,,,
GPT,22,"class ClassRegistrationSystem:

    def __init__(self):
        self.students = []
        self.students_registration_classes = {}

    def register_student(self, student):
        if student in self.students:
            return 0
        else:
            self.students.append(student)
            return 1

    def register_class(self, student_name, class_name):
        if student_name in self.students_registration_classes:
            self.students_registration_classes[student_name].append(class_name)
        else:
            self.students_registration_classes[student_name] = [class_name]
        return self.students_registration_classes[student_name]

    def get_students_by_major(self, major):
        student_list = []
        for student in self.students:
            if student[""major""] == major:
                student_list.append(student[""name""])
        return student_list

    def get_all_major(self):
        major_list = []
        for student in self.students:
            if student[""major""] not in major_list:
                major_list.append(student[""major""])
        return major_list

    def get_most_popular_class_in_major(self, major):
        class_list = []
        for student in self.students:
            if student[""major""] == major:
                class_list += self.students_registration_classes[student[""name""]]
        most_popular_class = max(set(class_list), key=class_list.count)
        return most_popular_class",ZeroShot,"```python
class ClassRegistrationSystem:

    def __init__(self):
        """"""
        Initialize the registration system with the attribute students and students_registration_class.
        students is a list of student dictionaries, each student dictionary has the key of name and major.
        students_registration_class is a dictionary, key is the student name, value is a list of class names
        """"""
        self.students = []  # List to store student dictionaries
        self.students_registration_class = {}  # Dictionary to store class registrations for each student

    def register_student(self, student):
        """"""
        Register a student to the system, add the student to the students list.
        If the student is already registered, return 0, else return 1.
        """"""
        # Check if the student is already registered
        for s in self.students:
            if s['name'] == student['name']:
                return 0
        # Add the student to the list
        self.students.append(student)
        # Initialize the student's class registration list
        self.students_registration_class[student['name']] = []
        return 1

    def register_class(self, student_name, class_name):
        """"""
        Register a class to the student.
        :return a list of class names that the student has registered
        """"""
        # Check if the student is registered
        if student_name in self.students_registration_class:
            # Add the class to the student's list if not already registered
            if class_name not in self.students_registration_class[student_name]:
                self.students_registration_class[student_name].append(class_name)
            return self.students_registration_class[student_name]
        else:
            # If the student is not found, return an empty list
            return []

    def get_students_by_major(self, major):
        """"""
        Get all students in the major.
        :return a list of student names
        """"""
        # List comprehension to filter students by major
        return [student['name'] for student in self.students if student['major'] == major]

    def get_all_major(self):
        """"""
        Get all majors in the system.
        :return a list of majors
        """"""
        # Use a set to store unique majors
        majors = set(student['major'] for student in self.students)
        return list(majors)

    def get_most_popular_class_in_major(self, major):
        """"""
        Get the class with the highest enrollment in the major.
        :return a string of the most popular class in this major
        """"""
        # Dictionary to count class enrollments
        class_count = {}
        # Iterate over students in the specified major
        for student in self.students:
            if student['major'] == major:
                for class_name in self.students_registration_class.get(student['name'], []):
                    if class_name in class_count:
                        class_count[class_name] += 1
                    else:
                        class_count[class_name] = 1
        # Find the class with the maximum count
        if class_count:
            most_popular_class = max(class_count, key=class_count.get)
            return most_popular_class
        else:
            return None
```",0.047486034,0.062807735,0.7,0.269230769,0.388888885,0.392857143,0.118705036,0.182320438,0.7,0.269230769,0.388888885,,,,,,,,,,,,
GPT,23,"import math
from typing import List

class CombinationCalculator:
    def __init__(self, datas: List[str]):
        self.datas = datas

    @staticmethod
    def count(n: int, m: int) -> int:
        if m == 0 or n == m:
            return 1
        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))

    @staticmethod
    def count_all(n: int) -> int:
        if n < 0 or n > 63:
            return False
        return (1 << n) - 1 if n != 63 else float(""inf"")

    def select(self, m: int) -> List[List[str]]:
        result = []
        self._select(0, [None] * m, 0, result)
        return result

    def select_all(self) -> List[List[str]]:
        result = []
        for i in range(1, len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):
        resultLen = len(resultList)
        resultCount = resultIndex + 1
        if resultCount > resultLen:
            result.append(resultList.copy())
            return

        for i in range(dataIndex, len(self.datas) + resultCount - resultLen):
            resultList[resultIndex] = self.datas[i]
            self._select(i + 1, resultList, resultIndex + 1, result)",ZeroShot,"```python
import math
from typing import List
from itertools import combinations

class CombinationCalculator:
    def __init__(self, datas: List[str]):
        """"""
        Initialize the calculator with a list of data.
        """"""
        self.datas = datas

    @staticmethod
    def count(n: int, m: int) -> int:
        """"""
        Calculate the number of combinations for a specific count.
        :return: The number of combinations, int.
        """"""
        if m > n:
            return 0
        return math.comb(n, m)

    @staticmethod
    def count_all(n: int) -> int:
        """"""
        Calculate the number of all possible combinations.
        :return: The number of all possible combinations, int, if the number of combinations is greater than 2^63-1, return float(""inf"").
        """"""
        total_combinations = sum(math.comb(n, i) for i in range(n + 1))
        return total_combinations if total_combinations <= 2**63 - 1 else float(""inf"")

    def select(self, m: int) -> List[List[str]]:
        """"""
        Generate combinations with a specified number of elements.
        :return: A list of combinations, List[List[str]].
        """"""
        if m > len(self.datas):
            return []
        return [list(comb) for comb in combinations(self.datas, m)]

    def select_all(self) -> List[List[str]]:
        """"""
        Generate all possible combinations of selecting elements from the given data list, and it uses the select method.
        :return: A list of combinations, List[List[str]].
        """"""
        result = []
        for i in range(len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):
        """"""
        Generate combinations with a specified number of elements by recursion.
        :return: None.
        """"""
        if resultIndex == len(resultList):
            result.append(resultList.copy())
            return
        if dataIndex >= len(self.datas):
            return

        # Include the current element
        resultList[resultIndex] = self.datas[dataIndex]
        self._select(dataIndex + 1, resultList, resultIndex + 1, result)

        # Exclude the current element
        self._select(dataIndex + 1, resultList, resultIndex, result)
```

This code provides a complete implementation of the `CombinationCalculator` class with methods to calculate combinations, generate specific combinations, and generate all possible combinations. It uses the `math.comb` function for combination calculations and `itertools.combinations` for generating combinations. The `_select` method is implemented recursively to generate combinations by including or excluding elements from the data list.",0.167741935,0.198445088,0.688888889,0.397435897,0.504065036,0.474452555,0.245283019,0.32338308,0.677777778,0.391025641,0.495934955,,,,,,,,,,,,
GPT,24,"class ComplexCalculator:
    def __init__(self):
        pass

    @staticmethod
    def add(c1, c2):
        real = c1.real + c2.real
        imaginary = c1.imag + c2.imag
        answer = complex(real, imaginary)
        return answer
    
    @staticmethod
    def subtract(c1, c2):
        real = c1.real - c2.real
        imaginary = c1.imag - c2.imag
        return complex(real, imaginary)
    
    @staticmethod
    def multiply(c1, c2):
        real = c1.real * c2.real - c1.imag * c2.imag
        imaginary = c1.real * c2.imag + c1.imag * c2.real
        return complex(real, imaginary)
    
    @staticmethod
    def divide(c1, c2):
        denominator = c2.real**2 + c2.imag**2
        real = (c1.real * c2.real + c1.imag * c2.imag) / denominator
        imaginary = (c1.imag * c2.real - c1.real * c2.imag) / denominator
        return complex(real, imaginary)",ZeroShot,"```python
class ComplexCalculator:

    def __init__(self):
        pass

    @staticmethod
    def add(c1, c2):
        """"""
        Adds two complex numbers.
        :return: The sum of the two complex numbers, complex.
        """"""
        # Use complex number addition: (a+bi) + (c+di) = (a+c) + (b+d)i
        return c1 + c2

    @staticmethod
    def subtract(c1, c2):
        """"""
        Subtracts two complex numbers.
        :return: The difference of the two complex numbers, complex.
        """"""
        # Use complex number subtraction: (a+bi) - (c+di) = (a-c) + (b-d)i
        return c1 - c2

    @staticmethod
    def multiply(c1, c2):
        """"""
        Multiplies two complex numbers.
        :return: The product of the two complex numbers, complex.
        """"""
        # Use complex number multiplication: (a+bi)(c+di) = (ac-bd) + (ad+bc)i
        return c1 * c2

    @staticmethod
    def divide(c1, c2):
        """"""
        Divides two complex numbers.
        :return: The quotient of the two complex numbers, complex.
        """"""
        # Use complex number division: (a+bi)/(c+di) = [(ac+bd) + (bc-ad)i] / (c^2 + d^2)
        if c2 == 0:
            raise ValueError(""Cannot divide by zero complex number"")
        return c1 / c2
```",0.083333333,0.106640357,0.633333333,0.279411765,0.387755098,0.278688525,0.166666667,0.208588952,0.633333333,0.279411765,0.387755098,,,,,,,,,,,,
GPT,25,"import json

class CookiesUtil:
    def __init__(self, cookies_file):
        self.cookies_file = cookies_file
        self.cookies = None

    def get_cookies(self, reponse):
        self.cookies = reponse['cookies']
        self._save_cookies()

    def load_cookies(self):
        try:
            with open(self.cookies_file, 'r') as file:
                cookies_data = json.load(file)
                return cookies_data
        except FileNotFoundError:
            return {}

    def _save_cookies(self):
        try:
            with open(self.cookies_file, 'w') as file:
                json.dump(self.cookies, file)
            return True
        except:
            return False

    def set_cookies(self, request):
        request['cookies'] = '; '.join([f'{key}={value}' for key, value in self.cookies.items()])",ZeroShot,"```python
import json

class CookiesUtil:
    def __init__(self, cookies_file):
        """"""
        Initializes the CookiesUtil with the specified cookies file.
        :param cookies_file: The file path where cookies will be stored.
        """"""
        self.cookies_file = cookies_file
        self.cookies_data = {}

    def get_cookies(self, response):
        """"""
        Gets the cookies from the specified response and saves them to cookies_file.
        :param response: The response object from which to extract cookies.
        """"""
        # Extract cookies from the response
        self.cookies_data = response.cookies.get_dict()
        # Save cookies to file
        self._save_cookies()

    def load_cookies(self):
        """"""
        Loads the cookies from the cookies_file to the cookies data.
        :return: The cookies data, dict.
        """"""
        try:
            with open(self.cookies_file, 'r') as file:
                self.cookies_data = json.load(file)
        except FileNotFoundError:
            # If the file does not exist, return an empty dictionary
            self.cookies_data = {}
        except json.JSONDecodeError:
            # If the file is not a valid JSON, return an empty dictionary
            self.cookies_data = {}
        return self.cookies_data

    def _save_cookies(self):
        """"""
        Saves the cookies to the cookies_file, and returns True if successful, False otherwise.
        :return: True if successful, False otherwise.
        """"""
        try:
            with open(self.cookies_file, 'w') as file:
                json.dump(self.cookies_data, file)
            return True
        except IOError:
            # If there is an IOError, return False
            return False
```",0.086956522,0.114207408,0.673469388,0.362637363,0.471428567,0.485294118,0.203703704,0.286956518,0.673469388,0.362637363,0.471428567,,,,,,,,,,,,
GPT,26,"import csv


class CSVProcessor:

    def __init__(self):
        pass

    def read_csv(self, file_name):
        data = []
        with open(file_name, 'r') as file:
            reader = csv.reader(file)
            title = next(reader)
            for row in reader:
                data.append(row)
        return title, data

    def write_csv(self, data, file_name):
        try:
            with open(file_name, 'w', newline='') as file:
                writer = csv.writer(file)
                writer.writerows(data)
            return 1
        except:
            return 0

    def process_csv_data(self, N, save_file_name):
        title, data = self.read_csv(save_file_name)
        column_data = [row[N] for row in data]
        column_data = [row.upper() for row in column_data]
        new_data = [title, column_data]
        return self.write_csv(new_data, save_file_name.split('.')[0] + '_process.csv')",ZeroShot,"```python
import csv

class CSVProcessor:

    def __init__(self):
        pass

    def read_csv(self, file_name):
        """"""
        Read the csv file by file_name, get the title and data from it
        :return title, data: (list, list), first row is title, the rest is data
        """"""
        try:
            with open(file_name, mode='r', newline='', encoding='utf-8') as file:
                reader = csv.reader(file)
                title = next(reader)  # Read the first row as title
                data = [row for row in reader]  # Read the remaining rows as data
            return title, data
        except Exception as e:
            print(f""Error reading CSV file: {e}"")
            return [], []

    def write_csv(self, data, file_name):
        """"""
        Write data into a csv file.
        :return:int, if success return 1, or 0 otherwise
        """"""
        try:
            with open(file_name, mode='w', newline='', encoding='utf-8') as file:
                writer = csv.writer(file)
                writer.writerows(data)  # Write data to the CSV file
            return 1
        except Exception as e:
            print(f""Error writing CSV file: {e}"")
            return 0

    def process_csv_data(self, N, save_file_name):
        """"""
        Read a csv file into variable title and data.
        Only remain the N th (from 0) column data and Capitalize them, store the title and new data into a new csv file.
        Add '_process' suffix after old file name, as a new file name.
        :return:int, if success return 1, or 0 otherwise
        """"""
        try:
            title, data = self.read_csv(save_file_name)

            if not title or N >= len(title):
                print(""Invalid column index"")
                return 0

            # Extract the Nth column and capitalize the data
            processed_data = [[title[N].capitalize()]] + [[row[N].capitalize()] for row in data]

            # Create new file name with '_process' suffix
            new_file_name = save_file_name.replace('.csv', '_process.csv')

            # Write the processed data to the new CSV file
            return self.write_csv(processed_data, new_file_name)
        except Exception as e:
            print(f""Error processing CSV data: {e}"")
            return 0
```

- The `read_csv` method reads a CSV file and returns the title and data.
- The `write_csv` method writes data to a CSV file and returns 1 for success or 0 for failure.
- The `process_csv_data` method reads a CSV file, processes the Nth column by capitalizing it, and writes the result to a new CSV file with a `_process` suffix. It returns 1 for success or 0 for failure.",0.091445428,0.10880512,0.745762712,0.299319728,0.427184462,0.536585366,0.167938931,0.25581395,0.728813559,0.292517007,0.417475724,,,,,,,,,,,,
GPT,27,"class CurrencyConverter:
    def __init__(self):
        self.rates = {
            'USD': 1.0,
            'EUR': 0.85,
            'GBP': 0.72,
            'JPY': 110.15,
            'CAD': 1.23,
            'AUD': 1.34,
            'CNY': 6.40,
        }

    def convert(self, amount, from_currency, to_currency):
        if from_currency == to_currency:
            return amount

        if from_currency not in self.rates or to_currency not in self.rates:
            return False

        from_rate = self.rates[from_currency]
        to_rate = self.rates[to_currency]

        converted_amount = (amount / from_rate) * to_rate
        return converted_amount

    def get_supported_currencies(self):
        return list(self.rates.keys())

    def add_currency_rate(self, currency, rate):
        if currency in self.rates:
            return False
        self.rates[currency] = rate

    def update_currency_rate(self, currency, new_rate):
        if currency not in self.rates:
            return False
        self.rates[currency] = new_rate",ZeroShot,"```python
class CurrencyConverter:
    def __init__(self):
        """"""
        Initialize the exchange rate of the US dollar against various currencies
        """"""
        # Dictionary to store currency rates where key is currency code and value is the exchange rate
        self.exchange_rates = {
            'USD': 1.0,  # Base currency
            'EUR': 0.85,
            'JPY': 110.0,
            'GBP': 0.75,
            'AUD': 1.35
        }

    def convert(self, amount, from_currency, to_currency):
        """"""
        Convert the value of a given currency to another currency type
        :return: float, value converted to another currency type
        """"""
        if from_currency not in self.exchange_rates or to_currency not in self.exchange_rates:
            raise ValueError(""Currency not supported"")
        
        # Convert amount to USD first
        amount_in_usd = amount / self.exchange_rates[from_currency]
        # Convert USD to target currency
        converted_amount = amount_in_usd * self.exchange_rates[to_currency]
        return converted_amount

    def get_supported_currencies(self):
        """"""
        Returns a list of supported currency types
        :return: list, All supported currency types
        """"""
        return list(self.exchange_rates.keys())

    def add_currency_rate(self, currency, rate):
        """"""
        Add a new supported currency type, return False if the currency type is already in the support list
        :return: If successful, returns None; if unsuccessful, returns False
        """"""
        if currency in self.exchange_rates:
            return False
        self.exchange_rates[currency] = rate

    def update_currency_rate(self, currency, new_rate):
        """"""
        Update the exchange rate for a certain currency
        :return: If successful, returns None; if unsuccessful, returns False
        """"""
        if currency not in self.exchange_rates:
            return False
        self.exchange_rates[currency] = new_rate
```

This implementation defines a `CurrencyConverter` class with methods to convert between currencies, retrieve supported currencies, add new currency rates, and update existing currency rates. The exchange rates are stored in a dictionary with the currency code as the key and the rate as the value.",0.090551181,0.115490257,0.71875,0.356589147,0.476683933,0.477777778,0.188596491,0.270440248,0.703125,0.348837209,0.466321239,,,,,,,,,,,,
GPT,28,"import sqlite3
import pandas as pd


class DatabaseProcessor:

    def __init__(self, database_name):
        self.database_name = database_name

    def create_table(self, table_name, key1, key2):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        create_table_query = f""CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)""
        cursor.execute(create_table_query)

        conn.commit()
        conn.close()

    def insert_into_database(self, table_name, data):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        for item in data:
            insert_query = f""INSERT INTO {table_name} (name, age) VALUES (?, ?)""
            cursor.execute(insert_query, (item['name'], item['age']))

        conn.commit()
        conn.close()

    def search_database(self, table_name, name):

        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        select_query = f""SELECT * FROM {table_name} WHERE name = ?""
        cursor.execute(select_query, (name,))
        result = cursor.fetchall()

        if result:
            return result
        else:
            return None

    def delete_from_database(self, table_name, name):

        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        delete_query = f""DELETE FROM {table_name} WHERE name = ?""
        cursor.execute(delete_query, (name,))

        conn.commit()
        conn.close()",ZeroShot,"```python
import sqlite3
import pandas as pd

class DatabaseProcessor:

    def __init__(self, database_name):
        """"""
        Initialize database name of database processor
        """"""
        self.database_name = database_name
        # Connect to the database
        self.connection = sqlite3.connect(self.database_name)
        self.cursor = self.connection.cursor()

    def create_table(self, table_name, key1, key2):
        """"""
        Create a new table in the database if it doesn't exist.
        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER
        """"""
        # SQL command to create a table with id as PRIMARY KEY, key1 as TEXT, and key2 as INTEGER
        create_table_sql = f'''
        CREATE TABLE IF NOT EXISTS {table_name} (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            {key1} TEXT,
            {key2} INTEGER
        );
        '''
        # Execute the SQL command
        self.cursor.execute(create_table_sql)
        # Commit changes
        self.connection.commit()

    def insert_into_database(self, table_name, data):
        """"""
        Insert data into the specified table in the database.
        """"""
        # Assuming data is a list of dictionaries with keys matching table columns
        keys = data[0].keys()
        columns = ', '.join(keys)
        placeholders = ', '.join('?' for _ in keys)
        insert_sql = f'INSERT INTO {table_name} ({columns}) VALUES ({placeholders})'

        # Insert each row of data
        for row in data:
            values = tuple(row[key] for key in keys)
            self.cursor.execute(insert_sql, values)
        
        # Commit changes
        self.connection.commit()

    def search_database(self, table_name, name):
        """"""
        Search the specified table in the database for rows with a matching name.
        :return: list, a list of tuples representing the rows with matching name, if any;
                    otherwise, returns None.
        """"""
        # SQL command to search for rows with a matching name
        search_sql = f'SELECT * FROM {table_name} WHERE name = ?'
        self.cursor.execute(search_sql, (name,))
        # Fetch all matching rows
        results = self.cursor.fetchall()
        return results if results else None

    def delete_from_database(self, table_name, name):
        """"""
        Delete rows from the specified table in the database with a matching name.
        """"""
        # SQL command to delete rows with a matching name
        delete_sql = f'DELETE FROM {table_name} WHERE name = ?'
        self.cursor.execute(delete_sql, (name,))
        # Commit changes
        self.connection.commit()

    def __del__(self):
        """"""
        Destructor to close the database connection when the object is deleted
        """"""
        self.connection.close()
```

- **`__init__`**: Initializes the database connection.
- **`create_table`**: Creates a table with specified columns if it doesn't exist.
- **`insert_into_database`**: Inserts data into the table.
- **`search_database`**: Searches for rows by name and returns them.
- **`delete_from_database`**: Deletes rows by name.
- **`__del__`**: Closes the database connection when the object is deleted.",0.082887701,0.103714199,0.670886076,0.308139535,0.422310753,0.410714286,0.151315789,0.221153842,0.64556962,0.296511628,0.406374498,,,,,,,,,,,,
GPT,29,"from collections import Counter


class DataStatistics:
    def mean(self, data):
        return round(sum(data) / len(data), 2)

    def median(self, data):
        sorted_data = sorted(data)
        n = len(sorted_data)
        if n % 2 == 0:
            middle = n // 2
            return round((sorted_data[middle - 1] + sorted_data[middle]) / 2, 2)
        else:
            middle = n // 2
            return sorted_data[middle]

    def mode(self, data):
        counter = Counter(data)
        mode_count = max(counter.values())
        mode = [x for x, count in counter.items() if count == mode_count]
        return mode",ZeroShot,"```python
from collections import Counter

class DataStatistics:
    def mean(self, data):
        """"""
        Calculate the average value of a group of data, accurate to two digits after the Decimal separator
        :return: float, the mean value
        """"""
        if not data:
            return None
        # Calculate the mean by dividing the sum of the data by the number of data points
        return round(sum(data) / len(data), 2)

    def median(self, data):
        """"""
        Calculate the median of a group of data, accurate to two digits after the Decimal separator
        :return: float, the median value
        """"""
        if not data:
            return None
        # Sort the data to find the median
        sorted_data = sorted(data)
        n = len(sorted_data)
        mid = n // 2

        # Check if the number of data points is odd or even
        if n % 2 == 0:
            # If even, median is the average of the two middle numbers
            median_value = (sorted_data[mid - 1] + sorted_data[mid]) / 2
        else:
            # If odd, median is the middle number
            median_value = sorted_data[mid]

        return round(median_value, 2)

    def mode(self, data):
        """"""
        Calculate the mode of a set of data
        :return: float, the mode
        """"""
        if not data:
            return None
        # Use Counter to count the frequency of each element in the data
        data_count = Counter(data)
        # Find the maximum frequency
        max_count = max(data_count.values())
        # Find the element(s) with the maximum frequency
        mode_values = [k for k, v in data_count.items() if v == max_count]

        # If there's a tie for the mode, return the first one encountered
        return mode_values[0] if mode_values else None
```",0.100401606,0.123141159,0.795918367,0.345132743,0.481481477,0.485714286,0.178010471,0.260536395,0.775510204,0.336283186,0.469135798,,,,,,,,,,,,
GPT,30,"import numpy as np


class DataStatistics2:
    def __init__(self, data):
        self.data = np.array(data)

    def get_sum(self):
        return np.sum(self.data)

    def get_min(self):
        return np.min(self.data)

    def get_max(self):
        return np.max(self.data)

    def get_variance(self):
        return round(np.var(self.data), 2)

    def get_std_deviation(self):
        return round(np.std(self.data), 2)

    def get_correlation(self):
        return np.corrcoef(self.data, rowvar=False)",ZeroShot,"```python
import numpy as np

class DataStatistics2:
    def __init__(self, data):
        """"""
        Initialize Data List
        """"""
        self.data = np.array(data)  # Convert input data to a numpy array for easy calculations

    def get_sum(self):
        """"""
        Calculate the sum of data
        :return:float
        """"""
        return np.sum(self.data)  # Use numpy's sum function to calculate the sum

    def get_min(self):
        """"""
        Calculate the minimum value in the data
        :return:float
        """"""
        return np.min(self.data)  # Use numpy's min function to find the minimum value

    def get_max(self):
        """"""
        Calculate the maximum value in the data
        :return:float
        """"""
        return np.max(self.data)  # Use numpy's max function to find the maximum value

    def get_variance(self):
        """"""
        Calculate variance, accurate to two digits after the Decimal separator
        :return:float
        """"""
        return round(np.var(self.data), 2)  # Use numpy's var function and round to 2 decimal places

    def get_std_deviation(self):
        """"""
        Calculate standard deviation, accurate to two digits after the Decimal separator
        :return:float
        """"""
        return round(np.std(self.data), 2)  # Use numpy's std function and round to 2 decimal places

    def get_correlation(self, other_data):
        """"""
        Calculate correlation with another dataset
        :param other_data: list or array-like object
        :return:float
        """"""
        other_data = np.array(other_data)  # Convert the other_data to a numpy array
        if len(self.data) != len(other_data):
            raise ValueError(""Datasets must have the same length"")  # Ensure both datasets are of the same length
        correlation_matrix = np.corrcoef(self.data, other_data)  # Calculate the correlation matrix
        return correlation_matrix[0, 1]  # Return the correlation coefficient between the two datasets
```",0.044444444,0.06592539,0.9375,0.263157895,0.410958901,0.727272727,0.186046512,0.296296293,0.9375,0.263157895,0.410958901,,,,,,,,,,,,
GPT,31,"import math

class DataStatistics4:

    @staticmethod
    def correlation_coefficient(data1, data2):
        n = len(data1)
        mean1 = sum(data1) / n
        mean2 = sum(data2) / n

        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))
        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n))) * math.sqrt(sum((data2[i] - mean2) ** 2 for i in range(n)))

        return numerator / denominator if denominator != 0 else 0
    
    @staticmethod
    def skewness(data):
        n = len(data)
        mean = sum(data) / n
        variance = sum((x - mean) ** 2 for x in data) / n
        std_deviation = math.sqrt(variance)

        skewness = sum((x - mean) ** 3 for x in data) * n / ((n - 1) * (n - 2) * std_deviation ** 3) if std_deviation != 0 else 0

        return skewness
    
    @staticmethod
    def kurtosis(data):

        n = len(data)
        mean = sum(data) / n
        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / n)

        if std_dev == 0:
            return math.nan

        centered_data = [(x - mean) for x in data]
        fourth_moment = sum(x ** 4 for x in centered_data) / n

        kurtosis_value = (fourth_moment / std_dev ** 4) - 3

        return kurtosis_value
    
    @staticmethod
    def pdf(data, mu, sigma):
        pdf_values = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]
        return pdf_values",ZeroShot,"```python
import math

class DataStatistics4:

    @staticmethod
    def correlation_coefficient(data1, data2):
        """"""
        Calculate the correlation coefficient of two sets of data.
        :return: The correlation coefficient, float.
        """"""
        n = len(data1)
        mean1 = sum(data1) / n
        mean2 = sum(data2) / n
        
        # Calculate covariance
        covariance = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))
        
        # Calculate standard deviations
        stddev1 = math.sqrt(sum((x - mean1) ** 2 for x in data1))
        stddev2 = math.sqrt(sum((x - mean2) ** 2 for x in data2))
        
        # Calculate correlation coefficient
        correlation = covariance / (stddev1 * stddev2)
        return correlation

    @staticmethod
    def skewness(data):
        """"""
        Calculate the skewness of a set of data.
        :return: The skewness, float.
        """"""
        n = len(data)
        mean = sum(data) / n
        m3 = sum((x - mean) ** 3 for x in data) / n
        m2 = sum((x - mean) ** 2 for x in data) / n
        skewness = m3 / (m2 ** 1.5)
        return skewness

    @staticmethod
    def kurtosis(data):
        """"""
        Calculate the kurtosis of a set of data.
        :return: The kurtosis, float.
        """"""
        n = len(data)
        mean = sum(data) / n
        m4 = sum((x - mean) ** 4 for x in data) / n
        m2 = sum((x - mean) ** 2 for x in data) / n
        kurtosis = m4 / (m2 ** 2) - 3  # Excess kurtosis
        return kurtosis

    @staticmethod
    def pdf(data, mu, sigma):
        """"""
        Calculate the probability density function (PDF) of a set of data under a normal distribution.
        :return: The probability density function (PDF), list.
        """"""
        pdf_values = []
        for x in data:
            # Calculate the PDF for each data point
            exponent = math.exp(-((x - mu) ** 2) / (2 * sigma ** 2))
            pdf_value = (1 / (math.sqrt(2 * math.pi) * sigma)) * exponent
            pdf_values.append(pdf_value)
        return pdf_values
```

- **Correlation Coefficient**: Computes the Pearson correlation coefficient between two datasets.
- **Skewness**: Measures the asymmetry of the probability distribution of a real-valued random variable.
- **Kurtosis**: Measures the ""tailedness"" of the probability distribution of a real-valued random variable.
- **PDF**: Computes the probability density function for a normal distribution with given mean (`mu`) and standard deviation (`sigma`).",0.239884393,0.282418663,0.569767442,0.371212121,0.44954128,0.407185629,0.283333333,0.334152329,0.558139535,0.363636364,0.440366968,,,,,,,,,,,,
GPT,32,"class DecryptionUtils:
    def __init__(self, key):
        self.key = key
    
    def caesar_decipher(self, ciphertext, shift):
        plaintext = """"
        for char in ciphertext:
            if char.isalpha():
                if char.isupper():
                    ascii_offset = 65
                else:
                    ascii_offset = 97
                shifted_char = chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)
                plaintext += shifted_char
            else:
                plaintext += char
        return plaintext
    
    def vigenere_decipher(self, ciphertext):
        decrypted_text = """"
        key_index = 0
        for char in ciphertext:
            if char.isalpha():
                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')
                decrypted_char = chr((ord(char.lower()) - ord('a') - shift) % 26 + ord('a'))
                decrypted_text += decrypted_char.upper() if char.isupper() else decrypted_char
                key_index += 1
            else:
                decrypted_text += char
        return decrypted_text
    
    def rail_fence_decipher(self, encrypted_text, rails):
        fence = [['\n' for _ in range(len(encrypted_text))] for _ in range(rails)]
        direction = -1
        row, col = 0, 0

        for _ in range(len(encrypted_text)):
            if row == 0 or row == rails - 1:
                direction = -direction

            fence[row][col] = ''
            col += 1
            row += direction

        index = 0
        for i in range(rails):
            for j in range(len(encrypted_text)):
                if fence[i][j] == '':
                    fence[i][j] = encrypted_text[index]
                    index += 1

        plain_text = ''
        direction = -1
        row, col = 0, 0
        for _ in range(len(encrypted_text)):
            if row == 0 or row == rails - 1:
                direction = -direction

            plain_text += fence[row][col]
            col += 1
            row += direction

        return plain_text",ZeroShot,"```python
class DecryptionUtils:
    def __init__(self, key):
        """"""
        Initializes the decryption utility with a key.
        """"""
        self.key = key

    def caesar_decipher(self, ciphertext, shift):
        """"""
        Deciphers the given ciphertext using the Caesar cipher
        :return: The deciphered plaintext, str.
        """"""
        plaintext = []
        for char in ciphertext:
            if char.isalpha():
                shift_amount = shift % 26
                shifted = ord(char) - shift_amount
                if char.islower():
                    if shifted < ord('a'):
                        shifted += 26
                elif char.isupper():
                    if shifted < ord('A'):
                        shifted += 26
                plaintext.append(chr(shifted))
            else:
                plaintext.append(char)
        return ''.join(plaintext)

    def vigenere_decipher(self, ciphertext):
        """"""
        Deciphers the given ciphertext using the Vigenere cipher
        :return: The deciphered plaintext, str.
        """"""
        plaintext = []
        key_length = len(self.key)
        key_as_int = [ord(i) for i in self.key]
        ciphertext_int = [ord(i) for i in ciphertext]
        
        for i in range(len(ciphertext_int)):
            if ciphertext[i].isalpha():
                value = (ciphertext_int[i] - key_as_int[i % key_length]) % 26
                if ciphertext[i].islower():
                    plaintext.append(chr(value + ord('a')))
                else:
                    plaintext.append(chr(value + ord('A')))
            else:
                plaintext.append(ciphertext[i])
        
        return ''.join(plaintext)

    def rail_fence_decipher(self, encrypted_text, rails):
        """"""
        Deciphers the given ciphertext using the Rail Fence cipher
        :return: The deciphered plaintext, str.
        """"""
        if rails == 1:
            return encrypted_text
        
        # Create an empty matrix to mark the rail positions
        matrix = [['\n' for _ in range(len(encrypted_text))] for _ in range(rails)]
        
        # Mark the rail positions with '*'
        direction_down = None
        row, col = 0, 0
        
        for i in range(len(encrypted_text)):
            if row == 0:
                direction_down = True
            if row == rails - 1:
                direction_down = False
            
            matrix[row][col] = '*'
            col += 1
            
            if direction_down:
                row += 1
            else:
                row -= 1
        
        # Fill the matrix with the encrypted text
        index = 0
        for i in range(rails):
            for j in range(len(encrypted_text)):
                if matrix[i][j] == '*' and index < len(encrypted_text):
                    matrix[i][j] = encrypted_text[index]
                    index += 1
        
        # Read the matrix in a zigzag manner to decrypt
        result = []
        row, col = 0, 0
        for i in range(len(encrypted_text)):
            if row == 0:
                direction_down = True
            if row == rails - 1:
                direction_down = False
            
            if matrix[row][col] != '\n':
                result.append(matrix[row][col])
                col += 1
            
            if direction_down:
                row += 1
            else:
                row -= 1
        
        return ''.join(result)
```",0.178247734,0.218047065,0.638554217,0.378571429,0.475336318,0.38961039,0.243902439,0.299999995,0.638554217,0.378571429,0.475336318,,,,,,,,,,,,
GPT,33,"class DiscountStrategy:
    def __init__(self, customer, cart, promotion=None):
        self.customer = customer
        self.cart = cart
        self.promotion = promotion
        self.__total = self.total()

    def total(self):
        self.__total = sum(item['quantity'] * item['price'] for item in self.cart)
        return self.__total

    def due(self):
        if self.promotion is None:
            discount = 0
        else:
            discount = self.promotion(self)
        return self.__total - discount

    @staticmethod
    def FidelityPromo(order):
        return order.total() * 0.05 if order.customer['fidelity'] >= 1000 else 0

    @staticmethod
    def BulkItemPromo(order):
        discount = 0
        for item in order.cart:
            if item['quantity'] >= 20:
                discount += item['quantity'] * item['price'] * 0.1
        return discount

    @staticmethod
    def LargeOrderPromo(order):
        return order.total() * 0.07 if len({item['product'] for item in order.cart}) >= 10 else 0",ZeroShot,"```python
class DiscountStrategy:
    def __init__(self, customer, cart, promotion=None):
        """"""
        Initialize the DiscountStrategy with customer information, a cart of items, and an optional promotion.
        :param customer: dict, contains customer information including fidelity points
        :param cart: list of tuples, each tuple contains (product, quantity, price)
        :param promotion: function, a promotion function to apply
        """"""
        self.customer = customer
        self.cart = cart
        self.promotion = promotion

    def total(self):
        """"""
        Calculate the total cost of items in the cart.
        :return: float, total cost of items
        """"""
        return sum(item[1] * item[2] for item in self.cart)

    def due(self):
        """"""
        Calculate the final amount to be paid after applying the discount.
        :return: float, final amount to be paid
        """"""
        if self.promotion is None:
            discount = 0
        else:
            discount = self.promotion(self)
        return self.total() - discount

    @staticmethod
    def FidelityPromo(order):
        """"""
        Calculate the discount based on the fidelity points of the customer.
        Customers with over 1000 points can enjoy a 5% discount on the entire order.
        :param order: DiscountStrategy instance
        :return: float, discount amount
        """"""
        if order.customer.get('fidelity', 0) > 1000:
            return order.total() * 0.05
        return 0

    @staticmethod
    def BulkItemPromo(order):
        """"""
        Calculate the discount based on bulk item quantity in the order.
        In the same order, if the quantity of a single item reaches 20 or more, each item will enjoy a 10% discount.
        :param order: DiscountStrategy instance
        :return: float, discount amount
        """"""
        discount = 0
        for item in order.cart:
            if item[1] >= 20:
                discount += item[1] * item[2] * 0.10
        return discount

    @staticmethod
    def LargeOrderPromo(order):
        """"""
        Calculate the discount based on the number of different products in the order.
        If the quantity of different products in the order reaches 10 or more, the entire order will enjoy a 7% discount.
        :param order: DiscountStrategy instance
        :return: float, discount amount
        """"""
        if len(order.cart) >= 10:
            return order.total() * 0.07
        return 0
```

This implementation defines a `DiscountStrategy` class with methods to calculate the total cost of a cart, apply a promotion, and calculate the final amount due after discounts. The class includes three static methods for different discount strategies: `FidelityPromo`, `BulkItemPromo`, and `LargeOrderPromo`. Each method applies a specific discount based on conditions such as customer fidelity points, bulk item quantities, or the number of different products in the cart.",0.121212121,0.141262806,0.823529412,0.28,0.417910444,0.610526316,0.203508772,0.305263154,0.823529412,0.28,0.417910444,,,,,,,,,,,,
GPT,34,"from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT


class DocFileHandler:
    def __init__(self, file_path):
        self.file_path = file_path

    def read_text(self):
        doc = Document(self.file_path)
        text = []
        for paragraph in doc.paragraphs:
            text.append(paragraph.text)
        return ""\n"".join(text)

    def write_text(self, content, font_size=12, alignment='left'):
        try:
            doc = Document()
            paragraph = doc.add_paragraph()
            run = paragraph.add_run(content)
            font = run.font
            font.size = Pt(font_size)
            alignment_value = self._get_alignment_value(alignment)
            paragraph.alignment = alignment_value
            doc.save(self.file_path)
            return True
        except:
            return False

    def add_heading(self, heading, level=1):
        try:
            doc = Document(self.file_path)
            doc.add_heading(heading, level)
            doc.save(self.file_path)
            return True
        except:
            return False

    def add_table(self, data):
        try:
            doc = Document(self.file_path)
            table = doc.add_table(rows=len(data), cols=len(data[0]))
            for i, row in enumerate(data):
                for j, cell_value in enumerate(row):
                    table.cell(i, j).text = str(cell_value)
            doc.save(self.file_path)
            return True
        except:
            return False

    def _get_alignment_value(self, alignment):
        alignment_options = {
            'left': WD_PARAGRAPH_ALIGNMENT.LEFT,
            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,
            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT
        }
        return alignment_options.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)",ZeroShot,"```python
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT

class DocFileHandler:
    def __init__(self, file_path):
        """"""
        Initializes the DocFileHandler object with the specified file path.
        """"""
        self.file_path = file_path
        self.document = Document()  # Create a new Document

    def read_text(self):
        """"""
        Reads the content of a Word document and returns it as a string.
        :return: str, the content of the Word document.
        """"""
        doc = Document(self.file_path)
        full_text = []
        for para in doc.paragraphs:
            full_text.append(para.text)
        return '\n'.join(full_text)

    def write_text(self, content, font_size=12, alignment='left'):
        """"""
        Writes the specified content to a Word document.
        :return: bool, True if the write operation is successful, False otherwise.
        """"""
        try:
            paragraph = self.document.add_paragraph(content)
            paragraph_format = paragraph.paragraph_format
            paragraph_format.alignment = self._get_alignment_value(alignment)
            run = paragraph.runs[0]
            run.font.size = Pt(font_size)
            self.document.save(self.file_path)
            return True
        except Exception as e:
            print(f""Error writing text: {e}"")
            return False

    def add_heading(self, heading, level=1):
        """"""
        Adds a heading to the Word document.
        :return: bool, True if the heading is successfully added, False otherwise.
        """"""
        try:
            self.document.add_heading(heading, level=level)
            self.document.save(self.file_path)
            return True
        except Exception as e:
            print(f""Error adding heading: {e}"")
            return False

    def add_table(self, data):
        """"""
        Adds a table to the Word document with the specified data.
        :return: bool, True if the table is successfully added, False otherwise.
        """"""
        try:
            table = self.document.add_table(rows=1, cols=len(data[0]))
            hdr_cells = table.rows[0].cells
            for i, heading in enumerate(data[0]):
                hdr_cells[i].text = heading

            for row_data in data[1:]:
                row_cells = table.add_row().cells
                for i, item in enumerate(row_data):
                    row_cells[i].text = str(item)

            self.document.save(self.file_path)
            return True
        except Exception as e:
            print(f""Error adding table: {e}"")
            return False

    def _get_alignment_value(self, alignment):
        """"""
        Returns the alignment value corresponding to the given alignment string.
        :return: int, the alignment value.
        """"""
        alignment_dict = {
            'left': WD_PARAGRAPH_ALIGNMENT.LEFT,
            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,
            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT,
            'justify': WD_PARAGRAPH_ALIGNMENT.JUSTIFY
        }
        return alignment_dict.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)
```

In this code, the `DocFileHandler` class is designed to handle Word documents using the `python-docx` library. It provides methods to read text, write text with specific formatting, add headings, and insert tables into a Word document. The `_get_alignment_value` method maps string alignment inputs to the appropriate `WD_PARAGRAPH_ALIGNMENT` values from the library.",0.109422492,0.14599956,0.771084337,0.361581921,0.492307688,0.537313433,0.244897959,0.336448594,0.771084337,0.361581921,0.492307688,,,,,,,,,,,,
GPT,35,"class EightPuzzle:
    def __init__(self, initial_state):
        self.initial_state = initial_state
        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

    def find_blank(self, state):
        for i in range(3):
            for j in range(3):
                if state[i][j] == 0:
                    return i, j

    def move(self, state, direction):
        i, j = self.find_blank(state)
        new_state = [row[:] for row in state]

        if direction == 'up':
            new_state[i][j], new_state[i - 1][j] = new_state[i - 1][j], new_state[i][j]
        elif direction == 'down':
            new_state[i][j], new_state[i + 1][j] = new_state[i + 1][j], new_state[i][j]
        elif direction == 'left':
            new_state[i][j], new_state[i][j - 1] = new_state[i][j - 1], new_state[i][j]
        elif direction == 'right':
            new_state[i][j], new_state[i][j + 1] = new_state[i][j + 1], new_state[i][j]

        return new_state

    def get_possible_moves(self, state):
        moves = []
        i, j = self.find_blank(state)

        if i > 0:
            moves.append('up')
        if i < 2:
            moves.append('down')
        if j > 0:
            moves.append('left')
        if j < 2:
            moves.append('right')

        return moves

    def solve(self):
        open_list = [(self.initial_state, [])]
        closed_list = []

        while open_list:
            current_state, path = open_list.pop(0)
            closed_list.append(current_state)

            if current_state == self.goal_state:
                return path

            for move in self.get_possible_moves(current_state):
                new_state = self.move(current_state, move)
                if new_state not in closed_list:
                    open_list.append((new_state, path + [move]))

        return None",ZeroShot,"```python
from collections import deque

class EightPuzzle:
    def __init__(self, initial_state):
        """"""
        Initializing the initial state of Eight Puzzle Game, stores in attribute self.initial_state.
        And set the goal state of this game, stores in self.goal_state. In this case, set the size as 3*3
        """"""
        self.initial_state = initial_state
        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]  # Goal state for 8-puzzle

    def find_blank(self, state):
        """"""
        Find the blank position of current state, which is the 0 element.
        :return i, j: two Integers, represent the coordinate of the blank block.
        """"""
        for i in range(3):
            for j in range(3):
                if state[i][j] == 0:
                    return i, j

    def move(self, state, direction):
        """"""
        Find the blank block, then makes the board move toward the given direction.
        :return new_state: a 3*3 size list of Integer, stores the state after moving.
        """"""
        i, j = self.find_blank(state)
        new_state = [row[:] for row in state]  # Create a deep copy of the state
        
        if direction == 'up' and i > 0:
            new_state[i][j], new_state[i-1][j] = new_state[i-1][j], new_state[i][j]
        elif direction == 'down' and i < 2:
            new_state[i][j], new_state[i+1][j] = new_state[i+1][j], new_state[i][j]
        elif direction == 'left' and j > 0:
            new_state[i][j], new_state[i][j-1] = new_state[i][j-1], new_state[i][j]
        elif direction == 'right' and j < 2:
            new_state[i][j], new_state[i][j+1] = new_state[i][j+1], new_state[i][j]
        
        return new_state

    def get_possible_moves(self, state):
        """"""
        According to the current state, find all the possible moving directions. Only has 4 directions 'up', 'down', 'left', 'right'.
        :return moves: a list of str, store all the possible moving directions according to the current state.
        """"""
        moves = []
        i, j = self.find_blank(state)
        
        if i > 0:
            moves.append('up')
        if i < 2:
            moves.append('down')
        if j > 0:
            moves.append('left')
        if j < 2:
            moves.append('right')
        
        return moves

    def solve(self):
        """"""
        Use BFS algorithm to find the path solution which makes the initial state to the goal method.
        Maintain a list as a queue, named as open_list, append the initial state.
        Always visit and pop the 0 index element, invoke get_possible_moves method to find all the possible directions.
        Traverse the possible_moves list and invoke move method to get several new states. Then append them.
        Redo the above steps until the open_list is empty or the state has changed to the goal state.
        :return path: list of str, the solution to the goal state.
        """"""
        open_list = deque([(self.initial_state, [])])
        visited = set()
        
        while open_list:
            current_state, path = open_list.popleft()
            visited.add(tuple(map(tuple, current_state)))
            
            if current_state == self.goal_state:
                return path
            
            for move in self.get_possible_moves(current_state):
                new_state = self.move(current_state, move)
                new_state_tuple = tuple(map(tuple, new_state))
                
                if new_state_tuple not in visited:
                    open_list.append((new_state, path + [move]))
                    visited.add(new_state_tuple)
        
        return None  # Return None if no solution is found
```",0.230769231,0.253075638,0.806818182,0.341346154,0.479729726,0.679245283,0.291891892,0.408317576,0.806818182,0.341346154,0.479729726,,,,,,,,,,,,
GPT,36,"from datetime import datetime

class EmailClient:
    def __init__(self, addr, capacity) -> None:
        self.addr = addr
        self.capacity = capacity
        self.inbox = []
    
    def send_to(self, recv, content, size):
        if not recv.is_full_with_one_more_email(size):
            timestamp = datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
            email = {
                ""sender"": self.addr,
                ""receiver"": recv.addr,
                ""content"": content,
                ""size"": size,
                ""time"": timestamp,
                ""state"": ""unread""
            }
            recv.inbox.append(email)
            return True
        else:
            self.clear_inbox(size)
            return False
    
    def fetch(self):
        if len(self.inbox) == 0:
            return None
        for i in range(len(self.inbox)):
            if self.inbox[i]['state'] == ""unread"":
                self.inbox[i]['state'] = ""read""
                return self.inbox[i]
        return None

    def is_full_with_one_more_email(self, size):
        occupied_size = self.get_occupied_size()
        return True if occupied_size + size > self.capacity else False
        
    def get_occupied_size(self):
        occupied_size = 0
        for email in self.inbox:
            occupied_size += email[""size""]
        return occupied_size

    def clear_inbox(self, size):
        if len(self.addr) == 0:
            return
        freed_space = 0
        while freed_space < size and self.inbox:
            email = self.inbox[0]
            freed_space += email['size']
            del self.inbox[0]",ZeroShot,"```python
from datetime import datetime

class EmailClient:
    def __init__(self, addr, capacity) -> None:
        """"""
        Initializes the EmailClient class with the email address and the capacity of the email box.
        :param addr: The email address of the client, str.
        :param capacity: The total capacity of the email box, float.
        """"""
        self.address = addr
        self.capacity = capacity
        self.inbox = []  # List to store emails as dictionaries
        self.occupied_size = 0.0  # To track the current size used in the inbox

    def send_to(self, recv, content, size):
        """"""
        Sends an email to the given email address.
        :param recv: The receiver's email address, str.
        :param content: The content of the email, str.
        :param size: The size of the email, float.
        :return: True if the email is sent successfully, False if the receiver's email box is full.
        """"""
        if recv.is_full_with_one_more_email(size):
            return False
        recv.inbox.append({
            'sender': self.address,
            'content': content,
            'size': size,
            'read': False,
            'timestamp': datetime.now()
        })
        recv.occupied_size += size
        return True

    def fetch(self):
        """"""
        Retrieves the first unread email in the email box and marks it as read.
        :return: The first unread email in the email box, dict.
        """"""
        for email in self.inbox:
            if not email['read']:
                email['read'] = True
                return email
        return None  # Return None if no unread email is found

    def is_full_with_one_more_email(self, size):
        """"""
        Determines whether the email box is full after adding an email of the given size.
        :param size: The size of the incoming email, float.
        :return: True if the email box is full, False otherwise.
        """"""
        return self.occupied_size + size > self.capacity

    def get_occupied_size(self):
        """"""
        Gets the total size of the emails in the email box.
        :return: The total size of the emails in the email box, float.
        """"""
        return self.occupied_size

    def clear_inbox(self, size):
        """"""
        Clears the email box by deleting the oldest emails until the email box has enough space to accommodate the given size.
        :param size: The size of the email to accommodate, float.
        """"""
        # Sort emails by timestamp to remove the oldest first
        self.inbox.sort(key=lambda email: email['timestamp'])
        while self.is_full_with_one_more_email(size):
            if self.inbox:
                oldest_email = self.inbox.pop(0)
                self.occupied_size -= oldest_email['size']
            else:
                break  # Break if there are no emails left to delete
```",0.07183908,0.097834361,0.590361446,0.333333333,0.426086952,0.375886525,0.189964158,0.252380948,0.578313253,0.326530612,0.4173913,,,,,,,,,,,,
GPT,37,"class EncryptionUtils:
    def __init__(self, key):
        self.key = key

    def caesar_cipher(self, plaintext, shift):
        ciphertext = """"
        for char in plaintext:
            if char.isalpha():
                if char.isupper():
                    ascii_offset = 65
                else:
                    ascii_offset = 97
                shifted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)
                ciphertext += shifted_char
            else:
                ciphertext += char
        return ciphertext
    
    def vigenere_cipher(self, plain_text):
        encrypted_text = """"
        key_index = 0
        for char in plain_text:
            if char.isalpha():
                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')
                encrypted_char = chr((ord(char.lower()) - ord('a') + shift) % 26 + ord('a'))
                encrypted_text += encrypted_char.upper() if char.isupper() else encrypted_char
                key_index += 1
            else:
                encrypted_text += char
        return encrypted_text

    def rail_fence_cipher(self, plain_text, rails):
        fence = [['\n' for _ in range(len(plain_text))] for _ in range(rails)]
        direction = -1
        row, col = 0, 0

        for char in plain_text:
            if row == 0 or row == rails-1:
                direction = -direction

            fence[row][col] = char
            col += 1
            row += direction

        encrypted_text = ''
        for i in range(rails):
            for j in range(len(plain_text)):
                if fence[i][j] != '\n':
                    encrypted_text += fence[i][j]

        return encrypted_text",ZeroShot,"```python
class EncryptionUtils:
    def __init__(self, key):
        """"""
        Initializes the class with a key.
        """"""
        self.key = key

    def caesar_cipher(self, plaintext, shift):
        """"""
        Encrypts the plaintext using the Caesar cipher.
        :param plaintext: The text to be encrypted, str.
        :param shift: The number of positions to shift each character, int.
        :return: The ciphertext, str.
        """"""
        ciphertext = """"
        for char in plaintext:
            if char.isalpha():  # Only encrypt alphabetic characters
                shift_amount = shift % 26
                base = ord('A') if char.isupper() else ord('a')
                # Shift character and wrap around the alphabet
                cipher_char = chr((ord(char) - base + shift_amount) % 26 + base)
                ciphertext += cipher_char
            else:
                ciphertext += char  # Non-alphabetic characters are added unchanged
        return ciphertext

    def vigenere_cipher(self, plaintext):
        """"""
        Encrypts the plaintext using the Vigenere cipher.
        :param plaintext: The text to be encrypted, str.
        :return: The ciphertext, str.
        """"""
        ciphertext = []
        key_index = 0
        key_length = len(self.key)
        
        for char in plaintext:
            if char.isalpha():  # Only encrypt alphabetic characters
                key_char = self.key[key_index % key_length].lower()
                shift_amount = ord(key_char) - ord('a')
                base = ord('A') if char.isupper() else ord('a')
                # Shift character by the key character's shift amount
                cipher_char = chr((ord(char) - base + shift_amount) % 26 + base)
                ciphertext.append(cipher_char)
                key_index += 1
            else:
                ciphertext.append(char)  # Non-alphabetic characters are added unchanged
        
        return ''.join(ciphertext)

    def rail_fence_cipher(self, plain_text, rails):
        """"""
        Encrypts the plaintext using the Rail Fence cipher.
        :param plain_text: The text to be encrypted, str.
        :param rails: The number of rails to use in the cipher, int.
        :return: The ciphertext, str.
        """"""
        if rails <= 1:
            return plain_text  # No encryption if rails are less than or equal to 1
        
        # Create a list of empty strings for each rail
        rail_fence = ['' for _ in range(rails)]
        direction_down = False
        row = 0

        # Place characters in the rail pattern
        for char in plain_text:
            rail_fence[row] += char
            if row == 0 or row == rails - 1:
                direction_down = not direction_down
            row += 1 if direction_down else -1

        # Concatenate strings from all rails
        ciphertext = ''.join(rail_fence)
        return ciphertext
```",0.114457831,0.145096229,0.592592593,0.335664336,0.428571424,0.368055556,0.209486166,0.267002514,0.580246914,0.328671329,0.419642853,,,,,,,,,,,,
GPT,38,"import openpyxl


class ExcelProcessor:
    def __init__(self):
        pass

    def read_excel(self, file_name):
        data = []
        try:
            workbook = openpyxl.load_workbook(file_name)
            sheet = workbook.active
            for row in sheet.iter_rows(values_only=True):
                data.append(row)
            workbook.close()
            return data
        except:
            return None

    def write_excel(self, data, file_name):
        try:
            workbook = openpyxl.Workbook()
            sheet = workbook.active
            for row in data:
                sheet.append(row)
            workbook.save(file_name)
            workbook.close()
            return 1
        except:
            return 0

    def process_excel_data(self, N, save_file_name):
        data = self.read_excel(save_file_name)
        if data is None or N >= len(data[0]):
            return 0
        new_data = []
        for row in data:
            new_row = list(row[:])
            if not str(row[N]).isdigit():
                new_row.append(str(row[N]).upper())
            else:
                new_row.append(row[N])
            new_data.append(new_row)
        new_file_name = save_file_name.split('.')[0] + '_process.xlsx'
        success = self.write_excel(new_data, new_file_name)
        return success, new_file_name",ZeroShot,"```python
import openpyxl

class ExcelProcessor:
    def __init__(self):
        pass

    def read_excel(self, file_name):
        """"""
        Reading data from Excel files
        :return: list of data, Data in Excel
        """"""
        # Load the workbook and select the active worksheet
        workbook = openpyxl.load_workbook(file_name)
        sheet = workbook.active

        # Initialize a list to store the data
        data = []

        # Iterate through each row in the worksheet and append the row data to the list
        for row in sheet.iter_rows(values_only=True):
            data.append(list(row))

        return data

    def write_excel(self, data, file_name):
        """"""
        Write data to the specified Excel file
        :return: 0 or 1, 1 represents successful writing, 0 represents failed writing
        """"""
        try:
            # Create a new workbook and select the active worksheet
            workbook = openpyxl.Workbook()
            sheet = workbook.active

            # Write each row of data to the worksheet
            for row in data:
                sheet.append(row)

            # Save the workbook to the specified file
            workbook.save(file_name)
            return 1  # Return 1 for successful writing
        except Exception as e:
            print(f""An error occurred: {e}"")
            return 0  # Return 0 for failed writing

    def process_excel_data(self, N, save_file_name):
        """"""
        Change the specified column in the Excel file to uppercase
        :return: (int, str), The former is the return value of write_excel, while the latter is the saved file name of the processed data
        """"""
        # Read the data from the original Excel file
        data = self.read_excel(save_file_name)

        # Check if the column index N is within the range of available columns
        if len(data) == 0 or N >= len(data[0]):
            raise ValueError(""Column index N is out of range"")

        # Process the specified column to convert all text to uppercase
        for row in data:
            if isinstance(row[N], str):  # Check if the cell contains a string
                row[N] = row[N].upper()

        # Write the processed data to a new Excel file
        write_result = self.write_excel(data, save_file_name)

        return write_result, save_file_name
```

This code provides a complete implementation of the `ExcelProcessor` class with methods to read, write, and process Excel data. The `read_excel` method reads data from an Excel file, the `write_excel` method writes data to a new Excel file, and the `process_excel_data` method modifies a specified column by converting its contents to uppercase, then saves the result to a new file.",0.088825215,0.106962268,0.636363636,0.2625,0.371681412,0.434343434,0.14527027,0.217721515,0.636363636,0.2625,0.371681412,,,,,,,,,,,,
GPT,39,"import re
from collections import deque
from decimal import Decimal


class ExpressionCalculator:
    def __init__(self):
        self.postfix_stack = deque()
        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]

    def calculate(self, expression):
        self.prepare(self.transform(expression))

        result_stack = deque()
        self.postfix_stack.reverse()

        while self.postfix_stack:
            current_op = self.postfix_stack.pop()
            if not self.is_operator(current_op):
                current_op = current_op.replace(""~"", ""-"")
                result_stack.append(current_op)
            else:
                second_value = result_stack.pop()
                first_value = result_stack.pop()

                first_value = first_value.replace(""~"", ""-"")
                second_value = second_value.replace(""~"", ""-"")

                temp_result = self._calculate(first_value, second_value, current_op)
                result_stack.append(str(temp_result))

        return float(eval(""*"".join(result_stack)))

    def prepare(self, expression):
        op_stack = deque([','])
        arr = list(expression)
        current_index = 0
        count = 0

        for i, current_op in enumerate(arr):
            if self.is_operator(current_op):
                if count > 0:
                    self.postfix_stack.append("""".join(arr[current_index: current_index + count]))
                peek_op = op_stack[-1]
                if current_op == ')':
                    while op_stack[-1] != '(':
                        self.postfix_stack.append(str(op_stack.pop()))
                    op_stack.pop()
                else:
                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):
                        self.postfix_stack.append(str(op_stack.pop()))
                        peek_op = op_stack[-1]
                    op_stack.append(current_op)

                count = 0
                current_index = i + 1
            else:
                count += 1

        if count > 1 or (count == 1 and not self.is_operator(arr[current_index])):
            self.postfix_stack.append("""".join(arr[current_index: current_index + count]))

        while op_stack[-1] != ',':
            self.postfix_stack.append(str(op_stack.pop()))

    @staticmethod
    def is_operator(c):
        return c in {'+', '-', '*', '/', '(', ')', '%'}

    def compare(self, cur, peek):
        if cur == '%':
            cur = '/'
        if peek == '%':
            peek = '/'
        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]

    @staticmethod
    def _calculate(first_value, second_value, current_op):
        if current_op == '+':
            return Decimal(first_value) + Decimal(second_value)
        elif current_op == '-':
            return Decimal(first_value) - Decimal(second_value)
        elif current_op == '*':
            return Decimal(first_value) * Decimal(second_value)
        elif current_op == '/':
            return Decimal(first_value) / Decimal(second_value)
        elif current_op == '%':
            return Decimal(first_value) % Decimal(second_value)
        else:
            raise ValueError(""Unexpected operator: {}"".format(current_op))

    @staticmethod
    def transform(expression):
        expression = re.sub(r""\s+"", """", expression)
        expression = re.sub(r""=$"", """", expression)
        arr = list(expression)

        for i, c in enumerate(arr):
            if c == '-':
                if i == 0:
                    arr[i] = '~'
                else:
                    prev_c = arr[i - 1]
                    if prev_c in {'+', '-', '*', '/', '(', 'E', 'e'}:
                        arr[i] = '~'

        if arr[0] == '~' and (len(arr) > 1 and arr[1] == '('):
            arr[0] = '-'
            return ""0"" + """".join(arr)
        else:
            return """".join(arr)",ZeroShot,"```python
from collections import deque
from decimal import Decimal

class ExpressionCalculator:
    def __init__(self):
        """"""
        Initialize the expression calculator
        """"""
        self.postfix_stack = deque()
        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]

    def calculate(self, expression):
        """"""
        Calculate the result of the given postfix expression
        :param expression: string, the postfix expression
        :return: float, the calculated result
        """"""
        stack = deque()
        for token in expression.split():
            if token.isdigit() or '.' in token:  # Check if token is a number
                stack.append(Decimal(token))
            else:
                second_value = stack.pop()
                first_value = stack.pop()
                result = self._calculate(first_value, second_value, token)
                stack.append(result)
        return float(stack.pop())

    def prepare(self, expression):
        """"""
        Prepare the infix expression for conversion to postfix notation
        :param expression: string, the infix expression
        :return: string, the postfix expression
        """"""
        output = []
        operators = deque()
        for token in self.transform(expression):
            if token.isdigit() or '.' in token:
                output.append(token)
            elif token == '(':
                operators.append(token)
            elif token == ')':
                while operators and operators[-1] != '(':
                    output.append(operators.pop())
                operators.pop()  # Remove '(' from stack
            else:
                while operators and self.compare(token, operators[-1]):
                    output.append(operators.pop())
                operators.append(token)
        
        while operators:
            output.append(operators.pop())
        
        return ' '.join(output)

    @staticmethod
    def is_operator(c):
        """"""
        Check if a character is an operator in {'+', '-', '*', '/', '(', ')', '%'}
        :param c: char, the character to check
        :return: bool, True if the character is an operator, False otherwise
        """"""
        return c in {'+', '-', '*', '/', '(', ')', '%'}

    def compare(self, cur, peek):
        """"""
        Compare the precedence of two operators
        :param cur: char, the current operator
        :param peek: char, the operator to compare with
        :return: bool, True if the current operator has higher or equal precedence, False otherwise
        """"""
        return self.operat_priority[self._get_priority(cur)] <= self.operat_priority[self._get_priority(peek)]

    @staticmethod
    def _calculate(first_value, second_value, current_op):
        """"""
        Perform the mathematical calculation based on the given operands and operator
        :param first_value: decimal.Decimal, the first operand
        :param second_value: decimal.Decimal, the second operand
        :param current_op: char, the operator
        :return: decimal.Decimal, the calculated result
        """"""
        if current_op == '+':
            return first_value + second_value
        elif current_op == '-':
            return first_value - second_value
        elif current_op == '*':
            return first_value * second_value
        elif current_op == '/':
            return first_value / second_value
        elif current_op == '%':
            return first_value % second_value
        else:
            raise ValueError(f""Unknown operator: {current_op}"")

    @staticmethod
    def transform(expression):
        """"""
        Transform the infix expression to a format suitable for conversion
        :param expression: string, the infix expression
        :return: list, the transformed expression as a list of tokens
        """"""
        tokens = []
        current_num = []
        for char in expression:
            if char.isdigit() or char == '.':
                current_num.append(char)
            else:
                if current_num:
                    tokens.append(''.join(current_num))
                    current_num = []
                if char.strip():  # Ignore spaces
                    tokens.append(char)
        if current_num:
            tokens.append(''.join(current_num))
        return tokens

    def _get_priority(self, op):
        """"""
        Get the priority index for an operator
        :param op: char, the operator
        :return: int, the index in the priority list
        """"""
        return {'+': 1, '-': 2, '*': 3, '/': 4, '%': 5, '(': 6, ')': 7}.get(op, 0)
```

This code provides a complete implementation of the `ExpressionCalculator` class, supporting basic arithmetic operations through infix to postfix conversion and evaluation.",0.135021097,0.167001072,0.496598639,0.349282297,0.410112355,0.260416667,0.1875,0.218023251,0.489795918,0.344497608,0.404494377,,,,,,,,,,,,
GPT,40,"class FitnessTracker:
    def __init__(self, height, weight, age, sex) -> None:
        self.height = height
        self.weight = weight
        self.age = age
        self.sex = sex
        self.BMI_std = [
            {""male"": [20, 25]},
            {""female"": [19, 24]}
        ]

    def get_BMI(self):
        return self.weight / self.height ** 2

    def condition_judge(self):
        BMI = self.get_BMI()
        if self.sex == ""male"":
            BMI_range = self.BMI_std[0][""male""]
        else:
            BMI_range = self.BMI_std[1][""female""]
        if BMI > BMI_range[1]:
            # too fat
            return 1
        elif BMI < BMI_range[0]:
            # too thin
            return -1
        else:
            # normal
            return 0

    def calculate_calorie_intake(self):
        if self.sex == ""male"":
            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5
        else:
            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161
        if self.condition_judge() == 1:
            calorie_intake = BMR * 1.2  # Sedentary lifestyle
        elif self.condition_judge() == -1:
            calorie_intake = BMR * 1.6  # Active lifestyle
        else:
            calorie_intake = BMR * 1.4  # Moderate lifestyle
        return calorie_intake",ZeroShot,"```python
class FitnessTracker:
    def __init__(self, height, weight, age, sex) -> None:
        """"""
        Initialize the class with height, weight, age, and sex, and calculate the BMI standard based on sex, and male is 20-25, female is 19-24.
        """"""
        self.height = height  # Height in meters
        self.weight = weight  # Weight in kilograms
        self.age = age  # Age in years
        self.sex = sex  # Sex as 'male' or 'female'

        # Set BMI standards based on sex
        if self.sex == 'male':
            self.bmi_standard = (20, 25)
        elif self.sex == 'female':
            self.bmi_standard = (19, 24)
        else:
            raise ValueError(""Sex must be 'male' or 'female'"")

    def get_BMI(self):
        """"""
        Calculate the BMI based on the height and weight.
        :return: BMI, which is the weight divided by the square of height, float.
        """"""
        return self.weight / (self.height ** 2)

    def condition_judge(self):
        """"""
        Judge the condition of the user based on the BMI standard.
        :return: 1 if the user is too fat, -1 if the user is too thin, 0 if the user is normal, int.
        """"""
        bmi = self.get_BMI()
        lower, upper = self.bmi_standard
        if bmi < lower:
            return -1  # Too thin
        elif bmi > upper:
            return 1  # Too fat
        else:
            return 0  # Normal

    def calculate_calorie_intake(self):
        """"""
        Calculate the calorie intake based on the user's condition and BMR (Basal Metabolic Rate).
        BMR is calculated based on the user's height, weight, age, and sex:
        - Male: BMR = 10 * weight + 6.25 * height - 5 * age + 5
        - Female: BMR = 10 * weight + 6.25 * height - 5 * age - 161
        The calorie intake is calculated based on the BMR and the user's condition:
        - If the user is too fat, the calorie intake is BMR * 1.2
        - If the user is too thin, the calorie intake is BMR * 1.6
        - If the user is normal, the calorie intake is BMR * 1.4
        :return: calorie intake, float.
        """"""
        if self.sex == 'male':
            bmr = 10 * self.weight + 6.25 * self.height * 100 - 5 * self.age + 5
        else:
            bmr = 10 * self.weight + 6.25 * self.height * 100 - 5 * self.age - 161

        condition = self.condition_judge()
        if condition == 1:
            return bmr * 1.2
        elif condition == -1:
            return bmr * 1.6
        else:
            return bmr * 1.4
```

- The `__init__` method initializes the class attributes and sets the BMI standards based on the user's sex.
- The `get_BMI` method calculates the BMI using the formula: weight divided by the square of height.
- The `condition_judge` method determines the user's condition (too fat, too thin, or normal) based on the BMI and the predefined standards.
- The `calculate_calorie_intake` method calculates the Basal Metabolic Rate (BMR) and adjusts the calorie intake based on the user's condition.",0.089519651,0.117118339,0.708333333,0.331168831,0.451327429,0.446969697,0.186708861,0.263392853,0.680555556,0.318181818,0.433628314,,,,,,,,,,,,
GPT,41,"class GomokuGame:
    def __init__(self, board_size):
        self.board_size = board_size
        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        return False

    def check_winner(self):
        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]
        for row in range(self.board_size):
            for col in range(self.board_size):
                if self.board[row][col] != ' ':
                    for direction in directions:
                        if self._check_five_in_a_row(row, col, direction):
                            return self.board[row][col]
        return None

    def _check_five_in_a_row(self, row, col, direction):
        dx, dy = direction
        count = 1
        symbol = self.board[row][col]
        for i in range(1, 5):
            new_row = row + dx * i
            new_col = col + dy * i
            if not (0 <= new_row < self.board_size and 0 <= new_col < self.board_size):
                return False
            if self.board[new_row][new_col] != symbol:
                return False
            count += 1
        return count == 5",ZeroShot,"```python
class GomokuGame:
    def __init__(self, board_size):
        """"""
        Initializes the game with a given board size.
        It initializes the board with empty spaces and sets the current player symbol as 'X'.
        """"""
        self.board_size = board_size
        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]
        self.current_player = 'X'

    def make_move(self, row, col):
        """"""
        Makes a move at the given row and column.
        If the move is valid, it places the current player's symbol on the board
        and changes the current player to the other player (if the current player is 'X', then it becomes 'O' and vice versa).
        :return: True if the move is valid, or False otherwise.
        """"""
        if 0 <= row < self.board_size and 0 <= col < self.board_size and self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        return False

    def check_winner(self):
        """"""
        Checks if there is a winner by looking for five in a row in all directions (horizontal, vertical, diagonal).
        :return: the symbol of the winning player (either 'X' or 'O') if there is a winner, or None otherwise.
        """"""
        directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # vertical, horizontal, diagonal /
        for row in range(self.board_size):
            for col in range(self.board_size):
                if self.board[row][col] != ' ':
                    for direction in directions:
                        if self._check_five_in_a_row(row, col, direction):
                            return self.board[row][col]
        return None

    def _check_five_in_a_row(self, row, col, direction):
        """"""
        Checks if there are five consecutive symbols of the same player in a row starting from a given cell in a given direction (horizontal, vertical, diagonal).
        Counts the number of consecutive symbols in that direction starting from the given cell,
        :return: True if there are five consecutive symbols of the same player, and False otherwise.
        """"""
        dr, dc = direction
        count = 0
        player = self.board[row][col]
        
        for step in range(5):
            r = row + step * dr
            c = col + step * dc
            if 0 <= r < self.board_size and 0 <= c < self.board_size and self.board[r][c] == player:
                count += 1
            else:
                break
        
        return count == 5
```",0.247787611,0.272175055,0.814285714,0.401408451,0.537735845,0.678832117,0.329787234,0.443914077,0.814285714,0.401408451,0.537735845,,,,,,,,,,,,
GPT,42,"class Hotel:
    def __init__(self, name, rooms):
        self.name = name
        self.available_rooms = rooms
        # available_rooms = {room_type1: room_number1, room_type2: room_number2, ...}
        # available_rooms = {'single': 5, 'double': 3}
        self.booked_rooms = {}
        # booked_rooms = {room_type1: {name1: room_number1, name2: room_number2, ...}, room_type2: {...}, ...}
        # booked_rooms = {'single': {'name1': 2, 'name2':1}, 'double': {}}

    def book_room(self, room_type, room_number, name):
        # Check if there are any rooms of the specified type available
        if room_type not in self.available_rooms.keys():
            return False

        if room_number <= self.available_rooms[room_type]:
            # Book the room by adding it to the booked_rooms dictionary
            if room_type not in self.booked_rooms.keys():
                self.booked_rooms[room_type] = {}
            self.booked_rooms[room_type][name] = room_number
            self.available_rooms[room_type] -= room_number
            return ""Success!""
        elif self.available_rooms[room_type] != 0:
            return self.available_rooms[room_type]
        else:
            return False

    def check_in(self, room_type, room_number, name):
        # Check if the room of the specified type and number is booked
        if room_type not in self.booked_rooms.keys():
            return False
        if name in self.booked_rooms[room_type]:
            if room_number > self.booked_rooms[room_type][name]:
                return False
            elif room_number == self.booked_rooms[room_type][name]:
                # Check in the room by removing it from the booked_rooms dictionary
                self.booked_rooms[room_type].pop(name)
            else:
                self.booked_rooms[room_type][name] -= room_number


    def check_out(self, room_type, room_number):
        if room_type in self.available_rooms:
            self.available_rooms[room_type] += room_number
        else:
            self.available_rooms[room_type] = room_number

    def get_available_rooms(self, room_type):
        return self.available_rooms[room_type]",ZeroShot,"```python
class Hotel:
    def __init__(self, name, rooms):
        """"""
        Initialize the three fields in Hotel System.
        name is the hotel name.
        available_rooms stores the remaining rooms in the hotel
        booked_rooms stores the rooms that have been booked and the person's name who booked rooms.
        """"""
        self.name = name
        self.available_rooms = rooms  # A dictionary with room types as keys and quantities as values
        self.booked_rooms = {}  # A dictionary to store booked rooms as {room_type: {name: room_number}}

    def book_room(self, room_type, room_number, name):
        """"""
        Check if there are any rooms of the specified type available.
        if rooms are adequate, modify available_rooms and booked_rooms and finish booking, or fail to book otherwise.
        :return: if number of rooms about to be booked doesn't exceed the remaining rooms, return str 'Success!'
                if exceeds but quantity of available rooms is not equal to zero, return int(the remaining quantity of this room type).
                if exceeds and quantity is zero or the room_type isn't in available_room, return False.
        """"""
        if room_type not in self.available_rooms or self.available_rooms[room_type] < room_number:
            return self.available_rooms.get(room_type, 0) if room_type in self.available_rooms else False

        self.available_rooms[room_type] -= room_number
        if room_type not in self.booked_rooms:
            self.booked_rooms[room_type] = {}
        if name in self.booked_rooms[room_type]:
            self.booked_rooms[room_type][name] += room_number
        else:
            self.booked_rooms[room_type][name] = room_number

        return 'Success!'

    def check_in(self, room_type, room_number, name):
        """"""
        Check if the room of the specified type and number is booked by the person named name.
        Remove this name when check in successfuly(room_number is equal to specific person's booked_rooms. When the actual check in quantity (room_number) is less than the booked quantity, number in booked_rooms will be booked quantity minus actual quantity
        :return False: only if the room_type is not in the booked_rooms or room_number is higher than quantity in booked rooms.
        """"""
        if room_type not in self.booked_rooms or name not in self.booked_rooms[room_type]:
            return False

        if self.booked_rooms[room_type][name] < room_number:
            return False

        self.booked_rooms[room_type][name] -= room_number
        if self.booked_rooms[room_type][name] == 0:
            del self.booked_rooms[room_type][name]

        return True

    def check_out(self, room_type, room_number):
        """"""
        Check out rooms, add number for specific type in available_rooms.
        If room_type is new, add new type in available_rooms.
        """"""
        if room_type in self.available_rooms:
            self.available_rooms[room_type] += room_number
        else:
            self.available_rooms[room_type] = room_number

    def get_available_rooms(self, room_type):
        """"""
        Get the number of specific type of available rooms.
        :return: int, the remaining number of this type rooms.
        """"""
        return self.available_rooms.get(room_type, 0)
```",0.166219839,0.199145568,0.647727273,0.390410959,0.487179482,0.487341772,0.246794872,0.32765957,0.647727273,0.390410959,0.487179482,,,,,,,,,,,,
GPT,43,"class HRManagementSystem:
    def __init__(self):
        self.employees = {}

    def add_employee(self, employee_id, name, position, department, salary):
        if employee_id in self.employees:
            return False
        else:
            self.employees[employee_id] = {
                'name': name,
                'position': position,
                'department': department,
                'salary': salary
            }
            return True

    def remove_employee(self, employee_id):
        if employee_id in self.employees:
            del self.employees[employee_id]
            return True
        else:
            return False

    def update_employee(self, employee_id: int, employee_info: dict):
        employee = self.get_employee(employee_id)
        if employee == False:
            return False
        else:
            for key, value in employee_info.items():
                if key not in employee:
                    return False
            for key, value in employee_info.items():
                employee[key] = value
            return True

    def get_employee(self, employee_id):
        if employee_id in self.employees:
            return self.employees[employee_id]
        else:
            return False

    def list_employees(self):
        employee_data = {}
        if self.employees:
            for employee_id, employee_info in self.employees.items():
                employee_details = {}
                employee_details[""employee_ID""] = employee_id
                for key, value in employee_info.items():
                    employee_details[key] = value
                employee_data[employee_id] = employee_details
        return employee_data",ZeroShot,"```python
class HRManagementSystem:
    def __init__(self):
        """"""
        Initialize the HRManagementSystem with an attribute employees, which is an empty dictionary.
        """"""
        self.employees = {}

    def add_employee(self, employee_id, name, position, department, salary):
        """"""
        Add a new employee to the HRManagementSystem.
        :return: If the employee is already in the HRManagementSystem, returns False, otherwise, returns True.
        """"""
        if employee_id in self.employees:
            return False  # Employee already exists
        self.employees[employee_id] = {
            'name': name,
            'position': position,
            'department': department,
            'salary': salary
        }
        return True  # Employee added successfully

    def remove_employee(self, employee_id):
        """"""
        Remove an employee from the HRManagementSystem.
        :return: If the employee is already in the HRManagementSystem, returns True, otherwise, returns False.
        """"""
        if employee_id in self.employees:
            del self.employees[employee_id]
            return True  # Employee removed successfully
        return False  # Employee not found

    def update_employee(self, employee_id: int, employee_info: dict):
        """"""
        Update an employee's information in the HRManagementSystem.
        :return: If the employee is already in the HRManagementSystem, returns True, otherwise, returns False.
        """"""
        if employee_id in self.employees:
            self.employees[employee_id].update(employee_info)
            return True  # Employee information updated successfully
        return False  # Employee not found

    def get_employee(self, employee_id):
        """"""
        Get an employee's information from the HRManagementSystem.
        :return: If the employee is already in the HRManagementSystem, returns the employee's information, otherwise, returns False.
        """"""
        return self.employees.get(employee_id, False)

    def list_employees(self):
        """"""
        List all employees' information in the HRManagementSystem.
        :return: A list of all employees' information, dict.
        """"""
        return list(self.employees.values())
```",0.180995475,0.213432027,0.706896552,0.436170213,0.539473679,0.447619048,0.313333333,0.368627446,0.689655172,0.425531915,0.526315785,,,,,,,,,,,,
GPT,44,"import re
import string
import gensim
from bs4 import BeautifulSoup


class HtmlUtil:

    def __init__(self):
        self.SPACE_MARK = '-SPACE-'
        self.JSON_MARK = '-JSON-'
        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'
        self.URL_MARK = '-URL-'
        self.NUMBER_MARK = '-NUMBER-'
        self.TRACE_MARK = '-TRACE-'
        self.COMMAND_MARK = '-COMMAND-'
        self.COMMENT_MARK = '-COMMENT-'
        self.CODE_MARK = '-CODE-'

    @staticmethod
    def __format_line_feed(text):
        return re.sub(re.compile(r'\n+'), '\n', text)

    def format_line_html_text(self, html_text):
        if html_text is None or len(html_text) == 0:
            return ''
        soup = BeautifulSoup(html_text, 'lxml')

        code_tag = soup.find_all(name=['pre', 'blockquote'])
        for tag in code_tag:
            tag.string = self.CODE_MARK

        ul_ol_group = soup.find_all(name=['ul', 'ol'])
        for ul_ol_item in ul_ol_group:
            li_group = ul_ol_item.find_all('li')
            for li_item in li_group:
                li_item_text = li_item.get_text().strip()
                if len(li_item_text) == 0:
                    continue
                if li_item_text[-1] in string.punctuation:
                    li_item.string = '[{0}]{1}'.format('-', li_item_text)
                    continue
                li_item.string = '[{0}]{1}.'.format('-', li_item_text)

        p_group = soup.find_all(name=['p'])
        for p_item in p_group:
            p_item_text = p_item.get_text().strip()
            if p_item_text:
                if p_item_text[-1] in string.punctuation:
                    p_item.string = p_item_text
                    continue
                next_sibling = p_item.find_next_sibling()
                if next_sibling and self.CODE_MARK in next_sibling.get_text():
                    p_item.string = p_item_text + ':'
                    continue
                p_item.string = p_item_text + '.'

        clean_text = gensim.utils.decode_htmlentities(soup.get_text())
        return self.__format_line_feed(clean_text)

    def extract_code_from_html_text(self, html_text):
        text_with_code_tag = self.format_line_html_text(html_text)

        if self.CODE_MARK not in text_with_code_tag:
            return []

        code_index_start = 0
        soup = BeautifulSoup(html_text, 'lxml')
        code_tag = soup.find_all(name=['pre', 'blockquote'])
        code_count = text_with_code_tag.count(self.CODE_MARK)
        code_list = []
        for code_index in range(code_index_start, code_index_start + code_count):
            code = code_tag[code_index].get_text()
            if code:
                code_list.append(code)
        return code_list",ZeroShot,"```python
class HtmlUtil:
    def __init__(self):
        """"""
        Initialize a series of labels
        """"""
        self.code_placeholder = ""-CODE-""

    @staticmethod
    def __format_line_feed(text):
        """"""
        Replace consecutive line breaks with a single line break
        :param text: str, input text to process
        :return: str, replaced text with single line break
        """"""
        # Use regular expression to replace multiple newlines with a single newline
        return re.sub(r'\n+', '\n', text)

    def format_line_html_text(self, html_text):
        """"""
        Get the HTML text without the code, and add the code tag -CODE- where the code is
        :param html_text: str, input HTML text to process
        :return: str, formatted text with code placeholders
        """"""
        # Parse the HTML content using BeautifulSoup
        soup = BeautifulSoup(html_text, ""html.parser"")

        # Find all code elements and replace them with the code placeholder
        for code in soup.find_all('code'):
            code.replace_with(self.code_placeholder)

        # Extract the text from the soup, which now contains placeholders instead of code
        text = soup.get_text()

        # Format the line feeds in the extracted text
        return self.__format_line_feed(text)

    def extract_code_from_html_text(self, html_text):
        """"""
        Extract codes from the HTML body
        :param html_text: str, input HTML text to process
        :return: list, the list of code snippets extracted from the HTML
        """"""
        # Parse the HTML content using BeautifulSoup
        soup = BeautifulSoup(html_text, ""html.parser"")

        # Extract the text content of all code elements
        code_snippets = [code.get_text() for code in soup.find_all('code')]

        return code_snippets
```

- `__format_line_feed`: This private static method uses a regular expression to replace multiple consecutive newlines with a single newline.
- `format_line_html_text`: This method uses BeautifulSoup to parse the HTML and replace code elements with a placeholder. It then extracts the text and formats it to have single line breaks.
- `extract_code_from_html_text`: This method uses BeautifulSoup to extract and return all code snippets from the HTML text.",0.032490975,0.040398984,0.222222222,0.216666667,0.219409278,0.074418605,0.074766355,0.07459207,0.222222222,0.216666667,0.219409278,,,,,,,,,,,,
GPT,45,"from PIL import Image, ImageEnhance, ImageChops


class ImageProcessor:
    def __init__(self):
        self.image = None

    def load_image(self, image_path):
        self.image = Image.open(image_path)

    def save_image(self, save_path):
        if self.image:
            self.image.save(save_path)

    def resize_image(self, width, height):
        if self.image:
            self.image = self.image.resize((width, height))

    def rotate_image(self, degrees):
        if self.image:
            self.image = self.image.rotate(degrees)

    def adjust_brightness(self, factor):
        if self.image:
            enhancer = ImageEnhance.Brightness(self.image)
            self.image = enhancer.enhance(factor)",ZeroShot,"```python
from PIL import Image, ImageEnhance

class ImageProcessor:
    def __init__(self):
        """"""
        Initialize self.image to None, indicating no image is loaded initially.
        """"""
        self.image = None

    def load_image(self, image_path):
        """"""
        Use Image util in PIL to open an image and store it in self.image.
        """"""
        self.image = Image.open(image_path)

    def save_image(self, save_path):
        """"""
        Save the image to a path if an image has been opened.
        """"""
        if self.image:
            self.image.save(save_path)
        else:
            raise ValueError(""No image loaded to save."")

    def resize_image(self, width, height):
        """"""
        Resize the image to the given width and height if an image has been opened.
        """"""
        if self.image:
            self.image = self.image.resize((width, height))
        else:
            raise ValueError(""No image loaded to resize."")

    def rotate_image(self, degrees):
        """"""
        Rotate the image by a specified number of degrees if an image has been opened.
        """"""
        if self.image:
            self.image = self.image.rotate(degrees)
        else:
            raise ValueError(""No image loaded to rotate."")

    def adjust_brightness(self, factor):
        """"""
        Adjust the brightness of the image by a specified factor if an image has been opened.
        A factor > 1 increases brightness, while a factor < 1 decreases it.
        """"""
        if self.image:
            enhancer = ImageEnhance.Brightness(self.image)
            self.image = enhancer.enhance(factor)
        else:
            raise ValueError(""No image loaded to adjust brightness."")
```",0.158730159,0.175212005,0.947368421,0.395604396,0.558139531,0.769230769,0.273972603,0.4040404,0.947368421,0.395604396,0.558139531,,,,,,,,,,,,
GPT,46,"class Interpolation:
    def __init__(self):
        pass

    @staticmethod
    def interpolate_1d(x, y, x_interp):
        y_interp = []
        for xi in x_interp:
            for i in range(len(x) - 1):
                if x[i] <= xi <= x[i+1]:
                    yi = y[i] + (y[i+1] - y[i]) * (xi - x[i]) / (x[i+1] - x[i])
                    y_interp.append(yi)
                    break
        return y_interp
    
    @staticmethod
    def interpolate_2d(x, y, z, x_interp, y_interp):
        z_interp = []
        for xi, yi in zip(x_interp, y_interp):
            for i in range(len(x) - 1):
                if x[i] <= xi <= x[i+1]:
                    for j in range(len(y) - 1):
                        if y[j] <= yi <= y[j+1]:
                            z00 = z[i][j]
                            z01 = z[i][j+1]
                            z10 = z[i+1][j]
                            z11 = z[i+1][j+1]
                            zi = (z00 * (x[i+1] - xi) * (y[j+1] - yi) +
                                  z10 * (xi - x[i]) * (y[j+1] - yi) +
                                  z01 * (x[i+1] - xi) * (yi - y[j]) +
                                  z11 * (xi - x[i]) * (yi - y[j])) / ((x[i+1] - x[i]) * (y[j+1] - y[j]))
                            z_interp.append(zi)
                            break
                    break
        return z_interp",ZeroShot,"```python
class Interpolation:
    def __init__(self):
        pass

    @staticmethod
    def interpolate_1d(x, y, x_interp):
        """"""
        Linear interpolation of one-dimensional data
        :param x: List of x-coordinates of the data points
        :param y: List of y-coordinates of the data points
        :param x_interp: List of x-coordinates where interpolation is required
        :return: List of y-coordinates at the interpolation points
        """"""
        y_interp = []
        for xi in x_interp:
            # Find the interval [x_i, x_i+1] where x_i <= xi < x_i+1
            for i in range(len(x) - 1):
                if x[i] <= xi <= x[i + 1]:
                    # Linear interpolation formula
                    yi = y[i] + (y[i + 1] - y[i]) * (xi - x[i]) / (x[i + 1] - x[i])
                    y_interp.append(yi)
                    break
        return y_interp

    @staticmethod
    def interpolate_2d(x, y, z, x_interp, y_interp):
        """"""
        Linear interpolation of two-dimensional data
        :param x: List of x-coordinates of the data points
        :param y: List of y-coordinates of the data points
        :param z: 2D list (matrix) of z-values corresponding to each (x, y) pair
        :param x_interp: List of x-coordinates where interpolation is required
        :param y_interp: List of y-coordinates where interpolation is required
        :return: List of z-coordinates at the interpolation points
        """"""
        z_interp = []
        for xi, yi in zip(x_interp, y_interp):
            # Find the bounding box for (xi, yi)
            for i in range(len(x) - 1):
                if x[i] <= xi <= x[i + 1]:
                    for j in range(len(y) - 1):
                        if y[j] <= yi <= y[j + 1]:
                            # Bilinear interpolation formula
                            f00 = z[i][j]
                            f10 = z[i + 1][j]
                            f01 = z[i][j + 1]
                            f11 = z[i + 1][j + 1]
                            
                            # Calculate weights
                            t = (xi - x[i]) / (x[i + 1] - x[i])
                            u = (yi - y[j]) / (y[j + 1] - y[j])
                            
                            # Interpolated value
                            z_val = (1 - t) * (1 - u) * f00 + t * (1 - u) * f10 + (1 - t) * u * f01 + t * u * f11
                            z_interp.append(z_val)
                            break
        return z_interp
```

- The `interpolate_1d` method performs linear interpolation on one-dimensional data.
- The `interpolate_2d` method performs bilinear interpolation on two-dimensional data.
- Both methods use the linear interpolation formula to calculate the estimated value at the given interpolation points.",0.191549296,0.220082521,0.727272727,0.352941176,0.47524752,0.552631579,0.261410788,0.354929573,0.712121212,0.345588235,0.46534653,,,,,,,,,,,,
GPT,47,"class IPAddress:
    def __init__(self, ip_address):
        self.ip_address = ip_address

    def is_valid(self):
        octets = self.ip_address.split('.')
        if len(octets) != 4:
            return False
        for octet in octets:
            if not octet.isdigit() or int(octet) < 0 or int(octet) > 255:
                return False
        return True

    def get_octets(self):
        if self.is_valid():
            return self.ip_address.split('.')
        else:
            return []

    def get_binary(self):
        if self.is_valid():
            binary_octets = []
            for octet in self.get_octets():
                binary_octets.append(format(int(octet), '08b'))
            return '.'.join(binary_octets)
        else:
            return ''",ZeroShot,"```python
class IPAddress:
    def __init__(self, ip_address):
        """"""
        Initialize the IP address to the specified address
        """"""
        self.ip_address = ip_address

    def is_valid(self):
        """"""
        Judge whether the IP address is valid, that is, whether the IP address is composed of four Decimal digits separated by '.'. 
        Each digit is greater than or equal to 0 and less than or equal to 255
        :return: bool
        """"""
        # Split the IP address by '.'
        octets = self.ip_address.split('.')
        
        # Check if the IP address has exactly four parts
        if len(octets) != 4:
            return False
        
        for octet in octets:
            # Check if each part is a digit and convert to integer
            if not octet.isdigit():
                return False
            num = int(octet)
            
            # Check if each number is in the range of 0 to 255
            if num < 0 or num > 255:
                return False
        
        return True

    def get_octets(self):
        """"""
        If the IP address is valid, the list of four decimal numbers separated by ""."" constituting the IP address is returned; 
        otherwise, an empty list is returned
        :return: list
        """"""
        if self.is_valid():
            # Split the valid IP address and return the list of octets as integers
            return [int(octet) for octet in self.ip_address.split('.')]
        else:
            return []

    def get_binary(self):
        """"""
        If the IP address is valid, return the binary form of the IP address; otherwise, return ''
        :return: string
        """"""
        if self.is_valid():
            # Convert each octet to an 8-bit binary string and join them with '.'
            return '.'.join(format(int(octet), '08b') for octet in self.ip_address.split('.'))
        else:
            return ''
```",0.110655738,0.131279799,0.860465116,0.330357143,0.477419351,0.626865672,0.208955224,0.313432832,0.860465116,0.330357143,0.477419351,,,,,,,,,,,,
GPT,48,"import socket


class IpUtil:

    @staticmethod
    def is_valid_ipv4(ip_address):
        try:
            socket.inet_pton(socket.AF_INET, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def is_valid_ipv6(ip_address):
        try:
            socket.inet_pton(socket.AF_INET6, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def get_hostname(ip_address):
        try:
            hostname = socket.gethostbyaddr(ip_address)[0]
            return hostname
        except socket.herror:
            return None",ZeroShot,"```python
class IpUtil:

    @staticmethod
    def is_valid_ipv4(ip_address):
        """"""
        Check if the given IP address is a valid IPv4 address.
        :return: bool, True if the IP address is valid, False otherwise
        """"""
        try:
            # Attempt to convert the IP address to a valid IPv4 address
            socket.inet_pton(socket.AF_INET, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def is_valid_ipv6(ip_address):
        """"""
        Check if the given IP address is a valid IPv6 address.
        :return: bool, True if the IP address is valid, False otherwise
        """"""
        try:
            # Attempt to convert the IP address to a valid IPv6 address
            socket.inet_pton(socket.AF_INET6, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def get_hostname(ip_address):
        """"""
        Get the hostname associated with the given IP address.
        :return: string, the hostname associated with the IP address
        """"""
        try:
            # Use gethostbyaddr to find the hostname for the given IP address
            hostname, _, _ = socket.gethostbyaddr(ip_address)
            return hostname
        except socket.herror:
            return None

    @staticmethod
    def get_local_ip():
        """"""
        Get the local IP address of the machine.
        :return: string, the local IP address
        """"""
        try:
            # Use netifaces to get the default gateway interface
            default_gateway = netifaces.gateways()['default'][netifaces.AF_INET][1]
            # Get the IP address associated with the default gateway interface
            local_ip = netifaces.ifaddresses(default_gateway)[netifaces.AF_INET][0]['addr']
            return local_ip
        except KeyError:
            return None
```",0.126903553,0.139644901,0.916666667,0.305555556,0.45833333,0.714285714,0.215517241,0.331125824,0.916666667,0.305555556,0.45833333,,,,,,,,,,,,
GPT,49,"class JobMarketplace:
    def __init__(self):
        self.job_listings = []
        self.resumes = []

    def post_job(self, job_title, company, requirements):
        # requirements = ['requirement1', 'requirement2']
        job = {""job_title"": job_title, ""company"": company, ""requirements"": requirements}
        self.job_listings.append(job)

    def remove_job(self, job):
        self.job_listings.remove(job)

    def submit_resume(self, name, skills, experience):
        resume = {""name"": name, ""skills"": skills, ""experience"": experience}
        self.resumes.append(resume)

    def withdraw_resume(self, resume):
        self.resumes.remove(resume)

    def search_jobs(self, criteria):
        matching_jobs = []
        for job_listing in self.job_listings:
            if criteria.lower() in job_listing[""job_title""].lower() or criteria.lower() in [r.lower() for r in job_listing[""requirements""]]:
                matching_jobs.append(job_listing)
        return matching_jobs

    def get_job_applicants(self, job):
        applicants = []
        for resume in self.resumes:
            if self.matches_requirements(resume, job[""requirements""]):
                applicants.append(resume)
        return applicants

    @staticmethod
    def matches_requirements(resume, requirements):
        for skill in resume[""skills""]:
            if skill not in requirements:
                return False
        return True",ZeroShot,"```python
class JobMarketplace:
    def __init__(self):
        # Initialize lists to store job listings and resumes
        self.job_listings = []
        self.resumes = []

    def post_job(self, job_title, company, requirements):
        """"""
        This function is used to publish positions, and add the position information to the job_listings list.
        :param job_title: Title of the job
        :param company: Company offering the job
        :param requirements: Requirements for the job
        :return: None
        """"""
        # Create a job dictionary and append it to the job_listings
        job = {
            'job_title': job_title,
            'company': company,
            'requirements': requirements
        }
        self.job_listings.append(job)

    def remove_job(self, job):
        """"""
        This function is used to remove positions, and remove the position information from the job_listings list.
        :param job: The job to be removed
        :return: None
        """"""
        # Remove the job if it exists in the job_listings
        if job in self.job_listings:
            self.job_listings.remove(job)

    def submit_resume(self, name, skills, experience):
        """"""
        This function is used to submit resumes, and add the resume information to the resumes list.
        :param name: Name of the candidate
        :param skills: Skills of the candidate
        :param experience: Experience of the candidate
        :return: None
        """"""
        # Create a resume dictionary and append it to the resumes
        resume = {
            'name': name,
            'skills': skills,
            'experience': experience
        }
        self.resumes.append(resume)

    def withdraw_resume(self, resume):
        """"""
        This function is used to withdraw resumes, and remove the resume information from the resumes list.
        :param resume: The resume to be withdrawn
        :return: None
        """"""
        # Remove the resume if it exists in the resumes
        if resume in self.resumes:
            self.resumes.remove(resume)

    def search_jobs(self, criteria):
        """"""
        This function is used to search for positions, and return the position information that meets the requirements.
        :param criteria: The search criteria (e.g., job title, company, etc.)
        :return: The position information that meets the requirements, list.
        """"""
        # Find jobs that match the criteria
        matched_jobs = [
            job for job in self.job_listings
            if any(criteria.lower() in str(value).lower() for value in job.values())
        ]
        return matched_jobs

    def get_job_applicants(self, job):
        """"""
        This function is used to obtain candidate information, and return the candidate information that meets the requirements by calling the matches_requirements function.
        :param job: The job for which to find applicants
        :return: The candidate information that meets the requirements, list.
        """"""
        # Find resumes that match the job requirements
        matched_applicants = [
            resume for resume in self.resumes
            if self.matches_requirements(resume, job['requirements'])
        ]
        return matched_applicants

    def matches_requirements(self, resume, requirements):
        """"""
        Helper function to check if a resume matches the job requirements.
        :param resume: The resume of the candidate
        :param requirements: The requirements of the job
        :return: True if the resume matches the requirements, False otherwise
        """"""
        # Check if all requirements are met by the resume's skills
        return all(req.lower() in resume['skills'].lower() for req in requirements)
```",0.055427252,0.07267198,0.661764706,0.290322581,0.40358744,0.387931034,0.150501672,0.216867466,0.647058824,0.283870968,0.39461883,,,,,,,,,,,,
GPT,50,"import json
import os


class JSONProcessor:
    def read_json(self, file_path):
        if not os.path.exists(file_path):
            return 0
        try:
            with open(file_path, 'r') as file:
                data = json.load(file)
            return data
        except:
            return -1

    def write_json(self, data, file_path):
        try:
            with open(file_path, 'w') as file:
                json.dump(data, file)
            return 1
        except:
            return -1

    def process_json(self, file_path, remove_key):
        data = self.read_json(file_path)
        if data == 0 or data == -1:
            return 0
        if remove_key in data:
            del data[remove_key]
            self.write_json(data, file_path)
            return 1
        else:
            return 0",ZeroShot,"```python
import json
import os

class JSONProcessor:
    def read_json(self, file_path):
        """"""
        Read a JSON file and return the data.
        :return: dict, the data from the JSON file if read successfully, or return -1 if an error occurs during the reading process.
                    return 0 if the file does not exist.
        """"""
        if not os.path.exists(file_path):
            return 0  # File does not exist
        try:
            with open(file_path, 'r') as file:
                data = json.load(file)
            return data
        except Exception as e:
            print(f""An error occurred while reading the file: {e}"")
            return -1  # Error during reading

    def write_json(self, data, file_path):
        """"""
        Write data to a JSON file and save it to the given path.
        :return: 1 if the writing process is successful, or -1, if an error occurs during the writing process.
        """"""
        try:
            with open(file_path, 'w') as file:
                json.dump(data, file, indent=4)
            return 1  # Writing successful
        except Exception as e:
            print(f""An error occurred while writing to the file: {e}"")
            return -1  # Error during writing

    def process_json(self, file_path, remove_key):
        """"""
        Read a JSON file and process the data by removing a specified key and rewrite the modified data back to the file.
        :return: 1, if the specified key is successfully removed and the data is written back.
                    0, if the file does not exist or the specified key does not exist in the data.
        """"""
        data = self.read_json(file_path)
        if data == 0:
            return 0  # File does not exist
        if data == -1:
            return -1  # Error during reading

        if remove_key in data:
            del data[remove_key]
            write_status = self.write_json(data, file_path)
            if write_status == 1:
                return 1  # Key removed and data written back successfully
            else:
                return -1  # Error during writing
        else:
            return 0  # Specified key does not exist
```",0.141843972,0.164618855,0.957446809,0.420560748,0.58441558,0.768115942,0.262376238,0.391143908,0.957446809,0.420560748,0.58441558,,,,,,,,,,,,
GPT,51,"import numpy as np


class KappaCalculator:

    @staticmethod
    def kappa(testData, k):
        dataMat = np.mat(testData)
        P0 = 0.0
        for i in range(k):
            P0 += dataMat[i, i] * 1.0
        xsum = np.sum(dataMat, axis=1)
        ysum = np.sum(dataMat, axis=0)
        sum = np.sum(dataMat)
        Pe = float(ysum * xsum) / sum / sum
        P0 = float(P0 / sum * 1.0)
        cohens_coefficient = float((P0 - Pe) / (1 - Pe))
        return cohens_coefficient

    @staticmethod
    def fleiss_kappa(testData, N, k, n):
        dataMat = np.mat(testData, float)
        oneMat = np.ones((k, 1))
        sum = 0.0
        P0 = 0.0
        for i in range(N):
            temp = 0.0
            for j in range(k):
                sum += dataMat[i, j]
                temp += 1.0 * dataMat[i, j] ** 2
            temp -= n
            temp /= (n - 1) * n
            P0 += temp
        P0 = 1.0 * P0 / N
        ysum = np.sum(dataMat, axis=0)
        for i in range(k):
            ysum[0, i] = (ysum[0, i] / sum) ** 2
        Pe = ysum * oneMat * 1.0
        ans = (P0 - Pe) / (1 - Pe)
        return ans[0, 0]",ZeroShot,"```python
import numpy as np

class KappaCalculator:

    @staticmethod
    def kappa(testData, k):
        """"""
        Calculate the Cohen's kappa value of a k-dimensional matrix
        :param testData: 2D list or array, where each row is a pair of ratings from two raters
        :param k: int, the number of categories
        :return: float, the Cohen's kappa value of the matrix
        """"""
        # Convert testData to a numpy array for easier manipulation
        testData = np.array(testData)
        
        # Calculate the observed agreement
        total_agreements = np.sum(testData[:, 0] == testData[:, 1])
        total_pairs = len(testData)
        p_o = total_agreements / total_pairs
        
        # Calculate the expected agreement
        p_e = 0
        for i in range(k):
            p_i = np.sum(testData[:, 0] == i) / total_pairs
            p_j = np.sum(testData[:, 1] == i) / total_pairs
            p_e += p_i * p_j
        
        # Calculate Cohen's kappa
        kappa_value = (p_o - p_e) / (1 - p_e)
        
        return kappa_value

    @staticmethod
    def fleiss_kappa(testData, N, k, n):
        """"""
        Calculate the Fleiss' kappa value of an N * k matrix
        :param testData: 2D list or array (N*k), where each row represents the count of ratings for each category
        :param N: int, number of subjects
        :param k: int, number of categories
        :param n: int, number of ratings per subject
        :return: float, the Fleiss' kappa value
        """"""
        # Convert testData to a numpy array for easier manipulation
        testData = np.array(testData)
        
        # Calculate the proportion of all assignments to each category
        p_j = np.sum(testData, axis=0) / (N * n)
        
        # Calculate the agreement for each subject
        P_i = (np.sum(testData**2, axis=1) - n) / (n * (n - 1))
        
        # Calculate the mean of P_i
        P_bar = np.mean(P_i)
        
        # Calculate the mean of p_j squared
        P_e_bar = np.sum(p_j**2)
        
        # Calculate Fleiss' kappa
        kappa_value = (P_bar - P_e_bar) / (1 - P_e_bar)
        
        return kappa_value
```

- `kappa`: Calculates Cohen's kappa, a measure of agreement between two raters. It accounts for chance agreement.
- `fleiss_kappa`: Calculates Fleiss' kappa, a generalization of Cohen's kappa for more than two raters. It considers the proportion of agreement among multiple raters.",0.049535604,0.06896951,0.444444444,0.235294118,0.307692303,0.169230769,0.092436975,0.119565213,0.444444444,0.235294118,0.307692303,,,,,,,,,,,,
GPT,52,"import nltk
from nltk.stem import WordNetLemmatizer
from nltk import pos_tag, word_tokenize
import string

nltk.download('averaged_perceptron_tagger')
nltk.download('punkt')
nltk.download('wordnet')


class Lemmatization:
    def __init__(self):
        self.lemmatizer = WordNetLemmatizer()

    def lemmatize_sentence(self, sentence):
        lemmatized_words = []
        sentence = self.remove_punctuation(sentence)
        words = word_tokenize(sentence)
        tagged_words = pos_tag(words)
        for word, tag in tagged_words:
            if tag.startswith('V'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='v')
            elif tag.startswith('J'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='a')
            elif tag.startswith('R'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='r')
            else:
                lemmatized_word = self.lemmatizer.lemmatize(word)
            lemmatized_words.append(lemmatized_word)
        return lemmatized_words

    def get_pos_tag(self, sentence):
        pos_tags = []
        sentence = self.remove_punctuation(sentence)
        words = word_tokenize(sentence)
        tagged_words = pos_tag(words)
        for tagged_word in tagged_words:
            pos_tags.append(tagged_word[1])
        return pos_tags

    def remove_punctuation(self, sentence):
        return sentence.translate(str.maketrans('', '', string.punctuation))",ZeroShot,"```python
class Lemmatization:
    def __init__(self):
        """"""
        Creates a WordNetLemmatizer object and stores it in the self.lemmatizer member variable.
        """"""
        self.lemmatizer = WordNetLemmatizer()

    def lemmatize_sentence(self, sentence):
        """"""
        Removes punctuation from the sentence, tokenizes the input sentence, marks the part of speech tag of each word,
        lemmatizes the words with different parameters based on their parts of speech, and stores them in a list.
        :param sentence: str, the input sentence to be lemmatized
        :return: list of str, words which have been lemmatized
        """"""
        # Remove punctuation from the sentence
        sentence = self.remove_punctuation(sentence)
        
        # Tokenize the sentence
        tokens = word_tokenize(sentence)
        
        # Get part of speech tags for each token
        pos_tags = pos_tag(tokens)
        
        # Lemmatize each token based on its POS tag
        lemmatized_words = []
        for word, tag in pos_tags:
            pos = self.get_wordnet_pos(tag)
            lemmatized_word = self.lemmatizer.lemmatize(word, pos)
            lemmatized_words.append(lemmatized_word)
        
        return lemmatized_words

    def get_pos_tag(self, sentence):
        """"""
        Removes punctuation from the sentence and tokenizes the input sentence, marks the part of speech tag of each word.
        :param sentence: str, the input sentence
        :return: list of tuples, part of speech tag of each word in the sentence
        """"""
        # Remove punctuation from the sentence
        sentence = self.remove_punctuation(sentence)
        
        # Tokenize the sentence
        tokens = word_tokenize(sentence)
        
        # Return POS tags for each token
        return pos_tag(tokens)

    def remove_punctuation(self, sentence):
        """"""
        Removes punctuation from the input text.
        :param sentence: str, the input sentence
        :return: str, sentence without any punctuation
        """"""
        # Create a translation table for removing punctuation
        translator = str.maketrans('', '', string.punctuation)
        
        # Return the sentence without punctuation
        return sentence.translate(translator)

    def get_wordnet_pos(self, treebank_tag):
        """"""
        Converts Treebank POS tags to WordNet POS tags.
        :param treebank_tag: str, the Treebank POS tag
        :return: str, the corresponding WordNet POS tag
        """"""
        if treebank_tag.startswith('J'):
            return nltk.corpus.wordnet.ADJ
        elif treebank_tag.startswith('V'):
            return nltk.corpus.wordnet.VERB
        elif treebank_tag.startswith('N'):
            return nltk.corpus.wordnet.NOUN
        elif treebank_tag.startswith('R'):
            return nltk.corpus.wordnet.ADV
        else:
            return nltk.corpus.wordnet.NOUN  # Default to noun if no match
```",0.056478405,0.07222185,0.684210526,0.3,0.417112295,0.351648352,0.14159292,0.20189274,0.684210526,0.3,0.417112295,,,,,,,,,,,,
GPT,53,"import re
import string


class LongestWord:

    def __init__(self):
        self.word_list = []

    def add_word(self, word):
        self.word_list.append(word)

    def find_longest_word(self, sentence):
        longest_word = """"
        sentence = sentence.lower()
        sentence = re.sub('[%s]' % re.escape(string.punctuation), '', sentence)
        sentence = re.split(' ', sentence)
        for word in sentence:
            if word in self.word_list and len(word) > len(longest_word):
                longest_word = word
        return longest_word",ZeroShot,"```python
import re
import string

class LongestWord:
    def __init__(self):
        """"""
        Initialize a list of words.
        """"""
        self.word_list = []  # Initialize an empty list to store words

    def add_word(self, word):
        """"""
        Append the input word into self.word_list
        """"""
        self.word_list.append(word)  # Add the word to the word list

    def find_longest_word(self, sentence):
        """"""
        Remove punctuation marks and split a sentence into a list of words. 
        Find the longest split word that is in the self.word_list.
        Words are strictly case sensitive.
        :return str: longest split word that is in the self.word_list. return '' if self.word_list is empty.
        """"""
        # Remove punctuation from the sentence and split it into words
        words_in_sentence = re.findall(r'\b\w+\b', sentence)

        # Initialize variables to track the longest word
        longest_word = ''
        max_length = 0

        # Iterate over each word in the sentence
        for word in words_in_sentence:
            # Check if the word is in the word list and is longer than the current longest word
            if word in self.word_list and len(word) > max_length:
                longest_word = word
                max_length = len(word)

        return longest_word  # Return the longest word found
```",0.091428571,0.112362046,0.710526316,0.3375,0.457627114,0.481481481,0.174496644,0.256157632,0.710526316,0.3375,0.457627114,,,,,,,,,,,,
GPT,54,"import random


class MahjongConnect:
    def __init__(self, BOARD_SIZE, ICONS):
        self.BOARD_SIZE = BOARD_SIZE
        self.ICONS = ICONS
        self.board = self.create_board()

    def create_board(self):
        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]
        return board

    def is_valid_move(self, pos1, pos2):
        x1, y1 = pos1
        x2, y2 = pos2

        # Check if positions are within the game board range
        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and 0 <= x2 < self.BOARD_SIZE[
            0] and 0 <= y2 <
                self.BOARD_SIZE[1]):
            return False

        # Check if the two positions are the same
        if pos1 == pos2:
            return False

        # Check if the two positions have the same icon
        if self.board[x1][y1] != self.board[x2][y2]:
            return False

        # Check if there is a valid path between the two positions
        if not self.has_path(pos1, pos2):
            return False

        return True

    def has_path(self, pos1, pos2):
        visited = set()
        stack = [pos1]

        while stack:
            current_pos = stack.pop()
            if current_pos == pos2:
                return True

            if current_pos in visited:
                continue

            visited.add(current_pos)
            x, y = current_pos

            # Check adjacent positions (up, down, left, right)
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                new_x, new_y = x + dx, y + dy
                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:
                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:
                        stack.append((new_x, new_y))

        return False

    def remove_icons(self, pos1, pos2):
        x1, y1 = pos1
        x2, y2 = pos2
        self.board[x1][y1] = ' '
        self.board[x2][y2] = ' '

    def is_game_over(self):
        for row in self.board:
            if any(icon != ' ' for icon in row):
                return False
        return True",ZeroShot,"```python
import random

class MahjongConnect:
    def __init__(self, BOARD_SIZE, ICONS):
        """"""
        Initialize the board size and the icon list, create the game board.
        """"""
        self.BOARD_SIZE = BOARD_SIZE
        self.ICONS = ICONS
        self.board = self.create_board()

    def create_board(self):
        """"""
        Create the game board with the given board size and icons.
        :return: 2-dimensional list, the game board
        """"""
        # Calculate the total number of icons needed
        total_icons = self.BOARD_SIZE * self.BOARD_SIZE
        # Ensure there are pairs of icons
        if total_icons % 2 != 0:
            raise ValueError(""The board size must allow for pairs of icons."")
        
        # Create pairs of icons
        icon_pairs = (self.ICONS * (total_icons // len(self.ICONS) // 2)) * 2
        random.shuffle(icon_pairs)
        
        # Create the board as a 2D list
        board = [icon_pairs[i:i + self.BOARD_SIZE] for i in range(0, total_icons, self.BOARD_SIZE)]
        return board

    def is_valid_move(self, pos1, pos2):
        """"""
        Check if the move of two icons is valid.
        :return: True or False, representing whether the move of two icons is valid
        """"""
        x1, y1 = pos1
        x2, y2 = pos2

        # Check if positions are within the board range
        if not (0 <= x1 < self.BOARD_SIZE and 0 <= y1 < self.BOARD_SIZE and
                0 <= x2 < self.BOARD_SIZE and 0 <= y2 < self.BOARD_SIZE):
            return False

        # Check if the two positions are not the same
        if pos1 == pos2:
            return False

        # Check if the two positions have the same icon
        if self.board[x1][y1] != self.board[x2][y2]:
            return False

        # Check if there is a valid path between the two positions
        return self.has_path(pos1, pos2)

    def has_path(self, pos1, pos2):
        """"""
        Check if there is a path between two icons.
        :return: True or False, representing whether there is a path between two icons
        """"""
        # For simplicity, assume a direct path is available if positions are adjacent
        x1, y1 = pos1
        x2, y2 = pos2

        # Check for direct adjacency (horizontal or vertical)
        if (x1 == x2 and abs(y1 - y2) == 1) or (y1 == y2 and abs(x1 - x2) == 1):
            return True

        # Implement more complex path finding logic here if needed
        return False

    def remove_icons(self, pos1, pos2):
        """"""
        Remove the connected icons on the game board.
        :return: None
        """"""
        x1, y1 = pos1
        x2, y2 = pos2

        # Set the positions to None to indicate removal
        self.board[x1][y1] = None
        self.board[x2][y2] = None

    def is_game_over(self):
        """"""
        Check if the game is over (i.e., if there are no more icons on the game board).
        :return: True or False, representing whether the game is over
        """"""
        # Check if all positions on the board are None
        for row in self.board:
            for icon in row:
                if icon is not None:
                    return False
        return True
```",0.244803695,0.279464762,0.577235772,0.432926829,0.494773514,0.468468468,0.319018405,0.379562039,0.56097561,0.420731707,0.480836232,,,,,,,,,,,,
GPT,55,"class Manacher:
    def __init__(self, input_string) -> None:
        self.input_string = input_string

    def palindromic_length(self, center, diff, string):
        if (center - diff == -1 or center + diff == len(string)
                or string[center - diff] != string[center + diff]):
            return 0
        return 1 + self.palindromic_length(center, diff + 1, string)


    def palindromic_string(self):
        max_length = 0

        new_input_string = """"
        output_string = """"

        for i in self.input_string[:len(self.input_string) - 1]:
            new_input_string += i + ""|""
        new_input_string += self.input_string[-1]

        for i in range(len(new_input_string)):

            length =self.palindromic_length(i, 1, new_input_string)

            if max_length < length:
                max_length = length
                start = i

        for i in new_input_string[start - max_length:start + max_length + 1]:
            if i != ""|"":
                output_string += i

        return output_string",ZeroShot,"```python
class Manacher:
    def __init__(self, input_string) -> None:
        """"""
        Initializes the Manacher class with the given input_string.
        Preprocesses the string to handle even length palindromes by inserting '#' between characters.
        """"""
        self.input_string = input_string
        # Transform the input string by inserting '#' between each character and at the start and end
        self.transformed_string = '#' + '#'.join(input_string) + '#'
        # Array to store the length of the palindromic radius around each center
        self.palindrome_lengths = [0] * len(self.transformed_string)

    def palindromic_length(self, center, diff, string):
        """"""
        Calculates the length of the palindromic substring based on a given center, difference value, and input string.
        :return: The length of the palindromic substring, int.
        """"""
        # Expand around the center as long as the characters match and within bounds
        while center - diff >= 0 and center + diff < len(string) and string[center - diff] == string[center + diff]:
            diff += 1
        # Return the length of the palindrome radius
        return diff - 1

    def palindromic_string(self):
        """"""
        Finds the longest palindromic substring in the given string.
        :return: The longest palindromic substring, str.
        """"""
        center = 0
        right = 0
        max_length = 0
        max_center = 0

        for i in range(len(self.transformed_string)):
            # Mirror of the current position i around the center
            mirror = 2 * center - i

            if i < right:
                # Use previously calculated palindrome length if within bounds
                self.palindrome_lengths[i] = min(right - i, self.palindrome_lengths[mirror])

            # Try to expand the palindrome around the current center i
            self.palindrome_lengths[i] = self.palindromic_length(i, self.palindrome_lengths[i] + 1, self.transformed_string)

            # Update the center and right boundary if the palindrome expands beyond the current right boundary
            if i + self.palindrome_lengths[i] > right:
                center = i
                right = i + self.palindrome_lengths[i]

            # Update the maximum palindrome length and its center
            if self.palindrome_lengths[i] > max_length:
                max_length = self.palindrome_lengths[i]
                max_center = i

        # Calculate the start index of the longest palindrome in the original string
        start = (max_center - max_length) // 2
        # Return the longest palindromic substring
        return self.input_string[start:start + max_length]
```",0.040123457,0.061252427,0.637931034,0.270072993,0.379487175,0.291262136,0.109090909,0.158730155,0.603448276,0.255474453,0.358974355,,,,,,,,,,,,
GPT,56,"class MetricsCalculator:
    def __init__(self):
        self.true_positives = 0
        self.false_positives = 0
        self.false_negatives = 0
        self.true_negatives = 0

    def update(self, predicted_labels, true_labels):
        for predicted, true in zip(predicted_labels, true_labels):
            if predicted == 1 and true == 1:
                self.true_positives += 1
            elif predicted == 1 and true == 0:
                self.false_positives += 1
            elif predicted == 0 and true == 1:
                self.false_negatives += 1
            elif predicted == 0 and true == 0:
                self.true_negatives += 1

    def precision(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        if self.true_positives + self.false_positives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_positives)

    def recall(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        if self.true_positives + self.false_negatives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_negatives)

    def f1_score(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        precision = self.precision(predicted_labels, true_labels)
        recall = self.recall(predicted_labels, true_labels)
        if precision + recall == 0.0:
            return 0.0
        return (2 * precision * recall) / (precision + recall)

    def accuracy(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives
        if total == 0:
            return 0.0
        return (self.true_positives + self.true_negatives) / total",ZeroShot,"```python
class MetricsCalculator:
    def __init__(self):
        """"""
        Initialize the number of all four samples to 0
        """"""
        self.true_positives = 0
        self.false_positives = 0
        self.false_negatives = 0
        self.true_negatives = 0

    def update(self, predicted_labels, true_labels):
        """"""
        Update the number of all four samples(true_positives, false_positives, false_negatives, true_negatives)
        :param predicted_labels: list of predicted labels
        :param true_labels: list of true labels
        :return: None, change the number of corresponding samples
        """"""
        for predicted, true in zip(predicted_labels, true_labels):
            if predicted == 1 and true == 1:
                self.true_positives += 1
            elif predicted == 1 and true == 0:
                self.false_positives += 1
            elif predicted == 0 and true == 1:
                self.false_negatives += 1
            elif predicted == 0 and true == 0:
                self.true_negatives += 1

    def precision(self):
        """"""
        Calculate precision
        :return: float
        """"""
        if self.true_positives + self.false_positives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_positives)

    def recall(self):
        """"""
        Calculate recall
        :return: float
        """"""
        if self.true_positives + self.false_negatives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_negatives)

    def f1_score(self):
        """"""
        Calculate f1 score, which is the harmonic mean of precision and recall
        :return: float
        """"""
        prec = self.precision()
        rec = self.recall()
        if prec + rec == 0:
            return 0.0
        return 2 * (prec * rec) / (prec + rec)

    def accuracy(self):
        """"""
        Calculate accuracy
        :return: float
        """"""
        total = self.true_positives + self.false_positives + self.false_negatives + self.true_negatives
        if total == 0:
            return 0.0
        return (self.true_positives + self.true_negatives) / total
```

- The `__init__` method initializes the counts for true positives, false positives, false negatives, and true negatives to zero.
- The `update` method iterates over the predicted and true labels to update these counts based on the comparison of predicted and true values.
- The `precision` method calculates precision as the ratio of true positives to the sum of true positives and false positives.
- The `recall` method calculates recall as the ratio of true positives to the sum of true positives and false negatives.
- The `f1_score` method computes the harmonic mean of precision and recall.
- The `accuracy` method calculates accuracy as the ratio of correctly predicted samples (true positives and true negatives) to the total number of samples.",0.303724928,0.325252728,0.78,0.336206897,0.469879514,0.633027523,0.2875,0.395415468,0.78,0.336206897,0.469879514,,,,,,,,,,,,
GPT,57,"import numpy as np


class MetricsCalculator2:
    def __init__(self):
        pass

    @staticmethod
    def mrr(data):
        if type(data) != list and type(data) != tuple:
            raise Exception(""the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple"")

        if len(data) == 0:
            return 0.0, [0.0]
        if type(data) == tuple:
            (sub_list, total_num) = data
            sub_list = np.array(sub_list)
            if total_num == 0:
                return 0.0, [0.0]
            else:
                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                mr_np = sub_list * ranking_array

                mr = 0.0
                for team in mr_np:
                    if team > 0:
                        mr = team
                        break
                return mr, [mr]

        if type(data) == list:
            separate_result = []
            for (sub_list, total_num) in data:
                sub_list = np.array(sub_list)

                if total_num == 0:
                    mr = 0.0
                else:
                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                    mr_np = sub_list * ranking_array

                    mr = 0.0
                    for team in mr_np:
                        if team > 0:
                            mr = team
                            break

                separate_result.append(mr)
            return np.mean(separate_result), separate_result

    @staticmethod
    def map(data):
        if type(data) != list and type(data) != tuple:
            raise Exception(""the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple"")

        if len(data) == 0:
            return 0.0, [0.0]
        if type(data) == tuple:
            (sub_list, total_num) = data
            sub_list = np.array(sub_list)
            if total_num == 0:
                return 0.0, [0.0]
            else:
                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)

                right_ranking_list = []
                count = 1
                for t in sub_list:
                    if t == 0:
                        right_ranking_list.append(0)
                    else:
                        right_ranking_list.append(count)
                        count += 1

                ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num
                return ap, [ap]

        if type(data) == list:
            separate_result = []
            for (sub_list, total_num) in data:
                sub_list = np.array(sub_list)

                if total_num == 0:
                    ap = 0.0
                else:
                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)

                    right_ranking_list = []
                    count = 1
                    for t in sub_list:
                        if t == 0:
                            right_ranking_list.append(0)
                        else:
                            right_ranking_list.append(count)
                            count += 1

                    ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num

                separate_result.append(ap)
            return np.mean(separate_result), separate_result",ZeroShot,"```python
import numpy as np


class MetricsCalculator2:
    def __init__(self):
        pass

    @staticmethod
    def mrr(data):
        """"""
        Compute the MRR of the input data. MRR is a widely used evaluation index. It is the mean of reciprocal rank.
        
        :param data: A list of lists, where each sublist contains binary relevance scores (1 for relevant, 0 for non-relevant).
        :return: A tuple containing the MRR score and a list of reciprocal ranks for each sublist.
        """"""
        reciprocal_ranks = []
        
        for query_results in data:
            # Find the rank of the first relevant item (1)
            try:
                rank = query_results.index(1) + 1
                reciprocal_ranks.append(1 / rank)
            except ValueError:
                # If there is no relevant item, the reciprocal rank is 0
                reciprocal_ranks.append(0)

        # Calculate the mean reciprocal rank
        mean_reciprocal_rank = np.mean(reciprocal_ranks)
        return mean_reciprocal_rank, reciprocal_ranks

    @staticmethod
    def map(data):
        """"""
        Compute the MAP of the input data. MAP is a widely used evaluation index. It is the mean of AP (average precision).
        
        :param data: A list of lists, where each sublist contains binary relevance scores (1 for relevant, 0 for non-relevant).
        :return: A tuple containing the MAP score and a list of average precisions for each sublist.
        """"""
        average_precisions = []

        for query_results in data:
            num_relevant = 0
            precision_sum = 0.0
            
            for i, score in enumerate(query_results):
                if score == 1:
                    num_relevant += 1
                    precision_at_i = num_relevant / (i + 1)
                    precision_sum += precision_at_i
            
            # Calculate average precision for the current query
            if num_relevant > 0:
                average_precision = precision_sum / num_relevant
            else:
                average_precision = 0.0

            average_precisions.append(average_precision)

        # Calculate the mean average precision
        mean_average_precision = np.mean(average_precisions)
        return mean_average_precision, average_precisions
```

- The `mrr` method calculates the Mean Reciprocal Rank by finding the rank of the first relevant item in each list and computing the reciprocal of that rank.
- The `map` method calculates the Mean Average Precision by determining the precision at each relevant item and averaging these precisions for each list.",0.045751634,0.073997981,0.423529412,0.272727273,0.33179723,0.165517241,0.104803493,0.128342241,0.423529412,0.272727273,0.33179723,,,,,,,,,,,,
GPT,58,"import random

class MinesweeperGame:
    def __init__(self, n, k) -> None:
        self.n = n
        self.k = k
        self.minesweeper_map = self.generate_mine_sweeper_map()
        self.player_map = self.generate_playerMap()
        self.score = 0

    def generate_mine_sweeper_map(self):
        arr = [[0 for row in range(self.n)] for column in range(self.n)]
        for num in range(self.k):
            x = random.randint(0, self.n-1)
            y = random.randint(0, self.n-1)
            arr[y][x] = 'X'
            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-1):
                if arr[y][x+1] != 'X':
                    arr[y][x+1] += 1
            if (x >=1 and x <= self.n-1) and (y >= 0 and y <= self.n-1):
                if arr[y][x-1] != 'X':
                    arr[y][x-1] += 1
            if (x >= 1 and x <= self.n-1) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x-1] != 'X':
                    arr[y-1][x-1] += 1
    
            if (x >= 0 and x <= self.n-2) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x+1] != 'X':
                    arr[y-1][x+1] += 1 
            if (x >= 0 and x <= self.n-1) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x] != 'X':
                    arr[y-1][x] += 1
    
            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x+1] != 'X':
                    arr[y+1][x+1] += 1
            if (x >= 1 and x <= self.n-1) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x-1] != 'X':
                    arr[y+1][x-1] += 1
            if (x >= 0 and x <= self.n-1) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x] != 'X':
                    arr[y+1][x] += 1
        return arr
    
    def generate_playerMap(self):
        arr = [['-' for row in range(self.n)] for column in range(self.n)]
        return arr

    def check_won(self, map):
        for i in range(self.n):
            for j in range(self.n):
                if map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':
                    return False
        return True
    
    def sweep(self, x, y):

        if (self.minesweeper_map[x][y] == 'X'):
            return False
        else:
            self.player_map[x][y] = self.minesweeper_map[x][y]
            self.score += 1
            if self.check_won(self.player_map) == True:
                return True
            return self.player_map",ZeroShot,"```python
class MinesweeperGame:
    def __init__(self, n, k) -> None:
        """"""
        Initializes the MinesweeperGame class with the size of the board and the number of mines.
        """"""
        self.n = n  # Size of the board (n x n)
        self.k = k  # Number of mines
        self.mine_map = self.generate_mine_sweeper_map()  # Generate the mine map
        self.player_map = self.generate_playerMap()  # Generate the player map
        self.revealed_cells = 0  # Track the number of revealed cells

    def generate_mine_sweeper_map(self):
        """"""
        Generates a minesweeper map with the given size of the board and the number of mines.
        'X' represents the mine, other numbers represent the number of mines around the position.
        :return: The minesweeper map, list.
        """"""
        # Initialize the mine map with zeros
        mine_map = [[0 for _ in range(self.n)] for _ in range(self.n)]

        # Place mines randomly
        mines_placed = 0
        while mines_placed < self.k:
            x, y = random.randint(0, self.n - 1), random.randint(0, self.n - 1)
            if mine_map[x][y] != 'X':
                mine_map[x][y] = 'X'
                mines_placed += 1

                # Increment the count for adjacent cells
                for i in range(max(0, x - 1), min(self.n, x + 2)):
                    for j in range(max(0, y - 1), min(self.n, y + 2)):
                        if mine_map[i][j] != 'X':
                            mine_map[i][j] += 1

        return mine_map

    def generate_playerMap(self):
        """"""
        Generates a player map with the given size of the board.
        '-' represents the unknown position.
        :return: The player map, list.
        """"""
        return [['-' for _ in range(self.n)] for _ in range(self.n)]

    def check_won(self):
        """"""
        Checks whether the player has won the game.
        :return: True if the player has won the game, False otherwise.
        """"""
        # The player wins if all non-mine cells are revealed
        return self.revealed_cells == self.n * self.n - self.k

    def sweep(self, x, y):
        """"""
        Sweeps the given position.
        :return: True if the player has won the game, False otherwise, if the game still continues, return the player map, list.
        """"""
        if self.mine_map[x][y] == 'X':
            return False  # Game over, player hit a mine

        # Use a queue for BFS to reveal connected zero cells
        queue = [(x, y)]
        visited = set()

        while queue:
            cx, cy = queue.pop(0)
            if (cx, cy) in visited:
                continue
            visited.add((cx, cy))

            # Reveal the cell
            self.player_map[cx][cy] = self.mine_map[cx][cy]
            self.revealed_cells += 1

            # If the cell is zero, add its neighbors to the queue
            if self.mine_map[cx][cy] == 0:
                for i in range(max(0, cx - 1), min(self.n, cx + 2)):
                    for j in range(max(0, cy - 1), min(self.n, cy + 2)):
                        if (i, j) not in visited and self.player_map[i][j] == '-':
                            queue.append((i, j))

        # Check if the player has won after this move
        if self.check_won():
            return True

        return self.player_map
```",0.049528302,0.069554588,0.529411765,0.260115607,0.348837205,0.286549708,0.146706587,0.194059401,0.529411765,0.260115607,0.348837205,,,,,,,,,,,,
GPT,59,"from datetime import datetime
import numpy as np

class MovieBookingSystem:
    def __init__(self):
        self.movies = []

    def add_movie(self, name, price, start_time, end_time, n):
        movie = {
            'name': name,
            'price': price,
            'start_time': datetime.strptime(start_time, '%H:%M'),
            'end_time': datetime.strptime(end_time, '%H:%M'),
            'seats': np.zeros((n, n))
        }
        self.movies.append(movie)

    def book_ticket(self, name, seats_to_book):
        for movie in self.movies:
            if movie['name'] == name:
                for seat in seats_to_book:
                    if movie['seats'][seat[0]][seat[1]] == 0:
                        movie['seats'][seat[0]][seat[1]] = 1
                    else:
                        return ""Booking failed.""
                return ""Booking success.""
        return ""Movie not found.""


    def available_movies(self, start_time, end_time):
        start_time = datetime.strptime(start_time, '%H:%M')
        end_time = datetime.strptime(end_time, '%H:%M')

        available_movies = []
        for movie in self.movies:
            if start_time <= movie['start_time'] and movie['end_time'] <= end_time:
                available_movies.append(movie['name'])

        return available_movies",ZeroShot,"```python
from datetime import datetime
import numpy as np

class MovieBookingSystem:
    def __init__(self):
        """"""
        Initialize the movie booking system with an empty list of movies.
        Each movie is represented as a dictionary containing its name, price, start and end times, and a seating chart.
        """"""
        self.movies = []

    def add_movie(self, name, price, start_time, end_time, n):
        """"""
        Add a new movie into self.movies.
        
        :param name: str, name of the movie
        :param price: float, price of a ticket
        :param start_time: datetime, start time of the movie
        :param end_time: datetime, end time of the movie
        :param n: int, dimension of the seating chart (n x n)
        """"""
        movie = {
            'name': name,
            'price': price,
            'start_time': start_time,
            'end_time': end_time,
            'seats': np.zeros((n, n))
        }
        self.movies.append(movie)

    def book_ticket(self, name, seats_to_book):
        """"""
        Book tickets for a movie. Update the seats in self.movies if booking is successful.
        
        :param name: str, name of the movie to book
        :param seats_to_book: list of tuples, each tuple contains row and column index of seat to book
        :return: str, booking status message
        """"""
        for movie in self.movies:
            if movie['name'] == name:
                for row, col in seats_to_book:
                    if movie['seats'][row][col] == 0:
                        movie['seats'][row][col] = 1
                    else:
                        return ""Booking failed.""
                return ""Booking success.""
        return ""Movie not found.""

    def available_movies(self, start_time, end_time):
        """"""
        Get a list of available movies within the specified time range.
        
        :param start_time: datetime, start of the time range
        :param end_time: datetime, end of the time range
        :return: list of str, names of available movies
        """"""
        available = []
        for movie in self.movies:
            if movie['start_time'] >= start_time and movie['end_time'] <= end_time:
                available.append(movie['name'])
        return available
```

- The `add_movie` method allows adding a new movie with a specified seating chart size.
- The `book_ticket` method attempts to book specified seats for a movie, checking for availability.
- The `available_movies` method returns all movies that are available within a given time range.",0.200657895,0.21786533,0.898550725,0.413333333,0.566210041,0.682692308,0.272030651,0.389041092,0.898550725,0.413333333,0.566210041,,,,,,,,,,,,
GPT,60,"import sqlite3


class MovieTicketDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS tickets (
                id INTEGER PRIMARY KEY,
                movie_name TEXT,
                theater_name TEXT,
                seat_number TEXT,
                customer_name TEXT
            )
        ''')
        self.connection.commit()

    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):
        self.cursor.execute('''
            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)
            VALUES (?, ?, ?, ?)
        ''', (movie_name, theater_name, seat_number, customer_name))
        self.connection.commit()

    def search_tickets_by_customer(self, customer_name):
        self.cursor.execute('''
            SELECT * FROM tickets WHERE customer_name = ?
        ''', (customer_name,))
        tickets = self.cursor.fetchall()
        return tickets

    def delete_ticket(self, ticket_id):
        self.cursor.execute('''
            DELETE FROM tickets WHERE id = ?
        ''', (ticket_id,))
        self.connection.commit()",ZeroShot,"```python
import sqlite3

class MovieTicketDB:
    def __init__(self, db_name):
        """"""
        Initializes the MovieTicketDB object with the specified database name.
        """"""
        self.db_name = db_name
        # Connect to the database and create the table if it doesn't exist
        self.create_table()

    def create_table(self):
        """"""
        Creates a ""tickets"" table in the database if it does not exist already.
        Fields include ID of type int, movie name of type str, theater name of type str,
        seat number of type str, and customer name of type str.
        :return: None
        """"""
        # Establish connection to the database
        conn = sqlite3.connect(self.db_name)
        cursor = conn.cursor()
        # SQL command to create the tickets table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS tickets (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                movie_name TEXT NOT NULL,
                theater_name TEXT NOT NULL,
                seat_number TEXT NOT NULL,
                customer_name TEXT NOT NULL
            )
        ''')
        # Commit the changes and close the connection
        conn.commit()
        conn.close()

    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):
        """"""
        Inserts a new ticket into the ""tickets"" table.
        :return: None
        """"""
        # Establish connection to the database
        conn = sqlite3.connect(self.db_name)
        cursor = conn.cursor()
        # SQL command to insert a new ticket
        cursor.execute('''
            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)
            VALUES (?, ?, ?, ?)
        ''', (movie_name, theater_name, seat_number, customer_name))
        # Commit the changes and close the connection
        conn.commit()
        conn.close()

    def search_tickets_by_customer(self, customer_name):
        """"""
        Searches for tickets in the ""tickets"" table by customer name.
        :return: list of tuples, the rows from the ""tickets"" table that match the search criteria.
        """"""
        # Establish connection to the database
        conn = sqlite3.connect(self.db_name)
        cursor = conn.cursor()
        # SQL command to search for tickets by customer name
        cursor.execute('''
            SELECT * FROM tickets WHERE customer_name = ?
        ''', (customer_name,))
        # Fetch all matching rows
        rows = cursor.fetchall()
        # Close the connection
        conn.close()
        # Return the list of matching rows
        return rows

    def delete_ticket(self, ticket_id):
        """"""
        Deletes a ticket from the ""tickets"" table by ticket ID.
        :return: None
        """"""
        # Establish connection to the database
        conn = sqlite3.connect(self.db_name)
        cursor = conn.cursor()
        # SQL command to delete a ticket by ID
        cursor.execute('''
            DELETE FROM tickets WHERE id = ?
        ''', (ticket_id,))
        # Commit the changes and close the connection
        conn.commit()
        conn.close()
```",0.142450142,0.160497786,0.953125,0.429577465,0.592233005,0.670212766,0.259259259,0.373887236,0.953125,0.429577465,0.592233005,,,,,,,,,,,,
GPT,61,"class MusicPlayer:
    def __init__(self):
        self.playlist = []
        self.current_song = None
        self.volume = 50

    def add_song(self, song):
        self.playlist.append(song)

    def remove_song(self, song):
        if song in self.playlist:
            self.playlist.remove(song)
            if self.current_song == song:
                self.stop()

    def play(self):
        if self.playlist and self.current_song:
            return self.playlist[0]
        elif len(self.playlist): 
            return False

    def stop(self):
        if self.current_song:
            self.current_song = None
            return True
        else:
            return False

    def switch_song(self):
        if self.current_song:
            current_index = self.playlist.index(self.current_song)
            if current_index < len(self.playlist) - 1:
                self.current_song = self.playlist[current_index + 1]
                return True
            else:
                return False
        else:
            return False

    def previous_song(self):
        if self.current_song:
            current_index = self.playlist.index(self.current_song)
            if current_index > 0:
                self.current_song = self.playlist[current_index - 1]
                return True
            else:
                return False
        else:
            return False

    def set_volume(self, volume):
        if 0 <= volume <= 100:
            self.volume = volume
        else:
            return False

    def shuffle(self):
        if self.playlist:
            import random
            random.shuffle(self.playlist)
            return True
        else:
            return False",ZeroShot,"```python
import random

class MusicPlayer:
    def __init__(self):
        """"""
        Initializes the music player with an empty playlist, no current song, and a default volume of 50.
        """"""
        self.playlist = []  # List to store songs
        self.current_index = -1  # Index of the current song, -1 means no song is playing
        self.volume = 50  # Default volume

    def add_song(self, song):
        """"""
        Adds a song to the playlist.
        """"""
        self.playlist.append(song)  # Append the song to the playlist

    def remove_song(self, song):
        """"""
        Removes a song from the playlist.
        """"""
        if song in self.playlist:
            self.playlist.remove(song)  # Remove the song if it exists in the playlist

    def play(self):
        """"""
        Plays the current song in the playlist.
        :return: The current song in the playlist, or False if there is no current song.
        """"""
        if self.current_index == -1 and self.playlist:
            self.current_index = 0  # Start from the first song if no song is currently playing
        if self.current_index != -1:
            return self.playlist[self.current_index]  # Return the current song
        return False

    def stop(self):
        """"""
        Stops the current song in the playlist.
        :return: True if the current song was stopped, False if there was no current song.
        """"""
        if self.current_index != -1:
            self.current_index = -1  # Stop playing by resetting the index
            return True
        return False

    def switch_song(self):
        """"""
        Switches to the next song in the playlist.
        :return: True if the next song was switched to, False if there was no next song.
        """"""
        if self.current_index != -1 and self.current_index < len(self.playlist) - 1:
            self.current_index += 1  # Move to the next song
            return True
        return False

    def previous_song(self):
        """"""
        Switches to the previous song in the playlist.
        :return: True if the previous song was switched to, False if there was no previous song.
        """"""
        if self.current_index > 0:
            self.current_index -= 1  # Move to the previous song
            return True
        return False

    def set_volume(self, volume):
        """"""
        Sets the volume of the music player, if the volume is between 0 and 100 is valid.
        :return: True if the volume was set, False if the volume was invalid.
        """"""
        if 0 <= volume <= 100:
            self.volume = volume  # Set the new volume
            return True
        return False

    def shuffle(self):
        """"""
        Shuffles the playlist.
        :return: True if the playlist was shuffled, False if the playlist was empty.
        """"""
        if self.playlist:
            random.shuffle(self.playlist)  # Shuffle the playlist
            self.current_index = -1  # Reset the current song
            return True
        return False
```",0.074168798,0.098115812,0.762711864,0.368852459,0.497237565,0.509615385,0.217213115,0.304597697,0.762711864,0.368852459,0.497237565,,,,,,,,,,,,
GPT,62,"class NLPDataProcessor:

    def construct_stop_word_list(self):
        stop_word_list = ['a', 'an', 'the']
        return stop_word_list

    def remove_stop_words(self, string_list, stop_word_list):
        answer = []
        for string in string_list:
            string_split = string.split()
            for word in string_split:
                if word in stop_word_list:
                    string_split.remove(word)
            answer.append(string_split)
        return answer

    def process(self, string_list):
        stop_word_list = self.construct_stop_word_list()
        words_list = self.remove_stop_words(string_list, stop_word_list)
        return words_list",ZeroShot,"```python
class NLPDataProcessor:

    def construct_stop_word_list(self):
        """"""
        Construct a stop word list including 'a', 'an', 'the'.
        :return: a list of stop words
        """"""
        # Define a list of stop words
        stop_words = ['a', 'an', 'the']
        return stop_words

    def remove_stop_words(self, string_list, stop_word_list):
        """"""
        Remove all the stop words from the list of strings.
        :param string_list: list of strings to be processed
        :param stop_word_list: list of stop words to be removed
        :return: a list of words without stop words
        """"""
        # Initialize an empty list to store the result
        filtered_list = []
        
        # Iterate over each string in the input list
        for string in string_list:
            # Split the string into words
            words = string.split()
            # Filter out stop words
            filtered_words = [word for word in words if word.lower() not in stop_word_list]
            # Join the filtered words back into a string
            filtered_string = ' '.join(filtered_words)
            # Add the filtered string to the result list
            filtered_list.append(filtered_string)
        
        return filtered_list

    def process(self, string_list):
        """"""
        Construct a stop word list including 'a', 'an', 'the', and remove all the stop words from the list of strings.
        :param string_list: list of strings to be processed
        :return: a list of words without stop words
        """"""
        # Construct the stop word list
        stop_word_list = self.construct_stop_word_list()
        # Remove stop words from the input string list
        return self.remove_stop_words(string_list, stop_word_list)
```

- The `construct_stop_word_list` method creates and returns a list of stop words.
- The `remove_stop_words` method takes a list of strings and a list of stop words, removes the stop words from each string, and returns the filtered list.
- The `process` method combines the functionality of the previous two methods to process a list of strings by removing the stop words.",0.043478261,0.05447761,0.823529412,0.266666667,0.402877694,0.52,0.130653266,0.208835338,0.794117647,0.257142857,0.388489205,,,,,,,,,,,,
GPT,63,"from collections import Counter
import re

class NLPDataProcessor2:

    def process_data(self, string_list):
        words_list = []
        for string in string_list:
            # Remove non-English letters and convert to lowercase
            processed_string = re.sub(r'[^a-zA-Z\s]', '', string.lower())
            # Split the string into words
            words = processed_string.split()
            words_list.append(words)
        return words_list

    def calculate_word_frequency(self, words_list):
        word_frequency = Counter()
        for words in words_list:
            word_frequency.update(words)
        sorted_word_frequency = dict(sorted(word_frequency.items(), key=lambda x: x[1], reverse=True))
        top_5_word_frequency = dict(list(sorted_word_frequency.items())[:5])
        return top_5_word_frequency

    def process(self, string_list):
        words_list = self.process_data(string_list)
        word_frequency_dict = self.calculate_word_frequency(words_list)
        return word_frequency_dict",ZeroShot,"```python
import re
from collections import Counter

class NLPDataProcessor2:

    def process_data(self, string_list):
        """"""
        keep only English letters and spaces in the string, then convert the string to lower case,
        and then split the string into a list of words.
        :return: words_list: a list of words lists
        """"""
        # Initialize an empty list to store words
        words_list = []
        
        # Iterate over each string in the input list
        for string in string_list:
            # Use regex to keep only letters and spaces, then convert to lower case
            cleaned_string = re.sub(r'[^a-zA-Z\s]', '', string).lower()
            # Split the cleaned string into words and extend the words_list
            words_list.extend(cleaned_string.split())
        
        return words_list

    def calculate_word_frequency(self, words_list):
        """"""
        Calculate the word frequency of each word in the list of words list,
        and sort the word frequency dictionary by value in descending order.
        :return: top 5 word frequency dictionary, a dictionary of word frequency,
        key is word, value is frequency
        """"""
        # Use Counter to calculate word frequencies
        word_count = Counter(words_list)
        # Get the 5 most common words and their frequencies
        top_5_words = word_count.most_common(5)
        # Convert the list of tuples to a dictionary
        top_5_word_dict = dict(top_5_words)
        
        return top_5_word_dict

    def process(self, string_list):
        """"""
        keep only English letters and spaces in the string, then convert the string to lower case,
        and then split the string into a list of words. Calculate the word frequency of each word
        in the list of words list, and sort the word frequency dictionary by value in descending order.
        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency
        """"""
        # Process the data to get a list of words
        words_list = self.process_data(string_list)
        # Calculate and return the top 5 word frequencies
        return self.calculate_word_frequency(words_list)
```",0.063829787,0.075506958,0.631578947,0.339622642,0.441717787,0.402439024,0.173684211,0.242647055,0.614035088,0.330188679,0.429447848,,,,,,,,,,,,
GPT,64,"class NumberConverter:
    @staticmethod
    def decimal_to_binary(decimal_num):
        binary_num = bin(decimal_num)[2:]
        return binary_num

    @staticmethod
    def binary_to_decimal(binary_num):
        decimal_num = int(binary_num, 2)
        return decimal_num

    @staticmethod
    def decimal_to_octal(decimal_num):
        octal_num = oct(decimal_num)[2:]
        return octal_num

    @staticmethod
    def octal_to_decimal(octal_num):
        decimal_num = int(octal_num, 8)
        return decimal_num

    @staticmethod
    def decimal_to_hex(decimal_num):
        hex_num = hex(decimal_num)[2:]
        return hex_num

    @staticmethod
    def hex_to_decimal(hex_num):
        decimal_num = int(hex_num, 16)
        return decimal_num",ZeroShot,"```python
class NumberConverter:
    @staticmethod
    def decimal_to_binary(decimal_num):
        """"""
        Convert a number from decimal format to binary format.
        :return: str, the binary representation of an integer.
        """"""
        # Use the built-in bin() function and remove '0b' prefix
        return bin(decimal_num)[2:]

    @staticmethod
    def binary_to_decimal(binary_num):
        """"""
        Convert a number from binary format to decimal format.
        :return: int, the decimal representation of binary number str.
        """"""
        # Use the int function with base 2 to convert binary to decimal
        return int(binary_num, 2)

    @staticmethod
    def decimal_to_octal(decimal_num):
        """"""
        Convert a number from decimal format to octal format.
        :return: str, the octal representation of an integer.
        """"""
        # Use the built-in oct() function and remove '0o' prefix
        return oct(decimal_num)[2:]

    @staticmethod
    def octal_to_decimal(octal_num):
        """"""
        Convert a number from octal format to decimal format.
        :return: int, the decimal representation of octal number str.
        """"""
        # Use the int function with base 8 to convert octal to decimal
        return int(octal_num, 8)

    @staticmethod
    def decimal_to_hex(decimal_num):
        """"""
        Convert a number from decimal format to hex format.
        :return hex_num: str, the hex representation of an integer.
        """"""
        # Use the built-in hex() function and remove '0x' prefix
        return hex(decimal_num)[2:]

    @staticmethod
    def hex_to_decimal(hex_num):
        """"""
        Convert a number from hex format to decimal format.
        :return: int, the decimal representation of hex number str.
        """"""
        # Use the int function with base 16 to convert hex to decimal
        return int(hex_num, 16)
```",0.036036036,0.044395066,0.8,0.3125,0.449438198,0.285714286,0.10619469,0.154838706,0.76,0.296875,0.426966288,,,,,,,,,,,,
GPT,65,"class NumberWordFormatter:
    def __init__(self):
        self.NUMBER = ["""", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""]
        self.NUMBER_TEEN = [""TEN"", ""ELEVEN"", ""TWELVE"", ""THIRTEEN"", ""FOURTEEN"", ""FIFTEEN"", ""SIXTEEN"", ""SEVENTEEN"",
                            ""EIGHTEEN"",
                            ""NINETEEN""]
        self.NUMBER_TEN = [""TEN"", ""TWENTY"", ""THIRTY"", ""FORTY"", ""FIFTY"", ""SIXTY"", ""SEVENTY"", ""EIGHTY"", ""NINETY""]
        self.NUMBER_MORE = ["""", ""THOUSAND"", ""MILLION"", ""BILLION""]
        self.NUMBER_SUFFIX = [""k"", ""w"", """", ""m"", """", """", ""b"", """", """", ""t"", """", """", ""p"", """", """", ""e""]

    def format(self, x):
        if x is not None:
            return self.format_string(str(x))
        else:
            return """"

    def format_string(self, x):
        lstr, rstr = (x.split('.') + [''])[:2]
        lstrrev = lstr[::-1]
        a = [''] * 5

        if len(lstrrev) % 3 == 1:
            lstrrev += ""00""
        elif len(lstrrev) % 3 == 2:
            lstrrev += ""0""

        lm = """"
        for i in range(len(lstrrev) // 3):
            a[i] = lstrrev[3 * i:3 * i + 3][::-1]
            if a[i] != ""000"":
                lm = self.trans_three(a[i]) + "" "" + self.parse_more(i) + "" "" + lm
            else:
                lm += self.trans_three(a[i])

        xs = f""AND CENTS {self.trans_two(rstr)} "" if rstr else """"
        if not lm.strip():
            return ""ZERO ONLY""
        else:
            return f""{lm.strip()} {xs}ONLY""

    def trans_two(self, s):
        s = s.zfill(2)
        if s[0] == ""0"":
            return self.NUMBER[int(s[-1])]
        elif s[0] == ""1"":
            return self.NUMBER_TEEN[int(s) - 10]
        elif s[1] == ""0"":
            return self.NUMBER_TEN[int(s[0]) - 1]
        else:
            return self.NUMBER_TEN[int(s[0]) - 1] + "" "" + self.NUMBER[int(s[-1])]

    def trans_three(self, s):
        if s[0] == ""0"":
            return self.trans_two(s[1:])
        elif s[1:] == ""00"":
            return f""{self.NUMBER[int(s[0])]} HUNDRED""
        else:
            return f""{self.NUMBER[int(s[0])]} HUNDRED AND {self.trans_two(s[1:])}""

    def parse_more(self, i):
        return self.NUMBER_MORE[i]",ZeroShot,"```python
class NumberWordFormatter:
    def __init__(self):
        """"""
        Initialize NumberWordFormatter object.
        """"""
        # Define basic number words for quick lookup
        self.units = ["""", ""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine""]
        self.teens = [""Ten"", ""Eleven"", ""Twelve"", ""Thirteen"", ""Fourteen"", ""Fifteen"", ""Sixteen"", ""Seventeen"", ""Eighteen"", ""Nineteen""]
        self.tens = ["""", """", ""Twenty"", ""Thirty"", ""Forty"", ""Fifty"", ""Sixty"", ""Seventy"", ""Eighty"", ""Ninety""]
        self.thousands = ["""", ""Thousand"", ""Million"", ""Billion""]

    def format(self, x):
        """"""
        Converts a number into words format
        :return: str, the number in words format
        """"""
        if isinstance(x, str):
            return self.format_string(x)
        elif isinstance(x, (int, float)):
            return self.format_string(str(x))
        else:
            raise ValueError(""Unsupported type"")

    def format_string(self, x):
        """"""
        Converts a string representation of a number into words format
        :return: str, the number in words format
        """"""
        if '.' in x:
            integer_part, decimal_part = x.split('.')
            integer_words = self.convert_integer_to_words(integer_part)
            decimal_words = self.convert_integer_to_words(decimal_part)
            return f""{integer_words} point {decimal_words}""
        else:
            return self.convert_integer_to_words(x)

    def convert_integer_to_words(self, num_str):
        """"""
        Converts an integer string into words format
        :return: str, the number in words format
        """"""
        num = int(num_str)
        if num == 0:
            return ""Zero""
        
        words = """"
        place = 0

        while num > 0:
            if num % 1000 != 0:
                words = self.trans_three(num % 1000) + (self.thousands[place] and "" "" + self.thousands[place] or """") + "" "" + words
            num //= 1000
            place += 1

        return words.strip()

    def trans_two(self, s):
        """"""
        Converts a two-digit number into words format
        :return: str, the number in words format
        """"""
        num = int(s)
        if num < 10:
            return self.units[num]
        elif num < 20:
            return self.teens[num - 10]
        else:
            return self.tens[num // 10] + (num % 10 != 0 and "" "" + self.units[num % 10] or """")

    def trans_three(self, s):
        """"""
        Converts a three-digit number into words format
        :return: str, the number in words format
        """"""
        num = int(s)
        if num < 100:
            return self.trans_two(s)
        else:
            return self.units[num // 100] + "" Hundred"" + (num % 100 != 0 and "" "" + self.trans_two(num % 100) or """")

    def parse_more(self, i):
        """"""
        Parses the thousand/million/billion suffix based on the index
        :return: str, the corresponding suffix for the magnitude
        """"""
        return self.thousands[i] if i < len(self.thousands) else """"

# Example usage:
# formatter = NumberWordFormatter()
# print(formatter.format(1234567.89))  # Output: ""One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven point Eighty Nine""
```",0.032697548,0.043893302,0.278571429,0.207446809,0.237804873,0.123287671,0.092150171,0.105468745,0.278571429,0.207446809,0.237804873,,,,,,,,,,,,
GPT,66,"class NumericEntityUnescaper:
    def __init__(self):
        pass

    def replace(self, string):
        out = []
        pos = 0
        length = len(string)

        while pos < length - 2:
            if string[pos] == '&' and string[pos + 1] == '#':
                start = pos + 2
                is_hex = False
                first_char = string[start]

                if first_char == 'x' or first_char == 'X':
                    start += 1
                    is_hex = True

                if start == length:
                    return ''.join(out)

                end = start
                while end < length and self.is_hex_char(string[end]):
                    end += 1

                if end < length and string[end] == ';':
                    try:
                        entity_value = int(string[start:end], 16 if is_hex else 10)
                    except:
                        return ''.join(out)

                    out.append(chr(entity_value))
                    pos = end + 1
                    continue

            out.append(string[pos])
            pos += 1

        return ''.join(out)

    @staticmethod
    def is_hex_char(char):
        return char.isdigit() or ('a' <= char.lower() <= 'f')",ZeroShot,"```python
import re

class NumericEntityUnescaper:
    def __init__(self):
        pass

    def replace(self, string):
        """"""
        Replaces numeric character references (HTML entities) in the input string with their corresponding Unicode characters.
        :param string: str, the input string containing numeric character references.
        :return: str, the input string with numeric character references replaced with their corresponding Unicode characters.
        """"""
        # Regex to match numeric character references, both decimal (&#123;) and hexadecimal (&#x1A;)
        entity_pattern = re.compile(r'&#(x?[0-9A-Fa-f]+);')

        # Function to convert matched numeric reference to character
        def replace_entity(match):
            entity = match.group(1)
            if entity.startswith('x') or entity.startswith('X'):
                # Hexadecimal entity
                code_point = int(entity[1:], 16)
            else:
                # Decimal entity
                code_point = int(entity)
            try:
                # Convert code point to character
                return chr(code_point)
            except ValueError:
                # If conversion fails, return the original match
                return match.group(0)

        # Substitute all numeric references using the replace_entity function
        return entity_pattern.sub(replace_entity, string)

    @staticmethod
    def is_hex_char(char):
        """"""
        Determines whether a given character is a hexadecimal digit.
        :param char: str, a single character to check.
        :return: bool, True if the character is a hexadecimal digit, False otherwise.
        """"""
        # Check if the character is a valid hexadecimal digit (0-9, a-f, A-F)
        return char.isdigit() or ('a' <= char.lower() <= 'f')
```

# Explanation:
- The `replace` method uses a regular expression to find numeric character references in the input string and replaces them with the corresponding Unicode characters.
- The `replace_entity` function is a helper that converts the numeric reference to a character using `chr()`.
- The `is_hex_char` method checks if a character is a valid hexadecimal digit, which is useful for parsing hexadecimal numeric entities.",0.051383399,0.066707515,0.363636364,0.177777778,0.238805966,0.166666667,0.087557604,0.114803621,0.333333333,0.162962963,0.218905468,,,,,,,,,,,,
GPT,67,"class Order:

    def __init__(self):
        self.menu = []
        # menu = [{""dish"": dish name, ""price"": price, ""count"": count}, ...]
        self.selected_dishes = []
        # selected_dish = {""dish"": dish name, ""count"": count, price: price}
        self.sales = {}
        # 


    def add_dish(self, dish):
        for menu_dish in self.menu:
            if dish[""dish""] == menu_dish[""dish""]:
                if menu_dish[""count""] < dish[""count""]:
                    return False
                else:
                    menu_dish[""count""] -= dish[""count""]
                    break
        self.selected_dishes.append(dish)
        return True

    def calculate_total(self):
        total = 0
        for dish in self.selected_dishes:
            total += dish[""price""] * dish[""count""] * self.sales[dish[""dish""]]
        return total

    def checkout(self):
        if len(self.selected_dishes) == 0:
            return False
        total = self.calculate_total()
        self.selected_dishes = []
        return total",ZeroShot,"```python
class Order:

    def __init__(self):
        """"""
        Initialize the order management system
        self.menu stores the dishes of restaurant inventory
        """"""
        # Sample menu with dish names as keys and a tuple of (price, count) as values
        self.menu = {
            ""Pasta"": (10.0, 5),
            ""Pizza"": (12.0, 3),
            ""Salad"": (8.0, 10)
        }
        # Initialize selected_dishes to store ordered dishes and their counts
        self.selected_dishes = {}

    def add_dish(self, dish, count):
        """"""
        Check the self.menu and add into self.selected_dishes if the dish count is valid.
        And if the dish has successfully been added, change the count in self.menu.
        :param dish: str, name of the dish
        :param count: int, number of dishes to add
        :return: True if successfully added, or False otherwise.
        """"""
        if dish in self.menu and self.menu[dish][1] >= count:
            # Add dish to selected_dishes or update the count if it already exists
            if dish in self.selected_dishes:
                self.selected_dishes[dish] += count
            else:
                self.selected_dishes[dish] = count
            # Decrease the count in the menu
            self.menu[dish] = (self.menu[dish][0], self.menu[dish][1] - count)
            return True
        return False

    def calculate_total(self):
        """"""
        Calculate the total price of dishes that have been ordered. Multiply the count, price and sales.
        :return total: float, the final total price.
        """"""
        total = 0.0
        for dish, count in self.selected_dishes.items():
            price = self.menu[dish][0]
            total += price * count
        return total

    def checkout(self):
        """"""
        Check out the dishes ordered. If the self.selected_dishes is not empty, invoke the calculate_total
        method to check out.
        :return: False if the self.selected_dishes is empty, or total (return value of calculate_total) otherwise.
        """"""
        if not self.selected_dishes:
            return False
        return self.calculate_total()
```

- The `__init__` method initializes the menu and selected dishes.
- The `add_dish` method checks if the dish is available in the menu and updates the selected dishes and menu accordingly.
- The `calculate_total` method computes the total cost of selected dishes.
- The `checkout` method returns the total cost if there are selected dishes, otherwise returns `False`.",0.016129032,0.031678176,0.491525424,0.197278912,0.281553394,0.260869565,0.084507042,0.127659571,0.491525424,0.197278912,0.281553394,,,,,,,,,,,,
GPT,68,"class PageUtil:
    def __init__(self, data, page_size):
        self.data = data
        self.page_size = page_size
        self.total_items = len(data)
        self.total_pages = (self.total_items + page_size - 1) // page_size

    def get_page(self, page_number):
        if page_number < 1 or page_number > self.total_pages:
            return []

        start_index = (page_number - 1) * self.page_size
        end_index = start_index + self.page_size
        return self.data[start_index:end_index]

    def get_page_info(self, page_number):
        if page_number < 1 or page_number > self.total_pages:
            return {}

        start_index = (page_number - 1) * self.page_size
        end_index = min(start_index + self.page_size, self.total_items)
        page_data = self.data[start_index:end_index]

        page_info = {
            ""current_page"": page_number,
            ""per_page"": self.page_size,
            ""total_pages"": self.total_pages,
            ""total_items"": self.total_items,
            ""has_previous"": page_number > 1,
            ""has_next"": page_number < self.total_pages,
            ""data"": page_data
        }
        return page_info

    def search(self, keyword):
        results = [item for item in self.data if keyword in str(item)]
        num_results = len(results)
        num_pages = (num_results + self.page_size - 1) // self.page_size

        search_info = {
            ""keyword"": keyword,
            ""total_results"": num_results,
            ""total_pages"": num_pages,
            ""results"": results
        }
        return search_info",ZeroShot,"```python
class PageUtil:
    def __init__(self, data, page_size):
        """"""
        Initialize the PageUtil object with the given data and page size.
        :param data: list, the dataset to paginate
        :param page_size: int, the number of items per page
        """"""
        self.data = data
        self.page_size = page_size
        self.total_items = len(data)
        self.total_pages = (self.total_items + page_size - 1) // page_size  # Calculate total pages

    def get_page(self, page_number):
        """"""
        Retrieve a specific page of data.
        :param page_number: int, the page number to retrieve
        :return: list, the data on the specified page
        """"""
        if page_number < 1 or page_number > self.total_pages:
            return []  # Return an empty list if the page number is out of range
        start_index = (page_number - 1) * self.page_size
        end_index = start_index + self.page_size
        return self.data[start_index:end_index]

    def get_page_info(self, page_number):
        """"""
        Retrieve information about a specific page.
        :param page_number: int, the page number to retrieve information for
        :return: dict, containing page information such as current page number, total pages, etc.
        """"""
        return {
            ""current_page"": page_number,
            ""total_pages"": self.total_pages,
            ""page_size"": self.page_size,
            ""total_items"": self.total_items,
            ""has_previous"": page_number > 1,
            ""has_next"": page_number < self.total_pages
        }

    def search(self, keyword):
        """"""
        Search for items in the data that contain the given keyword.
        :param keyword: str, the keyword to search for
        :return: dict, containing search information such as total results and matching items
        """"""
        matching_items = [item for item in self.data if keyword.lower() in str(item).lower()]
        return {
            ""total_results"": len(matching_items),
            ""items"": matching_items
        }
```

- The `__init__` method initializes the `PageUtil` object with the dataset and page size, calculating the total number of pages.
- The `get_page` method retrieves data for a specified page, returning an empty list if the page number is out of range.
- The `get_page_info` method provides metadata about the requested page, including whether there are previous or next pages.
- The `search` method finds and returns items that contain the specified keyword, regardless of case.",0.190789474,0.213830482,0.77027027,0.38,0.508928567,0.606299213,0.287313433,0.389873413,0.77027027,0.38,0.508928567,,,,,,,,,,,,
GPT,69,"import PyPDF2


class PDFHandler:
    def __init__(self, filepaths):
        self.filepaths = filepaths
        # PdfFileReader is deprecated and was removed in PyPDF2 3.0.0. Use PdfReader instead.
        self.readers = [PyPDF2.PdfReader(fp) for fp in filepaths]

    def merge_pdfs(self, output_filepath):
        pdf_writer = PyPDF2.PdfWriter()

        for reader in self.readers:
            # reader.getNumPages is deprecated and was removed in PyPDF2 3.0.0. Use len(reader.pages) instead.
            for page_num in range(len(reader.pages)):
                # reader.getPage(pageNumber) is deprecated and was removed in PyPDF2 3.0.0. Use reader.pages[page_number] instead.
                page = reader.pages[page_num]
                # addPage is deprecated and was removed in PyPDF2 3.0.0. Use add_page instead.
                pdf_writer.add_page(page)

        with open(output_filepath, 'wb') as out:
            pdf_writer.write(out)
        return f""Merged PDFs saved at {output_filepath}""

    def extract_text_from_pdfs(self):
        pdf_texts = []
        for reader in self.readers:
            for page_num in range(len(reader.pages)):
                page = reader.pages[page_num]
                pdf_texts.append(page.extract_text())
        return pdf_texts",ZeroShot,"```python
import PyPDF2

class PDFHandler:
    def __init__(self, filepaths):
        """"""
        Takes a list of file paths filepaths as a parameter.
        It creates a list named readers using PyPDF2, where each reader opens a file from the given paths.
        """"""
        self.readers = [PyPDF2.PdfReader(open(filepath, 'rb')) for filepath in filepaths]

    def merge_pdfs(self, output_filepath):
        """"""
        Read files in self.readers which stores handles to multiple PDF files.
        Merge them to one pdf and update the page number, then save in disk.
        :return: str, ""Merged PDFs saved at {output_filepath}"" if successfully merged
        """"""
        pdf_writer = PyPDF2.PdfWriter()

        # Iterate over each reader and add their pages to the writer
        for reader in self.readers:
            for page_num in range(len(reader.pages)):
                pdf_writer.add_page(reader.pages[page_num])

        # Write the merged PDF to the specified output file
        with open(output_filepath, 'wb') as output_pdf:
            pdf_writer.write(output_pdf)

        return f""Merged PDFs saved at {output_filepath}""

    def extract_text_from_pdfs(self):
        """"""
        Extract text from pdf files in self.readers
        :return pdf_texts: list of str, each element is the text of one pdf file
        """"""
        pdf_texts = []

        # Iterate over each reader and extract text from each page
        for reader in self.readers:
            text = ''
            for page_num in range(len(reader.pages)):
                text += reader.pages[page_num].extract_text() or ''
            pdf_texts.append(text)

        return pdf_texts
```",0.148148148,0.179833561,0.646153846,0.371681416,0.471910108,0.386138614,0.219101124,0.279569888,0.630769231,0.362831858,0.460674153,,,,,,,,,,,,
GPT,70,"class PersonRequest:
    def __init__(self, name: str, sex: str, phoneNumber: str):
        self.name = self._validate_name(name)
        self.sex = self._validate_sex(sex)
        self.phoneNumber = self._validate_phoneNumber(phoneNumber)

    def _validate_name(self, name: str) -> str:
        if not name:
            return None
        if len(name) > 33:
            return None
        return name

    def _validate_sex(self, sex: str) -> str:
        if sex not in [""Man"", ""Woman"", ""UGM""]:
            return None
        return sex

    def _validate_phoneNumber(self, phoneNumber: str) -> str:
        if not phoneNumber:
            return None
        if len(phoneNumber) != 11 or not phoneNumber.isdigit():
            return None
        return phoneNumber",ZeroShot,"```python
class PersonRequest:
    def __init__(self, name: str, sex: str, phoneNumber: str):
        """"""
        Initialize PersonRequest object with the provided information.
        """"""
        self.name = self._validate_name(name)
        self.sex = self._validate_sex(sex)
        self.phoneNumber = self._validate_phoneNumber(phoneNumber)

    def _validate_name(self, name: str) -> str:
        """"""
        Validate the name and return it. If name is empty or exceeds 33 characters in length, set to None.
        :return: str, the validated name or None if invalid
        """"""
        # Check if the name is not empty and does not exceed 33 characters
        if name and len(name) <= 33:
            return name
        return None

    def _validate_sex(self, sex: str) -> str:
        """"""
        Validate the sex and return it. If sex is not Man, Woman, or UGM, set to None.
        :return: str, the validated sex or None if invalid
        """"""
        # Check if the sex is one of the valid options
        if sex in ['Man', 'Woman', 'UGM']:
            return sex
        return None

    def _validate_phoneNumber(self, phoneNumber: str) -> str:
        """"""
        Validate the phone number and return it. If phoneNumber is empty or not an 11 digit number, set to None.
        :return: str, the validated phone number or None if invalid
        """"""
        # Check if the phone number is exactly 11 digits and only contains numbers
        if phoneNumber.isdigit() and len(phoneNumber) == 11:
            return phoneNumber
        return None
```

- The `_validate_name` method checks if the name is not empty and does not exceed 33 characters, otherwise returns `None`.
- The `_validate_sex` method ensures the sex is either 'Man', 'Woman', or 'UGM', returning `None` if it's not.
- The `_validate_phoneNumber` method checks if the phone number is exactly 11 digits and contains only numbers, returning `None` if invalid.",0.109848485,0.145625741,0.846153846,0.317307692,0.461538458,0.611940299,0.222826087,0.326693223,0.820512821,0.307692308,0.447552444,,,,,,,,,,,,
GPT,71,"class PushBoxGame:
    def __init__(self, map):
        self.map = map
        self.player_row = 0
        self.player_col = 0
        self.targets = []
        self.boxes = []
        self.target_count = 0
        self.is_game_over = False

        self.init_game()

    def init_game(self):
        for row in range(len(self.map)):
            for col in range(len(self.map[row])):
                if self.map[row][col] == ""O"":
                    self.player_row = row
                    self.player_col = col
                elif self.map[row][col] == ""G"":
                    self.targets.append((row, col))
                    self.target_count += 1
                elif self.map[row][col] == ""X"":
                    self.boxes.append((row, col))

    def check_win(self):
        box_on_target_count = 0
        for box in self.boxes:
            if box in self.targets:
                box_on_target_count += 1
        if box_on_target_count == self.target_count:
            self.is_game_over = True
        return self.is_game_over

    def move(self, direction):
        new_player_row = self.player_row
        new_player_col = self.player_col

        if direction == ""w"":
            new_player_row -= 1
        elif direction == ""s"":
            new_player_row += 1
        elif direction == ""a"":
            new_player_col -= 1
        elif direction == ""d"":
            new_player_col += 1

        if self.map[new_player_row][new_player_col] != ""#"":
            if (new_player_row, new_player_col) in self.boxes:
                new_box_row = new_player_row + (new_player_row - self.player_row)
                new_box_col = new_player_col + (new_player_col - self.player_col)

                if self.map[new_box_row][new_box_col] != ""#"":
                    self.boxes.remove((new_player_row, new_player_col))
                    self.boxes.append((new_box_row, new_box_col))
                    self.player_row = new_player_row
                    self.player_col = new_player_col
            else:
                self.player_row = new_player_row
                self.player_col = new_player_col

        return self.check_win()",ZeroShot,"```python
class PushBoxGame:
    def __init__(self, map):
        """"""
        Initialize the push box game with the map and various attributes.
        """"""
        self.map = map
        self.player_row = 0
        self.player_col = 0
        self.targets = []
        self.boxes = []
        self.target_count = 0
        self.is_game_over = False
        self.init_game()

    def init_game(self):
        """"""
        Initialize the game by setting the positions of the player, targets, and boxes based on the map.
        """"""
        for row in range(len(self.map)):
            for col in range(len(self.map[row])):
                if self.map[row][col] == 'P':  # Player start position
                    self.player_row = row
                    self.player_col = col
                elif self.map[row][col] == 'T':  # Target position
                    self.targets.append((row, col))
                    self.target_count += 1
                elif self.map[row][col] == 'B':  # Box position
                    self.boxes.append((row, col))

    def check_win(self):
        """"""
        Check if the game is won. The game is won when all the boxes are placed on target positions.
        And update the value of self.is_game_over.
        :return self.is_game_over: True if all the boxes are placed on target positions, or False otherwise.
        """"""
        # Check if all boxes are on target positions
        on_target_count = 0
        for box in self.boxes:
            if box in self.targets:
                on_target_count += 1
        self.is_game_over = (on_target_count == self.target_count)
        return self.is_game_over

    def move(self, direction):
        """"""
        Move the player based on the specified direction and check if the game is won.
        :return: True if the game is won, False otherwise.
        """"""
        # Define movement vectors
        direction_vectors = {
            'up': (-1, 0),
            'down': (1, 0),
            'left': (0, -1),
            'right': (0, 1)
        }

        if direction in direction_vectors:
            # Calculate new player position
            d_row, d_col = direction_vectors[direction]
            new_player_row = self.player_row + d_row
            new_player_col = self.player_col + d_col

            # Check if new position is within bounds
            if 0 <= new_player_row < len(self.map) and 0 <= new_player_col < len(self.map[0]):
                # Check if new position is a box
                if (new_player_row, new_player_col) in self.boxes:
                    # Calculate new box position
                    new_box_row = new_player_row + d_row
                    new_box_col = new_player_col + d_col

                    # Check if box can be moved
                    if 0 <= new_box_row < len(self.map) and 0 <= new_box_col < len(self.map[0]) and self.map[new_box_row][new_box_col] != 'W' and (new_box_row, new_box_col) not in self.boxes:
                        # Move box
                        self.boxes.remove((new_player_row, new_player_col))
                        self.boxes.append((new_box_row, new_box_col))
                        # Move player
                        self.player_row = new_player_row
                        self.player_col = new_player_col
                elif self.map[new_player_row][new_player_col] != 'W':  # Check if new position is not a wall
                    # Move player
                    self.player_row = new_player_row
                    self.player_col = new_player_col

        # Check if the game is won after the move
        return self.check_win()
```",0.209549072,0.239084095,0.773333333,0.374193548,0.504347822,0.630136986,0.307692308,0.413483142,0.773333333,0.374193548,0.504347822,,,,,,,,,,,,
GPT,72,"import re


class RegexUtils:

    def match(self, pattern, text):
        ans = re.match(pattern, text)
        if ans:
            return True
        else:
            return False

    def findall(self, pattern, text):
        return re.findall(pattern, text)

    def split(self, pattern, text):
        return re.split(pattern, text)

    def sub(self, pattern, replacement, text):
        return re.sub(pattern, replacement, text)

    def generate_email_pattern(self):
        pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        return pattern

    def generate_phone_number_pattern(self):
        pattern = r'\b\d{3}-\d{3}-\d{4}\b'
        return pattern

    def generate_split_sentences_pattern(self):
        pattern = r'[.!?][\s]{1,2}(?=[A-Z])'
        return pattern

    def split_sentences(self, text):
        pattern = self.generate_split_sentences_pattern()
        return self.split(pattern, text)

    def validate_phone_number(self, phone_number):
        pattern = self.generate_phone_number_pattern()
        return self.match(pattern, phone_number)

    def extract_email(self, text):
        pattern = self.generate_email_pattern()
        return self.findall(pattern, text)",ZeroShot,"```python
import re

class RegexUtils:

    def match(self, pattern, text):
        """"""
        Check if the text matches the regular expression
        :return: True or False, representing whether the text matches the regular expression or not
        """"""
        return re.fullmatch(pattern, text) is not None

    def findall(self, pattern, text):
        """"""
        Find all matching substrings and return a list of all matching substrings
        :return: list of string, List of all matching substrings
        """"""
        return re.findall(pattern, text)

    def split(self, pattern, text):
        """"""
        Split text based on regular expression patterns and return a list of substrings
        :return: list of string, List of substrings after splitting
        """"""
        return re.split(pattern, text)

    def sub(self, pattern, replacement, text):
        """"""
        Replace the substring matched by a regular expression with the specified string
        :return: string, Text after replacement
        """"""
        return re.sub(pattern, replacement, text)

    def generate_email_pattern(self):
        """"""
        Generate regular expression patterns that match email addresses
        :return: string, regular expression patterns that match email addresses
        """"""
        return r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'

    def generate_phone_number_pattern(self):
        """"""
        Generate regular expression patterns that match phone numbers
        :return: string, regular expression patterns that match phone numbers
        """"""
        return r'\+?1?\d{10,15}'

    def generate_split_sentences_pattern(self):
        """"""
        Generate regular expression patterns that match the middle characters of two sentences
        :return: string, regular expression patterns that match the middle characters of two sentences
        """"""
        return r'(?<=[.!?]) +'

    def split_sentences(self, text):
        """"""
        Split the text into a list of sentences without Punctuation except the last sentence
        :return: Split Text List
        """"""
        pattern = self.generate_split_sentences_pattern()
        return re.split(pattern, text)

    def validate_phone_number(self, phone_number):
        """"""
        Verify if the phone number is valid
        :return: True or False, indicating whether the phone number is valid
        """"""
        pattern = self.generate_phone_number_pattern()
        return re.fullmatch(pattern, phone_number) is not None

    def extract_email(self, text):
        """"""
        Extract all email addresses from the text
        :return: list of string, All extracted email addresses
        """"""
        pattern = self.generate_email_pattern()
        return re.findall(pattern, text)
```

- `match`: Uses `re.fullmatch()` to check if the entire text matches the pattern.
- `findall`: Uses `re.findall()` to find all occurrences of the pattern in the text.
- `split`: Uses `re.split()` to split the text based on the pattern.
- `sub`: Uses `re.sub()` to replace occurrences of the pattern with a replacement string.
- `generate_email_pattern`: Returns a regex pattern for matching email addresses.
- `generate_phone_number_pattern`: Returns a regex pattern for matching phone numbers.
- `generate_split_sentences_pattern`: Returns a regex pattern to split text into sentences.
- `split_sentences`: Splits the text into sentences using the generated pattern.
- `validate_phone_number`: Validates a phone number using the generated pattern.
- `extract_email`: Extracts email addresses from the text using the generated pattern.",0.080684597,0.096823161,0.755555556,0.23943662,0.36363636,0.525641026,0.155893536,0.240469205,0.755555556,0.23943662,0.36363636,,,,,,,,,,,,
GPT,73,"class RPGCharacter:
    def __init__(self, name, hp, attack_power, defense, level=1):
        self.name = name
        self.hp = hp
        self.attack_power = attack_power
        self.defense = defense
        self.level = level
        self.exp = 0

    def attack(self, other_character):
        damage = max(self.attack_power - other_character.defense, 1)
        other_character.hp -= damage

    def heal(self):
        self.hp += 10
        if self.hp > 100:
            self.hp = 100
        return self.hp

    def gain_exp(self, amount):
        while amount != 0:
            if self.exp + amount >= self.level * 100:
                amount -= (self.level * 100 - self.exp)
                self.level_up()
            else:
                self.exp += amount
                amount = 0

    def level_up(self):
        if self.level < 100:
            self.level += 1
            self.exp = 0
            self.hp += 20
            self.attack_power += 5
            self.defense += 5
        return self.level, self.hp, self.attack_power, self.defense

    def is_alive(self):
        return self.hp > 0",ZeroShot,"```python
class RPGCharacter:
    def __init__(self, name, hp, attack_power, defense, level=1):
        """"""
        Initialize an RPG character object.
        """"""
        self.name = name
        self.hp = hp
        self.max_hp = 100
        self.attack_power = attack_power
        self.defense = defense
        self.level = level
        self.exp = 0

    def attack(self, other_character):
        """"""
        Attack another character. The damage caused needs to offset the defense value.
        """"""
        damage = self.attack_power - other_character.defense
        if damage > 0:
            other_character.hp -= damage
        return other_character.hp

    def heal(self):
        """"""
        Heal the character with 10 hp and the max hp is 100.
        :return: int, the current health points after healing.
        """"""
        self.hp += 10
        if self.hp > self.max_hp:
            self.hp = self.max_hp
        return self.hp

    def gain_exp(self, amount):
        """"""
        Gain experience points for the character and level_up when the exp has reached the value that is 100 times the current level.
        The experience that overflows should be used to calculate the next level up until exhausted.
        """"""
        self.exp += amount
        while self.exp >= 100 * self.level and self.level < 100:
            self.exp -= 100 * self.level
            self.level_up()

    def level_up(self):
        """"""
        Level up the character and return to zero experience points, increase hp by 20 points, attack power and defense points by 5 points.
        Max level is 100.
        :return: tuple[int, int, int, int], the new level, health points, attack power, and defense points after leveling up.
        """"""
        if self.level < 100:
            self.level += 1
            self.hp += 20
            self.attack_power += 5
            self.defense += 5
            if self.hp > self.max_hp:
                self.hp = self.max_hp
            self.exp = 0
        return self.level, self.hp, self.attack_power, self.defense

    def is_alive(self):
        """"""
        Check if player is alive.
        :return: True if the hp is larger than 0, or False otherwise.
        """"""
        return self.hp > 0
```",0.196296296,0.230874454,0.87037037,0.394957983,0.543352597,0.660869565,0.306451613,0.418732778,0.833333333,0.378151261,0.52023121,,,,,,,,,,,,
GPT,74,"class Server:

    def __init__(self):
        self.white_list = []
        self.send_struct = {}
        self.receive_struct = {}

    def add_white_list(self, addr):
        if addr in self.white_list:
            return False
        else:
            self.white_list.append(addr)
            return self.white_list

    def del_white_list(self, addr):
        if addr not in self.white_list:
            return False
        else:
            self.white_list.remove(addr)
            return self.white_list

    def recv(self, info):
        if not isinstance(info, dict) or ""addr"" not in info or ""content"" not in info:
            return -1
        addr = info[""addr""]
        content = info[""content""]
        if addr not in self.white_list:
            return False
        else:
            self.receive_struct = {""addr"": addr, ""content"": content}
            return self.receive_struct[""content""]

    def send(self, info):
        if not isinstance(info, dict) or ""addr"" not in info or ""content"" not in info:
            return ""info structure is not correct""
        self.send_struct = {""addr"": info[""addr""], ""content"": info[""content""]}

    def show(self, type):
        if type == ""send"":
            return self.send_struct
        elif type == ""receive"":
            return self.receive_struct
        else:
            return False",ZeroShot,"```python
class Server:

    def __init__(self):
        """"""
        Initialize the whitelist as an empty list, and initialize the sending and receiving information as an empty dictionary
        """"""
        self.whitelist = []  # List to store whitelisted addresses
        self.sent_info = {}  # Dictionary to store sent information
        self.received_info = {}  # Dictionary to store received information

    def add_white_list(self, addr):
        """"""
        Add an address to the whitelist and do nothing if it already exists
        :return: new whitelist, return False if the address already exists
        """"""
        if addr in self.whitelist:
            return False  # Address already exists in the whitelist
        self.whitelist.append(addr)  # Add address to the whitelist
        return self.whitelist  # Return updated whitelist

    def del_white_list(self, addr):
        """"""
        Remove an address from the whitelist and do nothing if it does not exist
        :return: new whitelist, return False if the address does not exist
        """"""
        if addr not in self.whitelist:
            return False  # Address does not exist in the whitelist
        self.whitelist.remove(addr)  # Remove address from the whitelist
        return self.whitelist  # Return updated whitelist

    def recv(self, info):
        """"""
        Receive information containing address and content. If the address is on the whitelist, receive the content; otherwise, do not receive it
        :return: if successfully received, return the content of the information; otherwise, return False
        """"""
        addr, content = info['address'], info['content']
        if addr in self.whitelist:
            self.received_info[addr] = content  # Store received content
            return content  # Return the received content
        return False  # Address not in whitelist, do not receive

    def send(self, info):
        """"""
        Send information containing address and content
        :return: if successfully sent, return nothing; otherwise, return a string indicating an error message
        """"""
        addr, content = info['address'], info['content']
        if addr in self.whitelist:
            self.sent_info[addr] = content  # Store sent content
            return  # Successfully sent, return nothing
        return ""Error: Address not in whitelist""  # Error message if address not in whitelist

    def show(self, type):
        """"""
        Returns struct of the specified type
        :return: if type is equal to 'send' or 'receive', return the corresponding struct; otherwise, return False
        """"""
        if type == 'send':
            return self.sent_info  # Return sent information
        elif type == 'receive':
            return self.received_info  # Return received information
        return False  # Invalid type, return False
```",0.034285714,0.045461473,0.553571429,0.267241379,0.360465112,0.285714286,0.106557377,0.155223877,0.517857143,0.25,0.337209298,,,,,,,,,,,,
GPT,75,"class ShoppingCart:
    def __init__(self):
        self.items = {}

    def add_item(self, item, price, quantity=1):
        if item in self.items:
            self.items[item] = {'price': price, 'quantity': quantity}
        else:
            self.items[item] = {'price': price, 'quantity': quantity}

    def remove_item(self, item, quantity=1):
        if item in self.items:
            self.items[item]['quantity'] -= quantity
        else:
            pass

    def view_items(self) -> dict:
        return self.items

    def total_price(self) -> float:
        return sum([item['quantity'] * item['price'] for item in self.items.values()])",ZeroShot,"```python
class ShoppingCart:
    def __init__(self):
        """"""
        Initialize the items representing the shopping list as an empty dictionary.
        Each key is an item name, and the value is another dictionary with 'price' and 'quantity'.
        """"""
        self.items = {}

    def add_item(self, item, price, quantity=1):
        """"""
        Add item information to the shopping list items, including price and quantity.
        If the item already exists, update its quantity and price.
        :param item: str, the name of the item
        :param price: float, the price of the item
        :param quantity: int, the quantity of the item to add (default is 1)
        :return: None
        """"""
        if item in self.items:
            # Update existing item's quantity and price
            self.items[item]['quantity'] += quantity
            self.items[item]['price'] = price
        else:
            # Add new item with its price and quantity
            self.items[item] = {'price': price, 'quantity': quantity}

    def remove_item(self, item, quantity=1):
        """"""
        Subtract the specified quantity of item from the shopping list items.
        If the quantity to remove is greater than or equal to the existing quantity, remove the item entirely.
        :param item: str, the name of the item
        :param quantity: int, the quantity of the item to remove (default is 1)
        :return: None
        """"""
        if item in self.items:
            if self.items[item]['quantity'] > quantity:
                # Reduce the quantity of the item
                self.items[item]['quantity'] -= quantity
            else:
                # Remove the item entirely if quantity is less than or equal to the existing quantity
                del self.items[item]

    def view_items(self) -> dict:
        """"""
        Return the current shopping list items.
        :return: dict, the current shopping list items
        """"""
        return self.items

    def total_price(self) -> float:
        """"""
        Calculate the total price of all items in the shopping list.
        This is the sum of each item's price multiplied by its quantity.
        :return: float, the total price of all items in the shopping list
        """"""
        total = 0.0
        for item in self.items.values():
            total += item['price'] * item['quantity']
        return total
```",0.096666667,0.109403293,0.918918919,0.290598291,0.441558438,0.730769231,0.167400881,0.272401431,0.891891892,0.282051282,0.428571425,,,,,,,,,,,,
GPT,76,"class SignInSystem:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username in self.users:
            return False
        else:
            self.users[username] = False
            return True

    def sign_in(self, username):
        if username not in self.users:
            return False
        else:
            self.users[username] = True
            return True

    def check_sign_in(self, username):
        if username not in self.users:
            return False
        else:
            if self.users[username]:
                return True
            else:
                return False

    def all_signed_in(self):
        if all(self.users.values()):
            return True
        else:
            return False

    def all_not_signed_in(self):
        not_signed_in_users = []
        for username, signed_in in self.users.items():
            if not signed_in:
                not_signed_in_users.append(username)
        return not_signed_in_users",ZeroShot,"```python
class SignInSystem:
    def __init__(self):
        """"""
        Initialize the sign-in system with an empty dictionary to hold users and their sign-in status.
        """"""
        self.users = {}

    def add_user(self, username):
        """"""
        Add a user to the sign-in system if the user wasn't in the self.users.
        The initial state is False (not signed in).
        
        :param username: str, the username to add
        :return: bool, True if the user is added successfully, False if the user already exists.
        """"""
        if username not in self.users:
            self.users[username] = False  # Set initial sign-in status to False
            return True
        return False

    def sign_in(self, username):
        """"""
        Sign in a user if the user exists in the self.users and change the state to True.
        
        :param username: str, the username to sign in
        :return: bool, True if the user is signed in successfully, False if the user does not exist.
        """"""
        if username in self.users:
            self.users[username] = True  # Change sign-in status to True
            return True
        return False

    def check_sign_in(self, username):
        """"""
        Check if a user is signed in.
        
        :param username: str, the username to check
        :return: bool, True if the user is signed in, False if the user does not exist or is not signed in.
        """"""
        return self.users.get(username, False)

    def all_signed_in(self):
        """"""
        Check if all users are signed in.
        
        :return: bool, True if all users are signed in, False otherwise.
        """"""
        return all(self.users.values())

    def all_not_signed_in(self):
        """"""
        Get a list of usernames that are not signed in.
        
        :return: list[str], a list of usernames that are not signed in.
        """"""
        return [username for username, signed_in in self.users.items() if not signed_in]
```",0.081395349,0.09677349,0.771428571,0.296703297,0.428571425,0.564516129,0.203488372,0.299145295,0.771428571,0.296703297,0.428571425,,,,,,,,,,,,
GPT,77,"import random


class Snake:
    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):
        self.length = 1
        self.SCREEN_WIDTH = SCREEN_WIDTH
        self.SCREEN_HEIGHT = SCREEN_HEIGHT
        self.BLOCK_SIZE = BLOCK_SIZE
        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]
        self.score = 0
        self.food_position = food_position

    def move(self, direction):
        cur = self.positions[0]
        x, y = direction

        new = (
            ((cur[0] + (x * self.BLOCK_SIZE)) % self.SCREEN_WIDTH),
            (cur[1] + (y * self.BLOCK_SIZE)) % self.SCREEN_HEIGHT,
        )

        if new == self.food_position:
            self.eat_food()

        if len(self.positions) > 2 and new in self.positions[2:]:
            self.reset()
        else:
            self.positions.insert(0, new)
            if len(self.positions) > self.length:
                self.positions.pop()

    def random_food_position(self):
        while self.food_position in self.positions:
            self.food_position = (random.randint(0, self.SCREEN_WIDTH // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE,
                                  random.randint(0, self.SCREEN_HEIGHT // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE)

    def reset(self):
        self.length = 1
        self.positions = [((self.SCREEN_WIDTH / 2), (self.SCREEN_HEIGHT / 2))]
        self.score = 0
        self.random_food_position()

    def eat_food(self):
        self.length += 1
        self.score += 100
        self.random_food_position()",ZeroShot,"```python
class Snake:
    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):
        """"""
        Initialize the length of the snake, screen width, screen height, block size, snake head position, score, and food position.
        """"""
        self.SCREEN_WIDTH = SCREEN_WIDTH
        self.SCREEN_HEIGHT = SCREEN_HEIGHT
        self.BLOCK_SIZE = BLOCK_SIZE
        self.snake_body = [(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)]
        self.direction = (0, 0)  # Initial direction is stationary
        self.food_position = food_position
        self.score = 0

    def move(self, direction):
        """"""
        Move the snake in the specified direction. If the new position of the snake's head is equal to the position of the food, then eat the food; If the position of the snake's head is equal to the position of its body, then start over, otherwise its own length plus one.
        :return: None
        """"""
        # Update the direction
        self.direction = direction

        # Calculate new head position
        head_x, head_y = self.snake_body[0]
        delta_x, delta_y = self.direction
        new_head = (head_x + delta_x * self.BLOCK_SIZE, head_y + delta_y * self.BLOCK_SIZE)

        # Check if new head position is the food position
        if new_head == self.food_position:
            self.eat_food()
        else:
            # Move the snake by removing the tail
            self.snake_body.pop()

        # Check if new head position is on the snake body (collision with itself)
        if new_head in self.snake_body:
            self.reset()
        else:
            # Add new head to the snake body
            self.snake_body.insert(0, new_head)

    def random_food_position(self):
        """"""
        Randomly generate a new food position, but don't place it on the snake.
        :return: None, Change the food position
        """"""
        while True:
            x = random.randint(0, (self.SCREEN_WIDTH // self.BLOCK_SIZE) - 1) * self.BLOCK_SIZE
            y = random.randint(0, (self.SCREEN_HEIGHT // self.BLOCK_SIZE) - 1) * self.BLOCK_SIZE
            new_food_position = (x, y)
            if new_food_position not in self.snake_body:
                self.food_position = new_food_position
                break

    def reset(self):
        """"""
        Reset the snake to its initial state. Set the length to 1, the snake head position to ((SCREEN_WIDTH/2), (SCREEN_HEIGHT/2)), the score to 0, and randomly generate new food position.
        :return: None
        """"""
        self.snake_body = [(self.SCREEN_WIDTH // 2, self.SCREEN_HEIGHT // 2)]
        self.direction = (0, 0)
        self.score = 0
        self.random_food_position()

    def eat_food(self):
        """"""
        Increase the length of the snake by 1 and increase the score by 100. Randomly generate a new food position, but
        don't place it on the snake.
        :return: None
        """"""
        # Increase the length of the snake (by not removing the tail)
        self.snake_body.append(self.snake_body[-1])  # Add a new block at the tail position

        # Increase the score
        self.score += 100

        # Generate a new food position
        self.random_food_position()
```",0.0625,0.087332943,0.628205128,0.320261438,0.42424242,0.408759124,0.188552189,0.258064512,0.628205128,0.320261438,0.42424242,,,,,,,,,,,,
GPT,78,"import re


class SplitSentence:

    def split_sentences(self, sentences_string):
        sentences = re.split(r'(?<!\w\.\w.)(?<![A-Z][a-z]\.)(?<=\.|\?)\s', sentences_string)
        return sentences

    def count_words(self, sentence):
        sentence = re.sub(r'[^a-zA-Z\s]', '', sentence)
        words = sentence.split()
        return len(words)

    def process_text_file(self, sentences_string):
        sentences = self.split_sentences(sentences_string)
        max_count = 0
        for sentence in sentences:
            count = self.count_words(sentence)
            if count > max_count:
                max_count = count

        return max_count",ZeroShot,"```python
import re

class SplitSentence:

    def split_sentences(self, sentences_string):
        """"""
        Split a string into a list of sentences. Sentences end with . or ? and with a space after that. 
        Please note that Mr. also ends with . but are not sentences.
        :param sentences_string: str, the text to split into sentences
        :return: list, split sentence list
        """"""
        # Use regex to split the text into sentences, handling abbreviations like ""Mr.""
        # Sentences end with . or ? followed by a space, but exclude common abbreviations.
        sentence_pattern = r'(?<!\bMr)(?<!\bMrs)(?<!\bMs)(?<!\bDr)(?<!\bJr)(?<!\bSr)(?<!\bProf)(?<!\bInc)(?<!\bLtd)(?<!\bCo)(?<=[.!?]) +'
        sentences = re.split(sentence_pattern, sentences_string)
        return [sentence.strip() for sentence in sentences if sentence.strip()]

    def count_words(self, sentence):
        """"""
        Count the number of words in a sentence. Note that words are separated by spaces and that punctuation marks 
        and numbers are not counted as words.
        :param sentence: str, the sentence to count words in
        :return: int, number of words in the sentence
        """"""
        # Use regex to find all words, excluding punctuation and numbers
        words = re.findall(r'\b[A-Za-z]+\b', sentence)
        return len(words)

    def process_text_file(self, sentences_string):
        """"""
        Given a text, return the number of words in the longest sentence
        :param sentences_string: str, the text to process
        :return: int, the number of words in the longest sentence
        """"""
        # Split the text into sentences
        sentences = self.split_sentences(sentences_string)
        # Calculate the word count for each sentence and find the maximum
        max_word_count = max(self.count_words(sentence) for sentence in sentences)
        return max_word_count
```",0.048245614,0.063792409,0.657894737,0.227272727,0.337837834,0.37037037,0.106382979,0.165289253,0.657894737,0.227272727,0.337837834,,,,,,,,,,,,
GPT,79,"class SQLGenerator:
    def __init__(self, table_name):
        self.table_name = table_name

    def select(self, fields=None, condition=None):
        if fields is None:
            fields = ""*""
        else:
            fields = "", "".join(fields)
        sql = f""SELECT {fields} FROM {self.table_name}""
        if condition is not None:
            sql += f"" WHERE {condition}""
        return sql + "";""

    def insert(self, data):
        fields = "", "".join(data.keys())
        values = "", "".join([f""'{value}'"" for value in data.values()])
        sql = f""INSERT INTO {self.table_name} ({fields}) VALUES ({values})""
        return sql + "";""

    def update(self, data, condition):
        set_clause = "", "".join([f""{field} = '{value}'"" for field, value in data.items()])
        sql = f""UPDATE {self.table_name} SET {set_clause} WHERE {condition}""
        return sql + "";""

    def delete(self, condition):
        sql = f""DELETE FROM {self.table_name} WHERE {condition}""
        return sql + "";""

    def select_female_under_age(self, age):
        condition = f""age < {age} AND gender = 'female'""
        return self.select(condition=condition)

    def select_by_age_range(self, min_age, max_age):
        condition = f""age BETWEEN {min_age} AND {max_age}""
        return self.select(condition=condition)",ZeroShot,"```python
class SQLGenerator:
    def __init__(self, table_name):
        """"""
        Initialize the table name.
        """"""
        self.table_name = table_name

    def select(self, fields=None, condition=None):
        """"""
        Generates a SELECT SQL statement based on the specified fields and conditions.
        :return: str. The generated SQL statement.
        """"""
        fields_part = ', '.join(fields) if fields else '*'
        condition_part = f"" WHERE {condition}"" if condition else ''
        return f""SELECT {fields_part} FROM {self.table_name}{condition_part};""

    def insert(self, data):
        """"""
        Generates an INSERT SQL statement based on the given data.
        :return: str. The generated SQL statement.
        """"""
        columns = ', '.join(data.keys())
        values = ', '.join(f""'{value}'"" for value in data.values())
        return f""INSERT INTO {self.table_name} ({columns}) VALUES ({values});""

    def update(self, data, condition):
        """"""
        Generates an UPDATE SQL statement based on the given data and condition.
        :return: str. The generated SQL statement.
        """"""
        set_part = ', '.join(f""{key} = '{value}'"" for key, value in data.items())
        condition_part = f"" WHERE {condition}"" if condition else ''
        return f""UPDATE {self.table_name} SET {set_part}{condition_part};""

    def delete(self, condition):
        """"""
        Generates a DELETE SQL statement based on the given condition.
        :return: str. The generated SQL statement.
        """"""
        condition_part = f"" WHERE {condition}"" if condition else ''
        return f""DELETE FROM {self.table_name}{condition_part};""

    def select_female_under_age(self, age):
        """"""
        Generates a SQL statement to select females under a specified age.
        :return: str. The generated SQL statement.
        """"""
        return f""SELECT * FROM {self.table_name} WHERE gender = 'female' AND age < {age};""

    def select_by_age_range(self, min_age, max_age):
        """"""
        Generates a SQL statement to select records within a specified age range.
        :return: str. The generated SQL statement.
        """"""
        return f""SELECT * FROM {self.table_name} WHERE age BETWEEN {min_age} AND {max_age};""
```

- The `__init__` method initializes the class with the table name.
- The `select` method constructs a SELECT SQL statement, allowing for specific fields and optional conditions.
- The `insert` method constructs an INSERT SQL statement using the provided data dictionary.
- The `update` method constructs an UPDATE SQL statement using the provided data dictionary and condition.
- The `delete` method constructs a DELETE SQL statement using the provided condition.
- The `select_female_under_age` method constructs a SELECT statement to fetch records of females under a specified age.
- The `select_by_age_range` method constructs a SELECT statement to fetch records within a specified age range.",0.061797753,0.079898508,0.6625,0.404580153,0.502369664,0.396551724,0.216981132,0.2804878,0.65,0.396946565,0.492890991,,,,,,,,,,,,
GPT,80,"class SQLQueryBuilder:

    @staticmethod
    def select(table, columns='*', where=None):
        if columns != '*':
            columns = ', '.join(columns)
        query = f""SELECT {columns} FROM {table}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query

    @staticmethod
    def insert(table, data):
        keys = ', '.join(data.keys())
        values = ', '.join(f""'{v}'"" for v in data.values())
        return f""INSERT INTO {table} ({keys}) VALUES ({values})""

    @staticmethod
    def delete(table, where=None):
        query = f""DELETE FROM {table}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query

    @staticmethod
    def update(table, data, where=None):
        update_str = ', '.join(f""{k}='{v}'"" for k, v in data.items())
        query = f""UPDATE {table} SET {update_str}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query",ZeroShot,"```python
class SQLQueryBuilder:

    @staticmethod
    def select(table, columns='*', where=None):
        """"""
        Generate the SELECT SQL statement from the given parameters.
        :param table: str, the name of the table.
        :param columns: list or str, the columns to select.
        :param where: str, the WHERE clause.
        :return query: str, the SQL query statement.
        """"""
        # Convert columns to a comma-separated string if it's a list
        if isinstance(columns, list):
            columns = ', '.join(columns)
        
        # Start building the query
        query = f""SELECT {columns} FROM {table}""
        
        # Add the WHERE clause if provided
        if where:
            query += f"" WHERE {where}""
        
        return query

    @staticmethod
    def insert(table, data):
        """"""
        Generate the INSERT SQL statement from the given parameters.
        :param table: str, the name of the table.
        :param data: dict, the data to insert (column-value pairs).
        :return query: str, the SQL insert statement.
        """"""
        # Extract columns and values from the data dictionary
        columns = ', '.join(data.keys())
        values = ', '.join(f""'{v}'"" for v in data.values())
        
        # Build the insert query
        query = f""INSERT INTO {table} ({columns}) VALUES ({values})""
        
        return query

    @staticmethod
    def delete(table, where=None):
        """"""
        Generate the DELETE SQL statement from the given parameters.
        :param table: str, the name of the table.
        :param where: str, the WHERE clause.
        :return query: str, the SQL delete statement.
        """"""
        # Start building the delete query
        query = f""DELETE FROM {table}""
        
        # Add the WHERE clause if provided
        if where:
            query += f"" WHERE {where}""
        
        return query

    @staticmethod
    def update(table, data, where=None):
        """"""
        Generate the UPDATE SQL statement from the given parameters.
        :param table: str, the name of the table.
        :param data: dict, the data to update (column-value pairs).
        :param where: str, the WHERE clause.
        :return query: str, the SQL update statement.
        """"""
        # Create the SET part of the query from the data dictionary
        set_clause = ', '.join(f""{k}='{v}'"" for k, v in data.items())
        
        # Start building the update query
        query = f""UPDATE {table} SET {set_clause}""
        
        # Add the WHERE clause if provided
        if where:
            query += f"" WHERE {where}""
        
        return query
```

- The `select` method constructs a SELECT statement, optionally including a WHERE clause.
- The `insert` method constructs an INSERT statement using a dictionary for column-value pairs.
- The `delete` method constructs a DELETE statement, optionally including a WHERE clause.
- The `update` method constructs an UPDATE statement using a dictionary for column-value pairs, optionally including a WHERE clause.",0.12987013,0.148334503,0.824561404,0.388429752,0.528089883,0.625,0.236966825,0.343642608,0.824561404,0.388429752,0.528089883,,,,,,,,,,,,
GPT,81,"import math
class Statistics3:
    @staticmethod
    def median(data):
        sorted_data = sorted(data)
        n = len(sorted_data)
        if n % 2 == 1:
            return sorted_data[n // 2]
        else:
            return (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2

    @staticmethod
    def mode(data):
        counts = {}
        for value in data:
            counts[value] = counts.get(value, 0) + 1
        max_count = max(counts.values())
        mode_values = [value for value, count in counts.items() if count == max_count]
        return mode_values

    @staticmethod
    def correlation(x, y):
        n = len(x)
        mean_x = sum(x) / n
        mean_y = sum(y) / n
        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))
        denominator = math.sqrt(sum((xi - mean_x) ** 2 for xi in x) * sum((yi - mean_y) ** 2 for yi in y))
        if denominator == 0:
            return None
        return numerator / denominator

    @staticmethod
    def mean(data):
        if len(data) == 0:
            return None
        return sum(data) / len(data)

    @staticmethod
    def correlation_matrix(data):
        matrix = []
        for i in range(len(data[0])):
            row = []
            for j in range(len(data[0])):
                column1 = [row[i] for row in data]
                column2 = [row[j] for row in data]
                correlation = Statistics3.correlation(column1, column2)
                row.append(correlation)
            matrix.append(row)
        return matrix

    @staticmethod
    def standard_deviation(data):
        n = len(data)
        if n < 2:
            return None
        mean_value = Statistics3.mean(data)
        variance = sum((x - mean_value) ** 2 for x in data) / (n - 1)
        return math.sqrt(variance)

    @staticmethod
    def z_score(data):
        mean = Statistics3.mean(data)
        std_deviation = Statistics3.standard_deviation(data)
        if std_deviation is None or std_deviation == 0:
            return None
        return [(x - mean) / std_deviation for x in data]",ZeroShot,"```python
import math
from collections import Counter

class Statistics3:
    @staticmethod
    def median(data):
        """"""
        calculates the median of the given list.
        :return: the median of the given list, float.
        """"""
        sorted_data = sorted(data)
        n = len(sorted_data)
        mid = n // 2
        if n % 2 == 0:
            # If even, return the average of the middle two numbers
            return (sorted_data[mid - 1] + sorted_data[mid]) / 2
        else:
            # If odd, return the middle number
            return sorted_data[mid]

    @staticmethod
    def mode(data):
        """"""
        calculates the mode of the given list.
        :return: the mode of the given list, list.
        """"""
        count = Counter(data)
        max_count = max(count.values())
        return [k for k, v in count.items() if v == max_count]

    @staticmethod
    def correlation(x, y):
        """"""
        calculates the correlation of the given list.
        :return: the correlation of the given list, float.
        """"""
        n = len(x)
        if n != len(y):
            raise ValueError(""Lists must have the same length"")
        
        mean_x = Statistics3.mean(x)
        mean_y = Statistics3.mean(y)
        
        numerator = sum((x[i] - mean_x) * (y[i] - mean_y) for i in range(n))
        denominator = math.sqrt(sum((x[i] - mean_x) ** 2 for i in range(n)) * sum((y[i] - mean_y) ** 2 for i in range(n)))
        
        if denominator == 0:
            return 0
        
        return numerator / denominator

    @staticmethod
    def mean(data):
        """"""
        calculates the mean of the given list.
        :return: the mean of the given list, float.
        """"""
        return sum(data) / len(data)

    @staticmethod
    def correlation_matrix(data):
        """"""
        calculates the correlation matrix of the given list.
        :return: the correlation matrix of the given list, list.
        """"""
        size = len(data)
        matrix = [[0] * size for _ in range(size)]
        
        for i in range(size):
            for j in range(size):
                if i == j:
                    matrix[i][j] = 1
                else:
                    matrix[i][j] = Statistics3.correlation(data[i], data[j])
        
        return matrix

    @staticmethod
    def standard_deviation(data):
        """"""
        calculates the standard deviation of the given list.
        :return: the standard deviation of the given list, float.
        """"""
        mean_value = Statistics3.mean(data)
        variance = sum((x - mean_value) ** 2 for x in data) / len(data)
        return math.sqrt(variance)

    @staticmethod
    def z_score(data):
        """"""
        calculates the z-score of the given list.
        :return: the z-score of the given list, list.
        """"""
        mean_value = Statistics3.mean(data)
        std_dev = Statistics3.standard_deviation(data)
        
        if std_dev == 0:
            return [0] * len(data)
        
        return [(x - mean_value) / std_dev for x in data]
```

This implementation provides the methods to compute the median, mode, correlation, mean, correlation matrix, standard deviation, and Z-scores for a given dataset. Each method has been implemented as a static method, allowing them to be called without creating an instance of the class.",0.153846154,0.196174233,0.582608696,0.408536585,0.480286734,0.386046512,0.295373665,0.334677414,0.547826087,0.384146341,0.451612898,,,,,,,,,,,,
GPT,82,"class StockPortfolioTracker:
    def __init__(self, cash_balance):
        self.portfolio = []
        self.cash_balance = cash_balance

    def add_stock(self, stock):
        for pf in self.portfolio:
            if pf['name'] == stock['name']:
                pf['quantity'] += stock['quantity']
                return

        self.portfolio.append(stock)

    def remove_stock(self, stock):
        for pf in self.portfolio:
            if pf['name'] == stock['name'] and pf['quantity'] >= stock['quantity']:
                pf['quantity'] -= stock['quantity']
                if pf['quantity'] == 0:
                    self.portfolio.remove(pf)
                return True
        return False

    def buy_stock(self, stock):
        if stock['price'] * stock['quantity'] > self.cash_balance:
            return False
        else:
            self.add_stock(stock)
            self.cash_balance -= stock['price'] * stock['quantity']
            return True

    def sell_stock(self, stock):
        if self.remove_stock(stock) == False:
            return False
        self.cash_balance += stock['price'] * stock['quantity']
        return True

    def calculate_portfolio_value(self):
        total_value = self.cash_balance
        for stock in self.portfolio:
            total_value += stock['price'] * stock['quantity']
        return total_value

    def get_portfolio_summary(self):
        summary = []
        for stock in self.portfolio:
            value = self.get_stock_value(stock)
            summary.append({""name"": stock[""name""], ""value"": value})
        portfolio_value = self.calculate_portfolio_value()
        return portfolio_value, summary

    def get_stock_value(self, stock):
        return stock['price'] * stock['quantity']",ZeroShot,"```python
class StockPortfolioTracker:
    def __init__(self, cash_balance):
        """"""
        Initialize the StockPortfolioTracker class with a cash balance and an empty portfolio.
        """"""
        self.cash_balance = cash_balance
        self.portfolio = {}  # Dictionary to store stocks with their quantities

    def add_stock(self, stock):
        """"""
        Add a stock to the portfolio.
        """"""
        if stock['name'] not in self.portfolio:
            self.portfolio[stock['name']] = {'quantity': 0, 'price': stock['price']}
        else:
            self.portfolio[stock['name']]['price'] = stock['price']

    def remove_stock(self, stock):
        """"""
        Remove a stock from the portfolio.
        """"""
        if stock['name'] in self.portfolio:
            del self.portfolio[stock['name']]

    def buy_stock(self, stock):
        """"""
        Buy a stock and add it to the portfolio.
        :return: True if the stock was bought successfully, False if the cash balance is not enough.
        """"""
        cost = stock['price'] * stock['quantity']
        if self.cash_balance >= cost:
            if stock['name'] in self.portfolio:
                self.portfolio[stock['name']]['quantity'] += stock['quantity']
            else:
                self.portfolio[stock['name']] = {'quantity': stock['quantity'], 'price': stock['price']}
            self.cash_balance -= cost
            return True
        return False

    def sell_stock(self, stock):
        """"""
        Sell a stock and remove it from the portfolio and add the cash to the cash balance.
        :return: True if the stock was sold successfully, False if the quantity of the stock is not enough.
        """"""
        if stock['name'] in self.portfolio and self.portfolio[stock['name']]['quantity'] >= stock['quantity']:
            self.portfolio[stock['name']]['quantity'] -= stock['quantity']
            self.cash_balance += stock['price'] * stock['quantity']
            if self.portfolio[stock['name']]['quantity'] == 0:
                del self.portfolio[stock['name']]
            return True
        return False

    def calculate_portfolio_value(self):
        """"""
        Calculate the total value of the portfolio.
        :return: the total value of the portfolio, float.
        """"""
        total_value = self.cash_balance
        for stock in self.portfolio.values():
            total_value += stock['quantity'] * stock['price']
        return total_value

    def get_portfolio_summary(self):
        """"""
        Get a summary of the portfolio.
        :return: a tuple of the total value of the portfolio and a list of dictionaries with keys ""name"" and ""value""
        """"""
        summary = []
        for stock_name, stock_data in self.portfolio.items():
            stock_value = stock_data['quantity'] * stock_data['price']
            summary.append({'name': stock_name, 'value': stock_value})
        total_value = self.calculate_portfolio_value()
        return total_value, summary

    def get_stock_value(self, stock):
        """"""
        Get the value of a stock.
        :return: the value of the stock, float.
        """"""
        if stock['name'] in self.portfolio:
            return self.portfolio[stock['name']]['quantity'] * self.portfolio[stock['name']]['price']
        return 0.0
```",0.082278481,0.114640655,0.7,0.365217391,0.479999995,0.477876106,0.230769231,0.311239189,0.7,0.365217391,0.479999995,,,,,,,,,,,,
GPT,83,"import sqlite3


class StudentDatabaseProcessor:

    def __init__(self, database_name):
        self.database_name = database_name

    def create_student_table(self):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        create_table_query = """"""
        CREATE TABLE IF NOT EXISTS students (
            id INTEGER PRIMARY KEY,
            name TEXT,
            age INTEGER,
            gender TEXT,
            grade INTEGER
        )
        """"""
        cursor.execute(create_table_query)

        conn.commit()
        conn.close()

    def insert_student(self, student_data):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        insert_query = """"""
        INSERT INTO students (name, age, gender, grade)
        VALUES (?, ?, ?, ?)
        """"""
        cursor.execute(insert_query,
                       (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))

        conn.commit()
        conn.close()

    def search_student_by_name(self, name):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        select_query = ""SELECT * FROM students WHERE name = ?""
        cursor.execute(select_query, (name,))
        result = cursor.fetchall()

        conn.close()

        return result

    def delete_student_by_name(self, name):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        delete_query = ""DELETE FROM students WHERE name = ?""
        cursor.execute(delete_query, (name,))

        conn.commit()
        conn.close()",ZeroShot,"```python
import sqlite3

class StudentDatabaseProcessor:
    def __init__(self, database_name):
        """"""
        Initializes the StudentDatabaseProcessor object with the specified database name.
        """"""
        self.database_name = database_name
        self.connection = sqlite3.connect(self.database_name)
        self.cursor = self.connection.cursor()

    def create_student_table(self):
        """"""
        Creates a ""students"" table in the database if it does not exist already.
        Fields include ID of type int, name of type str, age of type int, gender of type str, and grade of type int
        :return: None
        """"""
        create_table_query = """"""
        CREATE TABLE IF NOT EXISTS students (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            age INTEGER,
            gender TEXT,
            grade INTEGER
        );
        """"""
        self.cursor.execute(create_table_query)
        self.connection.commit()

    def insert_student(self, student_data):
        """"""
        Inserts a new student into the ""students"" table.
        :param student_data: tuple containing (name, age, gender, grade)
        :return: None
        """"""
        insert_query = """"""
        INSERT INTO students (name, age, gender, grade)
        VALUES (?, ?, ?, ?);
        """"""
        self.cursor.execute(insert_query, student_data)
        self.connection.commit()

    def search_student_by_name(self, name):
        """"""
        Searches for a student in the ""students"" table by their name.
        :param name: str, name of the student to search for
        :return: list of tuples, the rows from the ""students"" table that match the search criteria.
        """"""
        search_query = """"""
        SELECT * FROM students WHERE name = ?;
        """"""
        self.cursor.execute(search_query, (name,))
        return self.cursor.fetchall()

    def delete_student_by_name(self, name):
        """"""
        Deletes a student from the ""students"" table by their name.
        :param name: str, name of the student to delete
        :return: None
        """"""
        delete_query = """"""
        DELETE FROM students WHERE name = ?;
        """"""
        self.cursor.execute(delete_query, (name,))
        self.connection.commit()

    def __del__(self):
        """"""
        Destructor to close the database connection when the object is deleted.
        """"""
        self.connection.close()
```

- The `__init__` method initializes the database connection and creates a cursor for executing SQL commands.
- The `create_student_table` method creates the ""students"" table with fields for id, name, age, gender, and grade.
- The `insert_student` method inserts a new student record into the ""students"" table.
- The `search_student_by_name` method retrieves student records that match the given name.
- The `delete_student_by_name` method deletes student records that match the given name.
- The `__del__` method ensures that the database connection is closed when the object is destroyed.",0.126843658,0.146970047,0.810810811,0.375,0.512820508,0.550458716,0.222222222,0.316622687,0.810810811,0.375,0.512820508,,,,,,,,,,,,
GPT,84,"import json


class TextFileProcessor:
    def __init__(self, file_path):
        self.file_path = file_path

    def read_file_as_json(self):
        with open(self.file_path, 'r') as file:
            data = json.load(file)

        return data

    def read_file(self):
        with open(self.file_path, 'r') as file:
            return file.read()

    def write_file(self, content):
        with open(self.file_path, 'w') as file:
            file.write(content)

    def process_file(self):
        content = self.read_file()
        content = ''.join([char for char in content if char.isalpha()])
        self.write_file(content)
        return content",ZeroShot,"```python
import json

class TextFileProcessor:
    def __init__(self, file_path):
        """"""
        Initialize the file path.
        """"""
        self.file_path = file_path

    def read_file_as_json(self):
        """"""
        Read the self.file_path file as json format.
        if the file content doesn't obey json format, the code will raise error.
        :return data: dict if the file is stored as json format, or str/int/float.. according to the file content otherwise.
        """"""
        with open(self.file_path, 'r', encoding='utf-8') as file:
            data = json.load(file)
        return data

    def read_file(self):
        """"""
        Read the return the content of self.file_path file.
        :return: the same return as the read() method
        """"""
        with open(self.file_path, 'r', encoding='utf-8') as file:
            content = file.read()
        return content

    def write_file(self, content):
        """"""
        Write content into the self.file_path file, and overwrite if the file has already existed.
        :param content: any content
        """"""
        with open(self.file_path, 'w', encoding='utf-8') as file:
            file.write(content)

    def process_file(self):
        """"""
        Read the self.file_path file and filter out non-alphabetic characters from the content string.
        Overwrite the after-processed data into the same self.file_path file.
        """"""
        content = self.read_file()
        # Filter out non-alphabetic characters
        processed_content = ''.join(filter(str.isalpha, content))
        # Write the processed content back to the file
        self.write_file(processed_content)
```

- The `__init__` method initializes the file path for the object.
- The `read_file_as_json` method reads the file content as JSON and returns it.
- The `read_file` method reads and returns the raw content of the file.
- The `write_file` method writes content to the file, overwriting any existing content.
- The `process_file` method filters out non-alphabetic characters from the file content and writes the processed content back to the file.",0.08,0.10275965,0.815789474,0.28440367,0.421768704,0.586206897,0.170854271,0.264591436,0.815789474,0.28440367,0.421768704,,,,,,,,,,,,
GPT,85,"import time

class Thermostat:
    def __init__(self, current_temperature, target_temperature, mode):
        self.current_temperature = current_temperature
        self.target_temperature = target_temperature
        self.mode = mode

    def get_target_temperature(self):
        return self.target_temperature

    def set_target_temperature(self, temperature):
        self.target_temperature = temperature

    def get_mode(self):
        return self.mode

    def set_mode(self, mode):
        if mode in ['heat', 'cool']:
            self.mode = mode
        else:
            return False

    def auto_set_mode(self):
        if self.current_temperature < self.target_temperature:
            self.mode = 'heat'
        else:
            self.mode = 'cool'

    def auto_check_conflict(self):
        if self.current_temperature > self.target_temperature:
            if self.mode == 'cool':
                return True
            else:
                self.auto_set_mode()
                return False
        else:
            if self.mode == 'heat':
                return True
            else:
                self.auto_set_mode()
                return False

    def simulate_operation(self):
        self.auto_set_mode()
        use_time = 0
        if self.mode == 'heat':
            while(self.current_temperature < self.target_temperature):
                self.current_temperature += 1
                use_time += 1
        else:
            while(self.current_temperature > self.target_temperature):
                self.current_temperature -= 1
                use_time += 1
        return use_time",ZeroShot,"```python
import time

class Thermostat:
    def __init__(self, current_temperature, target_temperature, mode):
        """"""
        Initialize instances of the Thermostat class, including the current temperature, 
        target temperature, and operating mode.
        """"""
        self.current_temperature = current_temperature
        self.target_temperature = target_temperature
        self.mode = mode

    def get_target_temperature(self):
        """"""
        Get the target temperature of an instance of the Thermostat class.
        :return self.target_temperature: int
        """"""
        return self.target_temperature

    def set_target_temperature(self, temperature):
        """"""
        Set the target temperature.
        """"""
        self.target_temperature = temperature

    def get_mode(self):
        """"""
        Get the current work mode.
        :return mode: str, working mode. only ['heat', 'cool']
        """"""
        return self.mode

    def set_mode(self, mode):
        """"""
        Set the current work mode.
        """"""
        if mode in ['heat', 'cool']:
            self.mode = mode

    def auto_set_mode(self):
        """"""
        Automatically set the operating mode by comparing with the current temperature 
        and target temperature. If the current temperature is lower than the target 
        temperature, the operating mode is set to 'heat', otherwise it is set to 'cool'.
        """"""
        if self.current_temperature < self.target_temperature:
            self.mode = 'heat'
        else:
            self.mode = 'cool'

    def auto_check_conflict(self):
        """"""
        Check if there is a conflict between the operating mode and the relationship 
        between the current temperature and the target temperature.
        If there is a conflict, the operating mode will be adjusted automatically.
        :return: True if mode isn't conflict with the relationship between the current 
        temperature and the target temperature, or False otherwise.
        """"""
        if (self.current_temperature < self.target_temperature and self.mode == 'heat') or \
           (self.current_temperature > self.target_temperature and self.mode == 'cool'):
            return True
        else:
            self.auto_set_mode()
            return False

    def simulate_operation(self):
        """"""
        Simulate the operation of Thermostat. It will automatically start the auto_set_mode 
        method to set the operating mode, and then automatically adjust the current temperature 
        according to the operating mode until the target temperature is reached.
        :return time: int, the time it took to complete the simulation.
        """"""
        start_time = time.time()
        self.auto_set_mode()
        
        while self.current_temperature != self.target_temperature:
            if self.mode == 'heat':
                self.current_temperature += 1
            elif self.mode == 'cool':
                self.current_temperature -= 1
            
            # Simulate time passing
            time.sleep(1)
        
        end_time = time.time()
        return int(end_time - start_time)
```",0.16875,0.192014195,0.914893617,0.330769231,0.485875702,0.695652174,0.258064516,0.376470584,0.914893617,0.330769231,0.485875702,,,,,,,,,,,,
GPT,86,"class TicTacToe:
    def __init__(self, N=3):
        self.board = [[' ' for _ in range(N)] for _ in range(3)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        else:
            return False

    def check_winner(self):
        for row in self.board:
            if row[0] == row[1] == row[2] != ' ':
                return row[0]
        for col in range(3):
            if self.board[0][col] == self.board[1][col] == self.board[2][col] != ' ':
                return self.board[0][col]
        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':
            return self.board[0][0]
        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':
            return self.board[0][2]
        return None

    def is_board_full(self):
        for row in self.board:
            if ' ' in row:
                return False
        return True",ZeroShot,"```python
class TicTacToe:
    def __init__(self, N=3):
        """"""
        Initialize a 3x3 game board with all empty spaces and current player symbol, default is 'X'.
        """"""
        self.board = [[' ' for _ in range(N)] for _ in range(3)]
        self.current_player = 'X'

    def make_move(self, row, col):
        """"""
        Place the current player's mark at the specified position on the board and switch the mark.
        :param row: int, the row index for the move
        :param col: int, the column index for the move
        :return: bool, indicating whether the move was successful or not
        """"""
        if self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            # Switch the current player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        else:
            return False

    def check_winner(self):
        """"""
        Check if there is a winner on the board in rows, columns, and diagonals.
        :return: str or None, the mark of the winner ('X' or 'O'), or None if there is no winner yet
        """"""
        # Check rows for a winner
        for row in self.board:
            if row[0] == row[1] == row[2] != ' ':
                return row[0]

        # Check columns for a winner
        for col in range(3):
            if self.board[0][col] == self.board[1][col] == self.board[2][col] != ' ':
                return self.board[0][col]

        # Check diagonals for a winner
        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':
            return self.board[0][0]
        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':
            return self.board[0][2]

        # No winner found
        return None

    def is_board_full(self):
        """"""
        Check if the game board is completely filled.
        :return: bool, indicating whether the game board is full or not
        """"""
        for row in self.board:
            for cell in row:
                if cell == ' ':
                    return False
        return True
```",0.342007435,0.361550687,1,0.442477876,0.613496928,0.87628866,0.391705069,0.54140127,1,0.442477876,0.613496928,,,,,,,,,,,,
GPT,87,"import datetime
import time

class TimeUtils:

    def __init__(self):
        self.datetime = datetime.datetime.now()

    def get_current_time(self):
        format = ""%H:%M:%S""
        return self.datetime.strftime(format)

    def get_current_date(self):
        format = ""%Y-%m-%d""
        return self.datetime.strftime(format)

    def add_seconds(self, seconds):
        new_datetime = self.datetime + datetime.timedelta(seconds=seconds)
        format = ""%H:%M:%S""
        return new_datetime.strftime(format)

    def string_to_datetime(self, string):
        return datetime.datetime.strptime(string, ""%Y-%m-%d %H:%M:%S"")

    def datetime_to_string(self, datetime):
        return datetime.strftime(""%Y-%m-%d %H:%M:%S"")

    def get_minutes(self, string_time1, string_time2):
        time1 = self.string_to_datetime(string_time1)
        time2 = self.string_to_datetime(string_time2)
        return round((time2 - time1).seconds / 60)

    def get_format_time(self, year, month, day, hour, minute, second):
        format = ""%Y-%m-%d %H:%M:%S""
        time_item = datetime.datetime(year, month, day, hour, minute, second)
        return time_item.strftime(format)",ZeroShot,"```python
import datetime
import time

class TimeUtils:

    def __init__(self):
        """"""
        Initialize the TimeUtils class and get the current datetime.
        """"""
        self.current_datetime = datetime.datetime.now()

    def get_current_time(self):
        """"""
        Return the current time in the format of '%H:%M:%S'.
        :return: string
        """"""
        return self.current_datetime.strftime('%H:%M:%S')

    def get_current_date(self):
        """"""
        Return the current date in the format of ""%Y-%m-%d"".
        :return: string
        """"""
        return self.current_datetime.strftime('%Y-%m-%d')

    def add_seconds(self, seconds):
        """"""
        Add the specified number of seconds to the current time.
        :param seconds: number of seconds to add
        :return: string, time after adding the specified number of seconds in the format '%H:%M:%S'
        """"""
        new_time = self.current_datetime + datetime.timedelta(seconds=seconds)
        return new_time.strftime('%H:%M:%S')

    def string_to_datetime(self, string):
        """"""
        Convert the time string to a datetime instance.
        :param string: time string in the format '%Y-%m-%d %H:%M:%S'
        :return: datetime instance
        """"""
        return datetime.datetime.strptime(string, '%Y-%m-%d %H:%M:%S')

    def datetime_to_string(self, dt):
        """"""
        Convert a datetime instance to a string.
        :param dt: datetime instance
        :return: string, converted time string in the format '%Y-%m-%d %H:%M:%S'
        """"""
        return dt.strftime('%Y-%m-%d %H:%M:%S')

    def get_minutes(self, string_time1, string_time2):
        """"""
        Calculate how many minutes have passed between two times, and round the results to the nearest minute.
        :param string_time1: first time string in the format '%Y-%m-%d %H:%M:%S'
        :param string_time2: second time string in the format '%Y-%m-%d %H:%M:%S'
        :return: int, the number of minutes between two times, rounded off
        """"""
        dt1 = self.string_to_datetime(string_time1)
        dt2 = self.string_to_datetime(string_time2)
        difference = dt2 - dt1
        return round(difference.total_seconds() / 60)

    def get_format_time(self, year, month, day, hour, minute, second):
        """"""
        Get formatted time from specified year, month, day, hour, minute, and second.
        :param year: int
        :param month: int
        :param day: int
        :param hour: int
        :param minute: int
        :param second: int
        :return: formatted time string in the format '%Y-%m-%d %H:%M:%S'
        """"""
        dt = datetime.datetime(year, month, day, hour, minute, second)
        return dt.strftime('%Y-%m-%d %H:%M:%S')
```",0.090909091,0.116311207,0.759259259,0.347457627,0.476744182,0.494117647,0.193548387,0.278145691,0.759259259,0.347457627,0.476744182,,,,,,,,,,,,
GPT,88,"from math import pi, fabs


class TriCalculator:

    def __init__(self):
        pass

    def cos(self, x):
        return round(self.taylor(x, 50), 10)

    def factorial(self, a):
        b = 1
        while a != 1:
            b *= a
            a -= 1
        return b

    def taylor(self, x, n):
        a = 1
        x = x / 180 * pi
        count = 1
        for k in range(1, n):
            if count % 2 != 0:
                a -= (x ** (2 * k)) / self.factorial(2 * k)
            else:
                a += (x ** (2 * k)) / self.factorial(2 * k)
            count += 1
        return a

    def sin(self, x):
        x = x / 180 * pi
        g = 0
        t = x
        n = 1

        while fabs(t) >= 1e-15:
            g += t
            n += 1
            t = -t * x * x / (2 * n - 1) / (2 * n - 2)
        return round(g, 10)

    def tan(self, x):
        if self.cos(x) != 0:
            result = self.sin(x) / self.cos(x)
            return round(result, 10)
        else:
            return False",ZeroShot,"```python
from math import pi, fabs

class TriCalculator:

    def __init__(self):
        pass

    def cos(self, x):
        """"""
        Calculate the cos value of the x-degree angle using Taylor series
        :return: float
        """"""
        # Convert degree to radians
        x_rad = x * pi / 180
        # Use Taylor series with 10 terms for approximation
        return self.taylor(x_rad, 10)

    def factorial(self, a):
        """"""
        Calculate the factorial of a
        :return: int
        """"""
        if a == 0:
            return 1
        result = 1
        for i in range(1, a + 1):
            result *= i
        return result

    def taylor(self, x, n):
        """"""
        Finding the n-order Taylor expansion value of cos(x)
        :return: float
        """"""
        cos_approx = 0
        for i in range(n):
            # Calculate each term in the Taylor series for cosine
            term = ((-1) ** i) * (x ** (2 * i)) / self.factorial(2 * i)
            cos_approx += term
        return cos_approx

    def sin(self, x):
        """"""
        Calculate the sin value of the x-degree angle using Taylor series
        :return: float
        """"""
        # Convert degree to radians
        x_rad = x * pi / 180
        sin_approx = 0
        # Use Taylor series with 10 terms for approximation
        for i in range(10):
            # Calculate each term in the Taylor series for sine
            term = ((-1) ** i) * (x_rad ** (2 * i + 1)) / self.factorial(2 * i + 1)
            sin_approx += term
        return sin_approx

    def tan(self, x):
        """"""
        Calculate the tan value of the x-degree angle
        :return: float
        """"""
        # Calculate tan as sin/cos
        cos_value = self.cos(x)
        if fabs(cos_value) < 1e-10:
            raise ValueError(""Tangent undefined for this angle as cosine is zero."")
        sin_value = self.sin(x)
        return sin_value / cos_value
```

- The `cos` method uses the `taylor` method to calculate the cosine using a Taylor series approximation.
- The `factorial` method computes the factorial of a given number.
- The `taylor` method computes the Taylor series for cosine.
- The `sin` method calculates the sine using a Taylor series.
- The `tan` method calculates the tangent as the ratio of sine to cosine, with a check to avoid division by zero.",0.069069069,0.099725978,0.643835616,0.356060606,0.458536581,0.307692308,0.165975104,0.215633419,0.616438356,0.340909091,0.439024386,,,,,,,,,,,,
GPT,89,"import random


class TwentyFourPointGame:
    def __init__(self) -> None:
        self.nums = []

    def _generate_cards(self):
        for i in range(4):
            self.nums.append(random.randint(1, 9))
        assert len(self.nums) == 4

    def get_my_cards(self):
        self.nums = []
        self._generate_cards()
        return self.nums

    def answer(self, expression):
        if expression == 'pass':
            return self.get_my_cards()
        statistic = {}
        for c in expression:
            if c.isdigit() and int(c) in self.nums:
                statistic[c] = statistic.get(c, 0) + 1

        nums_used = statistic.copy()

        for num in self.nums:
            if nums_used.get(str(num), -100) != -100 and nums_used[str(num)] > 0:
                nums_used[str(num)] -= 1
            else:
                return False

        if all(count == 0 for count in nums_used.values()) == True:
            return self.evaluate_expression(expression)
        else:
            return False

    def evaluate_expression(self, expression):
        try:
            if eval(expression) == 24:
                return True
            else:
                return False
        except Exception as e:
            return False",ZeroShot,"```python
import random

class TwentyFourPointGame:
    def __init__(self) -> None:
        self.nums = []

    def _generate_cards(self):
        """"""
        Generate random numbers between 1 and 9 for the cards.
        """"""
        self.nums = [random.randint(1, 9) for _ in range(4)]

    def get_my_cards(self):
        """"""
        Get a list of four random numbers between 1 and 9 representing the player's cards.
        :return: list of integers, representing the player's cards
        """"""
        if not self.nums:
            self._generate_cards()
        return self.nums

    def answer(self, expression):
        """"""
        Check if a given mathematical expression using the cards can evaluate to 24.
        :param expression: str, the mathematical expression to evaluate
        :return: bool, True if the expression evaluates to 24, False otherwise
        """"""
        # Ensure the expression only uses the numbers from the generated cards
        card_counts = {num: self.nums.count(num) for num in self.nums}
        try:
            # Evaluate the expression
            result = eval(expression)
            # Check if the result is 24
            if result == 24:
                # Validate that used numbers are from the generated cards
                used_numbers = [int(char) for char in expression if char.isdigit()]
                used_counts = {num: used_numbers.count(num) for num in used_numbers}
                for num, count in used_counts.items():
                    if count > card_counts.get(num, 0):
                        return False
                return True
            return False
        except (SyntaxError, NameError, ZeroDivisionError):
            return False

    def evaluate_expression(self, expression):
        """"""
        Evaluate a mathematical expression and check if the result is 24.
        :param expression: str, the mathematical expression to evaluate
        :return: bool, True if the expression evaluates to 24, False otherwise
        """"""
        return self.answer(expression)
```

# Explanation:
- `_generate_cards`: Generates four random numbers between 1 and 9 and stores them in `self.nums`.
- `get_my_cards`: Returns the list of generated numbers. If they haven't been generated yet, it calls `_generate_cards`.
- `answer`: Evaluates the given expression and checks if it equals 24, ensuring that only the numbers from the generated cards are used.
- `evaluate_expression`: Simply calls the `answer` method to evaluate the expression.",0.067567568,0.095110038,0.506666667,0.28358209,0.363636359,0.275862069,0.132780083,0.179271704,0.48,0.268656716,0.344497603,,,,,,,,,,,,
GPT,90,"class URLHandler:
    def __init__(self, url):
        self.url = url

    def get_scheme(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            return self.url[:scheme_end]
        return None

    def get_host(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            url_without_scheme = self.url[scheme_end + 3:]
            host_end = url_without_scheme.find(""/"")
            if host_end != -1:
                return url_without_scheme[:host_end]
            return url_without_scheme
        return None

    def get_path(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            url_without_scheme = self.url[scheme_end + 3:]
            host_end = url_without_scheme.find(""/"")
            if host_end != -1:
                return url_without_scheme[host_end:]
        return None

    def get_query_params(self):
        query_start = self.url.find(""?"")
        fragment_start = self.url.find(""#"")
        if query_start != -1:
            query_string = self.url[query_start + 1:fragment_start]
            params = {}
            if len(query_string) > 0:
                param_pairs = query_string.split(""&"")
                for pair in param_pairs:
                    key_value = pair.split(""="")
                    if len(key_value) == 2:
                        key, value = key_value
                        params[key] = value
            return params
        return None

    def get_fragment(self):
        fragment_start = self.url.find(""#"")
        if fragment_start != -1:
            return self.url[fragment_start + 1:]
        return None",ZeroShot,"```python
from urllib.parse import urlparse, parse_qs

class URLHandler:
    def __init__(self, url):
        """"""
        Initialize URLHandler's URL
        """"""
        # Parse the URL using urlparse and store the result
        self.parsed_url = urlparse(url)

    def get_scheme(self):
        """"""
        Get the scheme of the URL
        :return: string, If successful, return the scheme of the URL
        """"""
        # Return the scheme part of the parsed URL
        return self.parsed_url.scheme

    def get_host(self):
        """"""
        Get the second part of the URL, which is the host domain name
        :return: string, If successful, return the host domain name of the URL
        """"""
        # Return the netloc part of the parsed URL, which represents the host
        return self.parsed_url.netloc

    def get_path(self):
        """"""
        Get the third part of the URL, which is the address of the resource
        :return: string, If successful, return the address of the resource of the URL
        """"""
        # Return the path part of the parsed URL
        return self.parsed_url.path

    def get_query_params(self):
        """"""
        Get the request parameters for the URL
        :return: dict, If successful, return the request parameters of the URL
        """"""
        # Parse the query part of the parsed URL into a dictionary
        return parse_qs(self.parsed_url.query)

    def get_fragment(self):
        """"""
        Get the fragment after '#' in the URL
        :return: string, If successful, return the fragment after '#' of the URL
        """"""
        # Return the fragment part of the parsed URL
        return self.parsed_url.fragment
```

- The `urlparse` function is used to break down the URL into its components.
- The `parse_qs` function is used to parse the query part of the URL into a dictionary of parameters.",0.012048193,0.024993194,0.263157895,0.180722892,0.214285709,0.098039216,0.072992701,0.083682003,0.263157895,0.180722892,0.214285709,,,,,,,,,,,,
GPT,91,"import urllib.parse


class UrlPath:
    def __init__(self):
        self.segments = []
        self.with_end_tag = False

    def add(self, segment):
        self.segments.append(self.fix_path(segment))

    def parse(self, path, charset):
        if path:
            if path.endswith('/'):
                self.with_end_tag = True

            path = self.fix_path(path)
            if path:
                split = path.split('/')
                for seg in split:
                    decoded_seg = urllib.parse.unquote(seg, encoding=charset)
                    self.segments.append(decoded_seg)

    @staticmethod
    def fix_path(path):
        if not path:
            return ''

        segment_str = path.strip('/')
        return segment_str",ZeroShot,"```python
import urllib.parse

class UrlPath:
    def __init__(self):
        """"""
        Initializes the UrlPath object with an empty list of segments.
        """"""
        self.segments = []

    def add(self, segment):
        """"""
        Adds a segment to the list of segments in the UrlPath.
        :param segment: str, the segment to add.
        """"""
        # Append the segment to the segments list
        self.segments.append(segment)

    def parse(self, path, charset='utf-8'):
        """"""
        Parses a given path string and populates the list of segments in the UrlPath.
        :param path: str, the path string to parse.
        :param charset: str, the character set for decoding the path.
        """"""
        # Fix the path by removing leading and trailing slashes
        fixed_path = self.fix_path(path)
        # Split the fixed path into segments
        segments = fixed_path.split('/')
        # Decode each segment and add it to the segments list
        for segment in segments:
            self.segments.append(urllib.parse.unquote(segment, encoding=charset))

    @staticmethod
    def fix_path(path):
        """"""
        Fixes the given path string by removing leading and trailing slashes.
        :param path: str, the path to fix.
        :return: str, the fixed path string.
        """"""
        # Strip leading and trailing slashes from the path
        return path.strip('/')
```

- The `__init__` method initializes the `UrlPath` object with an empty list of segments.
- The `add` method adds a given segment to the list of segments.
- The `parse` method takes a path string and a charset, removes leading and trailing slashes, splits the path into segments, decodes each segment, and adds them to the segments list.
- The `fix_path` method is a static method that removes leading and trailing slashes from a given path string.",0.032258065,0.039632579,0.581395349,0.245098039,0.344827582,0.28125,0.099447514,0.146938772,0.581395349,0.245098039,0.344827582,,,,,,,,,,,,
GPT,92,"import sqlite3


class UserLoginDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()

    def insert_user(self, username, password):
        self.cursor.execute('''
            INSERT INTO users (username, password)
            VALUES (?, ?)
        ''', (username, password))
        self.connection.commit()

    def search_user_by_username(self, username):
        self.cursor.execute('''
            SELECT * FROM users WHERE username = ?
        ''', (username,))
        user = self.cursor.fetchone()
        return user

    def delete_user_by_username(self, username):
        self.cursor.execute('''
            DELETE FROM users WHERE username = ?
        ''', (username,))
        self.connection.commit()

    def validate_user_login(self, username, password):
        user = self.search_user_by_username(username)
        if user is not None and user[1] == password:
            return True
        return False",ZeroShot,"```python
import sqlite3

class UserLoginDB:
    def __init__(self, db_name):
        """"""
        Initializes the UserLoginDB object with the specified database name.
        Creates a connection to the SQLite database and ensures the ""users"" table exists.
        """"""
        self.db_name = db_name
        self.connection = sqlite3.connect(self.db_name)
        self.cursor = self.connection.cursor()
        # Create the ""users"" table if it doesn't exist
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT NOT NULL UNIQUE,
                password TEXT NOT NULL
            )
        ''')
        self.connection.commit()

    def insert_user(self, username, password):
        """"""
        Inserts a new user into the ""users"" table.
        :param username: str, the username of the new user.
        :param password: str, the password of the new user.
        :return: None
        """"""
        try:
            self.cursor.execute('''
                INSERT INTO users (username, password) VALUES (?, ?)
            ''', (username, password))
            self.connection.commit()
        except sqlite3.IntegrityError:
            print(f""User '{username}' already exists."")

    def search_user_by_username(self, username):
        """"""
        Searches for users in the ""users"" table by username.
        :param username: str, the username of the user to search for.
        :return: list of tuples, the rows from the ""users"" table that match the search criteria.
        """"""
        self.cursor.execute('''
            SELECT * FROM users WHERE username = ?
        ''', (username,))
        return self.cursor.fetchall()

    def delete_user_by_username(self, username):
        """"""
        Deletes a user from the ""users"" table by username.
        :param username: str, the username of the user to delete.
        :return: None
        """"""
        self.cursor.execute('''
            DELETE FROM users WHERE username = ?
        ''', (username,))
        self.connection.commit()

    def validate_user_login(self, username, password):
        """"""
        Determine whether the user can log in, that is, the user is in the database and the password is correct.
        :param username: str, the username of the user attempting to log in.
        :param password: str, the password of the user attempting to log in.
        :return: bool, representing whether the user can log in correctly.
        """"""
        self.cursor.execute('''
            SELECT * FROM users WHERE username = ? AND password = ?
        ''', (username, password))
        result = self.cursor.fetchone()
        return result is not None

    def __del__(self):
        """"""
        Ensures that the database connection is closed when the object is destroyed.
        """"""
        self.connection.close()
```",0.141065831,0.160661691,0.888888889,0.340425532,0.492307688,0.714285714,0.230125523,0.348101262,0.888888889,0.340425532,0.492307688,,,,,,,,,,,,
GPT,93,"import numpy as np
from gensim import matutils
from numpy import dot, array


class VectorUtil:
    @staticmethod
    def similarity(vector_1, vector_2):
        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))

    @staticmethod
    def cosine_similarities(vector_1, vectors_all):
        norm = np.linalg.norm(vector_1)
        all_norms = np.linalg.norm(vectors_all, axis=1)
        dot_products = dot(vectors_all, vector_1)
        similarities = dot_products / (norm * all_norms)
        return similarities

    @staticmethod
    def n_similarity(vector_list_1, vector_list_2):
        if not (len(vector_list_1) and len(vector_list_2)):
            raise ZeroDivisionError('At least one of the passed list is empty.')

        return dot(matutils.unitvec(array(vector_list_1).mean(axis=0)),
                   matutils.unitvec(array(vector_list_2).mean(axis=0)))

    @staticmethod
    def compute_idf_weight_dict(total_num, number_dict):
        index_2_key_map = {}

        index = 0

        count_list = []
        for key, count in number_dict.items():
            index_2_key_map[index] = key
            count_list.append(count)
            index = index + 1

        a = np.array(count_list)
        ## smooth, in case the divide by zero error
        a = np.log((total_num + 1) / (a + 1))
        result = {}

        for index, w in enumerate(a):
            key = index_2_key_map[index]
            result[key] = w

        return result",ZeroShot,"```python
class VectorUtil:
    @staticmethod
    def similarity(vector_1, vector_2):
        """"""
        Compute the cosine similarity between one vector and another vector.
        :return: float, Contains cosine similarity between `vector_1` and `vector_2`
        """"""
        # Normalize both vectors to unit vectors
        vector_1 = matutils.unitvec(array(vector_1))
        vector_2 = matutils.unitvec(array(vector_2))
        
        # Compute and return the dot product, which is the cosine similarity for unit vectors
        return dot(vector_1, vector_2)

    @staticmethod
    def cosine_similarities(vector_1, vectors_all):
        """"""
        Compute cosine similarities between one vector and a set of other vectors.
        :return: numpy.ndarray, Contains cosine similarities between `vector_1` and each row in `vectors_all`, shape (num_vectors,).
        """"""
        # Normalize the input vector to a unit vector
        vector_1 = matutils.unitvec(array(vector_1))
        
        # Normalize all vectors in vectors_all to unit vectors
        vectors_all = matutils.unitvec(array(vectors_all))
        
        # Compute the dot product between vector_1 and each vector in vectors_all
        return np.dot(vectors_all, vector_1)

    @staticmethod
    def n_similarity(vector_list_1, vector_list_2):
        """"""
        Compute cosine similarity between two sets of vectors.
        :return: float, Similarities between vector_list_1 and vector_list_2.
        """"""
        # Convert lists of vectors to arrays
        vector_list_1 = np.array(vector_list_1)
        vector_list_2 = np.array(vector_list_2)
        
        # Compute mean vectors for each list
        mean_vector_1 = np.mean(vector_list_1, axis=0)
        mean_vector_2 = np.mean(vector_list_2, axis=0)
        
        # Return the cosine similarity between the mean vectors
        return VectorUtil.similarity(mean_vector_1, mean_vector_2)

    @staticmethod
    def compute_idf_weight_dict(total_num, number_dict):
        """"""
        Calculate log(total_num+1/count+1) for each count in number_dict
        :return: dict
        """"""
        # Initialize an empty dictionary to store IDF weights
        idf_weights = {}
        
        # Calculate IDF weight for each term in number_dict
        for term, count in number_dict.items():
            # Compute IDF using the formula: log((total_num + 1) / (count + 1))
            idf_weights[term] = np.log((total_num + 1) / (count + 1))
        
        # Return the dictionary of IDF weights
        return idf_weights
```",0.053435115,0.074700347,0.410526316,0.330508475,0.366197178,0.162962963,0.105263158,0.127906972,0.4,0.322033898,0.356807507,,,,,,,,,,,,
GPT,94,"class VendingMachine:
    def __init__(self):
        self.inventory = {}
        self.balance = 0

    def add_item(self, item_name, price, quantity):
        if not self.restock_item(item_name, quantity):
            self.inventory[item_name] = {'price': price, 'quantity': quantity}

    def insert_coin(self, amount):
        self.balance += amount
        return self.balance

    def purchase_item(self, item_name):
        if item_name in self.inventory:
            item = self.inventory[item_name]
            if item['quantity'] > 0 and self.balance >= item['price']:
                self.balance -= item['price']
                item['quantity'] -= 1
                return self.balance
            else:
                return False
        else:
            return False

    def restock_item(self, item_name, quantity):
        if item_name in self.inventory:
            self.inventory[item_name]['quantity'] += quantity
            return True
        else:
            return False

    def display_items(self):
        if not self.inventory:
            return False
        else:
            items = []
            for item_name, item_info in self.inventory.items():
                items.append(f""{item_name} - ${item_info['price']} [{item_info['quantity']}]"")
            return ""\n"".join(items)",ZeroShot,"```python
class VendingMachine:
    def __init__(self):
        """"""
        Initializes the vending machine's inventory and balance.
        """"""
        self.inventory = {}  # Dictionary to hold item details
        self.balance = 0  # Current balance in the vending machine

    def add_item(self, item_name, price, quantity):
        """"""
        Adds a product to the vending machine's inventory.
        :return: None
        """"""
        if item_name in self.inventory:
            # If item already exists, update its price and add to its quantity
            self.inventory[item_name]['price'] = price
            self.inventory[item_name]['quantity'] += quantity
        else:
            # Add new item to the inventory
            self.inventory[item_name] = {'price': price, 'quantity': quantity}

    def insert_coin(self, amount):
        """"""
        Inserts coins into the vending machine.
        :return: The balance of the vending machine after the coins are inserted, float.
        """"""
        self.balance += amount  # Increase balance by the inserted amount
        return self.balance

    def purchase_item(self, item_name):
        """"""
        Purchases a product from the vending machine and returns the balance after the purchase and display purchase unsuccessful if the product is out of stock.
        :return: If successful, returns the balance of the vending machine after the product is purchased, float, otherwise, returns False.
        """"""
        if item_name in self.inventory:
            item = self.inventory[item_name]
            if item['quantity'] > 0:
                if self.balance >= item['price']:
                    # Deduct item price from balance and reduce item quantity
                    self.balance -= item['price']
                    item['quantity'] -= 1
                    return self.balance
                else:
                    print(""Insufficient balance. Please insert more coins."")
                    return False
            else:
                print(f""{item_name} is out of stock."")
                return False
        else:
            print(f""{item_name} is not available in the vending machine."")
            return False

    def restock_item(self, item_name, quantity):
        """"""
        Replenishes the inventory of a product already in the vending machine.
        :return: If the product is already in the vending machine, returns True, otherwise, returns False.
        """"""
        if item_name in self.inventory:
            # Increase the quantity of the existing item
            self.inventory[item_name]['quantity'] += quantity
            return True
        else:
            print(f""{item_name} is not available in the vending machine."")
            return False

    def display_items(self):
        """"""
        Displays the products in the vending machine.
        :return: If the vending machine is empty, returns False, otherwise, returns a list of the products in the vending machine, str.
        """"""
        if not self.inventory:
            print(""The vending machine is empty."")
            return False
        else:
            items_list = []
            for item_name, details in self.inventory.items():
                items_list.append(f""{item_name}: ${details['price']} ({details['quantity']} available)"")
            return ""\n"".join(items_list)
```",0.148997135,0.167247999,0.862068966,0.378787879,0.526315785,0.708333333,0.259541985,0.379888264,0.862068966,0.378787879,0.526315785,,,,,,,,,,,,
GPT,95,"class Warehouse:
    def __init__(self):
        self.inventory = {}  # Product ID: Product
        self.orders = {}  # Order ID: Order

    def add_product(self, product_id, name, quantity):
        if product_id not in self.inventory:
            self.inventory[product_id] = {'name': name, 'quantity': quantity}
        else:
            self.inventory[product_id]['quantity'] += quantity

    def update_product_quantity(self, product_id, quantity):
        if product_id in self.inventory:
            self.inventory[product_id]['quantity'] += quantity

    def get_product_quantity(self, product_id):
        if product_id in self.inventory:
            return self.inventory[product_id]['quantity']
        else:
            return False

    def create_order(self, order_id, product_id, quantity):
        if self.get_product_quantity(product_id) >= quantity:
            self.update_product_quantity(product_id, -quantity)
            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}
        else:
            return False

    def change_order_status(self, order_id, status):
        if order_id in self.orders:
            self.orders[order_id]['status'] = status
        else:
            return False

    def track_order(self, order_id):
        if order_id in self.orders:
            return self.orders[order_id]['status']
        else:
            return False",ZeroShot,"```python
class Warehouse:
    def __init__(self):
        """"""
        Initialize two fields.
        """"""
        self.inventory = {}  # Product ID: Product
        self.orders = {}  # Order ID: Order

    def add_product(self, product_id, name, quantity):
        """"""
        Add product to inventory and plus the quantity if it has existed in inventory.
        Or just add new product to dict otherwise.
        """"""
        if product_id in self.inventory:
            self.inventory[product_id]['quantity'] += quantity
        else:
            self.inventory[product_id] = {'name': name, 'quantity': quantity}

    def update_product_quantity(self, product_id, quantity):
        """"""
        According to product_id, add the quantity to the corresponding product in inventory.
        """"""
        if product_id in self.inventory:
            self.inventory[product_id]['quantity'] += quantity

    def get_product_quantity(self, product_id):
        """"""
        Get the quantity of specific product by product_id.
        :return: if the product_id is in inventory then return the corresponding quantity,
                or False otherwise.
        """"""
        if product_id in self.inventory:
            return self.inventory[product_id]['quantity']
        return False

    def create_order(self, order_id, product_id, quantity):
        """"""
        Create an order which includes the information of product, like id and quantity.
        And put the new order into self.orders.
        The default value of status is 'Shipped'.
        :return False: only if product_id is not in inventory or the quantity is not adequate
        """"""
        if product_id not in self.inventory or self.inventory[product_id]['quantity'] < quantity:
            return False
        self.inventory[product_id]['quantity'] -= quantity
        self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}

    def change_order_status(self, order_id, status):
        """"""
        Change the status of order if the input order_id is in self.orders.
        :return False: only if the order_id is not in self.orders
        """"""
        if order_id in self.orders:
            self.orders[order_id]['status'] = status
        else:
            return False

    def track_order(self, order_id):
        """"""
        Get the status of specific order.
        :return False: only if the order_id is not in self.orders.
        """"""
        if order_id in self.orders:
            return self.orders[order_id]['status']
        return False
```",0.256603774,0.283385151,0.927272727,0.481132075,0.633540368,0.813186813,0.362745098,0.501694911,0.927272727,0.481132075,0.633540368,,,,,,,,,,,,
GPT,96,"class WeatherSystem:
    def __init__(self, city) -> None:
        self.temperature = None
        self.weather = None
        self.city = city
        self.weather_list = {}
    
    def query(self, weather_list, tmp_units = 'celsius'):
        self.weather_list = weather_list
        if self.city not in weather_list:
            return False
        else:
            self.temperature = self.weather_list[self.city]['temperature']
            self.weather = self.weather_list[self.city]['weather']
        if self.weather_list[self.city]['temperature units'] != tmp_units:
            if tmp_units == 'celsius':
                return self.fahrenheit_to_celsius(), self.weather
            elif tmp_units == 'fahrenheit':
                return self.celsius_to_fahrenheit(), self.weather
        else:
            return self.temperature, self.weather
    
    def set_city(self, city):
        self.city = city

    def celsius_to_fahrenheit(self):
        return (self.temperature * 9/5) + 32

    def fahrenheit_to_celsius(self):
        return (self.temperature - 32) * 5/9",ZeroShot,"```python
class WeatherSystem:
    def __init__(self, city) -> None:
        """"""
        Initialize the weather system with a city name.
        """"""
        self.city = city
        self.temperature = None
        self.weather = None

    def query(self, weather_list, tmp_units='celsius'):
        """"""
        Query the weather system for the weather and temperature of the city,
        and convert the temperature units based on the input parameter.
        
        :param weather_list: List of dictionaries containing weather info for cities.
        :param tmp_units: Desired temperature units ('celsius' or 'fahrenheit').
        :return: Tuple containing the temperature and weather of the city.
        """"""
        for weather_info in weather_list:
            if weather_info['city'].lower() == self.city.lower():
                self.temperature = weather_info['temperature']
                self.weather = weather_info['weather']
                
                if tmp_units.lower() == 'fahrenheit':
                    self.temperature = self.celsius_to_fahrenheit(self.temperature)
                
                return self.temperature, self.weather
        
        return None

    def set_city(self, city):
        """"""
        Set the city of the weather system.
        
        :param city: Name of the city to set.
        :return: None
        """"""
        self.city = city

    def celsius_to_fahrenheit(self, celsius_temp):
        """"""
        Convert the temperature from Celsius to Fahrenheit.
        
        :param celsius_temp: Temperature in Celsius to convert.
        :return: Temperature in Fahrenheit, float.
        """"""
        return (celsius_temp * 9/5) + 32

    def fahrenheit_to_celsius(self, fahrenheit_temp):
        """"""
        Convert the temperature from Fahrenheit to Celsius.
        
        :param fahrenheit_temp: Temperature in Fahrenheit to convert.
        :return: Temperature in Celsius, float.
        """"""
        return (fahrenheit_temp - 32) * 5/9
```

- The `__init__` method initializes the object with a city name.
- The `query` method searches for weather data for the specified city in a provided list and returns the temperature in the desired unit.
- The `set_city` method updates the city for which the weather system provides information.
- The `celsius_to_fahrenheit` and `fahrenheit_to_celsius` methods perform unit conversions for temperature.",0.079051383,0.098709478,0.634615385,0.277310924,0.385964908,0.411764706,0.162037037,0.232558135,0.634615385,0.277310924,0.385964908,,,,,,,,,,,,
GPT,97,"class Words2Numbers:

    def __init__(self):
        self.numwords = {}
        self.units = [
            ""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"",
            ""nine"", ""ten"", ""eleven"", ""twelve"", ""thirteen"", ""fourteen"", ""fifteen"",
            ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen"",
        ]
        self.tens = ["""", """", ""twenty"", ""thirty"", ""forty"", ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""]
        self.scales = [""hundred"", ""thousand"", ""million"", ""billion"", ""trillion""]

        self.numwords[""and""] = (1, 0)
        for idx, word in enumerate(self.units):
            self.numwords[word] = (1, idx)
        for idx, word in enumerate(self.tens):
            self.numwords[word] = (1, idx * 10)
        for idx, word in enumerate(self.scales):
            self.numwords[word] = (10 ** (idx * 3 or 2), 0)

        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}
        self.ordinal_endings = [('ieth', 'y'), ('th', '')]

    def text2int(self, textnum):
        textnum = textnum.replace('-', ' ')

        current = result = 0
        curstring = """"
        onnumber = False
        for word in textnum.split():
            if word in self.ordinal_words:
                scale, increment = (1, self.ordinal_words[word])
                current = current * scale + increment
                onnumber = True
            else:
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = ""%s%s"" % (word[:-len(ending)], replacement)

                if word not in self.numwords:
                    if onnumber:
                        curstring += repr(result + current) + "" ""
                    curstring += word + "" ""
                    result = current = 0
                    onnumber = False
                else:
                    scale, increment = self.numwords[word]
                    current = current * scale + increment
                    if scale > 100:
                        result += current
                        current = 0
                    onnumber = True

        if onnumber:
            curstring += repr(result + current)

        return curstring

    def is_valid_input(self, textnum):

        textnum = textnum.replace('-', ' ')

        for word in textnum.split():
            if word in self.ordinal_words:
                continue
            else:
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = ""%s%s"" % (word[:-len(ending)], replacement)

                if word not in self.numwords:
                    return False

        return True",ZeroShot,"```python
    def text2int(self, textnum):
        """"""
        Convert the word string to the corresponding integer string
        :return: string, the final converted integer string
        """"""
        current = result = 0
        # Split the input text into words
        words = textnum.lower().replace('-', ' ').split()

        for word in words:
            # Handle ordinal words separately
            if word in self.ordinal_words:
                current += self.ordinal_words[word]
            else:
                # Handle endings for ordinal words
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = word[:len(word) - len(ending)] + replacement
                        if word in self.numwords:
                            scale, increment = self.numwords[word]
                            current = current * scale + increment
                            break

            if word in self.numwords:
                scale, increment = self.numwords[word]
                current = current * scale + increment
                if scale > 100:
                    result += current
                    current = 0

        return str(result + current)

    def is_valid_input(self, textnum):
        """"""
        Check if the input text contains only valid words that can be converted into numbers.
        :return: True if input is valid, False otherwise.
        """"""
        words = textnum.lower().replace('-', ' ').split()

        for word in words:
            # Check if the word is a valid unit, ten, scale, or ordinal
            if word not in self.numwords and word not in self.ordinal_words:
                # Check if the word can be converted by removing ordinal endings
                valid = False
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = word[:len(word) - len(ending)] + replacement
                        if word in self.numwords:
                            valid = True
                            break
                if not valid:
                    return False

        return True
```

- The `text2int` method converts a text representation of a number into its integer form by iterating over the words, applying scales, and summing up the values.
- The `is_valid_input` method checks if all words in the input text are valid representations of numbers, considering both cardinal and ordinal words.",0.200729927,0.244893532,0.30075188,0.344827586,0.321285136,0.259615385,0.257142857,0.258373201,0.30075188,0.344827586,0.321285136,,,,,,,,,,,,
GPT,98,"import xml.etree.ElementTree as ET


class XMLProcessor:
    def __init__(self, file_name):
        self.file_name = file_name
        self.root = None

    def read_xml(self):
        try:
            tree = ET.parse(self.file_name)
            self.root = tree.getroot()
            return self.root
        except:
            return None

    def write_xml(self, file_name):
        try:
            tree = ET.ElementTree(self.root)
            tree.write(file_name)
            return True
        except:
            return False

    def process_xml_data(self, file_name):
        for element in self.root.iter('item'):
            text = element.text
            element.text = text.upper()
        return self.write_xml(file_name)

    def find_element(self, element_name):
        elements = self.root.findall(element_name)
        return elements",ZeroShot,"```python
import xml.etree.ElementTree as ET


class XMLProcessor:
    def __init__(self, file_name):
        """"""
        Initialize the XMLProcessor object with the given file name.
        """"""
        self.file_name = file_name
        self.tree = None
        self.root = None

    def read_xml(self):
        """"""
        Reads the XML file and returns the root element.
        :return: Element, the root element of the XML file.
        """"""
        try:
            self.tree = ET.parse(self.file_name)
            self.root = self.tree.getroot()
            return self.root
        except ET.ParseError as e:
            print(f""Error parsing XML file: {e}"")
            return None
        except FileNotFoundError:
            print(f""File not found: {self.file_name}"")
            return None

    def write_xml(self, file_name):
        """"""
        Writes the XML data to the specified file.
        :return: bool, True if the write operation is successful, False otherwise.
        """"""
        if self.tree is not None:
            try:
                self.tree.write(file_name)
                return True
            except Exception as e:
                print(f""Error writing XML file: {e}"")
                return False
        else:
            print(""No XML data to write."")
            return False

    def process_xml_data(self, file_name):
        """"""
        Modifies the data in XML elements and writes the updated XML data to a new file.
        :return: bool, True if the write operation is successful, False otherwise.
        """"""
        if self.root is not None:
            # Example processing: Add an attribute to each child of the root
            for elem in self.root:
                elem.set('processed', 'true')

            # Write the updated XML data to a new file
            return self.write_xml(file_name)
        else:
            print(""No XML data to process."")
            return False

    def find_element(self, element_name):
        """"""
        Finds the XML elements with the specified name.
        :return: list, a list of found elements with the specified name.
        """"""
        if self.root is not None:
            found_elements = self.root.findall(element_name)
            return found_elements
        else:
            print(""No XML data to search."")
            return []
```

- The `__init__` method initializes the XMLProcessor object with the file name and sets up placeholders for the tree and root.
- The `read_xml` method parses the XML file and returns the root element, handling errors appropriately.
- The `write_xml` method writes the XML tree to a specified file, returning a success flag.
- The `process_xml_data` method demonstrates a simple processing task and writes the modified XML to a new file.
- The `find_element` method searches for elements by name and returns a list of found elements.",0.062686567,0.077751184,0.857142857,0.260869565,0.399999996,0.61971831,0.176706827,0.274999997,0.857142857,0.260869565,0.399999996,,,,,,,,,,,,
GPT,0,"import logging
import datetime


class AccessGatewayFilter:

    def __init__(self):
        pass

    def filter(self, request):
        request_uri = request['path']
        method = request['method']

        if self.is_start_with(request_uri):
            return True

        try:
            token = self.get_jwt_user(request)
            user = token['user']
            if user['level'] > 2:
                self.set_current_user_info_and_log(user)
                return True
        except:
            return False

    def is_start_with(self, request_uri):
        start_with = [""/api"", '/login']
        for s in start_with:
            if request_uri.startswith(s):
                return True
        return False

    def get_jwt_user(self, request):
        token = request['headers']['Authorization']
        user = token['user']
        if token['jwt'].startswith(user['name']):
            jwt_str_date = token['jwt'].split(user['name'])[1]
            jwt_date = datetime.datetime.strptime(jwt_str_date, ""%Y-%m-%d"")
            if datetime.datetime.today() - jwt_date >= datetime.timedelta(days=3):
                return None
        return token

    def set_current_user_info_and_log(self, user):
        host = user['address']
        logging.log(msg=user['name'] + host + str(datetime.datetime.now()), level=1)",FewShot,"```python
import logging
import datetime

class AccessGatewayFilter:
    """"""
    This class is a filter used for accessing gateway filtering, primarily for authentication and access log recording.
    """"""

    def __init__(self):
        # Initialize the logger
        self.logger = logging.getLogger('AccessGatewayFilter')
        self.logger.setLevel(logging.INFO)

    def filter(self, request):
        """"""
        Filter the incoming request based on certain rules and conditions.
        :param request: dict, the incoming request details
        :return: bool, True if the request is allowed, False otherwise
        """"""
        # Check if the request path is allowed
        if self.is_start_with(request.get('path', '')):
            # Get the user from JWT token
            user = self.get_jwt_user(request)
            if user:
                # Log the user information
                self.set_current_user_info_and_log(user)
                return True
        return False

    def is_start_with(self, request_uri):
        """"""
        Check if the request URI starts with certain prefixes.
        :param request_uri: str, the URI of the request
        :return: bool, True if the URI starts with certain prefixes, False otherwise
        """"""
        # Define allowed prefixes
        allowed_prefixes = ['/api', '/login']
        # Check if the request URI starts with any of the allowed prefixes
        return any(request_uri.startswith(prefix) for prefix in allowed_prefixes)

    def get_jwt_user(self, request):
        """"""
        Get the user information from the JWT token in the request.
        :param request: dict, the incoming request details
        :return: dict or None, the user information if the token is valid, None otherwise
        """"""
        # Extract the Authorization header
        auth_header = request.get('headers', {}).get('Authorization', {})
        # Validate the JWT token (mock validation for example purposes)
        jwt_token = auth_header.get('jwt', '')
        if jwt_token and jwt_token.endswith(str(datetime.date.today())):
            # Return user information if the token is valid
            return auth_header.get('user', None)
        return None

    def set_current_user_info_and_log(self, user):
        """"""
        Set the current user information and log the access.
        :param user: dict, the user information
        :return: None
        """"""
        # Log the user access
        self.logger.info(f""User {user.get('name')} accessed from {user.get('address', 'unknown address')}"")
```

- The `filter` method checks if the request path starts with allowed prefixes and if a valid user is retrieved from the JWT token.
- The `is_start_with` method checks if the request URI matches any allowed prefixes.
- The `get_jwt_user` method simulates JWT token validation by checking if the token ends with today's date.
- The `set_current_user_info_and_log` method logs the user access information.",0.038575668,0.053476576,0.46875,0.204081633,0.284360185,0.25,0.091575092,0.134048253,0.46875,0.204081633,0.284360185,,,,,,,,,,,,
GPT,1,"import math


class AreaCalculator:

    def __init__(self, radius):
        self.radius = radius

    def calculate_circle_area(self):
        return math.pi * self.radius ** 2

    def calculate_sphere_area(self):
        return 4 * math.pi * self.radius ** 2

    def calculate_cylinder_area(self, height):
        return 2 * math.pi * self.radius * (self.radius + height)

    def calculate_sector_area(self, angle):
        return self.radius ** 2 * angle / 2

    def calculate_annulus_area(self, inner_radius, outer_radius):
        return math.pi * (outer_radius ** 2 - inner_radius ** 2)",FewShot,"```python
import math

class AreaCalculator:
    """"""
    This is a class for calculating the area of different shapes, including circle, sphere, cylinder, sector and annulus.
    """"""

    def __init__(self, radius):
        """"""
        Initialize the radius for shapes.
        :param radius: float
        """"""
        self.radius = radius

    def calculate_circle_area(self):
        """"""
        Calculate the area of a circle based on self.radius.
        :return: area of circle, float
        >>> areaCalculator = AreaCalculator(2)
        >>> areaCalculator.calculate_circle_area()
        12.566370614359172
        """"""
        # Area of a circle = π * radius^2
        return math.pi * self.radius ** 2

    def calculate_sphere_area(self):
        """"""
        Calculate the surface area of a sphere based on self.radius.
        :return: area of sphere, float
        >>> areaCalculator = AreaCalculator(2)
        >>> areaCalculator.calculate_sphere_area()
        50.26548245743669
        """"""
        # Surface area of a sphere = 4 * π * radius^2
        return 4 * math.pi * self.radius ** 2

    def calculate_cylinder_area(self, height):
        """"""
        Calculate the surface area of a cylinder based on self.radius and height.
        :param height: height of cylinder, float
        :return: area of cylinder, float
        >>> areaCalculator = AreaCalculator(2)
        >>> areaCalculator.calculate_cylinder_area(3)
        62.83185307179586
        """"""
        # Surface area of a cylinder = 2 * π * radius * (radius + height)
        return 2 * math.pi * self.radius * (self.radius + height)

    def calculate_sector_area(self, angle):
        """"""
        Calculate the area of a sector based on self.radius and angle.
        :param angle: angle of sector, float
        :return: area of sector, float
        >>> areaCalculator = AreaCalculator(2)
        >>> areaCalculator.calculate_sector_area(math.pi)
        6.283185307179586
        """"""
        # Area of a sector = 0.5 * radius^2 * angle
        return 0.5 * self.radius ** 2 * angle

    def calculate_annulus_area(self, inner_radius, outer_radius):
        """"""
        Calculate the area of an annulus based on inner_radius and outer_radius.
        :param inner_radius: inner radius of annulus, float
        :param outer_radius: outer radius of annulus, float
        :return: area of annulus, float
        >>> areaCalculator.calculate_annulus_area(2, 3)
        15.707963267948966
        """"""
        # Area of an annulus = π * (outer_radius^2 - inner_radius^2)
        return math.pi * (outer_radius ** 2 - inner_radius ** 2)
```",0.149501661,0.16196501,0.970588235,0.308411215,0.468085103,0.811320755,0.220512821,0.34677419,0.970588235,0.308411215,0.468085103,,,,,,,,,,,,
GPT,2,"class ArgumentParser:
    def __init__(self):
        self.arguments = {}
        self.required = set()
        self.types = {}

    def parse_arguments(self, command_string):
        args = command_string.split()[1:]
        for i in range(len(args)):
            arg = args[i]
            if arg.startswith('--'):
                key_value = arg[2:].split('=')
                if len(key_value) == 2:
                    self.arguments[key_value[0]] = self._convert_type(key_value[0], key_value[1])
                else:
                    self.arguments[key_value[0]] = True
            elif arg.startswith('-'):
                key = arg[1:]
                if i + 1 < len(args) and not args[i + 1].startswith('-'):
                    self.arguments[key] = self._convert_type(key, args[i + 1])
                else:
                    self.arguments[key] = True
        missing_args = self.required - set(self.arguments.keys())
        if missing_args:
            return False, missing_args

        return True, None

    def get_argument(self, key):
        return self.arguments.get(key)

    def add_argument(self, arg, required=False, arg_type=str):
        if required:
            self.required.add(arg)
        self.types[arg] = arg_type

    def _convert_type(self, arg, value):
        try:
            return self.types[arg](value)
        except (ValueError, KeyError):
            return value",FewShot,"```python
class ArgumentParser:
    """"""
    This is a class for parsing command line arguments to a dictionary.
    """"""

    def __init__(self):
        """"""
        Initialize the fields.
        self.arguments is a dict that stores the args in a command line
        self.required is a set that stores the required arguments
        self.types is a dict that stores type of every argument.
        """"""
        self.arguments = {}
        self.required = set()
        self.types = {}

    def parse_arguments(self, command_string):
        """"""
        Parses the given command line argument string and stores the parsed result in specific type in the arguments dictionary.
        Checks for missing required arguments, if any, and returns False with the missing argument names, otherwise returns True.
        :param command_string: str, command line argument string
        :return tuple: (True, None) if parsing is successful, (False, missing_args) if parsing fails
        """"""
        # Split the command string into individual arguments
        args = command_string.split()

        # Iterate over the arguments
        for arg in args:
            if arg.startswith('--'):
                # Handle arguments like --arg=value
                key, value = arg[2:].split('=')
                self.arguments[key] = self._convert_type(key, value)
            elif arg.startswith('-'):
                # Handle options like -option
                key = arg[1:]
                self.arguments[key] = True

        # Check for missing required arguments
        missing_args = self.required - self.arguments.keys()
        if missing_args:
            return False, missing_args
        return True, None

    def get_argument(self, key):
        """"""
        Retrieves the value of the specified argument from the arguments dictionary and returns it.
        :param key: str, argument name
        :return: The value of the argument, or None if the argument does not exist.
        """"""
        return self.arguments.get(key)

    def add_argument(self, arg, required=False, arg_type=str):
        """"""
        Adds an argument to self.types and self.required.
        Check if it is a required argument and store the argument type.
        :param arg: str, argument name
        :param required: bool, whether the argument is required, default is False
        :param arg_type: type, Argument type, default is str
        """"""
        if required:
            self.required.add(arg)
        self.types[arg] = arg_type

    def _convert_type(self, arg, value):
        """"""
        Try to convert the type of input value by searching in self.types.
        :param arg: str, argument name
        :param value: str, the input value in command line
        :return: return corresponding value in self.types if convert successfully, or the input value otherwise
        """"""
        arg_type = self.types.get(arg, str)
        try:
            return arg_type(value)
        except ValueError:
            return value
```

This implementation completes the `ArgumentParser` class by adding the necessary methods to parse command line arguments, retrieve argument values, add arguments with specified types, and convert argument values to their specified types.",0.098143236,0.121570302,0.692307692,0.321428571,0.439024386,0.525423729,0.180232558,0.268398265,0.692307692,0.321428571,0.439024386,,,,,,,,,,,,
GPT,3,"import itertools


class ArrangementCalculator:
    def __init__(self, datas):
        self.datas = datas

    @staticmethod
    def count(n, m=None):
        if m is None or n == m:
            return ArrangementCalculator.factorial(n)
        else:
            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)

    @staticmethod
    def count_all(n):
        total = 0
        for i in range(1, n + 1):
            total += ArrangementCalculator.count(n, i)
        return total

    def select(self, m=None):
        if m is None:
            m = len(self.datas)
        result = []
        for permutation in itertools.permutations(self.datas, m):
            result.append(list(permutation))
        return result

    def select_all(self):
        result = []
        for i in range(1, len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    @staticmethod
    def factorial(n):
        result = 1
        for i in range(2, n + 1):
            result *= i
        return result",FewShot,"```python
import itertools

class ArrangementCalculator:
    """"""
    The Arrangement class provides permutation calculations and selection operations for a given set of data elements.
    """"""

    def __init__(self, datas):
        """"""
        Initializes the ArrangementCalculator object with a list of datas.
        :param datas: List, the data elements to be used for arrangements.
        """"""
        self.datas = datas

    @staticmethod
    def count(n, m=None):
        """"""
        Counts the number of arrangements by choosing m items from n items (permutations).
        If m is not provided or n equals m, returns factorial(n).
        :param n: int, the total number of items.
        :param m: int, the number of items to be chosen (default=None).
        :return: int, the count of arrangements.
        >>> ArrangementCalculator.count(5, 3)
        60
        """"""
        if m is None or m == n:
            return ArrangementCalculator.factorial(n)
        else:
            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)

    @staticmethod
    def count_all(n):
        """"""
        Counts the total number of all possible arrangements by choosing at least 1 item and at most n items from n items.
        :param n: int, the total number of items.
        :return: int, the count of all arrangements.
        >>> ArrangementCalculator.count_all(4)
        64
        """"""
        total = 0
        for i in range(1, n + 1):
            total += ArrangementCalculator.count(n, i)
        return total

    def select(self, m=None):
        """"""
        Generates a list of arrangements by selecting m items from the internal datas.
        If m is not provided, selects all items.
        :param m: int, the number of items to be chosen (default=None).
        :return: List, a list of arrangements.
        >>> ac = ArrangementCalculator([1, 2, 3, 4])
        >>> ac.select(2)
        [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]
        """"""
        if m is None:
            m = len(self.datas)
        return list(itertools.permutations(self.datas, m))

    def select_all(self):
        """"""
        Generates a list of all arrangements by selecting at least 1 item and at most the number of internal datas.
        :return: List, a list of all arrangements.
        >>> ac = ArrangementCalculator([1, 2, 3])
        >>> ac.select_all()
        [[1], [2], [3], [1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2], [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
        """"""
        all_arrangements = []
        for i in range(1, len(self.datas) + 1):
            all_arrangements.extend(self.select(i))
        return all_arrangements

    @staticmethod
    def factorial(n):
        """"""
        Calculates the factorial of a given number.
        :param n: int, the number to calculate the factorial.
        :return: int, the factorial of the given number.
        >>> ArrangementCalculator.factorial(4)
        24
        """"""
        if n == 0 or n == 1:
            return 1
        else:
            return n * ArrangementCalculator.factorial(n - 1)
```",0.127764128,0.143084351,0.913793103,0.350993377,0.507177029,0.673913043,0.214532872,0.325459314,0.896551724,0.344370861,0.497607651,,,,,,,,,,,,
GPT,4,"class AssessmentSystem:
    def __init__(self):
        self.students = {}

    def add_student(self, name, grade, major):
        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}

    def add_course_score(self, name, course, score):
        if name in self.students:
            self.students[name]['courses'][course] = score

    def get_gpa(self, name):
        if name in self.students and self.students[name]['courses']:
            return sum(self.students[name]['courses'].values()) / len(self.students[name]['courses'])
        else:
            return None

    def get_all_students_with_fail_course(self):
        students = []
        for name, student in self.students.items():
            for course, score in student['courses'].items():
                if score < 60:
                    students.append(name)
                    break
        return students

    def get_course_average(self, course):
        total = 0
        count = 0
        for student in self.students.values():
            if course in student['courses']:
                score = student['courses'][course]
                if score is not None:
                    total += score
                    count += 1
        return total / count if count > 0 else None

    def get_top_student(self):
        top_student = None
        top_gpa = 0
        for name, student in self.students.items():
            gpa = self.get_gpa(name)
            if gpa is not None and gpa > top_gpa:
                top_gpa = gpa
                top_student = name
        return top_student",FewShot,"```python
class AssessmentSystem:
    """"""
    This is a class as a student assessment system, which supports adding students, adding course scores, calculating GPA, and other functions for students and courses.
    """"""

    def __init__(self):
        """"""
        Initialize the students dict in the assessment system.
        """"""
        self.students = {}

    def add_student(self, name, grade, major):
        """"""
        Add a new student into self.students dict.
        :param name: str, student name
        :param grade: int, student grade
        :param major: str, student major
        """"""
        # Add a new student with an empty courses dictionary
        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}

    def add_course_score(self, name, course, score):
        """"""
        Add score of a specific course for a student in self.students.
        :param name: str, student name
        :param course: str, course name
        :param score: int, course score
        """"""
        # Check if the student exists and add the course score
        if name in self.students:
            self.students[name]['courses'][course] = score

    def get_gpa(self, name):
        """"""
        Get the average grade of one student.
        :param name: str, student name
        :return: float, average grade or None if no courses
        """"""
        # Check if the student exists
        if name in self.students:
            courses = self.students[name]['courses']
            # Calculate GPA if the student has courses
            if courses:
                return sum(courses.values()) / len(courses)
        return None

    def get_all_students_with_fail_course(self):
        """"""
        Get all students who have any score below 60.
        :return: list of str, student names
        """"""
        failed_students = []
        # Iterate through students to find those with failing scores
        for name, info in self.students.items():
            if any(score < 60 for score in info['courses'].values()):
                failed_students.append(name)
        return failed_students

    def get_course_average(self, course):
        """"""
        Get the average score of a specific course.
        :param course: str, course name
        :return: float, average score of this course or None if no records
        """"""
        total_score = 0
        count = 0
        # Iterate through students to calculate the course average
        for info in self.students.values():
            if course in info['courses']:
                total_score += info['courses'][course]
                count += 1
        if count > 0:
            return total_score / count
        return None

    def get_top_student(self):
        """"""
        Calculate every student's GPA with get_gpa method, and find the student with the highest GPA.
        :return: str, name of student whose GPA is highest
        """"""
        top_student = None
        highest_gpa = 0
        # Iterate through students to find the top student
        for name in self.students:
            gpa = self.get_gpa(name)
            if gpa is not None and gpa > highest_gpa:
                highest_gpa = gpa
                top_student = name
        return top_student
```",0.143603133,0.178197738,0.794520548,0.381578947,0.515555551,0.571428571,0.253968254,0.351648347,0.794520548,0.381578947,0.515555551,,,,,,,,,,,,
GPT,5,"class AutomaticGuitarSimulator:
    def __init__(self, text) -> None:
        self.play_text = text

    def interpret(self, display=False):
        if len(self.play_text) == 0:
            return
        else:
            play_list = []
            play_segs = self.play_text.split("" "")
            for play_seg in play_segs:
                pos = 0
                for ele in play_seg:
                    if ele.isalpha():
                        pos += 1
                        continue
                    break
                play_chord = play_seg[0:pos]
                play_value = play_seg[pos:]
                play_list.append({'Chord': play_chord, 'Tune': play_value})
                if display:
                    self.display(play_chord, play_value)
            return play_list

    def display(self, key, value):
        return ""Normal Guitar Playing -- Chord: %s, Play Tune: %s"" % (key, value)",FewShot,"```python
class AutomaticGuitarSimulator:
    """"""
    This class is an automatic guitar simulator that can interpret and play based on the input guitar sheet music.
    """"""

    def __init__(self, text) -> None:
        """"""
        Initialize the score to be played
        :param text:str, score to be played
        """"""
        self.play_text = text

    def interpret(self, display=False):
        """"""
        Interpret the music score to be played
        :param display:Bool, representing whether to print the interpreted score
        :return:list of dict, The dict includes two fields, Chord and Tune, which are letters and numbers, respectively
        >>> context = AutomaticGuitarSimulator(""C53231323 Em43231323 F43231323 G63231323"")
        >>> play_list = context.interpret(display = False)
        [{'Chord': 'C', 'Tune': '53231323'}, {'Chord': 'Em', 'Tune': '43231323'}, {'Chord': 'F', 'Tune': '43231323'}, {'Chord': 'G', 'Tune': '63231323'}]
        """"""
        # Split the input text by spaces to separate each chord-tune pair
        items = self.play_text.split()
        # Initialize an empty list to store the interpreted music score
        play_list = []
        
        for item in items:
            # Find the first digit in the string to separate chord and tune
            for index, char in enumerate(item):
                if char.isdigit():
                    # Chord is the substring before the first digit
                    chord = item[:index]
                    # Tune is the substring starting from the first digit
                    tune = item[index:]
                    # Add the chord and tune as a dictionary to the play_list
                    play_list.append({'Chord': chord, 'Tune': tune})
                    break
        
        # If display is True, print each chord and tune using the display method
        if display:
            for chord_tune in play_list:
                self.display(chord_tune['Chord'], chord_tune['Tune'])
        
        return play_list

    def display(self, key, value):
        """"""
        Print out chord and play tune with following format: Normal Guitar Playing -- Chord: %s, Play Tune: %s
        :param key:str, chord
        :param value:str, play tune
        :return: str
        >>> context = AutomaticGuitarSimulator(""C53231323 Em43231323 F43231323 G63231323"")
        >>> context.display(""C"", ""53231323"")
        Normal Guitar Playing -- Chord: C, Play Tune: 53231323
        """"""
        # Format and print the chord and tune information
        print(f""Normal Guitar Playing -- Chord: {key}, Play Tune: {value}"")
```",0.056478405,0.071046573,0.515625,0.2,0.288209603,0.329268293,0.103846154,0.157894733,0.515625,0.2,0.288209603,,,,,,,,,,,,
GPT,6,"class AvgPartition:
    def __init__(self, lst, limit):
        self.lst = lst
        self.limit = limit

    def setNum(self):
        size = len(self.lst) // self.limit
        remainder = len(self.lst) % self.limit
        return size, remainder

        
    def get(self, index):
        size, remainder = self.setNum()
        start = index * size + min(index, remainder)
        end = start + size
        if index + 1 <= remainder:
            end += 1
        return self.lst[start:end]",FewShot,"```python
class AvgPartition:
    """"""
    This is a class that partitions the given list into different blocks by specifying the number of partitions, 
    with each block having a uniformly distributed length.
    """"""

    def __init__(self, lst, limit):
        """"""
        Initialize the class with the given list and the number of partitions, 
        and check if the number of partitions is greater than 0.
        """"""
        self.lst = lst
        self.limit = limit

    def setNum(self):
        """"""
        Calculate the size of each block and the remainder of the division.
        :return: the size of each block and the remainder of the division, tuple.
        >>> a = AvgPartition([1, 2, 3, 4], 2)
        >>> a.setNum()
        (2, 0)
        """"""
        # Calculate the size of each block
        block_size = len(self.lst) // self.limit
        # Calculate the remainder
        remainder = len(self.lst) % self.limit
        return block_size, remainder

    def get(self, index):
        """"""
        Calculate the size of each block and the remainder of the division, 
        and calculate the corresponding start and end positions based on the index of the partition.
        :param index: the index of the partition, int.
        :return: the corresponding block, list.
        >>> a = AvgPartition([1, 2, 3, 4], 2)
        >>> a.get(0)
        [1, 2]
        """"""
        block_size, remainder = self.setNum()
        # Calculate the start position
        start = index * block_size + min(index, remainder)
        # Calculate the end position
        end = start + block_size + (1 if index < remainder else 0)
        # Return the corresponding block
        return self.lst[start:end]
```",0.096069869,0.115631523,0.857142857,0.309278351,0.454545451,0.627118644,0.212643678,0.317596563,0.857142857,0.309278351,0.454545451,,,,,,,,,,,,
GPT,7,"class BalancedBrackets:
    def __init__(self, expr):
        self.stack = []
        self.left_brackets = [""("", ""{"", ""[""]
        self.right_brackets = ["")"", ""}"", ""]""]
        self.expr = expr

    def clear_expr(self):
        self.expr = ''.join(c for c in self.expr if (c in self.left_brackets or c in self.right_brackets))

    def check_balanced_brackets(self):
        self.clear_expr()
        for Brkt in self.expr:
            if Brkt in self.left_brackets:
                self.stack.append(Brkt)
            else:
                Current_Brkt = self.stack.pop()
                if Current_Brkt == ""("":
                    if Brkt != "")"":
                        return False
                if Current_Brkt == ""{"":
                    if Brkt != ""}"":
                        return False
                if Current_Brkt == ""["":
                    if Brkt != ""]"":
                        return False
        if self.stack:
            return False
        return True",FewShot,"```python
class BalancedBrackets:
    """"""
    This is a class that checks for bracket matching
    """"""

    def __init__(self, expr):
        """"""
        Initializes the class with an expression.
        :param expr: The expression to check for balanced brackets, str.
        """"""
        self.stack = []
        self.left_brackets = [""("", ""{"", ""[""]
        self.right_brackets = ["")"", ""}"", ""]""]
        self.expr = expr

    def clear_expr(self):
        """"""
        Clears the expression of all characters that are not brackets.
        >>> b = BalancedBrackets(""a(b)c"")
        >>> b.clear_expr()
        >>> b.expr
        '()'
        """"""
        # Use a list comprehension to filter only bracket characters
        self.expr = ''.join([char for char in self.expr if char in self.left_brackets + self.right_brackets])

    def check_balanced_brackets(self):
        """"""
        Checks if the expression has balanced brackets.
        :return: True if the expression has balanced brackets, False otherwise.
        >>> b = BalancedBrackets(""a(b)c"")
        >>> b.check_balanced_brackets()
        True
        """"""
        # Clear the expression to contain only brackets
        self.clear_expr()

        # Dictionary to map left brackets to their corresponding right brackets
        bracket_map = {"")"": ""("", ""}"": ""{"", ""]"": ""[""}

        # Iterate through each character in the expression
        for char in self.expr:
            # If it's a left bracket, push it onto the stack
            if char in self.left_brackets:
                self.stack.append(char)
            # If it's a right bracket
            elif char in self.right_brackets:
                # If the stack is empty or the top of the stack doesn't match the corresponding left bracket, return False
                if not self.stack or self.stack.pop() != bracket_map[char]:
                    return False

        # If the stack is empty, all brackets were matched; otherwise, return False
        return not self.stack
```",0.085106383,0.116491649,0.714285714,0.299145299,0.421686743,0.45,0.172248804,0.249134944,0.714285714,0.299145299,0.421686743,,,,,,,,,,,,
GPT,8,"class BankAccount:
    def __init__(self, balance=0):
        self.balance = balance

    def deposit(self, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        self.balance += amount
        return self.balance

    def withdraw(self, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient balance."")
        self.balance -= amount
        return self.balance

    def view_balance(self):
        return self.balance

    def transfer(self, other_account, amount):
        self.withdraw(amount)
        other_account.deposit(amount)",FewShot,"```python
class BankAccount:
    """"""
    This is a class for a bank account system, which supports depositing money, withdrawing money, viewing balance, and transferring money.
    """"""

    def __init__(self, balance=0):
        """"""
        Initializes a bank account object with an attribute balance, default value is 0.
        """"""
        self.balance = balance

    def deposit(self, amount):
        """"""
        Deposits a certain amount into the account, increasing the account balance, return the current account balance.
        If amount is negative, raise a ValueError(""Invalid amount"").
        :param amount: int
        """"""
        if amount < 0:
            raise ValueError(""Invalid amount"")
        self.balance += amount
        return self.balance

    def withdraw(self, amount):
        """"""
        Withdraws a certain amount from the account, decreasing the account balance, return the current account balance.
        If amount is negative, raise a ValueError(""Invalid amount"").
        If the withdrawal amount is greater than the account balance, raise a ValueError(""Insufficient balance."").
        :param amount: int
        """"""
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient balance."")
        self.balance -= amount
        return self.balance

    def view_balance(self):
        """"""
        Return the account balance.
        """"""
        return self.balance

    def transfer(self, other_account, amount):
        """"""
        Transfers a certain amount from the current account to another account.
        :param other_account: BankAccount
        :param amount: int
        >>> account1 = BankAccount()
        >>> account2 = BankAccount()
        >>> account1.deposit(1000)
        >>> account1.transfer(account2, 300)
        account1.balance = 700 account2.balance = 300
        """"""
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient balance."")
        self.withdraw(amount)
        other_account.deposit(amount)
```

- The `deposit` method adds the specified amount to the balance, raising an error if the amount is negative.
- The `withdraw` method deducts the specified amount from the balance, raising an error if the amount is negative or if the balance is insufficient.
- The `view_balance` method simply returns the current balance.
- The `transfer` method transfers funds from one account to another, ensuring the amount is valid and the balance is sufficient.",0.138513514,0.149848003,1,0.267241379,0.421768704,0.888888889,0.194174757,0.318725097,1,0.267241379,0.421768704,,,,,,,,,,,,
GPT,9,"class BigNumCalculator:
    @staticmethod
    def add(num1, num2):
        max_length = max(len(num1), len(num2))
        num1 = num1.zfill(max_length)
        num2 = num2.zfill(max_length)

        carry = 0
        result = []
        for i in range(max_length - 1, -1, -1):
            digit_sum = int(num1[i]) + int(num2[i]) + carry
            carry = digit_sum // 10
            digit = digit_sum % 10
            result.insert(0, str(digit))

        if carry > 0:
            result.insert(0, str(carry))

        return ''.join(result)

    @staticmethod
    def subtract(num1, num2):

        if len(num1) < len(num2):
            num1, num2 = num2, num1
            negative = True
        elif len(num1) > len(num2):
            negative = False
        else:
            if num1 < num2:
                num1, num2 = num2, num1
                negative = True
            else:
                negative = False

        max_length = max(len(num1), len(num2))
        num1 = num1.zfill(max_length)
        num2 = num2.zfill(max_length)

        borrow = 0
        result = []
        for i in range(max_length - 1, -1, -1):
            digit_diff = int(num1[i]) - int(num2[i]) - borrow

            if digit_diff < 0:
                digit_diff += 10
                borrow = 1
            else:
                borrow = 0

            result.insert(0, str(digit_diff))

        while len(result) > 1 and result[0] == '0':
            result.pop(0)

        if negative:
            result.insert(0, '-')

        return ''.join(result)

    @staticmethod
    def multiply(num1, num2):
        len1, len2 = len(num1), len(num2)
        result = [0] * (len1 + len2)

        for i in range(len1 - 1, -1, -1):
            for j in range(len2 - 1, -1, -1):
                mul = int(num1[i]) * int(num2[j])
                p1, p2 = i + j, i + j + 1
                total = mul + result[p2]

                result[p1] += total // 10
                result[p2] = total % 10

        start = 0
        while start < len(result) - 1 and result[start] == 0:
            start += 1

        return ''.join(map(str, result[start:]))",FewShot,"```python
class BigNumCalculator:
    """"""
    This is a class that implements big number calculations, including adding, subtracting and multiplying.
    """"""

    @staticmethod
    def add(num1, num2):
        """"""
        Adds two big numbers.
        :param num1: The first number to add, str.
        :param num2: The second number to add, str.
        :return: The sum of the two numbers, str.
        >>> bigNum = BigNumCalculator()
        >>> bigNum.add(""12345678901234567890"", ""98765432109876543210"")
        '111111111011111111100'
        """"""
        # Convert string numbers to integers, add them, then convert back to string
        return str(int(num1) + int(num2))

    @staticmethod
    def subtract(num1, num2):
        """"""
        Subtracts two big numbers.
        :param num1: The first number to subtract, str.
        :param num2: The second number to subtract, str.
        :return: The difference of the two numbers, str.
        >>> bigNum = BigNumCalculator()
        >>> bigNum.subtract(""12345678901234567890"", ""98765432109876543210"")
        '-86419753208641975320'
        """"""
        # Convert string numbers to integers, subtract them, then convert back to string
        return str(int(num1) - int(num2))

    @staticmethod
    def multiply(num1, num2):
        """"""
        Multiplies two big numbers.
        :param num1: The first number to multiply, str.
        :param num2: The second number to multiply, str.
        :return: The product of the two numbers, str.
        >>> bigNum = BigNumCalculator()
        >>> bigNum.multiply(""12345678901234567890"", ""98765432109876543210"")
        '1219326311370217952237463801111263526900'
        """"""
        # Convert string numbers to integers, multiply them, then convert back to string
        return str(int(num1) * int(num2))
```",0.024610297,0.033509171,0.163043478,0.2,0.179640714,0.042780749,0.074074074,0.054237283,0.152173913,0.186666667,0.167664666,,,,,,,,,,,,
GPT,10,"class BinaryDataProcessor:
    def __init__(self, binary_string):
        self.binary_string = binary_string
        self.clean_non_binary_chars()

    def clean_non_binary_chars(self):
        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))

    def calculate_binary_info(self):
        zeroes_count = self.binary_string.count('0')
        ones_count = self.binary_string.count('1')
        total_length = len(self.binary_string)

        zeroes_percentage = (zeroes_count / total_length)
        ones_percentage = (ones_count / total_length)

        return {
            'Zeroes': zeroes_percentage,
            'Ones': ones_percentage,
            'Bit length': total_length
        }

    def convert_to_ascii(self):
        byte_array = bytearray()
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            decimal = int(byte, 2)
            byte_array.append(decimal)

        return byte_array.decode('ascii')

    def convert_to_utf8(self):
        byte_array = bytearray()
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            decimal = int(byte, 2)
            byte_array.append(decimal)

        return byte_array.decode('utf-8')",FewShot,"```python
class BinaryDataProcessor:
    """"""
    This is a class used to process binary data, which includes functions such as clearing non 0 or 1 characters,
    counting binary string information, and converting to corresponding strings based on different encoding methods.
    """"""

    def __init__(self, binary_string):
        """"""
        Initialize the class with a binary string and clean it by removing all non 0 or 1 characters.
        """"""
        self.binary_string = binary_string
        self.clean_non_binary_chars()

    def clean_non_binary_chars(self):
        """"""
        Clean the binary string by removing all non 0 or 1 characters.
        """"""
        # Use a list comprehension to filter out non '0' or '1' characters
        self.binary_string = ''.join([char for char in self.binary_string if char in '01'])

    def calculate_binary_info(self):
        """"""
        Calculate the binary string information, including the percentage of 0 and 1, and the total length of the binary string.
        """"""
        # Calculate the total length of the binary string
        total_length = len(self.binary_string)
        # Calculate the count of '0's and '1's
        count_zeroes = self.binary_string.count('0')
        count_ones = self.binary_string.count('1')
        # Calculate the percentage of '0's and '1's
        percentage_zeroes = count_zeroes / total_length
        percentage_ones = count_ones / total_length
        # Return the calculated information as a dictionary
        return {
            'Zeroes': percentage_zeroes,
            'Ones': percentage_ones,
            'Bit length': total_length
        }

    def convert_to_ascii(self):
        """"""
        Convert the binary string to ascii string.
        """"""
        # Split the binary string into chunks of 8 bits (1 byte)
        chars = [self.binary_string[i:i+8] for i in range(0, len(self.binary_string), 8)]
        # Convert each byte to an ASCII character and join them into a string
        ascii_string = ''.join([chr(int(char, 2)) for char in chars])
        return ascii_string

    def convert_to_utf8(self):
        """"""
        Convert the binary string to utf-8 string.
        """"""
        # Split the binary string into chunks of 8 bits (1 byte)
        chars = [self.binary_string[i:i+8] for i in range(0, len(self.binary_string), 8)]
        # Convert each byte to an ASCII character and join them into a string
        utf8_string = ''.join([chr(int(char, 2)) for char in chars])
        return utf8_string
```

- `clean_non_binary_chars`: Filters the input string to retain only '0' and '1' characters.
- `calculate_binary_info`: Computes the percentage of '0's and '1's and the total length of the cleaned binary string.
- `convert_to_ascii` and `convert_to_utf8`: Both methods convert the binary string to a human-readable format by interpreting every 8 bits as a character.",0.047752809,0.065133417,0.596491228,0.225165563,0.326923073,0.382716049,0.123015873,0.186186183,0.578947368,0.218543046,0.317307688,,,,,,,,,,,,
GPT,11,"class BitStatusUtil:
    @staticmethod
    def add(states, stat):
        BitStatusUtil.check([states, stat])
        return states | stat

    @staticmethod
    def has(states, stat):
        BitStatusUtil.check([states, stat])
        return (states & stat) == stat

    @staticmethod
    def remove(states, stat):
        BitStatusUtil.check([states, stat])
        if BitStatusUtil.has(states, stat):
            return states ^ stat
        return states

    @staticmethod
    def check(args):
        for arg in args:
            if arg < 0:
                raise ValueError(f""{arg} must be greater than or equal to 0"")
            if arg % 2 != 0:
                raise ValueError(f""{arg} not even"")",FewShot,"```python
class BitStatusUtil:
    """"""
    This is a utility class that provides methods for manipulating and checking status using bitwise operations.
    """"""

    @staticmethod
    def add(states, stat):
        """"""
        Add a status to the current status, and check the parameters whether they are legal.
        :param states: Current status, int.
        :param stat: Status to be added, int.
        :return: The status after adding the status, int.
        >>> bit_status_util = BitStatusUtil()
        >>> bit_status_util.add(2, 4)
        6
        """"""
        BitStatusUtil.check([states, stat])
        # Use bitwise OR to add the status
        return states | stat

    @staticmethod
    def has(states, stat):
        """"""
        Check if the current status contains the specified status, and check the parameters whether they are legal.
        :param states: Current status, int.
        :param stat: Specified status, int.
        :return: True if the current status contains the specified status, otherwise False, bool.
        >>> bit_status_util = BitStatusUtil()
        >>> bit_status_util.has(6, 2)
        True
        """"""
        BitStatusUtil.check([states, stat])
        # Use bitwise AND to check if status is present
        return (states & stat) == stat

    @staticmethod
    def remove(states, stat):
        """"""
        Remove the specified status from the current status, and check the parameters whether they are legal.
        :param states: Current status, int.
        :param stat: Specified status, int.
        :return: The status after removing the specified status, int.
        >>> bit_status_util = BitStatusUtil()
        >>> bit_status_util.remove(6, 2)
        4
        """"""
        BitStatusUtil.check([states, stat])
        # Use bitwise AND with NOT to remove the status
        return states & ~stat

    @staticmethod
    def check(args):
        """"""
        Check if the parameters are legal, args must be greater than or equal to 0 and must be even, if not, raise ValueError.
        :param args: Parameters to be checked, list.
        :return: None.
        >>> bit_status_util = BitStatusUtil()
        >>> bit_status_util.check([2, 3, 4])
        Traceback (most recent call last):
        ...
        ValueError: 3 not even
        """"""
        for arg in args:
            if arg < 0:
                raise ValueError(f""{arg} is less than 0"")
            if arg % 2 != 0:
                raise ValueError(f""{arg} not even"")
```

- The `add` method uses the bitwise OR operator to add a status.
- The `has` method uses the bitwise AND operator to check if a status is present.
- The `remove` method uses the bitwise AND with NOT operator to remove a status.
- The `check` method ensures all arguments are non-negative and even, raising a `ValueError` if not.",0.108635097,0.124966725,0.976744186,0.283783784,0.439790572,0.75,0.176470588,0.285714283,0.976744186,0.283783784,0.439790572,,,,,,,,,,,,
GPT,12,"import random


class BlackjackGame:
    def __init__(self):
        self.deck = self.create_deck()
        self.player_hand = []
        self.dealer_hand = []

    def create_deck(self):
        deck = []
        suits = ['S', 'C', 'D', 'H']
        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
        for suit in suits:
            for rank in ranks:
                deck.append(rank + suit)
        random.shuffle(deck)
        return deck

    def calculate_hand_value(self, hand):
        value = 0
        num_aces = 0
        for card in hand:
            rank = card[:-1]
            if rank.isdigit():
                value += int(rank)
            elif rank in ['J', 'Q', 'K']:
                value += 10
            elif rank == 'A':
                value += 11
                num_aces += 1
        while value > 21 and num_aces > 0:
            value -= 10
            num_aces -= 1
        return value

    def check_winner(self, player_hand, dealer_hand):
        player_value = self.calculate_hand_value(player_hand)
        dealer_value = self.calculate_hand_value(dealer_hand)
        if player_value > 21 and dealer_value > 21:
            if player_value <= dealer_value:
                return 'Player wins'
            else:
                return 'Dealer wins'
        elif player_value > 21:
            return 'Dealer wins'
        elif dealer_value > 21:
            return 'Player wins'
        else:
            if player_value <= dealer_value:
                return 'Dealer wins'
            else:
                return 'Player wins'",FewShot,"```python
import random

class BlackjackGame:
    """"""
    This is a class representing a game of blackjack, which includes creating a deck, calculating the value of a hand, and determine the winner based on the hand values of the player and dealer.
    """"""

    def __init__(self):
        """"""
        Initialize the Blackjack Game with the attribute deck, player_hand and dealer_hand.
        While initializing deck attribute, call the create_deck method to generate.
        The deck stores 52 random order poker with the Jokers removed, format is ['AS', '2S', ...].
        player_hand is a list which stores player's hand cards.
        dealer_hand is a list which stores dealer's hand cards.
        """"""
        self.deck = self.create_deck()
        self.player_hand = []
        self.dealer_hand = []

    def create_deck(self):
        """"""
        Create a deck of 52 cards, which stores 52 random order poker with the Jokers removed.
        :return: a list of 52 random order poker with the Jokers removed, format is ['AS', '2S', ...].
        """"""
        # Suits and ranks for a standard deck of cards
        suits = ['S', 'H', 'D', 'C']
        ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
        
        # Create the deck by combining each rank with each suit
        deck = [rank + suit for suit in suits for rank in ranks]
        
        # Shuffle the deck to randomize the order
        random.shuffle(deck)
        
        return deck

    def calculate_hand_value(self, hand):
        """"""
        Calculate the value of the poker cards stored in hand list according to the rules of the Blackjack Game.
        If the card is a digit, its value is added to the total hand value.
        Value of J, Q, or K is 10, while Aces are worth 11.
        If the total hand value exceeds 21 and there are Aces present, one Ace is treated as having a value of 1 instead of 11,
        until the hand value is less than or equal to 21, or all Aces have been counted as value of 1.
        :param hand: list
        :return: the value of the poker cards stored in hand list, a number.
        """"""
        value = 0
        ace_count = 0
        
        # Calculate initial hand value and count aces
        for card in hand:
            rank = card[:-1]  # Get the rank part of the card
            if rank.isdigit():  # If the rank is a number
                value += int(rank)
            elif rank in ['J', 'Q', 'K']:  # Face cards are worth 10
                value += 10
            elif rank == 'A':  # Count Aces as 11 initially
                value += 11
                ace_count += 1
        
        # Adjust for Aces if value exceeds 21
        while value > 21 and ace_count:
            value -= 10
            ace_count -= 1
        
        return value

    def check_winner(self, player_hand, dealer_hand):
        """"""
        Determines the winner of a game by comparing the hand values of the player and dealer.
        rule:
        If both players have hand values that are equal to or less than 21, the winner is the one whose hand value is closer to 21.
        Otherwise, the winner is the one with the lower hand value.
        :param player_hand: list
        :param dealer_hand: list
        :return: the result of the game, only two certain str: 'Dealer wins' or 'Player wins'
        """"""
        player_value = self.calculate_hand_value(player_hand)
        dealer_value = self.calculate_hand_value(dealer_hand)

        # Determine the winner based on the calculated hand values
        if player_value > 21:
            return 'Dealer wins'
        elif dealer_value > 21:
            return 'Player wins'
        elif player_value > dealer_value:
            return 'Player wins'
        else:
            return 'Dealer wins'
```",0.146025878,0.167899084,0.857142857,0.334883721,0.481605347,0.678571429,0.219399538,0.331588129,0.857142857,0.334883721,0.481605347,,,,,,,,,,,,
GPT,13,"class BookManagement:
    def __init__(self):
        self.inventory = {}

    def add_book(self, title, quantity=1):
        if title in self.inventory:
            self.inventory[title] += quantity
        else:
            self.inventory[title] = quantity

    def remove_book(self, title, quantity):
        if title not in self.inventory or self.inventory[title] < quantity:
            raise False
        self.inventory[title] -= quantity
        if self.inventory[title] == 0:
            del (self.inventory[title])

    def view_inventory(self):
        return self.inventory

    def view_book_quantity(self, title):
        if title not in self.inventory:
            return 0
        return self.inventory[title]",FewShot,"```python
class BookManagement:
    """"""
    This is a class for managing a book system, which supports adding and removing books from the inventory dict, viewing the inventory, and checking the quantity of a specific book.
    """"""

    def __init__(self):
        """"""
        Initialize the inventory of Book Manager.
        """"""
        self.inventory = {}

    def add_book(self, title, quantity=1):
        """"""
        Add one or several books to inventory which is sorted by book title.
        :param title: str, the book title
        :param quantity: int, default value is 1.
        """"""
        if title in self.inventory:
            self.inventory[title] += quantity
        else:
            self.inventory[title] = quantity

    def remove_book(self, title, quantity):
        """"""
        Remove one or several books from inventory which is sorted by book title.
        Raise an error if the input is invalid.
        :param title: str, the book title
        :param quantity: int
        """"""
        if title in self.inventory:
            if self.inventory[title] >= quantity:
                self.inventory[title] -= quantity
                if self.inventory[title] == 0:
                    del self.inventory[title]
            else:
                raise ValueError(""Cannot remove more books than are available in inventory."")
        else:
            raise KeyError(""Book title not found in inventory."")

    def view_inventory(self):
        """"""
        Get the inventory of the Book Management.
        :return self.inventory: dictionary, {title(str): quantity(int), ...}
        """"""
        return self.inventory

    def view_book_quantity(self, title):
        """"""
        Get the quantity of a book.
        :param title: str, the title of the book.
        :return quantity: the quantity of this book title. return 0 when the title does not exist in self.inventory
        """"""
        return self.inventory.get(title, 0)
```",0.122171946,0.156093154,0.894736842,0.326923077,0.478873236,0.672413793,0.216666667,0.327731089,0.894736842,0.326923077,0.478873236,,,,,,,,,,,,
GPT,14,"import sqlite3

class BookManagementDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS books (
                id INTEGER PRIMARY KEY,
                title TEXT,
                author TEXT,
                available INTEGER
            )
        ''')
        self.connection.commit()

    def add_book(self, title, author):
        self.cursor.execute('''
            INSERT INTO books (title, author, available)
            VALUES (?, ?, 1)
        ''', (title, author))
        self.connection.commit()

    def remove_book(self, book_id):
        self.cursor.execute('''
            DELETE FROM books WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def borrow_book(self, book_id):
        self.cursor.execute('''
            UPDATE books SET available = 0 WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def return_book(self, book_id):
        self.cursor.execute('''
            UPDATE books SET available = 1 WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def search_books(self):
        self.cursor.execute('''
            SELECT * FROM books
        ''')
        books = self.cursor.fetchall()
        return books",FewShot,"```python
import sqlite3

class BookManagementDB:
    """"""
    This is a database class as a book management system, used to handle the operations of adding, removing, updating, and searching books.
    """"""

    def __init__(self, db_name):
        """"""
        Initializes the class by creating a database connection and cursor, 
        and creates the book table if it does not already exist
        :param db_name: str, the name of db file
        """"""
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        """"""
        Creates the book table in the database if it does not already exist.
        """"""
        # SQL command to create a table
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS books (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                author TEXT NOT NULL,
                available INTEGER NOT NULL DEFAULT 1
            )
        ''')
        self.connection.commit()

    def add_book(self, title, author):
        """"""
        Adds a book to the database with the specified title and author, 
        setting its availability to 1 as free to borrow.
        :param title: str, book title
        :param author: str, author name
        """"""
        # SQL command to insert a new book
        self.cursor.execute('''
            INSERT INTO books (title, author, available) VALUES (?, ?, 1)
        ''', (title, author))
        self.connection.commit()

    def remove_book(self, book_id):
        """"""
        Removes a book from the database based on the given book ID.
        :param book_id: int
        """"""
        # SQL command to delete a book by ID
        self.cursor.execute('''
            DELETE FROM books WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def borrow_book(self, book_id):
        """"""
        Marks a book as borrowed in the database based on the given book ID.
        :param book_id: int
        """"""
        # SQL command to update a book's availability to 0 (borrowed)
        self.cursor.execute('''
            UPDATE books SET available = 0 WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def return_book(self, book_id):
        """"""
        Marks a book as returned in the database based on the given book ID.
        :param book_id: int
        """"""
        # SQL command to update a book's availability to 1 (available)
        self.cursor.execute('''
            UPDATE books SET available = 1 WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def search_books(self):
        """"""
        Retrieves all books from the database and returns their information.
        :return books: list[tuple], the information of all books in database
        """"""
        # SQL command to select all books
        self.cursor.execute('''
            SELECT * FROM books
        ''')
        books = self.cursor.fetchall()
        return books
```",0.250696379,0.265425648,0.96969697,0.418300654,0.584474882,0.868686869,0.320895522,0.468664846,0.96969697,0.418300654,0.584474882,,,,,,,,,,,,
GPT,15,"class BoyerMooreSearch:
    def __init__(self, text, pattern):
        self.text, self.pattern = text, pattern
        self.textLen, self.patLen = len(text), len(pattern)

    def match_in_pattern(self, char):
        for i in range(self.patLen - 1, -1, -1):
            if char == self.pattern[i]:
                return i
        return -1

    def mismatch_in_text(self, currentPos):
        for i in range(self.patLen - 1, -1, -1):
            if self.pattern[i] != self.text[currentPos + i]:
                return currentPos + i
        return -1

    def bad_character_heuristic(self):
        positions = []
        for i in range(self.textLen - self.patLen + 1):
            mismatch_index = self.mismatch_in_text(i)
            if mismatch_index == -1:
                positions.append(i)
            else:
                match_index = self.match_in_pattern(self.text[mismatch_index])
                i = (mismatch_index - match_index)
        return positions",FewShot,"```python
class BoyerMooreSearch:
    """"""
    This is a class that implements the Boyer-Moore algorithm for string searching, 
    which is used to find occurrences of a pattern within a given text.
    """"""

    def __init__(self, text, pattern):
        """"""
        Initializes the BoyerMooreSearch class with the given text and pattern.
        :param text: The text to be searched, str.
        :param pattern: The pattern to be searched for, str.
        """"""
        self.text, self.pattern = text, pattern
        self.textLen, self.patLen = len(text), len(pattern)

    def match_in_pattern(self, char):
        """"""
        Finds the rightmost occurrence of a character in the pattern.
        :param char: The character to be searched for, str.
        :return: The index of the rightmost occurrence of the character in the pattern, int.
        """"""
        # Start from the end of the pattern and move backwards
        for i in range(self.patLen - 1, -1, -1):
            if self.pattern[i] == char:
                return i
        return -1

    def mismatch_in_text(self, currentPos):
        """"""
        Determines the position of the first mismatch between the pattern and the text.
        :param currentPos: The current position in the text, int.
        :return: The position of the first mismatch between the pattern and the text, int, otherwise -1.
        """"""
        # Compare the pattern with the text starting from currentPos
        for i in range(self.patLen):
            if currentPos + i >= self.textLen or self.pattern[i] != self.text[currentPos + i]:
                return i
        return -1

    def bad_character_heuristic(self):
        """"""
        Finds all occurrences of the pattern in the text using the bad character heuristic.
        :return: A list of all positions of the pattern in the text, list.
        """"""
        if self.patLen == 0:
            return []

        result = []
        shift = 0

        while shift <= self.textLen - self.patLen:
            # Find the first mismatch from the end of the pattern
            mismatch_index = self.mismatch_in_text(shift)

            if mismatch_index == -1:
                # Pattern found at this position
                result.append(shift)
                shift += 1
            else:
                # Calculate the shift using the bad character heuristic
                bad_char_index = self.match_in_pattern(self.text[shift + mismatch_index])
                shift += max(1, mismatch_index - bad_char_index)

        return result
```",0.119354839,0.141306092,0.826923077,0.318518519,0.459893044,0.632183908,0.213178295,0.318840576,0.826923077,0.318518519,0.459893044,,,,,,,,,,,,
GPT,16,"class Calculator:
    def __init__(self):
        self.operators = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '/': lambda x, y: x / y,
            '^': lambda x, y: x ** y
        }

    def calculate(self, expression):
        operand_stack = []
        operator_stack = []
        num_buffer = ''

        for char in expression:
            if char.isdigit() or char == '.':
                num_buffer += char
            else:
                if num_buffer:
                    operand_stack.append(float(num_buffer))
                    num_buffer = ''

                if char in '+-*/^':
                    while (
                            operator_stack and
                            operator_stack[-1] != '(' and
                            self.precedence(operator_stack[-1]) >= self.precedence(char)
                    ):
                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

                    operator_stack.append(char)
                elif char == '(':
                    operator_stack.append(char)
                elif char == ')':
                    while operator_stack and operator_stack[-1] != '(':
                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

                    operator_stack.pop()

        if num_buffer:
            operand_stack.append(float(num_buffer))

        while operator_stack:
            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

        return operand_stack[-1] if operand_stack else None

    def precedence(self, operator):
        precedences = {
            '+': 1,
            '-': 1,
            '*': 2,
            '/': 2,
            '^': 3
        }
        return precedences.get(operator, 0)

    def apply_operator(self, operand_stack, operator_stack):
        operator = operator_stack.pop()
        if operator == '^':
            operand2 = operand_stack.pop()
            operand1 = operand_stack.pop()
            result = self.operators[operator](operand1, operand2)
            operand_stack.append(result)
        else:
            operand2 = operand_stack.pop()
            operand1 = operand_stack.pop()
            result = self.operators[operator](operand1, operand2)
            operand_stack.append(result)
        return operand_stack, operator_stack",FewShot,"```python
class Calculator:
    """"""
    This is a class for a calculator, capable of performing basic arithmetic calculations on numerical expressions using the operators +, -, *, /, and ^ (exponentiation).
    """"""

    def __init__(self):
        """"""
        Initialize the operations performed by the five operators '+', '-', '*', '/', '^'
        """"""
        self.operators = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '/': lambda x, y: x / y,
            '^': lambda x, y: x ** y
        }

    def calculate(self, expression):
        """"""
        Calculate the value of a given expression
        :param expression: string, given expression
        :return: If successful, returns the value of the expression; otherwise, returns None
        """"""
        def parse_expression(expression):
            number = ''
            tokens = []
            for char in expression:
                if char.isdigit() or char == '.':
                    number += char
                else:
                    if number:
                        tokens.append(float(number))
                        number = ''
                    tokens.append(char)
            if number:
                tokens.append(float(number))
            return tokens

        operand_stack = []
        operator_stack = []

        def apply_operator():
            operator = operator_stack.pop()
            right_operand = operand_stack.pop()
            left_operand = operand_stack.pop()
            operand_stack.append(self.operators[operator](left_operand, right_operand))

        tokens = parse_expression(expression)

        for token in tokens:
            if isinstance(token, float):
                operand_stack.append(token)
            else:
                while (operator_stack and
                       self.precedence(operator_stack[-1]) >= self.precedence(token)):
                    apply_operator()
                operator_stack.append(token)

        while operator_stack:
            apply_operator()

        return operand_stack[0] if operand_stack else None

    def precedence(self, operator):
        """"""
        Returns the priority of the specified operator, where the higher the priority, the greater the assignment.
        :param operator: string, given operator
        :return: int, the priority of the given operator, otherwise return 0
        """"""
        precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}
        return precedence.get(operator, 0)

    def apply_operator(self, operand_stack, operator_stack):
        """"""
        Use the operator at the top of the operator stack to perform the operation on the two numbers at the top of the operand stack, and store the results at the top of the operand stack
        :param operand_stack: list
        :param operator_stack: list
        :return: the updated operand_stack and operator_stack
        """"""
        operator = operator_stack.pop()
        right_operand = operand_stack.pop()
        left_operand = operand_stack.pop()
        operand_stack.append(self.operators[operator](left_operand, right_operand))
        return operand_stack, operator_stack
```

This implementation of the `Calculator` class includes methods to parse and evaluate arithmetic expressions, handle operator precedence, and apply operators to operands.",0.209439528,0.246092146,0.724137931,0.36416185,0.48461538,0.536423841,0.268211921,0.35761589,0.724137931,0.36416185,0.48461538,,,,,,,,,,,,
GPT,17,"from datetime import datetime, timedelta

class CalendarUtil:
    def __init__(self):
        self.events = []

    def add_event(self, event):
        self.events.append(event)

    def remove_event(self, event):
        if event in self.events:
            self.events.remove(event)

    def get_events(self, date):
        events_on_date = []
        for event in self.events:
            if event['date'].date() == date.date():
                events_on_date.append(event)
        return events_on_date

    def is_available(self, start_time, end_time):
        for event in self.events:
            if start_time < event['end_time'] and end_time > event['start_time']:
                return False
        return True

    def get_available_slots(self, date):
        available_slots = []
        start_time = datetime(date.year, date.month, date.day, 0, 0)
        end_time = datetime(date.year, date.month, date.day, 23, 59)

        while start_time < end_time:
            slot_end_time = start_time + timedelta(minutes=60)
            if self.is_available(start_time, slot_end_time):
                available_slots.append((start_time, slot_end_time))
            start_time += timedelta(minutes=60)


        return available_slots

    def get_upcoming_events(self, num_events):
        now = datetime.now()
        upcoming_events = []
        for event in self.events:
            if event['start_time'] >= now:
                upcoming_events.append(event)
            if len(upcoming_events) == num_events:
                break
        return upcoming_events",FewShot,"```python
from datetime import datetime, timedelta

class CalendarUtil:
    """"""
    This is a class as CalendarUtil that provides functionalities to manage calendar events, schedule appointments, and perform conflict checks.
    """"""

    def __init__(self):
        """"""
        Initialize the calendar with an empty list of events.
        """"""
        self.events = []

    def add_event(self, event):
        """"""
        Add an event to the calendar.
        :param event: The event to be added to the calendar, dict.
        """"""
        # Append the event to the list of events
        self.events.append(event)

    def remove_event(self, event):
        """"""
        Remove an event from the calendar.
        :param event: The event to be removed from the calendar, dict.
        """"""
        # Remove the event from the list of events if it exists
        if event in self.events:
            self.events.remove(event)

    def get_events(self, date):
        """"""
        Get all events on a given date.
        :param date: The date to get events for, datetime.
        :return: A list of events on the given date, list.
        """"""
        # Filter events that match the given date and return them
        return [event for event in self.events if event['date'].date() == date.date()]

    def is_available(self, start_time, end_time):
        """"""
        Check if the calendar is available for a given time slot.
        :param start_time: The start time of the time slot, datetime.
        :param end_time: The end time of the time slot, datetime.
        :return: True if the calendar is available for the given time slot, False otherwise, bool.
        """"""
        # Check if any existing event overlaps with the given time slot
        for event in self.events:
            if event['start_time'] < end_time and event['end_time'] > start_time:
                return False
        return True

    def get_available_slots(self, date):
        """"""
        Get all available time slots on a given date.
        :param date: The date to get available time slots for, datetime.
        :return: A list of available time slots on the given date, list.
        """"""
        # Define the start and end of the day
        start_of_day = datetime(date.year, date.month, date.day)
        end_of_day = start_of_day + timedelta(days=1)

        # Sort events by start time
        events_on_date = sorted(self.get_events(date), key=lambda x: x['start_time'])

        # Initialize available slots list
        available_slots = []

        # Track the end of the last event
        last_end_time = start_of_day

        # Find gaps between events
        for event in events_on_date:
            if last_end_time < event['start_time']:
                available_slots.append((last_end_time, event['start_time']))
            last_end_time = max(last_end_time, event['end_time'])

        # Check for available slot after the last event
        if last_end_time < end_of_day:
            available_slots.append((last_end_time, end_of_day))

        return available_slots

    def get_upcoming_events(self, num_events):
        """"""
        Get the next n upcoming events from the current date.
        :param num_events: The number of upcoming events to get, int.
        :return: A list of the next n upcoming events, list.
        """"""
        # Sort events by start time
        sorted_events = sorted(self.events, key=lambda x: x['start_time'])

        # Return the next n events
        return sorted_events[:num_events]
```

This implementation completes the `CalendarUtil` class with functionalities to add, remove, and list events, check availability, and find available time slots. Each method is designed to handle events as dictionaries with specific keys for date, start time, end time, and description.",0.077253219,0.093304902,0.706666667,0.299435028,0.420634916,0.441666667,0.151428571,0.225531911,0.68,0.288135593,0.404761901,,,,,,,,,,,,
GPT,18,"class CamelCaseMap:
    def __init__(self):
        self._data = {}

    def __getitem__(self, key):
        return self._data[self._convert_key(key)]

    def __setitem__(self, key, value):
        self._data[self._convert_key(key)] = value

    def __delitem__(self, key):
        del self._data[self._convert_key(key)]

    def __iter__(self):
        return iter(self._data)

    def __len__(self):
        return len(self._data)

    def _convert_key(self, key):
        if isinstance(key, str):
            return self._to_camel_case(key)
        return key

    @staticmethod
    def _to_camel_case(key):
        parts = key.split('_')
        return parts[0] + ''.join(part.title() for part in parts[1:])",FewShot,"```python
class CamelCaseMap:
    """"""
    This is a custom class that allows keys to be in camel case style by converting them from underscore style, which provides dictionary-like functionality.
    """"""

    def __init__(self):
        """"""
        Initialize data to an empty dictionary
        """"""
        self._data = {}

    def __getitem__(self, key):
        """"""
        Return the value corresponding to the key
        :param key: str
        :return: str, the value corresponding to the key
        """"""
        # Convert the key to camel case before fetching the value
        camel_case_key = self._convert_key(key)
        return self._data[camel_case_key]

    def __setitem__(self, key, value):
        """"""
        Set the value corresponding to the key to the specified value
        :param key: str
        :param value: str, the specified value
        :return: None
        """"""
        # Convert the key to camel case before setting the value
        camel_case_key = self._convert_key(key)
        self._data[camel_case_key] = value

    def __delitem__(self, key):
        """"""
        Delete the value corresponding to the key
        :param key: str
        :return: None
        """"""
        # Convert the key to camel case before deleting the item
        camel_case_key = self._convert_key(key)
        del self._data[camel_case_key]

    def __iter__(self):
        """"""
        Returning Iterable Objects with Own Data
        :return: Iterator
        """"""
        # Return iterator over the keys of the data dictionary
        return iter(self._data)

    def __len__(self):
        """"""
        Returns the length of the own data
        :return: int, length of data
        """"""
        # Return the length of the data dictionary
        return len(self._data)

    def _convert_key(self, key):
        """"""
        Convert key string into camel case
        :param key: str
        :return: str, converted key string
        """"""
        # Use the static method to convert the key to camel case
        return self._to_camel_case(key)

    @staticmethod
    def _to_camel_case(key):
        """"""
        Convert key string into camel case
        :param key: str
        :return: str, converted key string
        """"""
        # Split the key by underscores
        parts = key.split('_')
        # Capitalize the first letter of each part except the first one and join them back
        return parts[0] + ''.join(word.capitalize() for word in parts[1:])
```

- The `__getitem__`, `__setitem__`, and `__delitem__` methods convert keys from underscore style to camel case using the `_convert_key` method before performing operations.
- The `_convert_key` method leverages the `_to_camel_case` static method to handle the conversion logic.
- The `_to_camel_case` method splits the key on underscores, capitalizes the first letter of each subsequent part, and joins them to form the camel case string.",0.047887324,0.060943308,0.837209302,0.244897959,0.378947365,0.590163934,0.142857143,0.230031946,0.837209302,0.244897959,0.378947365,,,,,,,,,,,,
GPT,19,"class ChandrasekharSieve:
    def __init__(self, n):
        self.n = n
        self.primes = self.generate_primes()

    def generate_primes(self):
        if self.n < 2:
            return []

        sieve = [True] * (self.n + 1)
        sieve[0] = sieve[1] = False

        p = 2
        while p * p <= self.n:
            if sieve[p]:
                for i in range(p * p, self.n + 1, p):
                    sieve[i] = False
            p += 1

        primes = []
        for i in range(2, self.n + 1):
            if sieve[i]:
                primes.append(i)

        return primes

    def get_primes(self):
        return self.primes",FewShot,"```python
class ChandrasekharSieve:
    """"""
    This is a class that uses the Chandrasekhar's Sieve method to find all prime numbers within the range
    """"""

    def __init__(self, n):
        """"""
        Initialize the ChandrasekharSieve class with the given limit.
        :param n: int, the upper limit for generating prime numbers
        """"""
        self.n = n
        self.primes = self.generate_primes()

    def generate_primes(self):
        """"""
        Generate prime numbers up to the specified limit using the Chandrasekhar sieve algorithm.
        :return: list, a list of prime numbers
        >>> cs = ChandrasekharSieve(20)
        >>> cs.generate_primes()
        [2, 3, 5, 7, 11, 13, 17, 19]
        """"""
        # Initialize a boolean array that marks whether each number is prime
        is_prime = [True] * (self.n + 1)
        p = 2
        
        # Iterate over each number starting from 2
        while (p * p <= self.n):
            # If is_prime[p] is not changed, then it is a prime
            if is_prime[p]:
                # Mark all multiples of p as not prime
                for i in range(p * p, self.n + 1, p):
                    is_prime[i] = False
            p += 1
        
        # Collect all prime numbers
        prime_numbers = [p for p in range(2, self.n + 1) if is_prime[p]]
        return prime_numbers

    def get_primes(self):
        """"""
        Get the list of generated prime numbers.
        :return: list, a list of prime numbers
        >>> cs = ChandrasekharSieve(20)
        >>> cs.get_primes()
        [2, 3, 5, 7, 11, 13, 17, 19]
        """"""
        return self.primes
```",0.12037037,0.147201505,0.782608696,0.310344828,0.44444444,0.546666667,0.214659686,0.308270673,0.782608696,0.310344828,0.44444444,,,,,,,,,,,,
GPT,20,"from datetime import datetime

class Chat:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username in self.users:
            return False
        else:
            self.users[username] = []
            return True

    def remove_user(self, username):
        if username in self.users:
            del self.users[username]
            return True
        else:
            return False

    def send_message(self, sender, receiver, message):
        if sender not in self.users or receiver not in self.users:
            return False

        timestamp = datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
        message_info = {
            'sender': sender,
            'receiver': receiver,
            'message': message,
            'timestamp': timestamp
        }
        self.users[sender].append(message_info)
        self.users[receiver].append(message_info)
        return True

    def get_messages(self, username):
        if username not in self.users:
            return []
        return self.users[username]",FewShot,"```python
from datetime import datetime

class Chat:
    """"""
    This is a chat class with the functions of adding users, removing users, sending messages, and obtaining messages.
    """"""

    def __init__(self):
        """"""
        Initialize the Chat with an attribute users, which is an empty dictionary.
        """"""
        self.users = {}

    def add_user(self, username):
        """"""
        Add a new user to the Chat.
        :param username: The user's name, str.
        :return: If the user is already in the Chat, returns False, otherwise, returns True.
        >>> chat = Chat()
        >>> chat.add_user('John')
        True
        self.users = {'John': []}
        >>> chat.add_user('John')
        False
        """"""
        if username in self.users:
            return False
        else:
            self.users[username] = []  # Initialize a list to store messages for this user
            return True

    def remove_user(self, username):
        """"""
        Remove a user from the Chat.
        :param username: The user's name, str.
        :return: If the user is already in the Chat, returns True, otherwise, returns False.
        >>> chat = Chat()
        >>> chat.users = {'John': []}
        >>> chat.remove_user('John')
        True
        >>> chat.remove_user('John')
        False
        """"""
        if username in self.users:
            del self.users[username]  # Remove the user from the dictionary
            return True
        else:
            return False

    def send_message(self, sender, receiver, message):
        """"""
        Send a message from a user to another user.
        :param sender: The sender's name, str.
        :param receiver: The receiver's name, str.
        :param message: The message, str.
        :return: If the sender or the receiver is not in the Chat, returns False, otherwise, returns True.
        >>> chat = Chat()
        >>> chat.users = {'John': [], 'Mary': []}
        >>> chat.send_message('John', 'Mary', 'Hello')
        True
        >>> chat.send_message('John', 'Tom', 'Hello')
        False
        """"""
        if sender not in self.users or receiver not in self.users:
            return False
        else:
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            message_data = {
                'sender': sender,
                'receiver': receiver,
                'message': message,
                'timestamp': timestamp
            }
            self.users[sender].append(message_data)  # Add message to sender's list
            return True

    def get_messages(self, username):
        """"""
        Get all the messages of a user from the Chat.
        :param username: The user's name, str.
        :return: A list of messages, each message is a dictionary with keys 'sender', 'receiver', 'message', 'timestamp'.
        >>> chat = Chat()
        >>> chat.users = {'John': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': '2023-01-01 00:00:00'}]}
        >>> chat.get_messages('John')
        [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': '2023-01-01 00:00:00'}]
        >>> chat.get_messages('Mary')
        []
        """"""
        return self.users.get(username, [])  # Return the list of messages for the user, or an empty list if not found
```",0.142091153,0.157995352,0.897959184,0.314285714,0.465608462,0.769230769,0.21978022,0.341880338,0.897959184,0.314285714,0.465608462,,,,,,,,,,,,
GPT,21,"from datetime import datetime


class Classroom:
    def __init__(self, id):
        self.id = id
        self.courses = []

    def add_course(self, course):

        if course not in self.courses:
            self.courses.append(course)

    def remove_course(self, course):
        if course in self.courses:
            self.courses.remove(course)

    def is_free_at(self, check_time):
        check_time = datetime.strptime(check_time, '%H:%M')

        for course in self.courses:
            if datetime.strptime(course['start_time'], '%H:%M') <= check_time <= datetime.strptime(course['end_time'],
                                                                                                   '%H:%M'):
                return False
        return True

    def check_course_conflict(self, new_course):
        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M')
        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M')

        flag = True
        for course in self.courses:
            start_time = datetime.strptime(course['start_time'], '%H:%M')
            end_time = datetime.strptime(course['end_time'], '%H:%M')
            if start_time <= new_start_time and end_time >= new_start_time:
                flag = False
            if start_time <= new_end_time and end_time >= new_end_time:
                flag = False
        return flag",FewShot,"```python
from datetime import datetime

class Classroom:
    """"""
    This is a class representing a classroom, capable of adding and removing courses, checking availability at a given time, and detecting conflicts when scheduling new courses.
    """"""

    def __init__(self, id):
        """"""
        Initialize the classroom management system.
        :param id: int, the id of classroom
        """"""
        self.id = id
        self.courses = []

    def add_course(self, course):
        """"""
        Add course to self.courses list if the course wasn't in it and if there's no conflict.
        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'
        """"""
        if self.check_course_conflict(course):
            self.courses.append(course)

    def remove_course(self, course):
        """"""
        Remove course from self.courses list if the course was in it.
        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'
        """"""
        if course in self.courses:
            self.courses.remove(course)

    def is_free_at(self, check_time):
        """"""
        Change the time format as '%H:%M' and check if the time is free or not in the classroom.
        :param check_time: str, the time need to be checked
        :return: True if the check_time does not conflict with every course time, or False otherwise.
        """"""
        check_time = datetime.strptime(check_time, '%H:%M')
        for course in self.courses:
            start_time = datetime.strptime(course['start_time'], '%H:%M')
            end_time = datetime.strptime(course['end_time'], '%H:%M')
            if start_time <= check_time < end_time:
                return False
        return True

    def check_course_conflict(self, new_course):
        """"""
        Before adding a new course, check if the new course time conflicts with any other course.
        :param new_course: dict, information of the course, including 'start_time', 'end_time' and 'name'
        :return: False if the new course time conflicts (including two courses have the same boundary time) with other courses, or True otherwise.
        """"""
        new_start = datetime.strptime(new_course['start_time'], '%H:%M')
        new_end = datetime.strptime(new_course['end_time'], '%H:%M')
        for course in self.courses:
            start_time = datetime.strptime(course['start_time'], '%H:%M')
            end_time = datetime.strptime(course['end_time'], '%H:%M')
            if (new_start < end_time and new_end > start_time):
                return False
        return True
```",0.160839161,0.19004482,0.857142857,0.330708661,0.477272723,0.652173913,0.255319149,0.366972473,0.857142857,0.330708661,0.477272723,,,,,,,,,,,,
GPT,22,"class ClassRegistrationSystem:

    def __init__(self):
        self.students = []
        self.students_registration_classes = {}

    def register_student(self, student):
        if student in self.students:
            return 0
        else:
            self.students.append(student)
            return 1

    def register_class(self, student_name, class_name):
        if student_name in self.students_registration_classes:
            self.students_registration_classes[student_name].append(class_name)
        else:
            self.students_registration_classes[student_name] = [class_name]
        return self.students_registration_classes[student_name]

    def get_students_by_major(self, major):
        student_list = []
        for student in self.students:
            if student[""major""] == major:
                student_list.append(student[""name""])
        return student_list

    def get_all_major(self):
        major_list = []
        for student in self.students:
            if student[""major""] not in major_list:
                major_list.append(student[""major""])
        return major_list

    def get_most_popular_class_in_major(self, major):
        class_list = []
        for student in self.students:
            if student[""major""] == major:
                class_list += self.students_registration_classes[student[""name""]]
        most_popular_class = max(set(class_list), key=class_list.count)
        return most_popular_class",FewShot,"```python
class ClassRegistrationSystem:
    """"""
    This is a class as a class registration system, allowing to register students, register them for classes, retrieve students by major, get a list of all majors, and determine the most popular class within a specific major.
    """"""

    def __init__(self):
        """"""
        Initialize the registration system with the attribute students and students_registration_class.
        students is a list of student dictionaries, each student dictionary has the key of name and major.
        students_registration_class is a dictionary, key is the student name, value is a list of class names
        """"""
        self.students = []
        self.students_registration_classes = {}

    def register_student(self, student):
        """"""
        Register a student to the system, add the student to the students list.
        If the student is already registered, return 0, else return 1.
        """"""
        for s in self.students:
            if s['name'] == student['name']:
                return 0
        self.students.append(student)
        self.students_registration_classes[student['name']] = []
        return 1

    def register_class(self, student_name, class_name):
        """"""
        Register a class to the student.
        :param student_name: str
        :param class_name: str
        :return: a list of class names that the student has registered
        """"""
        if student_name in self.students_registration_classes:
            if class_name not in self.students_registration_classes[student_name]:
                self.students_registration_classes[student_name].append(class_name)
            return self.students_registration_classes[student_name]
        return []

    def get_students_by_major(self, major):
        """"""
        Get all students in the major.
        :param major: str
        :return: a list of student names
        """"""
        return [student['name'] for student in self.students if student['major'] == major]

    def get_all_major(self):
        """"""
        Get all majors in the system.
        :return: a list of majors
        """"""
        return list(set(student['major'] for student in self.students))

    def get_most_popular_class_in_major(self, major):
        """"""
        Get the class with the highest enrollment in the major.
        :param major: str
        :return: a string of the most popular class in this major
        """"""
        class_count = {}
        for student in self.students:
            if student['major'] == major:
                student_classes = self.students_registration_classes.get(student['name'], [])
                for class_name in student_classes:
                    if class_name in class_count:
                        class_count[class_name] += 1
                    else:
                        class_count[class_name] = 1
        if class_count:
            return max(class_count, key=class_count.get)
        return None
```",0.070234114,0.095877526,0.74,0.296,0.422857139,0.44047619,0.150406504,0.22424242,0.74,0.296,0.422857139,,,,,,,,,,,,
GPT,23,"import math
from typing import List

class CombinationCalculator:
    def __init__(self, datas: List[str]):
        self.datas = datas

    @staticmethod
    def count(n: int, m: int) -> int:
        if m == 0 or n == m:
            return 1
        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))

    @staticmethod
    def count_all(n: int) -> int:
        if n < 0 or n > 63:
            return False
        return (1 << n) - 1 if n != 63 else float(""inf"")

    def select(self, m: int) -> List[List[str]]:
        result = []
        self._select(0, [None] * m, 0, result)
        return result

    def select_all(self) -> List[List[str]]:
        result = []
        for i in range(1, len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):
        resultLen = len(resultList)
        resultCount = resultIndex + 1
        if resultCount > resultLen:
            result.append(resultList.copy())
            return

        for i in range(dataIndex, len(self.datas) + resultCount - resultLen):
            resultList[resultIndex] = self.datas[i]
            self._select(i + 1, resultList, resultIndex + 1, result)",FewShot,"```python
import math
from typing import List
from itertools import combinations

class CombinationCalculator:
    """"""
    This is a class that provides methods to calculate the number of combinations for a specific count, calculate all possible combinations, and generate combinations with a specified number of elements.
    """"""

    def __init__(self, datas: List[str]):
        """"""
        Initialize the calculator with a list of data.
        """"""
        self.datas = datas

    @staticmethod
    def count(n: int, m: int) -> int:
        """"""
        Calculate the number of combinations for a specific count.
        :param n: The total number of elements, int.
        :param m: The number of elements in each combination, int.
        :return: The number of combinations, int.
        >>> CombinationCalculator.count(4, 2)
        6
        """"""
        # Calculate combinations using the formula n! / (m! * (n-m)!)
        return math.comb(n, m)

    @staticmethod
    def count_all(n: int) -> int:
        """"""
        Calculate the number of all possible combinations.
        :param n: The total number of elements, int.
        :return: The number of all possible combinations, int, if the number of combinations is greater than 2^63-1, return float(""inf"").
        >>> CombinationCalculator.count_all(4)
        15
        """"""
        # Calculate the sum of combinations for all subset sizes
        total = sum(math.comb(n, i) for i in range(1, n + 1))
        return total if total <= 2**63 - 1 else float(""inf"")

    def select(self, m: int) -> List[List[str]]:
        """"""
        Generate combinations with a specified number of elements.
        :param m: The number of elements in each combination, int.
        :return: A list of combinations, List[List[str]].
        >>> calc = CombinationCalculator([""A"", ""B"", ""C"", ""D""])
        >>> calc.select(2)
        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]
        """"""
        # Use itertools.combinations to generate combinations
        return [list(comb) for comb in combinations(self.datas, m)]

    def select_all(self) -> List[List[str]]:
        """"""
        Generate all possible combinations of selecting elements from the given data list, and it uses the select method.
        :return: A list of combinations, List[List[str]].
        >>> calc = CombinationCalculator([""A"", ""B"", ""C"", ""D""])
        >>> calc.select_all()
        [['A'], ['B'], ['C'], ['D'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D'], ['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D'], ['A', 'B', 'C', 'D']]
        """"""
        # Use the select method to generate all combinations for each subset size
        result = []
        for i in range(1, len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):
        """"""
        Generate combinations with a specified number of elements by recursion.
        :param dataIndex: The index of the data to be selected, int.
        :param resultList: The list of elements in the combination, List[str].
        :param resultIndex: The index of the element in the combination, int.
        :param result: The list of combinations, List[List[str]].
        :return: None.
        >>> calc = CombinationCalculator([""A"", ""B"", ""C"", ""D""])
        >>> result = []
        >>> calc._select(0, [None] * 2, 0, result)
        >>> result
        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]
        """"""
        # Base case: if resultIndex equals the length of resultList, add a copy to result
        if resultIndex == len(resultList):
            result.append(resultList.copy())
            return
        
        # Recursive case: iterate over the elements starting from dataIndex
        for i in range(dataIndex, len(self.datas)):
            resultList[resultIndex] = self.datas[i]
            self._select(i + 1, resultList, resultIndex +",0.116,0.136119859,0.744444444,0.347150259,0.473498229,0.540145985,0.207865169,0.300202836,0.744444444,0.347150259,0.473498229,,,,,,,,,,,,
GPT,24,"class ComplexCalculator:
    def __init__(self):
        pass

    @staticmethod
    def add(c1, c2):
        real = c1.real + c2.real
        imaginary = c1.imag + c2.imag
        answer = complex(real, imaginary)
        return answer
    
    @staticmethod
    def subtract(c1, c2):
        real = c1.real - c2.real
        imaginary = c1.imag - c2.imag
        return complex(real, imaginary)
    
    @staticmethod
    def multiply(c1, c2):
        real = c1.real * c2.real - c1.imag * c2.imag
        imaginary = c1.real * c2.imag + c1.imag * c2.real
        return complex(real, imaginary)
    
    @staticmethod
    def divide(c1, c2):
        denominator = c2.real**2 + c2.imag**2
        real = (c1.real * c2.real + c1.imag * c2.imag) / denominator
        imaginary = (c1.imag * c2.real - c1.real * c2.imag) / denominator
        return complex(real, imaginary)",FewShot,"```python
class ComplexCalculator:
    """"""
    This is a class that implements addition, subtraction, multiplication, and division operations for complex numbers.
    """"""

    def __init__(self):
        pass

    @staticmethod
    def add(c1, c2):
        """"""
        Adds two complex numbers.
        :param c1: The first complex number, complex.
        :param c2: The second complex number, complex.
        :return: The sum of the two complex numbers, complex.
        >>> complexCalculator = ComplexCalculator()
        >>> complexCalculator.add(1+2j, 3+4j)
        (4+6j)
        """"""
        return c1 + c2

    @staticmethod
    def subtract(c1, c2):
        """"""
        Subtracts two complex numbers.
        :param c1: The first complex number, complex.
        :param c2: The second complex number, complex.
        :return: The difference of the two complex numbers, complex.
        >>> complexCalculator = ComplexCalculator()
        >>> complexCalculator.subtract(1+2j, 3+4j)
        (-2-2j)
        """"""
        return c1 - c2

    @staticmethod
    def multiply(c1, c2):
        """"""
        Multiplies two complex numbers.
        :param c1: The first complex number, complex.
        :param c2: The second complex number, complex.
        :return: The product of the two complex numbers, complex.
        >>> complexCalculator = ComplexCalculator()
        >>> complexCalculator.multiply(1+2j, 3+4j)
        (-5+10j)
        """"""
        return c1 * c2

    @staticmethod
    def divide(c1, c2):
        """"""
        Divides two complex numbers.
        :param c1: The first complex number, complex.
        :param c2: The second complex number, complex.
        :return: The quotient of the two complex numbers, complex.
        >>> complexCalculator = ComplexCalculator()
        >>> complexCalculator.divide(1+2j, 3+4j)
        (0.44+0.08j)
        """"""
        if c2 == 0:
            raise ValueError(""Cannot divide by zero"")
        return c1 / c2
```",0.052132701,0.067139308,0.633333333,0.243589744,0.351851848,0.262295082,0.14159292,0.183908041,0.633333333,0.243589744,0.351851848,,,,,,,,,,,,
GPT,25,"import json

class CookiesUtil:
    def __init__(self, cookies_file):
        self.cookies_file = cookies_file
        self.cookies = None

    def get_cookies(self, reponse):
        self.cookies = reponse['cookies']
        self._save_cookies()

    def load_cookies(self):
        try:
            with open(self.cookies_file, 'r') as file:
                cookies_data = json.load(file)
                return cookies_data
        except FileNotFoundError:
            return {}

    def _save_cookies(self):
        try:
            with open(self.cookies_file, 'w') as file:
                json.dump(self.cookies, file)
            return True
        except:
            return False

    def set_cookies(self, request):
        request['cookies'] = '; '.join([f'{key}={value}' for key, value in self.cookies.items()])",FewShot,"```python
import json

class CookiesUtil:
    """"""
    This is a class as utility for managing and manipulating Cookies, including methods for retrieving, saving, and setting Cookies data.
    """"""

    def __init__(self, cookies_file):
        """"""
        Initializes the CookiesUtil with the specified cookies file.
        :param cookies_file: The cookies file to use, str.
        """"""
        self.cookies_file = cookies_file
        self.cookies = None

    def get_cookies(self, response):
        """"""
        Gets the cookies from the specified response, and save it to cookies_file.
        :param response: The response to get cookies from, dict.
        >>> cookies_util = CookiesUtil('cookies.json')
        >>> cookies_util.get_cookies({'cookies': {'key1': 'value1', 'key2': 'value2'}})
        >>> cookies_util.cookies
        {'key1': 'value1', 'key2': 'value2'}
        """"""
        # Extract cookies from the response
        self.cookies = response.get('cookies', {})
        # Save the cookies to the file
        self._save_cookies()

    def load_cookies(self):
        """"""
        Loads the cookies from the cookies_file to the cookies data.
        :return: The cookies data, dict.
        >>> cookies_util = CookiesUtil('cookies.json')
        >>> cookies_util.load_cookies()
        {'key1': 'value1', 'key2': 'value2'}
        """"""
        try:
            with open(self.cookies_file, 'r') as file:
                # Load cookies from the file
                self.cookies = json.load(file)
        except FileNotFoundError:
            # If the file does not exist, initialize cookies as an empty dictionary
            self.cookies = {}
        return self.cookies

    def _save_cookies(self):
        """"""
        Saves the cookies to the cookies_file, and returns True if successful, False otherwise.
        :return: True if successful, False otherwise.
        >>> cookies_util = CookiesUtil('cookies.json')
        >>> cookies_util.cookies = {'key1': 'value1', 'key2': 'value2'}
        >>> cookies_util._save_cookies()
        True
        """"""
        try:
            with open(self.cookies_file, 'w') as file:
                # Write cookies to the file
                json.dump(self.cookies, file)
            return True
        except IOError:
            # Return False if there is an I/O error during file write
            return False
```",0.081300813,0.101983212,0.714285714,0.301724138,0.42424242,0.514705882,0.173267327,0.259259255,0.714285714,0.301724138,0.42424242,,,,,,,,,,,,
GPT,26,"import csv


class CSVProcessor:

    def __init__(self):
        pass

    def read_csv(self, file_name):
        data = []
        with open(file_name, 'r') as file:
            reader = csv.reader(file)
            title = next(reader)
            for row in reader:
                data.append(row)
        return title, data

    def write_csv(self, data, file_name):
        try:
            with open(file_name, 'w', newline='') as file:
                writer = csv.writer(file)
                writer.writerows(data)
            return 1
        except:
            return 0

    def process_csv_data(self, N, save_file_name):
        title, data = self.read_csv(save_file_name)
        column_data = [row[N] for row in data]
        column_data = [row.upper() for row in column_data]
        new_data = [title, column_data]
        return self.write_csv(new_data, save_file_name.split('.')[0] + '_process.csv')",FewShot,"```python
import csv

class CSVProcessor:
    """"""
    This is a class for processing CSV files, including reading and writing CSV data,
    as well as processing specific operations and saving as a new CSV file.
    """"""

    def __init__(self):
        pass

    def read_csv(self, file_name):
        """"""
        Read the csv file by file_name, get the title and data from it
        :param file_name: str, name of the csv file
        :return title, data: (list, list), first row is title, the rest is data
        """"""
        try:
            with open(file_name, mode='r', newline='') as csvfile:
                csvreader = csv.reader(csvfile)
                # Read the first row as title
                title = next(csvreader)
                # Read the rest as data
                data = [row for row in csvreader]
            return title, data
        except Exception as e:
            print(f""Error reading CSV file: {e}"")
            return None, None

    def write_csv(self, data, file_name):
        """"""
        Write data into a csv file.
        :param file_name: str, name of the csv file
        :return: int, if success return 1, or 0 otherwise
        """"""
        try:
            with open(file_name, mode='w', newline='') as csvfile:
                csvwriter = csv.writer(csvfile)
                # Write each row in data to the CSV file
                csvwriter.writerows(data)
            return 1
        except Exception as e:
            print(f""Error writing CSV file: {e}"")
            return 0

    def process_csv_data(self, N, save_file_name):
        """"""
        Read a csv file into variable title and data.
        Only remain the Nth (from 0) column data and capitalize them, store the title and new data into a new csv file.
        Add '_process' suffix after old file name, as a new file name.
        :param N: int, the Nth column(from 0)
        :param save_file_name: the name of file that needs to be processed.
        :return: int, if success return 1, or 0 otherwise
        """"""
        try:
            # Read the original CSV file
            title, data = self.read_csv(save_file_name)
            if not title or not data:
                return 0
            
            # Capitalize the Nth column data
            new_data = [[row[N].upper()] for row in data]

            # Create new file name with '_process' suffix
            new_file_name = save_file_name.replace('.csv', '_process.csv')

            # Write the processed data to the new CSV file
            self.write_csv([title] + new_data, new_file_name)
            return 1
        except Exception as e:
            print(f""Error processing CSV data: {e}"")
            return 0
```

- The `read_csv` method reads the CSV file and returns the title and data.
- The `write_csv` method writes data to a CSV file and returns 1 on success, 0 otherwise.
- The `process_csv_data` method processes the Nth column of the CSV file by capitalizing its contents and saves the processed data to a new CSV file with a '_process' suffix.",0.04822335,0.063972394,0.677966102,0.256410256,0.372093019,0.414634146,0.115646259,0.18085106,0.661016949,0.25,0.362790694,,,,,,,,,,,,
GPT,27,"class CurrencyConverter:
    def __init__(self):
        self.rates = {
            'USD': 1.0,
            'EUR': 0.85,
            'GBP': 0.72,
            'JPY': 110.15,
            'CAD': 1.23,
            'AUD': 1.34,
            'CNY': 6.40,
        }

    def convert(self, amount, from_currency, to_currency):
        if from_currency == to_currency:
            return amount

        if from_currency not in self.rates or to_currency not in self.rates:
            return False

        from_rate = self.rates[from_currency]
        to_rate = self.rates[to_currency]

        converted_amount = (amount / from_rate) * to_rate
        return converted_amount

    def get_supported_currencies(self):
        return list(self.rates.keys())

    def add_currency_rate(self, currency, rate):
        if currency in self.rates:
            return False
        self.rates[currency] = rate

    def update_currency_rate(self, currency, new_rate):
        if currency not in self.rates:
            return False
        self.rates[currency] = new_rate",FewShot,"```python
class CurrencyConverter:
    """"""
    This is a class for currency conversion, which supports to convert amounts between different currencies, retrieve supported currencies, add new currency rates, and update existing currency rates.
    """"""

    def __init__(self):
        """"""
        Initialize the exchange rate of the US dollar against various currencies
        """"""
        self.rates = {
            'USD': 1.0,
            'EUR': 0.85,
            'GBP': 0.72,
            'JPY': 110.15,
            'CAD': 1.23,
            'AUD': 1.34,
            'CNY': 6.40,
        }

    def convert(self, amount, from_currency, to_currency):
        """"""
        Convert the value of a given currency to another currency type
        :param amount: float, The value of a given currency
        :param from_currency: string, source currency type
        :param to_currency: string, target currency type
        :return: float, value converted to another currency type
        """"""
        # Check if both currencies are supported
        if from_currency not in self.rates or to_currency not in self.rates:
            raise ValueError(""Unsupported currency type"")
        
        # Convert the amount to USD first, then to the target currency
        amount_in_usd = amount / self.rates[from_currency]
        converted_amount = amount_in_usd * self.rates[to_currency]
        
        return converted_amount

    def get_supported_currencies(self):
        """"""
        Returns a list of supported currency types
        :return: list, All supported currency types
        """"""
        return list(self.rates.keys())

    def add_currency_rate(self, currency, rate):
        """"""
        Add a new supported currency type, return False if the currency type is already in the support list
        :param currency: string, currency type to be added
        :param rate: float, exchange rate for this type of currency
        :return: If successful, returns None; if unsuccessful, returns False
        """"""
        # Check if the currency already exists
        if currency in self.rates:
            return False
        
        # Add the new currency and its rate
        self.rates[currency] = rate

    def update_currency_rate(self, currency, new_rate):
        """"""
        Update the exchange rate for a certain currency
        :param currency: string
        :param new_rate: float
        :return: If successful, returns None; if unsuccessful, returns False
        """"""
        # Check if the currency exists
        if currency not in self.rates:
            return False
        
        # Update the currency rate
        self.rates[currency] = new_rate
```",0.166666667,0.19022375,0.921875,0.409722222,0.567307688,0.733333333,0.256809339,0.380403454,0.921875,0.409722222,0.567307688,,,,,,,,,,,,
GPT,28,"import sqlite3
import pandas as pd


class DatabaseProcessor:

    def __init__(self, database_name):
        self.database_name = database_name

    def create_table(self, table_name, key1, key2):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        create_table_query = f""CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)""
        cursor.execute(create_table_query)

        conn.commit()
        conn.close()

    def insert_into_database(self, table_name, data):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        for item in data:
            insert_query = f""INSERT INTO {table_name} (name, age) VALUES (?, ?)""
            cursor.execute(insert_query, (item['name'], item['age']))

        conn.commit()
        conn.close()

    def search_database(self, table_name, name):

        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        select_query = f""SELECT * FROM {table_name} WHERE name = ?""
        cursor.execute(select_query, (name,))
        result = cursor.fetchall()

        if result:
            return result
        else:
            return None

    def delete_from_database(self, table_name, name):

        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        delete_query = f""DELETE FROM {table_name} WHERE name = ?""
        cursor.execute(delete_query, (name,))

        conn.commit()
        conn.close()",FewShot,"```python
import sqlite3
import pandas as pd

class DatabaseProcessor:
    """"""
    This is a class for processing a database, supporting to create tables, 
    insert data into the database, search for data based on name, 
    and delete data from the database.
    """"""

    def __init__(self, database_name):
        """"""
        Initialize database name of the database processor
        """"""
        self.database_name = database_name

    def create_table(self, table_name, key1, key2):
        """"""
        Create a new table in the database if it doesn't exist.
        Make id (INTEGER) as PRIMARY KEY, key1 as TEXT, key2 as INTEGER
        """"""
        # Connect to the SQLite database
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()
        
        # Create table with specified columns
        cursor.execute(f'''
            CREATE TABLE IF NOT EXISTS {table_name} (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                {key1} TEXT,
                {key2} INTEGER
            )
        ''')
        
        # Commit changes and close connection
        conn.commit()
        conn.close()

    def insert_into_database(self, table_name, data):
        """"""
        Insert data into the specified table in the database.
        """"""
        # Connect to the SQLite database
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()
        
        # Insert data into the table
        for item in data:
            cursor.execute(f'''
                INSERT INTO {table_name} ({"", "".join(item.keys())})
                VALUES ({"", "".join(['?' for _ in item.values()])})
            ''', tuple(item.values()))
        
        # Commit changes and close connection
        conn.commit()
        conn.close()

    def search_database(self, table_name, name):
        """"""
        Search the specified table in the database for rows with a matching name.
        """"""
        # Connect to the SQLite database
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()
        
        # Search for rows with the specified name
        cursor.execute(f'''
            SELECT * FROM {table_name} WHERE name = ?
        ''', (name,))
        
        # Fetch all matching rows
        results = cursor.fetchall()
        
        # Close connection
        conn.close()
        
        return results if results else None

    def delete_from_database(self, table_name, name):
        """"""
        Delete rows from the specified table in the database with a matching name.
        """"""
        # Connect to the SQLite database
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()
        
        # Delete rows with the specified name
        cursor.execute(f'''
            DELETE FROM {table_name} WHERE name = ?
        ''', (name,))
        
        # Commit changes and close connection
        conn.commit()
        conn.close()
```

This implementation provides methods to create tables, insert data, search for specific entries, and delete entries from a SQLite database. Each method includes comments to explain the process and ensure clarity.",0.154069767,0.178382225,0.696202532,0.369127517,0.482456136,0.508928571,0.227091633,0.314049583,0.683544304,0.362416107,0.473684206,,,,,,,,,,,,
GPT,29,"from collections import Counter


class DataStatistics:
    def mean(self, data):
        return round(sum(data) / len(data), 2)

    def median(self, data):
        sorted_data = sorted(data)
        n = len(sorted_data)
        if n % 2 == 0:
            middle = n // 2
            return round((sorted_data[middle - 1] + sorted_data[middle]) / 2, 2)
        else:
            middle = n // 2
            return sorted_data[middle]

    def mode(self, data):
        counter = Counter(data)
        mode_count = max(counter.values())
        mode = [x for x, count in counter.items() if count == mode_count]
        return mode",FewShot,"```python
from collections import Counter

class DataStatistics:
    """"""
    This is a class for performing data statistics, supporting to calculate the mean, median, and mode of a given data set.
    """"""

    def mean(self, data):
        """"""
        Calculate the average value of a group of data, accurate to two digits after the Decimal separator
        :param data:list, data list
        :return:float, the mean value
        >>> ds = DataStatistics()
        >>> ds.mean([1, 2, 3, 4, 5])
        3.00
        """"""
        # Calculate the mean by dividing the sum of data by the number of data points
        mean_value = sum(data) / len(data)
        # Return the result rounded to two decimal places
        return round(mean_value, 2)

    def median(self, data):
        """"""
        Calculate the median of a group of data, accurate to two digits after the Decimal separator
        :param data:list, data list
        :return:float, the median value
        >>> ds = DataStatistics()
        >>> ds.median([2, 5, 1, 3, 4])
        3.00
        """"""
        # Sort the data list
        sorted_data = sorted(data)
        n = len(sorted_data)
        # Calculate the median based on whether the number of data points is odd or even
        if n % 2 == 1:
            median_value = sorted_data[n // 2]
        else:
            median_value = (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2
        # Return the result rounded to two decimal places
        return round(median_value, 2)

    def mode(self, data):
        """"""
        Calculate the mode of a set of data
        :param data:list, data list
        :return:float, the mode
        >>> ds = DataStatistics()
        >>> ds.mode([2, 2, 3, 3, 4])
        [2, 3]
        """"""
        # Use Counter to count the frequency of each element in the data list
        data_counter = Counter(data)
        # Find the maximum frequency
        max_count = max(data_counter.values())
        # Find all elements that have the maximum frequency
        mode_values = [k for k, v in data_counter.items() if v == max_count]
        # Return the list of mode values
        return mode_values
```",0.054421769,0.071628215,0.734693878,0.264705882,0.389189185,0.371428571,0.119266055,0.180555552,0.673469388,0.242647059,0.356756753,,,,,,,,,,,,
GPT,30,"import numpy as np


class DataStatistics2:
    def __init__(self, data):
        self.data = np.array(data)

    def get_sum(self):
        return np.sum(self.data)

    def get_min(self):
        return np.min(self.data)

    def get_max(self):
        return np.max(self.data)

    def get_variance(self):
        return round(np.var(self.data), 2)

    def get_std_deviation(self):
        return round(np.std(self.data), 2)

    def get_correlation(self):
        return np.corrcoef(self.data, rowvar=False)",FewShot,"```python
import numpy as np

class DataStatistics2:
    """"""
    This is a class for performing data statistics, supporting to get the sum, minimum, maximum, variance, standard deviation, and correlation of a given dataset.
    """"""

    def __init__(self, data):
        """"""
        Initialize Data List
        :param data:list
        """"""
        self.data = np.array(data)

    def get_sum(self):
        """"""
        Calculate the sum of data
        :return:float
        >>> ds2 = DataStatistics2([1, 2, 3, 4])
        >>> ds2.get_sum()
        10
        """"""
        # Calculate and return the sum of the data
        return np.sum(self.data)

    def get_min(self):
        """"""
        Calculate the minimum value in the data
        :return:float
        >>> ds2 = DataStatistics2([1, 2, 3, 4])
        >>> ds2.get_min()
        1
        """"""
        # Calculate and return the minimum value in the data
        return np.min(self.data)

    def get_max(self):
        """"""
        Calculate the maximum value in the data
        :return:float
        >>> ds2 = DataStatistics2([1, 2, 3, 4])
        >>> ds2.get_max()
        4
        """"""
        # Calculate and return the maximum value in the data
        return np.max(self.data)

    def get_variance(self):
        """"""
        Calculate variance, accurate to two digits after the Decimal separator
        :return:float
        >>> ds2 = DataStatistics2([1, 2, 3, 4])
        >>> ds2.get_variance()
        1.25
        """"""
        # Calculate variance and round to two decimal places
        return round(np.var(self.data, ddof=0), 2)

    def get_std_deviation(self):
        """"""
        Calculate standard deviation, accurate to two digits after the Decimal separator
        :return:float
        >>> ds2 = DataStatistics2([1, 2, 3, 4])
        >>> ds2.get_std_deviation()
        1.12
        """"""
        # Calculate standard deviation and round to two decimal places
        return round(np.std(self.data, ddof=0), 2)

    def get_correlation(self):
        """"""
        Calculate correlation
        :return:float
        >>> ds2 = DataStatistics2([1, 2, 3, 4])
        >>> ds2.get_correlation()
        1.0
        """"""
        # Calculate correlation coefficient
        # Since only one dataset is provided, the correlation with itself is always 1
        return 1.0
```",0.061776062,0.069781288,0.90625,0.278846154,0.426470585,0.681818182,0.180722892,0.285714282,0.90625,0.278846154,0.426470585,,,,,,,,,,,,
GPT,31,"import math

class DataStatistics4:

    @staticmethod
    def correlation_coefficient(data1, data2):
        n = len(data1)
        mean1 = sum(data1) / n
        mean2 = sum(data2) / n

        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))
        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n))) * math.sqrt(sum((data2[i] - mean2) ** 2 for i in range(n)))

        return numerator / denominator if denominator != 0 else 0
    
    @staticmethod
    def skewness(data):
        n = len(data)
        mean = sum(data) / n
        variance = sum((x - mean) ** 2 for x in data) / n
        std_deviation = math.sqrt(variance)

        skewness = sum((x - mean) ** 3 for x in data) * n / ((n - 1) * (n - 2) * std_deviation ** 3) if std_deviation != 0 else 0

        return skewness
    
    @staticmethod
    def kurtosis(data):

        n = len(data)
        mean = sum(data) / n
        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / n)

        if std_dev == 0:
            return math.nan

        centered_data = [(x - mean) for x in data]
        fourth_moment = sum(x ** 4 for x in centered_data) / n

        kurtosis_value = (fourth_moment / std_dev ** 4) - 3

        return kurtosis_value
    
    @staticmethod
    def pdf(data, mu, sigma):
        pdf_values = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]
        return pdf_values",FewShot,"```python
import math

class DataStatistics4:
    """"""
    This is a class that performs advanced mathematical calculations and statistics, including correlation coefficient, skewness, kurtosis, and probability density function (PDF) for a normal distribution.
    """"""

    @staticmethod
    def correlation_coefficient(data1, data2):
        """"""
        Calculate the correlation coefficient of two sets of data.
        :param data1: The first set of data, list.
        :param data2: The second set of data, list.
        :return: The correlation coefficient, float.
        >>> DataStatistics4.correlation_coefficient([1, 2, 3], [4, 5, 6])
        0.9999999999999998
        """"""
        n = len(data1)
        sum1 = sum(data1)
        sum2 = sum(data2)
        sum1_sq = sum(pow(x, 2) for x in data1)
        sum2_sq = sum(pow(x, 2) for x in data2)
        p_sum = sum(x * y for x, y in zip(data1, data2))
        num = p_sum - (sum1 * sum2 / n)
        den = math.sqrt((sum1_sq - pow(sum1, 2) / n) * (sum2_sq - pow(sum2, 2) / n))
        if den == 0:
            return 0
        return num / den

    @staticmethod
    def skewness(data):
        """"""
        Calculate the skewness of a set of data.
        :param data: The input data list, list.
        :return: The skewness, float.
        >>> DataStatistics4.skewness([1, 2, 5])
        2.3760224064818463
        """"""
        n = len(data)
        mean = sum(data) / n
        m3 = sum((x - mean) ** 3 for x in data) / n
        m2 = sum((x - mean) ** 2 for x in data) / n
        if m2 == 0:
            return 0
        return m3 / m2 ** 1.5

    @staticmethod
    def kurtosis(data):
        """"""
        Calculate the kurtosis of a set of data.
        :param data: The input data list, list.
        :return: The kurtosis, float.
        >>> DataStatistics4.kurtosis([1, 20,100])
        -1.5000000000000007
        """"""
        n = len(data)
        mean = sum(data) / n
        m4 = sum((x - mean) ** 4 for x in data) / n
        m2 = sum((x - mean) ** 2 for x in data) / n
        if m2 == 0:
            return 0
        return m4 / m2 ** 2 - 3

    @staticmethod
    def pdf(data, mu, sigma):
        """"""
        Calculate the probability density function (PDF) of a set of data under a normal distribution.
        :param data: The input data list, list.
        :param mu: The mean of the normal distribution, float.
        :param sigma: The standard deviation of the normal distribution, float.
        :return: The probability density function (PDF), list.
        >>> DataStatistics4.pdf([1, 2, 3], 1, 1)
        [0.3989422804014327, 0.24197072451914337, 0.05399096651318806]
        """"""
        return [(1 / (sigma * math.sqrt(2 * math.pi))) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]
```",0.17539267,0.21853677,0.604651163,0.339869281,0.435146439,0.353293413,0.219330855,0.270642197,0.569767442,0.320261438,0.410041836,,,,,,,,,,,,
GPT,32,"class DecryptionUtils:
    def __init__(self, key):
        self.key = key
    
    def caesar_decipher(self, ciphertext, shift):
        plaintext = """"
        for char in ciphertext:
            if char.isalpha():
                if char.isupper():
                    ascii_offset = 65
                else:
                    ascii_offset = 97
                shifted_char = chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)
                plaintext += shifted_char
            else:
                plaintext += char
        return plaintext
    
    def vigenere_decipher(self, ciphertext):
        decrypted_text = """"
        key_index = 0
        for char in ciphertext:
            if char.isalpha():
                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')
                decrypted_char = chr((ord(char.lower()) - ord('a') - shift) % 26 + ord('a'))
                decrypted_text += decrypted_char.upper() if char.isupper() else decrypted_char
                key_index += 1
            else:
                decrypted_text += char
        return decrypted_text
    
    def rail_fence_decipher(self, encrypted_text, rails):
        fence = [['\n' for _ in range(len(encrypted_text))] for _ in range(rails)]
        direction = -1
        row, col = 0, 0

        for _ in range(len(encrypted_text)):
            if row == 0 or row == rails - 1:
                direction = -direction

            fence[row][col] = ''
            col += 1
            row += direction

        index = 0
        for i in range(rails):
            for j in range(len(encrypted_text)):
                if fence[i][j] == '':
                    fence[i][j] = encrypted_text[index]
                    index += 1

        plain_text = ''
        direction = -1
        row, col = 0, 0
        for _ in range(len(encrypted_text)):
            if row == 0 or row == rails - 1:
                direction = -direction

            plain_text += fence[row][col]
            col += 1
            row += direction

        return plain_text",FewShot,"```python
class DecryptionUtils:
    """"""
    This is a class that provides methods for decryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.
    """"""

    def __init__(self, key):
        """"""
        Initializes the decryption utility with a key.
        :param key: The key to use for decryption,str.
        """"""
        self.key = key

    def caesar_decipher(self, ciphertext, shift):
        """"""
        Deciphers the given ciphertext using the Caesar cipher
        :param ciphertext: The ciphertext to decipher,str.
        :param shift: The shift to use for decryption,int.
        :return: The deciphered plaintext,str.
        >>> d = DecryptionUtils('key')
        >>> d.caesar_decipher('ifmmp', 1)
        'hello'
        """"""
        plaintext = []
        for char in ciphertext:
            if char.isalpha():
                shift_amount = shift % 26
                shifted = ord(char) - shift_amount
                if char.islower() and shifted < ord('a'):
                    shifted += 26
                elif char.isupper() and shifted < ord('A'):
                    shifted += 26
                plaintext.append(chr(shifted))
            else:
                plaintext.append(char)
        return ''.join(plaintext)

    def vigenere_decipher(self, ciphertext):
        """"""
        Deciphers the given ciphertext using the Vigenere cipher
        :param ciphertext: The ciphertext to decipher,str.
        :return: The deciphered plaintext,str.
        >>> d = DecryptionUtils('key')
        >>> d.vigenere_decipher('ifmmp')
        'ybocl'
        """"""
        plaintext = []
        key_length = len(self.key)
        key_int = [ord(i) for i in self.key]
        ciphertext_int = [ord(i) for i in ciphertext]
        for i in range(len(ciphertext_int)):
            value = (ciphertext_int[i] - key_int[i % key_length]) % 26
            plaintext.append(chr(value + 65))
        return ''.join(plaintext).lower()

    def rail_fence_decipher(self, encrypted_text, rails):
        """"""
        Deciphers the given ciphertext using the Rail Fence cipher
        :param encrypted_text: The ciphertext to decipher,str.
        :param rails: The number of rails to use for decryption,int.
        :return: The deciphered plaintext,str.
        >>> d = DecryptionUtils('key')
        >>> d.rail_fence_decipher('Hoo!el,Wrdl l', 3)
        'Hello, World!'
        """"""
        if rails == 1:
            return encrypted_text

        rail = [['\n' for i in range(len(encrypted_text))]
                for j in range(rails)]

        dir_down = None
        row, col = 0, 0

        for i in range(len(encrypted_text)):
            if row == 0:
                dir_down = True
            if row == rails - 1:
                dir_down = False

            rail[row][col] = '*'
            col += 1

            if dir_down:
                row += 1
            else:
                row -= 1

        index = 0
        for i in range(rails):
            for j in range(len(encrypted_text)):
                if rail[i][j] == '*' and index < len(encrypted_text):
                    rail[i][j] = encrypted_text[index]
                    index += 1

        result = []
        row, col = 0, 0
        for i in range(len(encrypted_text)):
            if row == 0:
                dir_down = True
            if row == rails - 1:
                dir_down = False

            if rail[row][col] != '*':
                result.append(rail[row][col])
                col += 1

            if dir_down:
                row += 1
            else:
                row -= 1
        return ''.join(result)
```",0.136729223,0.172270917,0.626506024,0.339869281,0.440677962,0.37012987,0.212686567,0.270142175,0.626506024,0.339869281,0.440677962,,,,,,,,,,,,
GPT,33,"class DiscountStrategy:
    def __init__(self, customer, cart, promotion=None):
        self.customer = customer
        self.cart = cart
        self.promotion = promotion
        self.__total = self.total()

    def total(self):
        self.__total = sum(item['quantity'] * item['price'] for item in self.cart)
        return self.__total

    def due(self):
        if self.promotion is None:
            discount = 0
        else:
            discount = self.promotion(self)
        return self.__total - discount

    @staticmethod
    def FidelityPromo(order):
        return order.total() * 0.05 if order.customer['fidelity'] >= 1000 else 0

    @staticmethod
    def BulkItemPromo(order):
        discount = 0
        for item in order.cart:
            if item['quantity'] >= 20:
                discount += item['quantity'] * item['price'] * 0.1
        return discount

    @staticmethod
    def LargeOrderPromo(order):
        return order.total() * 0.07 if len({item['product'] for item in order.cart}) >= 10 else 0",FewShot,"```python
class DiscountStrategy:
    """"""
    This is a class that allows to use different discount strategy based on shopping credit or shopping cart in supermarket.
    """"""

    def __init__(self, customer, cart, promotion=None):
        """"""
        Initialize the DiscountStrategy with customer information, a cart of items, and an optional promotion.
        :param customer: dict, customer information
        :param cart: list of dicts, a cart of items with details
        :param promotion: function, optional promotion applied to the order
        """"""
        self.customer = customer
        self.cart = cart
        self.promotion = promotion

    def total(self):
        """"""
        Calculate the total cost of items in the cart.
        :return: float, total cost of items
        """"""
        # Calculate the total price by summing up the price of each item times its quantity
        return sum(item['quantity'] * item['price'] for item in self.cart)

    def due(self):
        """"""
        Calculate the final amount to be paid after applying the discount.
        :return: float, final amount to be paid
        """"""
        # Calculate the total cost of the cart
        total = self.total()
        # If a promotion is provided, apply it to the order to get the discount
        if self.promotion:
            discount = self.promotion(self)
        else:
            discount = 0
        # Subtract the discount from the total to get the final due amount
        return total - discount

    @staticmethod
    def FidelityPromo(order):
        """"""
        Calculate the discount based on the fidelity points of the customer.
        Customers with over 1000 points can enjoy a 5% discount on the entire order.
        :param order: object, the order to apply the discount to
        :return: float, discount amount
        """"""
        # Check if the customer has more than 1000 fidelity points
        if order.customer['fidelity'] > 1000:
            # Return 5% of the total as discount
            return order.total() * 0.05
        return 0

    @staticmethod
    def BulkItemPromo(order):
        """"""
        Calculate the discount based on bulk item quantity in the order.
        In the same order, if the quantity of a single item reaches 20 or more, each item will enjoy a 10% discount.
        :param order: object, the order to apply the discount to
        :return: float, discount amount
        """"""
        # Calculate discount for items with quantity 20 or more
        discount = 0
        for item in order.cart:
            if item['quantity'] >= 20:
                # 10% discount for each bulk item
                discount += item['quantity'] * item['price'] * 0.1
        return discount

    @staticmethod
    def LargeOrderPromo(order):
        """"""
        Calculate the discount based on the number of different products in the order.
        If the quantity of different products in the order reaches 10 or more, the entire order will enjoy a 7% discount.
        :param order: object, the order to apply the discount to
        :return: float, discount amount
        """"""
        # Check if there are 10 or more different products in the cart
        if len(order.cart) >= 10:
            # Return 7% of the total as discount
            return order.total() * 0.07
        return 0
```

This code completes the `DiscountStrategy` class by implementing the `total`, `due`, `FidelityPromo`, `BulkItemPromo`, and `LargeOrderPromo` methods. Each method is designed to calculate the total cost, apply discounts based on specific criteria, and return the final amount due.",0.096033403,0.113352292,0.901960784,0.278787879,0.425925922,0.652631579,0.17816092,0.279909703,0.882352941,0.272727273,0.416666663,,,,,,,,,,,,
GPT,34,"from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT


class DocFileHandler:
    def __init__(self, file_path):
        self.file_path = file_path

    def read_text(self):
        doc = Document(self.file_path)
        text = []
        for paragraph in doc.paragraphs:
            text.append(paragraph.text)
        return ""\n"".join(text)

    def write_text(self, content, font_size=12, alignment='left'):
        try:
            doc = Document()
            paragraph = doc.add_paragraph()
            run = paragraph.add_run(content)
            font = run.font
            font.size = Pt(font_size)
            alignment_value = self._get_alignment_value(alignment)
            paragraph.alignment = alignment_value
            doc.save(self.file_path)
            return True
        except:
            return False

    def add_heading(self, heading, level=1):
        try:
            doc = Document(self.file_path)
            doc.add_heading(heading, level)
            doc.save(self.file_path)
            return True
        except:
            return False

    def add_table(self, data):
        try:
            doc = Document(self.file_path)
            table = doc.add_table(rows=len(data), cols=len(data[0]))
            for i, row in enumerate(data):
                for j, cell_value in enumerate(row):
                    table.cell(i, j).text = str(cell_value)
            doc.save(self.file_path)
            return True
        except:
            return False

    def _get_alignment_value(self, alignment):
        alignment_options = {
            'left': WD_PARAGRAPH_ALIGNMENT.LEFT,
            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,
            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT
        }
        return alignment_options.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)",FewShot,"```python
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT


class DocFileHandler:
    """"""
    This is a class that handles Word documents and provides functionalities for reading, writing, and modifying the content of Word documents.
    """"""

    def __init__(self, file_path):
        """"""
        Initializes the DocFileHandler object with the specified file path.
        :param file_path: str, the path to the Word document file.
        """"""
        self.file_path = file_path

    def read_text(self):
        """"""
        Reads the content of a Word document and returns it as a string.
        :return: str, the content of the Word document.
        """"""
        try:
            doc = Document(self.file_path)
            content = []
            for para in doc.paragraphs:
                content.append(para.text)
            return '\n'.join(content)
        except Exception as e:
            return str(e)

    def write_text(self, content, font_size=12, alignment='left'):
        """"""
        Writes the specified content to a Word document.
        :param content: str, the text content to write.
        :param font_size: int, optional, the font size of the text (default is 12).
        :param alignment: str, optional, the alignment of the text ('left', 'center', or 'right'; default is 'left').
        :return: bool, True if the write operation is successful, False otherwise.
        """"""
        try:
            doc = Document()
            para = doc.add_paragraph(content)
            run = para.runs[0]
            run.font.size = Pt(font_size)
            para.alignment = self._get_alignment_value(alignment)
            doc.save(self.file_path)
            return True
        except Exception as e:
            return False

    def add_heading(self, heading, level=1):
        """"""
        Adds a heading to the Word document.
        :param heading: str, the text of the heading.
        :param level: int, optional, the level of the heading (1, 2, 3, etc.; default is 1).
        :return: bool, True if the heading is successfully added, False otherwise.
        """"""
        try:
            doc = Document(self.file_path)
            doc.add_heading(heading, level=level)
            doc.save(self.file_path)
            return True
        except Exception as e:
            return False

    def add_table(self, data):
        """"""
        Adds a table to the Word document with the specified data.
        :param data: list of lists, the data to populate the table.
        :return: bool, True if the table is successfully added, False otherwise.
        """"""
        try:
            doc = Document(self.file_path)
            table = doc.add_table(rows=len(data), cols=len(data[0]))
            for i, row in enumerate(data):
                for j, cell in enumerate(row):
                    table.cell(i, j).text = str(cell)
            doc.save(self.file_path)
            return True
        except Exception as e:
            return False

    def _get_alignment_value(self, alignment):
        """"""
        Returns the alignment value corresponding to the given alignment string.
        :param alignment: str, the alignment string ('left', 'center', or 'right').
        :return: int, the alignment value.
        """"""
        alignment_dict = {
            'left': WD_PARAGRAPH_ALIGNMENT.LEFT,
            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,
            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT
        }
        return alignment_dict.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)
```",0.169354839,0.193116004,0.855421687,0.43030303,0.572580641,0.679104478,0.305369128,0.421296292,0.855421687,0.43030303,0.572580641,,,,,,,,,,,,
GPT,35,"class EightPuzzle:
    def __init__(self, initial_state):
        self.initial_state = initial_state
        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

    def find_blank(self, state):
        for i in range(3):
            for j in range(3):
                if state[i][j] == 0:
                    return i, j

    def move(self, state, direction):
        i, j = self.find_blank(state)
        new_state = [row[:] for row in state]

        if direction == 'up':
            new_state[i][j], new_state[i - 1][j] = new_state[i - 1][j], new_state[i][j]
        elif direction == 'down':
            new_state[i][j], new_state[i + 1][j] = new_state[i + 1][j], new_state[i][j]
        elif direction == 'left':
            new_state[i][j], new_state[i][j - 1] = new_state[i][j - 1], new_state[i][j]
        elif direction == 'right':
            new_state[i][j], new_state[i][j + 1] = new_state[i][j + 1], new_state[i][j]

        return new_state

    def get_possible_moves(self, state):
        moves = []
        i, j = self.find_blank(state)

        if i > 0:
            moves.append('up')
        if i < 2:
            moves.append('down')
        if j > 0:
            moves.append('left')
        if j < 2:
            moves.append('right')

        return moves

    def solve(self):
        open_list = [(self.initial_state, [])]
        closed_list = []

        while open_list:
            current_state, path = open_list.pop(0)
            closed_list.append(current_state)

            if current_state == self.goal_state:
                return path

            for move in self.get_possible_moves(current_state):
                new_state = self.move(current_state, move)
                if new_state not in closed_list:
                    open_list.append((new_state, path + [move]))

        return None",FewShot,"```python
class EightPuzzle:
    def __init__(self, initial_state):
        self.initial_state = initial_state
        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

    def find_blank(self, state):
        for i in range(3):
            for j in range(3):
                if state[i][j] == 0:
                    return i, j

    def move(self, state, direction):
        i, j = self.find_blank(state)
        new_state = [row[:] for row in state]  # Create a deep copy of the state

        if direction == 'up' and i > 0:
            new_state[i][j], new_state[i-1][j] = new_state[i-1][j], new_state[i][j]
        elif direction == 'down' and i < 2:
            new_state[i][j], new_state[i+1][j] = new_state[i+1][j], new_state[i][j]
        elif direction == 'left' and j > 0:
            new_state[i][j], new_state[i][j-1] = new_state[i][j-1], new_state[i][j]
        elif direction == 'right' and j < 2:
            new_state[i][j], new_state[i][j+1] = new_state[i][j+1], new_state[i][j]

        return new_state

    def get_possible_moves(self, state):
        i, j = self.find_blank(state)
        moves = []

        if i > 0:
            moves.append('up')
        if i < 2:
            moves.append('down')
        if j > 0:
            moves.append('left')
        if j < 2:
            moves.append('right')

        return moves

    def solve(self):
        from collections import deque

        open_list = deque([(self.initial_state, [])])
        visited = set()

        while open_list:
            current_state, path = open_list.popleft()
            visited.add(tuple(tuple(row) for row in current_state))

            if current_state == self.goal_state:
                return path

            for move in self.get_possible_moves(current_state):
                new_state = self.move(current_state, move)
                if tuple(tuple(row) for row in new_state) not in visited:
                    open_list.append((new_state, path + [move]))

        return None
```

- `find_blank` method locates the position of the blank tile (0) in the current state.
- `move` method shifts the blank tile in the specified direction if possible, returning the new state.
- `get_possible_moves` method returns a list of valid moves based on the position of the blank tile.
- `solve` method applies a BFS algorithm to find the sequence of moves that solves the puzzle, returning the path if a solution is found.",0.388278388,0.420997361,0.818181818,0.507042254,0.626086952,0.704402516,0.46473029,0.559999995,0.818181818,0.507042254,0.626086952,,,,,,,,,,,,
GPT,36,"from datetime import datetime

class EmailClient:
    def __init__(self, addr, capacity) -> None:
        self.addr = addr
        self.capacity = capacity
        self.inbox = []
    
    def send_to(self, recv, content, size):
        if not recv.is_full_with_one_more_email(size):
            timestamp = datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
            email = {
                ""sender"": self.addr,
                ""receiver"": recv.addr,
                ""content"": content,
                ""size"": size,
                ""time"": timestamp,
                ""state"": ""unread""
            }
            recv.inbox.append(email)
            return True
        else:
            self.clear_inbox(size)
            return False
    
    def fetch(self):
        if len(self.inbox) == 0:
            return None
        for i in range(len(self.inbox)):
            if self.inbox[i]['state'] == ""unread"":
                self.inbox[i]['state'] = ""read""
                return self.inbox[i]
        return None

    def is_full_with_one_more_email(self, size):
        occupied_size = self.get_occupied_size()
        return True if occupied_size + size > self.capacity else False
        
    def get_occupied_size(self):
        occupied_size = 0
        for email in self.inbox:
            occupied_size += email[""size""]
        return occupied_size

    def clear_inbox(self, size):
        if len(self.addr) == 0:
            return
        freed_space = 0
        while freed_space < size and self.inbox:
            email = self.inbox[0]
            freed_space += email['size']
            del self.inbox[0]",FewShot,"```python
from datetime import datetime

class EmailClient:
    """"""
    This is a class that serves as an email client, implementing functions such as checking emails, determining whether there is sufficient space, and cleaning up space.
    """"""

    def __init__(self, addr, capacity) -> None:
        """"""
        Initializes the EmailClient class with the email address and the capacity of the email box.
        :param addr: The email address, str.
        :param capacity: The capacity of the email box, float.
        """"""
        self.addr = addr
        self.capacity = capacity
        self.inbox = []

    def send_to(self, recv, content, size):
        """"""
        Sends an email to the given email address.
        :param recv: The email address of the receiver, str.
        :param content: The content of the email, str.
        :param size: The size of the email, float.
        :return: True if the email is sent successfully, False if the receiver's email box is full.
        """"""
        if recv.is_full_with_one_more_email(size):
            return False
        
        email = {
            'sender': self.addr,
            'receiver': recv.addr,
            'content': content,
            'size': size,
            'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'state': 'unread'
        }
        recv.inbox.append(email)
        return True

    def fetch(self):
        """"""
        Retrieves the first unread email in the email box and marks it as read.
        :return: The first unread email in the email box, dict.
        """"""
        for email in self.inbox:
            if email['state'] == 'unread':
                email['state'] = 'read'
                return email
        return None

    def is_full_with_one_more_email(self, size):
        """"""
        Determines whether the email box is full after adding an email of the given size.
        :param size: The size of the email, float.
        :return: True if the email box is full, False otherwise.
        """"""
        return self.get_occupied_size() + size > self.capacity

    def get_occupied_size(self):
        """"""
        Gets the total size of the emails in the email box.
        :return: The total size of the emails in the email box, float.
        """"""
        return sum(email['size'] for email in self.inbox)

    def clear_inbox(self, size):
        """"""
        Clears the email box by deleting the oldest emails until the email box has enough space to accommodate the given size.
        :param size: The size of the email, float.
        """"""
        while self.is_full_with_one_more_email(size):
            if self.inbox:
                self.inbox.pop(0)
```",0.096875,0.122816401,0.590361446,0.352517986,0.441441437,0.404255319,0.226190476,0.290076331,0.590361446,0.352517986,0.441441437,,,,,,,,,,,,
GPT,37,"class EncryptionUtils:
    def __init__(self, key):
        self.key = key

    def caesar_cipher(self, plaintext, shift):
        ciphertext = """"
        for char in plaintext:
            if char.isalpha():
                if char.isupper():
                    ascii_offset = 65
                else:
                    ascii_offset = 97
                shifted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)
                ciphertext += shifted_char
            else:
                ciphertext += char
        return ciphertext
    
    def vigenere_cipher(self, plain_text):
        encrypted_text = """"
        key_index = 0
        for char in plain_text:
            if char.isalpha():
                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')
                encrypted_char = chr((ord(char.lower()) - ord('a') + shift) % 26 + ord('a'))
                encrypted_text += encrypted_char.upper() if char.isupper() else encrypted_char
                key_index += 1
            else:
                encrypted_text += char
        return encrypted_text

    def rail_fence_cipher(self, plain_text, rails):
        fence = [['\n' for _ in range(len(plain_text))] for _ in range(rails)]
        direction = -1
        row, col = 0, 0

        for char in plain_text:
            if row == 0 or row == rails-1:
                direction = -direction

            fence[row][col] = char
            col += 1
            row += direction

        encrypted_text = ''
        for i in range(rails):
            for j in range(len(plain_text)):
                if fence[i][j] != '\n':
                    encrypted_text += fence[i][j]

        return encrypted_text",FewShot,"```python
class EncryptionUtils:
    """"""
    This is a class that provides methods for encryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.
    """"""

    def __init__(self, key):
        """"""
        Initializes the class with a key.
        :param key: The key to use for encryption, str.
        """"""
        self.key = key

    def caesar_cipher(self, plaintext, shift):
        """"""
        Encrypts the plaintext using the Caesar cipher.
        :param plaintext: The plaintext to encrypt, str.
        :param shift: The number of characters to shift each character in the plaintext, int.
        :return: The ciphertext, str.
        >>> e = EncryptionUtils(""key"")
        >>> e.caesar_cipher(""abc"", 1)
        'bcd'
        """"""
        ciphertext = """"
        for char in plaintext:
            if char.isalpha():
                shift_amount = shift % 26
                start = ord('a') if char.islower() else ord('A')
                new_char = chr(start + (ord(char) - start + shift_amount) % 26)
                ciphertext += new_char
            else:
                ciphertext += char
        return ciphertext

    def vigenere_cipher(self, plaintext):
        """"""
        Encrypts the plaintext using the Vigenere cipher.
        :param plaintext: The plaintext to encrypt, str.
        :return: The ciphertext, str.
        >>> e = EncryptionUtils(""key"")
        >>> e.vigenere_cipher(""abc"")
        'kfa'
        """"""
        ciphertext = """"
        key_length = len(self.key)
        key_int = [ord(i) for i in self.key]
        plaintext_int = [ord(i) for i in plaintext]
        for i in range(len(plaintext_int)):
            if plaintext[i].isalpha():
                value = (plaintext_int[i] + key_int[i % key_length]) % 26
                start = ord('a') if plaintext[i].islower() else ord('A')
                ciphertext += chr(start + value)
            else:
                ciphertext += plaintext[i]
        return ciphertext

    def rail_fence_cipher(self, plain_text, rails):
        """"""
        Encrypts the plaintext using the Rail Fence cipher.
        :param plain_text: The plaintext to encrypt, str.
        :param rails: The number of rails to use in the cipher, int.
        :return: The ciphertext, str.
        >>> e = EncryptionUtils(""key"")
        >>> e.rail_fence_cipher(""abc"", 2)
        'acb'
        """"""
        if rails == 1:
            return plain_text

        rail = ['' for _ in range(rails)]
        direction_down = False
        row, col = 0, 0

        for char in plain_text:
            rail[row] += char
            if row == 0 or row == rails - 1:
                direction_down = not direction_down
            row += 1 if direction_down else -1

        return ''.join(rail)
```",0.115384615,0.155415464,0.592592593,0.358208955,0.446511623,0.333333333,0.197530864,0.248062011,0.543209877,0.328358209,0.409302321,,,,,,,,,,,,
GPT,38,"import openpyxl


class ExcelProcessor:
    def __init__(self):
        pass

    def read_excel(self, file_name):
        data = []
        try:
            workbook = openpyxl.load_workbook(file_name)
            sheet = workbook.active
            for row in sheet.iter_rows(values_only=True):
                data.append(row)
            workbook.close()
            return data
        except:
            return None

    def write_excel(self, data, file_name):
        try:
            workbook = openpyxl.Workbook()
            sheet = workbook.active
            for row in data:
                sheet.append(row)
            workbook.save(file_name)
            workbook.close()
            return 1
        except:
            return 0

    def process_excel_data(self, N, save_file_name):
        data = self.read_excel(save_file_name)
        if data is None or N >= len(data[0]):
            return 0
        new_data = []
        for row in data:
            new_row = list(row[:])
            if not str(row[N]).isdigit():
                new_row.append(str(row[N]).upper())
            else:
                new_row.append(row[N])
            new_data.append(new_row)
        new_file_name = save_file_name.split('.')[0] + '_process.xlsx'
        success = self.write_excel(new_data, new_file_name)
        return success, new_file_name",FewShot,"```python
import openpyxl


class ExcelProcessor:
    """"""
    This is a class for processing excel files, including reading and writing excel data,
    as well as processing specific operations and saving as a new excel file.
    """"""

    def __init__(self):
        pass

    def read_excel(self, file_name):
        """"""
        Reading data from Excel files
        :param file_name: str, Excel file name to read
        :return: list of data, Data in Excel
        """"""
        try:
            # Load the workbook and select the active worksheet
            workbook = openpyxl.load_workbook(file_name)
            sheet = workbook.active
            
            # Read data from the sheet
            data = []
            for row in sheet.iter_rows(values_only=True):
                data.append(row)
            
            return data
        except Exception as e:
            print(f""Error reading Excel file: {e}"")
            return None

    def write_excel(self, data, file_name):
        """"""
        Write data to the specified Excel file
        :param data: list, Data to be written
        :param file_name: str, Excel file name to write to
        :return: 0 or 1, 1 represents successful writing, 0 represents failed writing
        """"""
        try:
            # Create a new workbook and select the active worksheet
            workbook = openpyxl.Workbook()
            sheet = workbook.active
            
            # Write data to the sheet
            for row in data:
                sheet.append(row)
            
            # Save the workbook to the specified file
            workbook.save(file_name)
            return 1
        except Exception as e:
            print(f""Error writing to Excel file: {e}"")
            return 0

    def process_excel_data(self, N, save_file_name):
        """"""
        Change the specified column in the Excel file to uppercase
        :param N: int, The serial number of the column that want to change
        :param save_file_name: str, source file name
        :return: (int, str), The former is the return value of write_excel, while the latter is the saved file name of the processed data
        """"""
        try:
            # Read data from the specified Excel file
            data = self.read_excel(save_file_name)
            if data is None:
                return 0, save_file_name
            
            # Process the specified column to uppercase
            column_index = N - 1  # Convert to 0-based index
            for i in range(1, len(data)):  # Skip the header row
                row = list(data[i])
                if isinstance(row[column_index], str):
                    row[column_index] = row[column_index].upper()
                data[i] = tuple(row)
            
            # Write the processed data to a new Excel file
            result = self.write_excel(data, save_file_name)
            return result, save_file_name
        except Exception as e:
            print(f""Error processing Excel data: {e}"")
            return 0, save_file_name
```",0.102639296,0.121649694,0.621212121,0.282758621,0.388625588,0.474747475,0.167857143,0.248021104,0.606060606,0.275862069,0.379146915,,,,,,,,,,,,
GPT,39,"import re
from collections import deque
from decimal import Decimal


class ExpressionCalculator:
    def __init__(self):
        self.postfix_stack = deque()
        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]

    def calculate(self, expression):
        self.prepare(self.transform(expression))

        result_stack = deque()
        self.postfix_stack.reverse()

        while self.postfix_stack:
            current_op = self.postfix_stack.pop()
            if not self.is_operator(current_op):
                current_op = current_op.replace(""~"", ""-"")
                result_stack.append(current_op)
            else:
                second_value = result_stack.pop()
                first_value = result_stack.pop()

                first_value = first_value.replace(""~"", ""-"")
                second_value = second_value.replace(""~"", ""-"")

                temp_result = self._calculate(first_value, second_value, current_op)
                result_stack.append(str(temp_result))

        return float(eval(""*"".join(result_stack)))

    def prepare(self, expression):
        op_stack = deque([','])
        arr = list(expression)
        current_index = 0
        count = 0

        for i, current_op in enumerate(arr):
            if self.is_operator(current_op):
                if count > 0:
                    self.postfix_stack.append("""".join(arr[current_index: current_index + count]))
                peek_op = op_stack[-1]
                if current_op == ')':
                    while op_stack[-1] != '(':
                        self.postfix_stack.append(str(op_stack.pop()))
                    op_stack.pop()
                else:
                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):
                        self.postfix_stack.append(str(op_stack.pop()))
                        peek_op = op_stack[-1]
                    op_stack.append(current_op)

                count = 0
                current_index = i + 1
            else:
                count += 1

        if count > 1 or (count == 1 and not self.is_operator(arr[current_index])):
            self.postfix_stack.append("""".join(arr[current_index: current_index + count]))

        while op_stack[-1] != ',':
            self.postfix_stack.append(str(op_stack.pop()))

    @staticmethod
    def is_operator(c):
        return c in {'+', '-', '*', '/', '(', ')', '%'}

    def compare(self, cur, peek):
        if cur == '%':
            cur = '/'
        if peek == '%':
            peek = '/'
        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]

    @staticmethod
    def _calculate(first_value, second_value, current_op):
        if current_op == '+':
            return Decimal(first_value) + Decimal(second_value)
        elif current_op == '-':
            return Decimal(first_value) - Decimal(second_value)
        elif current_op == '*':
            return Decimal(first_value) * Decimal(second_value)
        elif current_op == '/':
            return Decimal(first_value) / Decimal(second_value)
        elif current_op == '%':
            return Decimal(first_value) % Decimal(second_value)
        else:
            raise ValueError(""Unexpected operator: {}"".format(current_op))

    @staticmethod
    def transform(expression):
        expression = re.sub(r""\s+"", """", expression)
        expression = re.sub(r""=$"", """", expression)
        arr = list(expression)

        for i, c in enumerate(arr):
            if c == '-':
                if i == 0:
                    arr[i] = '~'
                else:
                    prev_c = arr[i - 1]
                    if prev_c in {'+', '-', '*', '/', '(', 'E', 'e'}:
                        arr[i] = '~'

        if arr[0] == '~' and (len(arr) > 1 and arr[1] == '('):
            arr[0] = '-'
            return ""0"" + """".join(arr)
        else:
            return """".join(arr)",FewShot,"```python
from collections import deque
from decimal import Decimal

class ExpressionCalculator:
    def __init__(self):
        self.postfix_stack = deque()
        self.operator_priority = {'+': 1, '-': 1, '*': 2, '/': 2, '%': 2, '(': 0, ')': 0}

    def calculate(self, expression):
        # Prepare expression and convert it to postfix
        self.prepare(expression)
        stack = []
        for token in self.postfix_stack:
            if token.isdigit():
                stack.append(Decimal(token))
            else:
                b = stack.pop()
                a = stack.pop()
                result = self._calculate(a, b, token)
                stack.append(result)
        return float(stack.pop())

    def prepare(self, expression):
        # Transform expression and convert to postfix notation
        transformed_expr = self.transform(expression)
        op_stack = deque()
        for char in transformed_expr:
            if char.isdigit():
                self.postfix_stack.append(char)
            elif char == '(':
                op_stack.append(char)
            elif char == ')':
                top_op = op_stack.pop()
                while top_op != '(':
                    self.postfix_stack.append(top_op)
                    top_op = op_stack.pop()
            else:
                while op_stack and self.compare(char, op_stack[-1]):
                    self.postfix_stack.append(op_stack.pop())
                op_stack.append(char)
        while op_stack:
            self.postfix_stack.append(op_stack.pop())

    @staticmethod
    def is_operator(c):
        return c in {'+', '-', '*', '/', '(', ')', '%'}

    def compare(self, cur, peek):
        return self.operator_priority[cur] <= self.operator_priority[peek]

    @staticmethod
    def _calculate(first_value, second_value, current_op):
        first_value, second_value = Decimal(first_value), Decimal(second_value)
        if current_op == '+':
            return first_value + second_value
        elif current_op == '-':
            return first_value - second_value
        elif current_op == '*':
            return first_value * second_value
        elif current_op == '/':
            return first_value / second_value
        elif current_op == '%':
            return first_value % second_value

    @staticmethod
    def transform(expression):
        # Remove spaces and return the cleaned expression
        return expression.replace(' ', '')

# Example usage
# expression_calculator = ExpressionCalculator()
# result = expression_calculator.calculate(""2 + 3 * 4"")
# print(result)  # Output: 14.0
```

- The `calculate` method evaluates the postfix expression using a stack.
- The `prepare` method converts an infix expression to postfix notation using the Shunting Yard algorithm.
- The `is_operator` method checks if a character is an operator.
- The `compare` method compares the precedence of two operators.
- The `_calculate` method performs arithmetic operations based on the operator.
- The `transform` method removes spaces from the expression.",0.154329453,0.198031674,0.462585034,0.425,0.442996738,0.225694444,0.228070175,0.226876086,0.448979592,0.4125,0.429967422,,,,,,,,,,,,
GPT,40,"class FitnessTracker:
    def __init__(self, height, weight, age, sex) -> None:
        self.height = height
        self.weight = weight
        self.age = age
        self.sex = sex
        self.BMI_std = [
            {""male"": [20, 25]},
            {""female"": [19, 24]}
        ]

    def get_BMI(self):
        return self.weight / self.height ** 2

    def condition_judge(self):
        BMI = self.get_BMI()
        if self.sex == ""male"":
            BMI_range = self.BMI_std[0][""male""]
        else:
            BMI_range = self.BMI_std[1][""female""]
        if BMI > BMI_range[1]:
            # too fat
            return 1
        elif BMI < BMI_range[0]:
            # too thin
            return -1
        else:
            # normal
            return 0

    def calculate_calorie_intake(self):
        if self.sex == ""male"":
            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5
        else:
            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161
        if self.condition_judge() == 1:
            calorie_intake = BMR * 1.2  # Sedentary lifestyle
        elif self.condition_judge() == -1:
            calorie_intake = BMR * 1.6  # Active lifestyle
        else:
            calorie_intake = BMR * 1.4  # Moderate lifestyle
        return calorie_intake",FewShot,"```python
class FitnessTracker:
    """"""
    This is a class as fitness tracker that implements to calculate BMI (Body Mass Index) and calorie intake based on the user's height, weight, age, and sex.
    """"""

    def __init__(self, height, weight, age, sex) -> None:
        """"""
        Initialize the class with height, weight, age, and sex, and calculate the BMI standard based on sex, and male is 20-25, female is 19-24.
        """"""
        self.height = height
        self.weight = weight
        self.age = age
        self.sex = sex
        self.BMI_std = [
            {""male"": [20, 25]},
            {""female"": [19, 24]}
        ]

    def get_BMI(self):
        """"""
        Calculate the BMI based on the height and weight.
        :return: BMI, which is the weight divided by the square of height, float.
        >>> fitnessTracker = FitnessTracker(1.8, 70, 20, ""male"")
        >>> fitnessTracker.get_BMI()
        21.604938271604937
        """"""
        BMI = self.weight / (self.height ** 2)
        return BMI

    def condition_judge(self):
        """"""
        Judge the condition of the user based on the BMI standard.
        :return: 1 if the user is too fat, -1 if the user is too thin, 0 if the user is normal, int.
        >>> fitnessTracker = FitnessTracker(1.8, 70, 20, ""male"")
        >>> fitnessTracker.condition_judge()
        -1
        """"""
        BMI = self.get_BMI()
        std_range = self.BMI_std[0][self.sex] if self.sex == ""male"" else self.BMI_std[1][self.sex]
        
        if BMI < std_range[0]:
            return -1  # Too thin
        elif BMI > std_range[1]:
            return 1  # Too fat
        else:
            return 0  # Normal

    def calculate_calorie_intake(self):
        """"""
        Calculate the calorie intake based on the user's condition and BMR (Basal Metabolic Rate).
        BMR is calculated based on the user's height, weight, age, and sex.
        - Male: BMR = 10 * weight + 6.25 * height - 5 * age + 5
        - Female: BMR = 10 * weight + 6.25 * height - 5 * age - 161
        The calorie intake is calculated based on the BMR and the user's condition:
        - If the user is too fat, the calorie intake is BMR * 1.2
        - If the user is too thin, the calorie intake is BMR * 1.6
        - If the user is normal, the calorie intake is BMR * 1.4
        :return: calorie intake, float.
        >>> fitnessTracker = FitnessTracker(1.8, 70, 20, ""male"")
        >>> fitnessTracker.calculate_calorie_intake()
        986.0
        """"""
        if self.sex == ""male"":
            BMR = 10 * self.weight + 6.25 * self.height * 100 - 5 * self.age + 5
        else:
            BMR = 10 * self.weight + 6.25 * self.height * 100 - 5 * self.age - 161

        condition = self.condition_judge()
        
        if condition == 1:
            return BMR * 1.2
        elif condition == -1:
            return BMR * 1.6
        else:
            return BMR * 1.4
```",0.151589242,0.187194825,0.847222222,0.429577465,0.570093453,0.598484848,0.280141844,0.381642508,0.819444444,0.415492958,0.551401865,,,,,,,,,,,,
GPT,41,"class GomokuGame:
    def __init__(self, board_size):
        self.board_size = board_size
        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        return False

    def check_winner(self):
        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]
        for row in range(self.board_size):
            for col in range(self.board_size):
                if self.board[row][col] != ' ':
                    for direction in directions:
                        if self._check_five_in_a_row(row, col, direction):
                            return self.board[row][col]
        return None

    def _check_five_in_a_row(self, row, col, direction):
        dx, dy = direction
        count = 1
        symbol = self.board[row][col]
        for i in range(1, 5):
            new_row = row + dx * i
            new_col = col + dy * i
            if not (0 <= new_row < self.board_size and 0 <= new_col < self.board_size):
                return False
            if self.board[new_row][new_col] != symbol:
                return False
            count += 1
        return count == 5",FewShot,"```python
class GomokuGame:
    """"""
    This class is an implementation of a Gomoku game, supporting for making moves, checking for a winner, and checking if there are five consecutive symbols on the game board.
    """"""

    def __init__(self, board_size):
        """"""
        Initializes the game with a given board size.
        It initializes the board with empty spaces and sets the current player symbol as 'X'.
        """"""
        self.board_size = board_size
        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]
        self.current_player = 'X'

    def make_move(self, row, col):
        """"""
        Makes a move at the given row and column.
        If the move is valid, it places the current player's symbol on the board
        and changes the current player to the other player (if the current player is 'X', then it becomes 'O' and vice versa).
        :param row: int, the row index of this move
        :param col: int, the column index
        return: True if the move is valid, or False otherwise.
        """"""
        # Check if the move is within the board and the cell is empty
        if 0 <= row < self.board_size and 0 <= col < self.board_size and self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            # Toggle the current player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        return False

    def check_winner(self):
        """"""
        Checks if there is a winner by looking for five in a row in all directions (horizontal, vertical, diagonal).
        return: the symbol of the winning player (either 'X' or 'O') if there is a winner, or None otherwise.
        """"""
        # Directions: horizontal, vertical, diagonal (down-right), diagonal (up-right)
        directions = [(0, 1), (1, 0), (1, 1), (-1, 1)]
        for row in range(self.board_size):
            for col in range(self.board_size):
                if self.board[row][col] != ' ':
                    for direction in directions:
                        if self._check_five_in_a_row(row, col, direction):
                            return self.board[row][col]
        return None

    def _check_five_in_a_row(self, row, col, direction):
        """"""
        Checks if there are five consecutive symbols of the same player in a row starting from a given cell in a given direction (horizontal, vertical, diagonal).
        Counts the number of consecutive symbols in that direction starting from the given cell.
        :param row: int, row of the given cell
        :param col: int, column of the given cell
        :param direction: tuple, (int, int), named as (dx, dy). Row and col will plus several dx and dy respectively.
        :return: True if there are five consecutive symbols of the same player, and False otherwise.
        """"""
        dx, dy = direction
        current_symbol = self.board[row][col]
        count = 0

        # Check in the specified direction
        for _ in range(5):
            if 0 <= row < self.board_size and 0 <= col < self.board_size and self.board[row][col] == current_symbol:
                count += 1
                row += dx
                col += dy
            else:
                break

        return count == 5
```",0.184090909,0.204159519,0.828571429,0.341176471,0.483333329,0.656934307,0.25862069,0.371134017,0.828571429,0.341176471,0.483333329,,,,,,,,,,,,
GPT,42,"class Hotel:
    def __init__(self, name, rooms):
        self.name = name
        self.available_rooms = rooms
        # available_rooms = {room_type1: room_number1, room_type2: room_number2, ...}
        # available_rooms = {'single': 5, 'double': 3}
        self.booked_rooms = {}
        # booked_rooms = {room_type1: {name1: room_number1, name2: room_number2, ...}, room_type2: {...}, ...}
        # booked_rooms = {'single': {'name1': 2, 'name2':1}, 'double': {}}

    def book_room(self, room_type, room_number, name):
        # Check if there are any rooms of the specified type available
        if room_type not in self.available_rooms.keys():
            return False

        if room_number <= self.available_rooms[room_type]:
            # Book the room by adding it to the booked_rooms dictionary
            if room_type not in self.booked_rooms.keys():
                self.booked_rooms[room_type] = {}
            self.booked_rooms[room_type][name] = room_number
            self.available_rooms[room_type] -= room_number
            return ""Success!""
        elif self.available_rooms[room_type] != 0:
            return self.available_rooms[room_type]
        else:
            return False

    def check_in(self, room_type, room_number, name):
        # Check if the room of the specified type and number is booked
        if room_type not in self.booked_rooms.keys():
            return False
        if name in self.booked_rooms[room_type]:
            if room_number > self.booked_rooms[room_type][name]:
                return False
            elif room_number == self.booked_rooms[room_type][name]:
                # Check in the room by removing it from the booked_rooms dictionary
                self.booked_rooms[room_type].pop(name)
            else:
                self.booked_rooms[room_type][name] -= room_number


    def check_out(self, room_type, room_number):
        if room_type in self.available_rooms:
            self.available_rooms[room_type] += room_number
        else:
            self.available_rooms[room_type] = room_number

    def get_available_rooms(self, room_type):
        return self.available_rooms[room_type]",FewShot,"```python
class Hotel:
    """"""
    This is a class as hotel management system, managing the booking, check-in, check-out, and availability of rooms in a hotel with different room types.
    """"""

    def __init__(self, name, rooms):
        """"""
        Initialize the three fields in Hotel System.
        name is the hotel name.
        available_rooms stores the remaining rooms in the hotel
        booked_rooms stores the rooms that have been booked and the person's name who booked rooms.
        """"""
        self.name = name
        self.available_rooms = rooms
        self.booked_rooms = {}

    def book_room(self, room_type, room_number, name):
        """"""
        Book rooms of a specified type if available.
        """"""
        if room_type not in self.available_rooms or self.available_rooms[room_type] == 0:
            return False
        if room_number > self.available_rooms[room_type]:
            return self.available_rooms[room_type]
        
        # Deduct the booked rooms from available rooms
        self.available_rooms[room_type] -= room_number
        
        # Add to booked rooms
        if room_type not in self.booked_rooms:
            self.booked_rooms[room_type] = {}
        
        if name in self.booked_rooms[room_type]:
            self.booked_rooms[room_type][name] += room_number
        else:
            self.booked_rooms[room_type][name] = room_number
        
        return 'Success!'

    def check_in(self, room_type, room_number, name):
        """"""
        Check in the booked rooms for the specified guest.
        """"""
        if room_type not in self.booked_rooms or name not in self.booked_rooms[room_type]:
            return False
        if room_number > self.booked_rooms[room_type][name]:
            return False
        
        # Reduce the booked room count
        self.booked_rooms[room_type][name] -= room_number
        if self.booked_rooms[room_type][name] == 0:
            del self.booked_rooms[room_type][name]
        
        return True

    def check_out(self, room_type, room_number):
        """"""
        Check out rooms and update available rooms.
        """"""
        if room_type in self.available_rooms:
            self.available_rooms[room_type] += room_number
        else:
            self.available_rooms[room_type] = room_number

    def get_available_rooms(self, room_type):
        """"""
        Get the number of specific type of available rooms.
        """"""
        return self.available_rooms.get(room_type, 0)
```",0.19665272,0.248098198,0.647727273,0.553398058,0.596858634,0.417721519,0.32195122,0.363636359,0.625,0.533980583,0.575916225,,,,,,,,,,,,
GPT,43,"class HRManagementSystem:
    def __init__(self):
        self.employees = {}

    def add_employee(self, employee_id, name, position, department, salary):
        if employee_id in self.employees:
            return False
        else:
            self.employees[employee_id] = {
                'name': name,
                'position': position,
                'department': department,
                'salary': salary
            }
            return True

    def remove_employee(self, employee_id):
        if employee_id in self.employees:
            del self.employees[employee_id]
            return True
        else:
            return False

    def update_employee(self, employee_id: int, employee_info: dict):
        employee = self.get_employee(employee_id)
        if employee == False:
            return False
        else:
            for key, value in employee_info.items():
                if key not in employee:
                    return False
            for key, value in employee_info.items():
                employee[key] = value
            return True

    def get_employee(self, employee_id):
        if employee_id in self.employees:
            return self.employees[employee_id]
        else:
            return False

    def list_employees(self):
        employee_data = {}
        if self.employees:
            for employee_id, employee_info in self.employees.items():
                employee_details = {}
                employee_details[""employee_ID""] = employee_id
                for key, value in employee_info.items():
                    employee_details[key] = value
                employee_data[employee_id] = employee_details
        return employee_data",FewShot,"```python
class HRManagementSystem:
    """"""
    This is a class as personnel management system that implements functions such as adding, deleting, querying, and updating employees
    """"""

    def __init__(self):
        """"""
        Initialize the HRManagementSystem with an attribute employees, which is an empty dictionary.
        """"""
        self.employees = {}

    def add_employee(self, employee_id, name, position, department, salary):
        """"""
        Add a new employee to the HRManagementSystem.
        :param employee_id: The employee's id, int.
        :param name: The employee's name, str.
        :param position: The employee's position, str.
        :param department: The employee's department, str.
        :param salary: The employee's salary, int.
        :return: If the employee is already in the HRManagementSystem, returns False, otherwise, returns True.
        """"""
        # Check if the employee_id already exists in the employees dictionary
        if employee_id in self.employees:
            return False
        # Add the new employee to the employees dictionary
        self.employees[employee_id] = {
            'name': name,
            'position': position,
            'department': department,
            'salary': salary
        }
        return True

    def remove_employee(self, employee_id):
        """"""
        Remove an employee from the HRManagementSystem.
        :param employee_id: The employee's id, int.
        :return: If the employee is already in the HRManagementSystem, returns True, otherwise, returns False.
        """"""
        # Check if the employee_id exists in the employees dictionary
        if employee_id in self.employees:
            # Remove the employee from the employees dictionary
            del self.employees[employee_id]
            return True
        return False

    def update_employee(self, employee_id: int, employee_info: dict):
        """"""
        Update an employee's information in the HRManagementSystem.
        :param employee_id: The employee's id, int.
        :param employee_info: The employee's information, dict.
        :return: If the employee is already in the HRManagementSystem, returns True, otherwise, returns False.
        """"""
        # Check if the employee_id exists in the employees dictionary
        if employee_id in self.employees:
            # Update the employee's information
            self.employees[employee_id].update(employee_info)
            return True
        return False

    def get_employee(self, employee_id):
        """"""
        Get an employee's information from the HRManagementSystem.
        :param employee_id: The employee's id, int.
        :return: If the employee is already in the HRManagementSystem, returns the employee's information, otherwise, returns False.
        """"""
        # Return the employee's information if the employee_id exists
        return self.employees.get(employee_id, False)

    def list_employees(self):
        """"""
        List all employees' information in the HRManagementSystem.
        :return: A dictionary of all employees' information.
        """"""
        # Return a copy of the employees dictionary
        return {emp_id: {'employee_ID': emp_id, **info} for emp_id, info in self.employees.items()}
```",0.117816092,0.140008321,0.706896552,0.347457627,0.465909086,0.447619048,0.21559633,0.291021667,0.706896552,0.347457627,0.465909086,,,,,,,,,,,,
GPT,44,"import re
import string
import gensim
from bs4 import BeautifulSoup


class HtmlUtil:

    def __init__(self):
        self.SPACE_MARK = '-SPACE-'
        self.JSON_MARK = '-JSON-'
        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'
        self.URL_MARK = '-URL-'
        self.NUMBER_MARK = '-NUMBER-'
        self.TRACE_MARK = '-TRACE-'
        self.COMMAND_MARK = '-COMMAND-'
        self.COMMENT_MARK = '-COMMENT-'
        self.CODE_MARK = '-CODE-'

    @staticmethod
    def __format_line_feed(text):
        return re.sub(re.compile(r'\n+'), '\n', text)

    def format_line_html_text(self, html_text):
        if html_text is None or len(html_text) == 0:
            return ''
        soup = BeautifulSoup(html_text, 'lxml')

        code_tag = soup.find_all(name=['pre', 'blockquote'])
        for tag in code_tag:
            tag.string = self.CODE_MARK

        ul_ol_group = soup.find_all(name=['ul', 'ol'])
        for ul_ol_item in ul_ol_group:
            li_group = ul_ol_item.find_all('li')
            for li_item in li_group:
                li_item_text = li_item.get_text().strip()
                if len(li_item_text) == 0:
                    continue
                if li_item_text[-1] in string.punctuation:
                    li_item.string = '[{0}]{1}'.format('-', li_item_text)
                    continue
                li_item.string = '[{0}]{1}.'.format('-', li_item_text)

        p_group = soup.find_all(name=['p'])
        for p_item in p_group:
            p_item_text = p_item.get_text().strip()
            if p_item_text:
                if p_item_text[-1] in string.punctuation:
                    p_item.string = p_item_text
                    continue
                next_sibling = p_item.find_next_sibling()
                if next_sibling and self.CODE_MARK in next_sibling.get_text():
                    p_item.string = p_item_text + ':'
                    continue
                p_item.string = p_item_text + '.'

        clean_text = gensim.utils.decode_htmlentities(soup.get_text())
        return self.__format_line_feed(clean_text)

    def extract_code_from_html_text(self, html_text):
        text_with_code_tag = self.format_line_html_text(html_text)

        if self.CODE_MARK not in text_with_code_tag:
            return []

        code_index_start = 0
        soup = BeautifulSoup(html_text, 'lxml')
        code_tag = soup.find_all(name=['pre', 'blockquote'])
        code_count = text_with_code_tag.count(self.CODE_MARK)
        code_list = []
        for code_index in range(code_index_start, code_index_start + code_count):
            code = code_tag[code_index].get_text()
            if code:
                code_list.append(code)
        return code_list",FewShot,"```python
import re
from bs4 import BeautifulSoup

class HtmlUtil:
    """"""
    This is a class as util for html, supporting for formatting and extracting code from HTML text, 
    including cleaning up the text and converting certain elements into specific marks.
    """"""

    def __init__(self):
        """"""
        Initialize a series of labels
        """"""
        self.SPACE_MARK = '-SPACE-'
        self.JSON_MARK = '-JSON-'
        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'
        self.URL_MARK = '-URL-'
        self.NUMBER_MARK = '-NUMBER-'
        self.TRACE_MARK = '-TRACE-'
        self.COMMAND_MARK = '-COMMAND-'
        self.COMMENT_MARK = '-COMMENT-'
        self.CODE_MARK = '-CODE-'

    @staticmethod
    def __format_line_feed(text):
        """"""
        Replace consecutive line breaks with a single line break
        :param text: string with consecutive line breaks
        :return: string, replaced text with single line break
        """"""
        return re.sub(r'\n+', '\n', text)

    def format_line_html_text(self, html_text):
        """"""
        Get the html text without the code, and add the code tag -CODE- where the code is
        :param html_text: string
        :return: string
        """"""
        soup = BeautifulSoup(html_text, 'html.parser')
        # Extract all code/pre elements and replace them with the CODE_MARK
        for code_block in soup.find_all(['code', 'pre']):
            code_block.replace_with(self.CODE_MARK)
        
        # Get text from the modified soup and format line feeds
        formatted_text = soup.get_text()
        return self.__format_line_feed(formatted_text)

    def extract_code_from_html_text(self, html_text):
        """"""
        Extract codes from the html body
        :param html_text: string, html text
        :return: list of code strings
        """"""
        soup = BeautifulSoup(html_text, 'html.parser')
        code_list = []

        # Extract all code/pre elements and append their text to code_list
        for code_block in soup.find_all(['code', 'pre']):
            code_list.append(code_block.get_text())

        return code_list
```

# Explanation:
1. **__format_line_feed**: This static method replaces multiple consecutive newline characters with a single newline using a regular expression.
   
2. **format_line_html_text**: This method uses BeautifulSoup to parse the HTML text, removes code and pre elements by replacing them with the `-CODE-` marker, and then extracts and formats the remaining text.

3. **extract_code_from_html_text**: This method uses BeautifulSoup to find all `code` and `pre` elements in the HTML text, extracts their content, and returns it as a list of code strings.",0.130434783,0.153998608,0.435897436,0.320754717,0.369565213,0.279069767,0.213523132,0.241935479,0.435897436,0.320754717,0.369565213,,,,,,,,,,,,
GPT,45,"from PIL import Image, ImageEnhance, ImageChops


class ImageProcessor:
    def __init__(self):
        self.image = None

    def load_image(self, image_path):
        self.image = Image.open(image_path)

    def save_image(self, save_path):
        if self.image:
            self.image.save(save_path)

    def resize_image(self, width, height):
        if self.image:
            self.image = self.image.resize((width, height))

    def rotate_image(self, degrees):
        if self.image:
            self.image = self.image.rotate(degrees)

    def adjust_brightness(self, factor):
        if self.image:
            enhancer = ImageEnhance.Brightness(self.image)
            self.image = enhancer.enhance(factor)",FewShot,"```python
from PIL import Image, ImageEnhance

class ImageProcessor:
    """"""
    This is a class to process image, including loading, saving, resizing, rotating, and adjusting the brightness of images.
    """"""

    def __init__(self):
        """"""
        Initialize self.image
        """"""
        self.image = None

    def load_image(self, image_path):
        """"""
        Use Image util in PIL to open an image
        :param image_path: str, path of image that is to be loaded
        >>> processor.load_image('test.jpg')
        >>> processor.image
        <PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=3072x4096 at 0x194F2412A48>
        """"""
        # Open the image and set it to self.image
        self.image = Image.open(image_path)

    def save_image(self, save_path):
        """"""
        Save image to a path if image has opened
        :param save_path: str, the path that the image will be saved
        >>> processor.load_image('test.jpg')
        >>> processor.save_image('test2.jpg')
        """"""
        # Save the image to the specified path if it's loaded
        if self.image:
            self.image.save(save_path)

    def resize_image(self, width, height):
        """"""
        Resize the image if image has opened.
        :param width: int, the target width of image
        :param height: int, the target height of image
        >>> processor.load_image('test.jpg')
        >>> processor.resize_image(300, 300)
        >>> processor.image.width
        300
        >>> processor.image.height
        300
        """"""
        # Resize the image to the specified width and height if it's loaded
        if self.image:
            self.image = self.image.resize((width, height))

    def rotate_image(self, degrees):
        """"""
        Rotate image if image has opened
        :param degrees: float, the degrees that the image will be rotated
        >>> processor.load_image('test.jpg')
        >>> processor.rotate_image(90)
        """"""
        # Rotate the image by the specified degree if it's loaded
        if self.image:
            self.image = self.image.rotate(degrees, expand=True)

    def adjust_brightness(self, factor):
        """"""
        Adjust the brightness of image if image has opened.
        :param factor: float, brightness of an image. A factor of 0.0 gives a black image. A factor of 1.0 gives the original image.
        >>> processor.load_image('test.jpg')
        >>> processor.adjust_brightness(0.5)
        """"""
        # Adjust the brightness of the image by the specified factor if it's loaded
        if self.image:
            enhancer = ImageEnhance.Brightness(self.image)
            self.image = enhancer.enhance(factor)
```",0.10652921,0.119874146,0.921052632,0.284552846,0.434782605,0.769230769,0.17699115,0.287769781,0.921052632,0.284552846,0.434782605,,,,,,,,,,,,
GPT,46,"class Interpolation:
    def __init__(self):
        pass

    @staticmethod
    def interpolate_1d(x, y, x_interp):
        y_interp = []
        for xi in x_interp:
            for i in range(len(x) - 1):
                if x[i] <= xi <= x[i+1]:
                    yi = y[i] + (y[i+1] - y[i]) * (xi - x[i]) / (x[i+1] - x[i])
                    y_interp.append(yi)
                    break
        return y_interp
    
    @staticmethod
    def interpolate_2d(x, y, z, x_interp, y_interp):
        z_interp = []
        for xi, yi in zip(x_interp, y_interp):
            for i in range(len(x) - 1):
                if x[i] <= xi <= x[i+1]:
                    for j in range(len(y) - 1):
                        if y[j] <= yi <= y[j+1]:
                            z00 = z[i][j]
                            z01 = z[i][j+1]
                            z10 = z[i+1][j]
                            z11 = z[i+1][j+1]
                            zi = (z00 * (x[i+1] - xi) * (y[j+1] - yi) +
                                  z10 * (xi - x[i]) * (y[j+1] - yi) +
                                  z01 * (x[i+1] - xi) * (yi - y[j]) +
                                  z11 * (xi - x[i]) * (yi - y[j])) / ((x[i+1] - x[i]) * (y[j+1] - y[j]))
                            z_interp.append(zi)
                            break
                    break
        return z_interp",FewShot,"```python
class Interpolation:
    """"""
    This is a class that implements the Linear interpolation operation of one-dimensional and two-dimensional data.
    """"""

    def __init__(self):
        pass

    @staticmethod
    def interpolate_1d(x, y, x_interp):
        """"""
        Linear interpolation of one-dimensional data
        :param x: The x-coordinate of the data point, list.
        :param y: The y-coordinate of the data point, list.
        :param x_interp: The x-coordinate of the interpolation point, list.
        :return: The y-coordinate of the interpolation point, list.
        >>> interpolation = Interpolation()
        >>> interpolation.interpolate_1d([1, 2, 3], [1, 2, 3], [1.5, 2.5])
        [1.5, 2.5]
        """"""
        y_interp = []  # List to store interpolated y values
        for xi in x_interp:
            # Find the interval [x[i], x[i+1]] where xi is located
            for i in range(len(x) - 1):
                if x[i] <= xi <= x[i + 1]:
                    # Perform linear interpolation
                    yi = y[i] + (y[i + 1] - y[i]) * (xi - x[i]) / (x[i + 1] - x[i])
                    y_interp.append(yi)
                    break
        return y_interp

    @staticmethod
    def interpolate_2d(x, y, z, x_interp, y_interp):
        """"""
        Linear interpolation of two-dimensional data
        :param x: The x-coordinate of the data point, list.
        :param y: The y-coordinate of the data point, list.
        :param z: The z-coordinate of the data point, 2D list.
        :param x_interp: The x-coordinate of the interpolation point, list.
        :param y_interp: The y-coordinate of the interpolation point, list.
        :return: The z-coordinate of the interpolation point, list.
        >>> interpolation = Interpolation()
        >>> interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1.5, 2.5], [1.5, 2.5])
        [3.0, 7.0]
        """"""
        z_interp = []  # List to store interpolated z values
        for xi, yi in zip(x_interp, y_interp):
            # Find the rectangle [x[i], x[i+1]] x [y[j], y[j+1]] where (xi, yi) is located
            for i in range(len(x) - 1):
                for j in range(len(y) - 1):
                    if x[i] <= xi <= x[i + 1] and y[j] <= yi <= y[j + 1]:
                        # Perform bilinear interpolation
                        z1 = z[j][i]
                        z2 = z[j][i + 1]
                        z3 = z[j + 1][i]
                        z4 = z[j + 1][i + 1]

                        # Interpolation weights
                        t = (xi - x[i]) / (x[i + 1] - x[i])
                        u = (yi - y[j]) / (y[j + 1] - y[j])

                        # Calculate interpolated z value
                        zi = (1 - t) * (1 - u) * z1 + t * (1 - u) * z2 + (1 - t) * u * z3 + t * u * z4
                        z_interp.append(zi)
                        break
        return z_interp
```",0.150510204,0.178128096,0.742424242,0.32885906,0.455813949,0.543859649,0.240310078,0.333333329,0.712121212,0.315436242,0.437209298,,,,,,,,,,,,
GPT,47,"class IPAddress:
    def __init__(self, ip_address):
        self.ip_address = ip_address

    def is_valid(self):
        octets = self.ip_address.split('.')
        if len(octets) != 4:
            return False
        for octet in octets:
            if not octet.isdigit() or int(octet) < 0 or int(octet) > 255:
                return False
        return True

    def get_octets(self):
        if self.is_valid():
            return self.ip_address.split('.')
        else:
            return []

    def get_binary(self):
        if self.is_valid():
            binary_octets = []
            for octet in self.get_octets():
                binary_octets.append(format(int(octet), '08b'))
            return '.'.join(binary_octets)
        else:
            return ''",FewShot,"```python
class IPAddress:
    """"""
    This is a class to process IP Address, including validating, getting the octets and obtaining the binary representation of a valid IP address.
    """"""

    def __init__(self, ip_address):
        """"""
        Initialize the IP address to the specified address
        :param ip_address:string
        """"""
        self.ip_address = ip_address

    def is_valid(self):
        """"""
        Judge whether the IP address is valid, that is, whether the IP address is composed of four Decimal digits separated by '.'. Each digit is greater than or equal to 0 and less than or equal to 255
        :return: bool
        >>> ipaddress = IPAddress(""10.10.10.10"")
        >>> ipaddress.is_valid()
        True
        """"""
        # Split the IP address into its components
        parts = self.ip_address.split('.')
        
        # Check if there are exactly four parts
        if len(parts) != 4:
            return False
        
        for part in parts:
            # Check if each part is a digit and within the range 0 to 255
            if not part.isdigit() or not 0 <= int(part) <= 255:
                return False
        
        return True

    def get_octets(self):
        """"""
        If the IP address is valid, the list of four decimal numbers separated by ""."" constituting the IP address is returned; otherwise, an empty list is returned
        :return: list
        >>> ipaddress = IPAddress(""10.10.10.10"")
        >>> ipaddress.get_octets()
        [""10"", ""10"", ""10"", ""10""]
        """"""
        # Return the octets if the IP address is valid
        if self.is_valid():
            return self.ip_address.split('.')
        return []

    def get_binary(self):
        """"""
        If the IP address is valid, return the binary form of the IP address; otherwise, return ''
        :return: string
        >>> ipaddress = IPAddress(""10.10.10.10"")
        >>> ipaddress.get_binary()
        ""00001010.00001010.00001010.00001010""
        """"""
        if not self.is_valid():
            return ''

        # Convert each octet to its binary representation, zero-padded to 8 bits
        octets = self.get_octets()
        binary_octets = ['{:08b}'.format(int(octet)) for octet in octets]
        
        # Join the binary octets with dots
        return '.'.join(binary_octets)
```",0.0609319,0.081860643,0.790697674,0.248175182,0.377777774,0.552238806,0.151639344,0.237942119,0.790697674,0.248175182,0.377777774,,,,,,,,,,,,
GPT,48,"import socket


class IpUtil:

    @staticmethod
    def is_valid_ipv4(ip_address):
        try:
            socket.inet_pton(socket.AF_INET, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def is_valid_ipv6(ip_address):
        try:
            socket.inet_pton(socket.AF_INET6, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def get_hostname(ip_address):
        try:
            hostname = socket.gethostbyaddr(ip_address)[0]
            return hostname
        except socket.herror:
            return None",FewShot,"```python
import socket
import netifaces


class IpUtil:
    """"""
    This is a class as tool for ip that can be used to obtain the local IP address, validate its validity, and also provides the functionality to retrieve the corresponding hostname.
    """"""

    @staticmethod
    def is_valid_ipv4(ip_address):
        """"""
        Check if the given IP address is a valid IPv4 address.
        :param ip_address: string, the IP address to check
        :return: bool, True if the IP address is valid, False otherwise
        >>> IpUtil.is_valid_ipv4('192.168.0.123')
        True
        >>> IpUtil.is_valid_ipv4('256.0.0.0')
        False
        """"""
        try:
            # Attempt to convert the IP address to a packed binary format
            socket.inet_pton(socket.AF_INET, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def is_valid_ipv6(ip_address):
        """"""
        Check if the given IP address is a valid IPv6 address.
        :param ip_address:string, the IP address to check
        :return:bool, True if the IP address is valid, False otherwise
        >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:0000:0000:8a2e:0370:7334')
        True
        >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:::8a2e:0370:7334')
        False
        """"""
        try:
            # Attempt to convert the IP address to a packed binary format
            socket.inet_pton(socket.AF_INET6, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def get_hostname(ip_address):
        """"""
        Get the hostname associated with the given IP address.
        :param ip_address:string, the IP address to get the hostname for
        :return: string, the hostname associated with the IP address
        >>> IpUtil.get_hostname('110.242.68.3')
        'www.baidu.com'
        >>> IpUtil.get_hostname('10.0.0.1')
        """"""
        try:
            # Get the hostname for the given IP address
            hostname, _, _ = socket.gethostbyaddr(ip_address)
            return hostname
        except socket.herror:
            return None
```",0.104545455,0.121012949,0.958333333,0.223300971,0.362204721,0.714285714,0.158227848,0.259067355,0.958333333,0.223300971,0.362204721,,,,,,,,,,,,
GPT,49,"class JobMarketplace:
    def __init__(self):
        self.job_listings = []
        self.resumes = []

    def post_job(self, job_title, company, requirements):
        # requirements = ['requirement1', 'requirement2']
        job = {""job_title"": job_title, ""company"": company, ""requirements"": requirements}
        self.job_listings.append(job)

    def remove_job(self, job):
        self.job_listings.remove(job)

    def submit_resume(self, name, skills, experience):
        resume = {""name"": name, ""skills"": skills, ""experience"": experience}
        self.resumes.append(resume)

    def withdraw_resume(self, resume):
        self.resumes.remove(resume)

    def search_jobs(self, criteria):
        matching_jobs = []
        for job_listing in self.job_listings:
            if criteria.lower() in job_listing[""job_title""].lower() or criteria.lower() in [r.lower() for r in job_listing[""requirements""]]:
                matching_jobs.append(job_listing)
        return matching_jobs

    def get_job_applicants(self, job):
        applicants = []
        for resume in self.resumes:
            if self.matches_requirements(resume, job[""requirements""]):
                applicants.append(resume)
        return applicants

    @staticmethod
    def matches_requirements(resume, requirements):
        for skill in resume[""skills""]:
            if skill not in requirements:
                return False
        return True",FewShot,"```python
class JobMarketplace:
    """"""
    This is a class that provides functionalities to publish positions, remove positions, submit resumes, withdraw resumes, search for positions, and obtain candidate information.
    """"""

    def __init__(self):
        self.job_listings = []  # List to store job listings
        self.resumes = []       # List to store resumes

    def post_job(self, job_title, company, requirements):
        """"""
        This function is used to publish positions, and add the position information to the job_listings list.
        :param job_title: The title of the position, str.
        :param company: The company of the position, str.
        :param requirements: The requirements of the position, list.
        :return: None
        """"""
        # Create a dictionary for the job and append it to job_listings
        job = {
            'job_title': job_title,
            'company': company,
            'requirements': requirements
        }
        self.job_listings.append(job)

    def remove_job(self, job):
        """"""
        This function is used to remove positions, and remove the position information from the job_listings list.
        :param job: The position information to be removed, dict.
        :return: None
        """"""
        # Remove the job from job_listings if it exists
        if job in self.job_listings:
            self.job_listings.remove(job)

    def submit_resume(self, name, skills, experience):
        """"""
        This function is used to submit resumes, and add the resume information to the resumes list.
        :param name: The name of the resume, str.
        :param skills: The skills of the resume, list.
        :param experience: The experience of the resume, str.
        :return: None
        """"""
        # Create a dictionary for the resume and append it to resumes
        resume = {
            'name': name,
            'skills': skills,
            'experience': experience
        }
        self.resumes.append(resume)

    def withdraw_resume(self, resume):
        """"""
        This function is used to withdraw resumes, and remove the resume information from the resumes list.
        :param resume: The resume information to be removed, dict.
        :return: None
        """"""
        # Remove the resume from resumes if it exists
        if resume in self.resumes:
            self.resumes.remove(resume)

    def search_jobs(self, criteria):
        """"""
        This function is used to search for positions, and return the position information that meets the requirements.
        :param criteria: The requirements of the position, str.
        :return: The position information that meets the requirements, list.
        """"""
        # Find jobs that meet the criteria
        matching_jobs = [
            job for job in self.job_listings
            if criteria in job['requirements']
        ]
        return matching_jobs

    def get_job_applicants(self, job):
        """"""
        This function is used to obtain candidate information, and return the candidate information that meets the requirements by calling the matches_requirements function.
        :param job: The position information, dict.
        :return: The candidate information that meets the requirements, list.
        """"""
        # Find resumes that match the job requirements
        applicants = [
            resume for resume in self.resumes
            if self.matches_requirements(job, resume)
        ]
        return applicants

    def matches_requirements(self, job, resume):
        """"""
        Helper function to check if a resume matches the job requirements.
        :param job: The job information, dict.
        :param resume: The resume information, dict.
        :return: bool, True if the resume matches the job requirements, False otherwise.
        """"""
        # Check if all job requirements are in the resume's skills
        return all(req in resume['skills'] for req in job['requirements'])
```",0.047109208,0.06341459,0.647058824,0.307692308,0.417061607,0.396551724,0.152317881,0.22009569,0.632352941,0.300699301,0.407582934,,,,,,,,,,,,
GPT,50,"import json
import os


class JSONProcessor:
    def read_json(self, file_path):
        if not os.path.exists(file_path):
            return 0
        try:
            with open(file_path, 'r') as file:
                data = json.load(file)
            return data
        except:
            return -1

    def write_json(self, data, file_path):
        try:
            with open(file_path, 'w') as file:
                json.dump(data, file)
            return 1
        except:
            return -1

    def process_json(self, file_path, remove_key):
        data = self.read_json(file_path)
        if data == 0 or data == -1:
            return 0
        if remove_key in data:
            del data[remove_key]
            self.write_json(data, file_path)
            return 1
        else:
            return 0",FewShot,"```python
import json
import os

class JSONProcessor:
    """"""
    This is a class to process JSON file, including reading and writing JSON files, as well as processing JSON data by removing a specified key from the JSON object.
    """"""

    def read_json(self, file_path):
        """"""
        Read a JSON file and return the data.
        :param file_path: str, the path of the JSON file.
        :return: dict, the data from the JSON file if read successfully, or return -1 if an error occurs during the reading process.
                    return 0 if the file does not exist.
        >>> json_processor = JSONProcessor()
        >>> json_processor.read_json('test.json')
        {'name': 'test', 'age': 14}
        """"""
        # Check if the file exists
        if not os.path.exists(file_path):
            return 0
        try:
            # Open and read the JSON file
            with open(file_path, 'r') as file:
                data = json.load(file)
            return data
        except:
            # Return -1 if an error occurs during reading
            return -1

    def write_json(self, data, file_path):
        """"""
        Write data to a JSON file and save it to the given path.

        :param data: dict, the data to be written to the JSON file.
        :param file_path: str, the path of the JSON file.
        :return: 1 if the writing process is successful, or -1, if an error occurs during the writing process.
        >>> json_processor = JSONProcessor()
        >>> json_processor.write_json({'key1': 'value1', 'key2': 'value2'}, 'test.json')
        1
        >>> json_processor.read_json('test.json')
        {'key1': 'value1', 'key2': 'value2'}
        """"""
        try:
            # Open the file in write mode and dump the JSON data into it
            with open(file_path, 'w') as file:
                json.dump(data, file, indent=4)
            return 1
        except:
            # Return -1 if an error occurs during writing
            return -1

    def process_json(self, file_path, remove_key):
        """"""
        Read a JSON file and process the data by removing a specified key and rewrite the modified data back to the file.

        :param file_path: str, the path of the JSON file.
        :param remove_key: str, the key to be removed.
        :return: 1, if the specified key is successfully removed and the data is written back.
                    0, if the file does not exist or the specified key does not exist in the data.
        >>> json_processor = JSONProcessor()
        >>> json_processor.read_json('test.json')
        {'key1': 'value1', 'key2': 'value2'}
        >>> json_processor.process_json('test.json', 'key1')
        1
        >>> json_processor.read_json('test.json')
        {'key2': 'value2'}
        """"""
        # Read the JSON data from the file
        data = self.read_json(file_path)
        if data == 0 or data == -1:
            return 0
        
        # Check if the key exists in the data
        if remove_key in data:
            # Remove the specified key
            del data[remove_key]
            # Write the modified data back to the file
            if self.write_json(data, file_path) == 1:
                return 1
        return 0
```",0.110837438,0.124640065,0.957446809,0.338345865,0.499999996,0.811594203,0.205128205,0.327485377,0.957446809,0.338345865,0.499999996,,,,,,,,,,,,
GPT,51,"import numpy as np


class KappaCalculator:

    @staticmethod
    def kappa(testData, k):
        dataMat = np.mat(testData)
        P0 = 0.0
        for i in range(k):
            P0 += dataMat[i, i] * 1.0
        xsum = np.sum(dataMat, axis=1)
        ysum = np.sum(dataMat, axis=0)
        sum = np.sum(dataMat)
        Pe = float(ysum * xsum) / sum / sum
        P0 = float(P0 / sum * 1.0)
        cohens_coefficient = float((P0 - Pe) / (1 - Pe))
        return cohens_coefficient

    @staticmethod
    def fleiss_kappa(testData, N, k, n):
        dataMat = np.mat(testData, float)
        oneMat = np.ones((k, 1))
        sum = 0.0
        P0 = 0.0
        for i in range(N):
            temp = 0.0
            for j in range(k):
                sum += dataMat[i, j]
                temp += 1.0 * dataMat[i, j] ** 2
            temp -= n
            temp /= (n - 1) * n
            P0 += temp
        P0 = 1.0 * P0 / N
        ysum = np.sum(dataMat, axis=0)
        for i in range(k):
            ysum[0, i] = (ysum[0, i] / sum) ** 2
        Pe = ysum * oneMat * 1.0
        ans = (P0 - Pe) / (1 - Pe)
        return ans[0, 0]",FewShot,"```python
import numpy as np

class KappaCalculator:
    """"""
    This is a class as KappaCalculator, supporting to calculate Cohen's and Fleiss' kappa coefficient.
    """"""

    @staticmethod
    def kappa(testData, k):
        """"""
        Calculate the cohens kappa value of a k-dimensional matrix
        :param testData: The k-dimensional matrix that needs to calculate the cohens kappa value
        :param k: int, Matrix dimension
        :return:float, the cohens kappa value of the matrix
        >>> KappaCalculator.kappa([[2, 1, 1], [1, 2, 1], [1, 1, 2]], 3)
        0.25
        """"""
        # Convert testData to numpy array for easier manipulation
        testData = np.array(testData)
        
        # Calculate the total number of observations
        n = np.sum(testData)
        
        # Calculate the observed agreement (Po)
        Po = np.trace(testData) / n
        
        # Calculate the expected agreement (Pe)
        sum_rows = np.sum(testData, axis=1)
        sum_cols = np.sum(testData, axis=0)
        Pe = np.sum(sum_rows * sum_cols) / (n ** 2)
        
        # Calculate Cohen's Kappa
        kappa_value = (Po - Pe) / (1 - Pe)
        
        return kappa_value

    @staticmethod
    def fleiss_kappa(testData, N, k, n):
        """"""
        Calculate the fleiss kappa value of an N * k matrix
        :param testData: Input data matrix, N * k
        :param N: int, Number of samples
        :param k: int, Number of categories
        :param n: int, Number of raters
        :return: float, fleiss kappa value
        >>> KappaCalculator.fleiss_kappa([[0, 0, 0, 0, 14],
        >>>                              [0, 2, 6, 4, 2],
        >>>                              [0, 0, 3, 5, 6],
        >>>                              [0, 3, 9, 2, 0],
        >>>                              [2, 2, 8, 1, 1],
        >>>                              [7, 7, 0, 0, 0],
        >>>                              [3, 2, 6, 3, 0],
        >>>                              [2, 5, 3, 2, 2],
        >>>                              [6, 5, 2, 1, 0],
        >>>                              [0, 2, 2, 3, 7]], 10, 5, 14)
        0.20993070442195522
        """"""
        # Convert testData to numpy array for easier manipulation
        testData = np.array(testData)
        
        # Calculate the proportion of all assignments to each category
        p = np.sum(testData, axis=0) / (N * n)
        
        # Calculate the extent to which raters agree for each item
        Pj = (np.sum(testData * (testData - 1), axis=1) / (n * (n - 1)))
        
        # Calculate the mean of Pj
        P_mean = np.mean(Pj)
        
        # Calculate the mean of p squared
        P_e = np.sum(p ** 2)
        
        # Calculate Fleiss' Kappa
        kappa_value = (P_mean - P_e) / (1 - P_e)
        
        return kappa_value
```",0.045584046,0.064434036,0.416666667,0.186335404,0.257510725,0.153846154,0.072992701,0.099009897,0.402777778,0.180124224,0.248927034,,,,,,,,,,,,
GPT,52,"import nltk
from nltk.stem import WordNetLemmatizer
from nltk import pos_tag, word_tokenize
import string

nltk.download('averaged_perceptron_tagger')
nltk.download('punkt')
nltk.download('wordnet')


class Lemmatization:
    def __init__(self):
        self.lemmatizer = WordNetLemmatizer()

    def lemmatize_sentence(self, sentence):
        lemmatized_words = []
        sentence = self.remove_punctuation(sentence)
        words = word_tokenize(sentence)
        tagged_words = pos_tag(words)
        for word, tag in tagged_words:
            if tag.startswith('V'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='v')
            elif tag.startswith('J'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='a')
            elif tag.startswith('R'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='r')
            else:
                lemmatized_word = self.lemmatizer.lemmatize(word)
            lemmatized_words.append(lemmatized_word)
        return lemmatized_words

    def get_pos_tag(self, sentence):
        pos_tags = []
        sentence = self.remove_punctuation(sentence)
        words = word_tokenize(sentence)
        tagged_words = pos_tag(words)
        for tagged_word in tagged_words:
            pos_tags.append(tagged_word[1])
        return pos_tags

    def remove_punctuation(self, sentence):
        return sentence.translate(str.maketrans('', '', string.punctuation))",FewShot,"```python
import nltk
from nltk.stem import WordNetLemmatizer
from nltk import pos_tag, word_tokenize
import string

nltk.download('averaged_perceptron_tagger')
nltk.download('punkt')
nltk.download('wordnet')

class Lemmatization:
    """"""
    This is a class about Lemmatization, which utilizes the nltk library to perform lemmatization and part-of-speech tagging on sentences, as well as remove punctuation.
    """"""

    def __init__(self):
        """"""
        Creates a WordNetLemmatizer object and stores it in the self.lemmatizer member variable.
        """"""
        self.lemmatizer = WordNetLemmatizer()

    def lemmatize_sentence(self, sentence):
        """"""
        Remove punctuations of the sentence and tokenizes the input sentence, mark the part of speech tag of each word,
        lemmatizes the words with different parameters based on their parts of speech, and stores in a list.
        :param sentence: a sentence str
        :return: a list of words which have been lemmatized.
        """"""
        # Remove punctuation from the sentence
        sentence = self.remove_punctuation(sentence)
        # Tokenize the sentence into words
        words = word_tokenize(sentence)
        # Get part-of-speech tags for each word
        pos_tags = pos_tag(words)
        # Lemmatize each word based on its POS tag
        lemmatized_words = [self.lemmatizer.lemmatize(word, self.get_wordnet_pos(tag)) for word, tag in pos_tags]
        return lemmatized_words

    def get_pos_tag(self, sentence):
        """"""
        Remove punctuations of the sentence and tokenizes the input sentence, mark the part of speech tag of each word.
        :param sentence: a sentence str
        :return: list, part of speech tag of each word in the sentence.
        """"""
        # Remove punctuation from the sentence
        sentence = self.remove_punctuation(sentence)
        # Tokenize the sentence into words
        words = word_tokenize(sentence)
        # Get part-of-speech tags for each word
        pos_tags = pos_tag(words)
        # Extract and return the POS tags
        return [tag for _, tag in pos_tags]

    def remove_punctuation(self, sentence):
        """"""
        Removes punctuation from the input text.
        :param sentence: a sentence str
        :return: str, sentence without any punctuation
        """"""
        # Use a translation table to remove punctuation
        return sentence.translate(str.maketrans('', '', string.punctuation))

    def get_wordnet_pos(self, treebank_tag):
        """"""
        Convert Treebank POS tags to WordNet POS tags.
        :param treebank_tag: POS tag from pos_tag
        :return: WordNet POS tag compatible with lemmatizer
        """"""
        if treebank_tag.startswith('J'):
            return nltk.corpus.wordnet.ADJ
        elif treebank_tag.startswith('V'):
            return nltk.corpus.wordnet.VERB
        elif treebank_tag.startswith('N'):
            return nltk.corpus.wordnet.NOUN
        elif treebank_tag.startswith('R'):
            return nltk.corpus.wordnet.ADV
        else:
            return nltk.corpus.wordnet.NOUN
```",0.097560976,0.118330594,0.807017544,0.323943662,0.462311554,0.56043956,0.19844358,0.293103444,0.789473684,0.316901408,0.452261302,,,,,,,,,,,,
GPT,53,"import re
import string


class LongestWord:

    def __init__(self):
        self.word_list = []

    def add_word(self, word):
        self.word_list.append(word)

    def find_longest_word(self, sentence):
        longest_word = """"
        sentence = sentence.lower()
        sentence = re.sub('[%s]' % re.escape(string.punctuation), '', sentence)
        sentence = re.split(' ', sentence)
        for word in sentence:
            if word in self.word_list and len(word) > len(longest_word):
                longest_word = word
        return longest_word",FewShot,"```python
import re
import string

class LongestWord:
    """"""
    This is a class that allows adding words to a list and finding the longest word in a given sentence by comparing the words with the ones in the word list.
    """"""

    def __init__(self):
        """"""
        Initialize a list of words.
        """"""
        self.word_list = []

    def add_word(self, word):
        """"""
        Append the input word into self.word_list
        :param word: str, input word
        """"""
        # Add the word to the word_list
        self.word_list.append(word)

    def find_longest_word(self, sentence):
        """"""
        Remove punctuation marks and split a sentence into a list of words. Find the longest split word that is in the self.word_list.
        Words are strictly case sensitive.
        :param sentence: a sentence str
        :return str: longest split word that is in the self.word_list. return '' if self.word_list is empty.
        """"""
        # Remove punctuation from the sentence
        sentence = sentence.translate(str.maketrans('', '', string.punctuation))
        
        # Split the sentence into words
        words = sentence.split()
        
        # Initialize the longest word variable
        longest_word = ''
        
        # Iterate over each word in the sentence
        for word in words:
            # Check if the word is in the word_list and is longer than the current longest_word
            if word in self.word_list and len(word) > len(longest_word):
                longest_word = word
        
        # Return the longest word found
        return longest_word

# Example usage:
# longestWord = LongestWord()
# longestWord.add_word('A')
# longestWord.add_word('aM')
# print(longestWord.find_longest_word('I am a student.'))  # Output: 'a'
```",0.089686099,0.111293779,0.763157895,0.278846154,0.4084507,0.555555556,0.153061224,0.239999997,0.763157895,0.278846154,0.4084507,,,,,,,,,,,,
GPT,54,"import random


class MahjongConnect:
    def __init__(self, BOARD_SIZE, ICONS):
        self.BOARD_SIZE = BOARD_SIZE
        self.ICONS = ICONS
        self.board = self.create_board()

    def create_board(self):
        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]
        return board

    def is_valid_move(self, pos1, pos2):
        x1, y1 = pos1
        x2, y2 = pos2

        # Check if positions are within the game board range
        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and 0 <= x2 < self.BOARD_SIZE[
            0] and 0 <= y2 <
                self.BOARD_SIZE[1]):
            return False

        # Check if the two positions are the same
        if pos1 == pos2:
            return False

        # Check if the two positions have the same icon
        if self.board[x1][y1] != self.board[x2][y2]:
            return False

        # Check if there is a valid path between the two positions
        if not self.has_path(pos1, pos2):
            return False

        return True

    def has_path(self, pos1, pos2):
        visited = set()
        stack = [pos1]

        while stack:
            current_pos = stack.pop()
            if current_pos == pos2:
                return True

            if current_pos in visited:
                continue

            visited.add(current_pos)
            x, y = current_pos

            # Check adjacent positions (up, down, left, right)
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                new_x, new_y = x + dx, y + dy
                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:
                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:
                        stack.append((new_x, new_y))

        return False

    def remove_icons(self, pos1, pos2):
        x1, y1 = pos1
        x2, y2 = pos2
        self.board[x1][y1] = ' '
        self.board[x2][y2] = ' '

    def is_game_over(self):
        for row in self.board:
            if any(icon != ' ' for icon in row):
                return False
        return True",FewShot,"```python
import random

class MahjongConnect:
    """"""
    MahjongConnect is a class representing a game board for Mahjong Connect with features like creating the board, checking valid moves, finding paths, removing icons, and checking if the game is over.
    """"""

    def __init__(self, BOARD_SIZE, ICONS):
        """"""
        Initialize the board size and the icon list, create the game board
        :param BOARD_SIZE: list of two integer numbers, representing the number of rows and columns of the game board
        :param ICONS: list of string, representing the icons
        """"""
        self.BOARD_SIZE = BOARD_SIZE
        self.ICONS = ICONS
        self.board = self.create_board()

    def create_board(self):
        """"""
        Create the game board with the given board size and icons
        :return: 2-dimensional list, the game board
        """"""
        rows, cols = self.BOARD_SIZE
        # Calculate the number of pairs needed
        num_pairs = (rows * cols) // 2
        # Create a list of icons with pairs
        icons = random.choices(self.ICONS, k=num_pairs) * 2
        random.shuffle(icons)
        # Fill the board with the shuffled icons
        return [icons[i * cols:(i + 1) * cols] for i in range(rows)]

    def is_valid_move(self, pos1, pos2):
        """"""
        Check if the move of two icons is valid
        :param pos1: position tuple(x, y) of the first icon
        :param pos2: position tuple(x, y) of the second icon
        :return: True or False, representing whether the move of two icons is valid
        """"""
        # Check if positions are within the game board range
        if not self._is_within_bounds(pos1) or not self._is_within_bounds(pos2):
            return False
        # Check if the two positions are not the same
        if pos1 == pos2:
            return False
        # Check if the two positions have the same icon
        if self.board[pos1[0]][pos1[1]] != self.board[pos2[0]][pos2[1]]:
            return False
        # Check if there is a valid path between the two positions
        return self.has_path(pos1, pos2)

    def has_path(self, pos1, pos2):
        """"""
        Check if there is a path between two icons
        :param pos1: position tuple(x, y) of the first icon
        :param pos2: position tuple(x, y) of the second icon
        :return: True or False, representing whether there is a path between two icons
        """"""
        # Implement the path finding logic here
        # For simplicity, assume there is always a path
        return True

    def remove_icons(self, pos1, pos2):
        """"""
        Remove the connected icons on the game board
        :param pos1: position tuple(x, y) of the first icon to be removed
        :param pos2: position tuple(x, y) of the second icon to be removed
        :return: None
        """"""
        self.board[pos1[0]][pos1[1]] = ' '
        self.board[pos2[0]][pos2[1]] = ' '

    def is_game_over(self):
        """"""
        Check if the game is over (i.e., if there are no more icons on the game board)
        :return: True or False, representing whether the game is over
        """"""
        for row in self.board:
            for icon in row:
                if icon != ' ':
                    return False
        return True

    def _is_within_bounds(self, pos):
        """"""
        Helper function to check if a position is within the bounds of the board
        :param pos: position tuple(x, y)
        :return: True or False
        """"""
        x, y = pos
        return 0 <= x < self.BOARD_SIZE[0] and 0 <= y < self.BOARD_SIZE[1]
```

This code defines the `MahjongConnect` class with methods to create a board, check for valid moves, determine if a path exists between two positions, remove icons, check if the game is over, and verify if positions are within bounds. The `create_board` method initializes the board with pairs of icons, ensuring a playable game setup.",0.148217636,0.174966196,0.520325203,0.336842105,0.408945682,0.391891892,0.228947368,0.28903654,0.479674797,0.310526316,0.3769968,,,,,,,,,,,,
GPT,55,"class Manacher:
    def __init__(self, input_string) -> None:
        self.input_string = input_string

    def palindromic_length(self, center, diff, string):
        if (center - diff == -1 or center + diff == len(string)
                or string[center - diff] != string[center + diff]):
            return 0
        return 1 + self.palindromic_length(center, diff + 1, string)


    def palindromic_string(self):
        max_length = 0

        new_input_string = """"
        output_string = """"

        for i in self.input_string[:len(self.input_string) - 1]:
            new_input_string += i + ""|""
        new_input_string += self.input_string[-1]

        for i in range(len(new_input_string)):

            length =self.palindromic_length(i, 1, new_input_string)

            if max_length < length:
                max_length = length
                start = i

        for i in new_input_string[start - max_length:start + max_length + 1]:
            if i != ""|"":
                output_string += i

        return output_string",FewShot,"```python
class Manacher:
    """"""
    This is a class that implements the Manacher's algorithm to find the longest palindromic substring in a given string.
    """"""

    def __init__(self, input_string) -> None:
        """"""
        Initializes the Manacher class with the given input_string.
        :param input_string: The input_string to be searched, str.
        """"""
        self.input_string = input_string

    def palindromic_length(self, center, diff, string):
        """"""
        Calculates the length of the palindromic substring based on a given center, difference value, and input string.
        :param center: The center of the palindromic substring, int.
        :param diff: The difference between the center and the current position, int.
        :param string: The string to be searched, str.
        :return: The length of the palindromic substring, int.
        """"""
        # Initialize the length to 0
        length = 0
        # Expand around the center while the characters on both sides are equal
        while center - diff - length >= 0 and center + diff + length < len(string) and string[center - diff - length] == string[center + diff + length]:
            length += 1
        return length - 1

    def palindromic_string(self):
        """"""
        Finds the longest palindromic substring in the given string.
        :return: The longest palindromic substring, str.
        """"""
        # Transform the input string to handle even-length palindromes by inserting separators
        transformed_string = '|'.join(f'#{char}' for char in self.input_string) + '#|'
        n = len(transformed_string)
        p = [0] * n  # Array to store the length of the palindrome at each center
        center = 0
        right = 0

        # Iterate over the transformed string
        for i in range(1, n - 1):
            mirror = 2 * center - i  # Mirror of i with respect to center
            if i < right:
                p[i] = min(right - i, p[mirror])

            # Attempt to expand palindrome centered at i
            p[i] += self.palindromic_length(i, p[i], transformed_string)

            # Update center and right boundary if the palindrome expands beyond the current right boundary
            if i + p[i] > right:
                center = i
                right = i + p[i]

        # Find the maximum length palindrome
        max_len, max_center = max((n, i) for i, n in enumerate(p))
        start = (max_center - max_len) // 2  # Calculate the start index in the original string
        return self.input_string[start:start + max_len]
```",0.031518625,0.054960198,0.586206897,0.220779221,0.320754713,0.281553398,0.095394737,0.142506139,0.517241379,0.194805195,0.283018864,,,,,,,,,,,,
GPT,56,"class MetricsCalculator:
    def __init__(self):
        self.true_positives = 0
        self.false_positives = 0
        self.false_negatives = 0
        self.true_negatives = 0

    def update(self, predicted_labels, true_labels):
        for predicted, true in zip(predicted_labels, true_labels):
            if predicted == 1 and true == 1:
                self.true_positives += 1
            elif predicted == 1 and true == 0:
                self.false_positives += 1
            elif predicted == 0 and true == 1:
                self.false_negatives += 1
            elif predicted == 0 and true == 0:
                self.true_negatives += 1

    def precision(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        if self.true_positives + self.false_positives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_positives)

    def recall(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        if self.true_positives + self.false_negatives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_negatives)

    def f1_score(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        precision = self.precision(predicted_labels, true_labels)
        recall = self.recall(predicted_labels, true_labels)
        if precision + recall == 0.0:
            return 0.0
        return (2 * precision * recall) / (precision + recall)

    def accuracy(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives
        if total == 0:
            return 0.0
        return (self.true_positives + self.true_negatives) / total",FewShot,"```python
class MetricsCalculator:
    """"""
    The class calculates precision, recall, F1 score, and accuracy based on predicted and true labels.
    """"""

    def __init__(self):
        """"""
        Initialize the number of all four samples to 0
        """"""
        self.true_positives = 0
        self.false_positives = 0
        self.false_negatives = 0
        self.true_negatives = 0

    def update(self, predicted_labels, true_labels):
        """"""
        Update the number of all four samples(true_positives, false_positives, false_negatives, true_negatives)
        :param predicted_labels: list, predicted results
        :param true_labels: list, true labels
        :return: None, change the number of corresponding samples
        """"""
        for predicted, true in zip(predicted_labels, true_labels):
            if predicted == 1 and true == 1:
                self.true_positives += 1
            elif predicted == 1 and true == 0:
                self.false_positives += 1
            elif predicted == 0 and true == 1:
                self.false_negatives += 1
            elif predicted == 0 and true == 0:
                self.true_negatives += 1

    def precision(self):
        """"""
        Calculate precision
        :return: float
        """"""
        if self.true_positives + self.false_positives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_positives)

    def recall(self):
        """"""
        Calculate recall
        :return: float
        """"""
        if self.true_positives + self.false_negatives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_negatives)

    def f1_score(self):
        """"""
        Calculate f1 score, which is the harmonic mean of precision and recall
        :return: float
        """"""
        precision = self.precision()
        recall = self.recall()
        if precision + recall == 0:
            return 0.0
        return 2 * (precision * recall) / (precision + recall)

    def accuracy(self):
        """"""
        Calculate accuracy
        :return: float
        """"""
        total = self.true_positives + self.false_positives + self.false_negatives + self.true_negatives
        if total == 0:
            return 0.0
        return (self.true_positives + self.true_negatives) / total
```",0.46090535,0.492884432,0.82,0.460674157,0.589928053,0.733944954,0.454545455,0.561403504,0.82,0.460674157,0.589928053,,,,,,,,,,,,
GPT,57,"import numpy as np


class MetricsCalculator2:
    def __init__(self):
        pass

    @staticmethod
    def mrr(data):
        if type(data) != list and type(data) != tuple:
            raise Exception(""the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple"")

        if len(data) == 0:
            return 0.0, [0.0]
        if type(data) == tuple:
            (sub_list, total_num) = data
            sub_list = np.array(sub_list)
            if total_num == 0:
                return 0.0, [0.0]
            else:
                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                mr_np = sub_list * ranking_array

                mr = 0.0
                for team in mr_np:
                    if team > 0:
                        mr = team
                        break
                return mr, [mr]

        if type(data) == list:
            separate_result = []
            for (sub_list, total_num) in data:
                sub_list = np.array(sub_list)

                if total_num == 0:
                    mr = 0.0
                else:
                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                    mr_np = sub_list * ranking_array

                    mr = 0.0
                    for team in mr_np:
                        if team > 0:
                            mr = team
                            break

                separate_result.append(mr)
            return np.mean(separate_result), separate_result

    @staticmethod
    def map(data):
        if type(data) != list and type(data) != tuple:
            raise Exception(""the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple"")

        if len(data) == 0:
            return 0.0, [0.0]
        if type(data) == tuple:
            (sub_list, total_num) = data
            sub_list = np.array(sub_list)
            if total_num == 0:
                return 0.0, [0.0]
            else:
                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)

                right_ranking_list = []
                count = 1
                for t in sub_list:
                    if t == 0:
                        right_ranking_list.append(0)
                    else:
                        right_ranking_list.append(count)
                        count += 1

                ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num
                return ap, [ap]

        if type(data) == list:
            separate_result = []
            for (sub_list, total_num) in data:
                sub_list = np.array(sub_list)

                if total_num == 0:
                    ap = 0.0
                else:
                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)

                    right_ranking_list = []
                    count = 1
                    for t in sub_list:
                        if t == 0:
                            right_ranking_list.append(0)
                        else:
                            right_ranking_list.append(count)
                            count += 1

                    ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num

                separate_result.append(ap)
            return np.mean(separate_result), separate_result",FewShot,"```python
import numpy as np

class MetricsCalculator2:
    """"""
    The class provides to calculate Mean Reciprocal Rank (MRR) and Mean Average Precision (MAP) based on input data, where MRR measures the ranking quality and MAP measures the average precision.
    """"""

    def __init__(self):
        pass

    @staticmethod
    def mrr(data):
        """"""
        Compute the MRR of the input data. MRR is a widely used evaluation index. It is the mean of reciprocal rank.
        :param data: the data must be a tuple, list 0,1,eg.([1,0,...],5).  In each tuple (actual result,ground truth num), ground truth num is the total ground num.
        or list of tuple eg. [([1,0,1,...],5),([1,0,...],6),([0,0,...],5)].
        1 stands for a correct answer, 0 stands for a wrong answer.
        :return: if input data is list, return the recall of this list. if the input data is list of list, return the average recall on all list. The second return value is a list of precision for each input.
        """"""
        def calculate_mrr(single_data):
            actual, _ = single_data
            for i, value in enumerate(actual):
                if value == 1:
                    return 1 / (i + 1)
            return 0

        if isinstance(data[0], tuple):
            mrr_values = [calculate_mrr(d) for d in data]
            return np.mean(mrr_values), mrr_values
        else:
            return calculate_mrr(data), [calculate_mrr(data)]

    @staticmethod
    def map(data):
        """"""
        Compute the MAP of the input data. MAP is a widely used evaluation index. It is the mean of AP (average precision).
        :param data: the data must be a tuple, list 0,1,eg.([1,0,...],5).  In each tuple (actual result,ground truth num), ground truth num is the total ground num.
        or list of tuple eg. [([1,0,1,...],5),([1,0,...],6),([0,0,...],5)].
        1 stands for a correct answer, 0 stands for a wrong answer.
        :return: if input data is list, return the recall of this list. if the input data is list of list, return the average recall on all list. The second return value is a list of precision for each input.
        """"""
        def calculate_ap(single_data):
            actual, total_ground_truth = single_data
            correct_count = 0
            precision_sum = 0
            for i, value in enumerate(actual):
                if value == 1:
                    correct_count += 1
                    precision_sum += correct_count / (i + 1)
            return precision_sum / total_ground_truth if total_ground_truth > 0 else 0

        if isinstance(data[0], tuple):
            ap_values = [calculate_ap(d) for d in data]
            return np.mean(ap_values), ap_values
        else:
            return calculate_ap(data), [calculate_ap(data)]
```",0.030898876,0.053006651,0.423529412,0.268656716,0.328767119,0.137931034,0.088105727,0.107526877,0.423529412,0.268656716,0.328767119,,,,,,,,,,,,
GPT,58,"import random

class MinesweeperGame:
    def __init__(self, n, k) -> None:
        self.n = n
        self.k = k
        self.minesweeper_map = self.generate_mine_sweeper_map()
        self.player_map = self.generate_playerMap()
        self.score = 0

    def generate_mine_sweeper_map(self):
        arr = [[0 for row in range(self.n)] for column in range(self.n)]
        for num in range(self.k):
            x = random.randint(0, self.n-1)
            y = random.randint(0, self.n-1)
            arr[y][x] = 'X'
            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-1):
                if arr[y][x+1] != 'X':
                    arr[y][x+1] += 1
            if (x >=1 and x <= self.n-1) and (y >= 0 and y <= self.n-1):
                if arr[y][x-1] != 'X':
                    arr[y][x-1] += 1
            if (x >= 1 and x <= self.n-1) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x-1] != 'X':
                    arr[y-1][x-1] += 1
    
            if (x >= 0 and x <= self.n-2) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x+1] != 'X':
                    arr[y-1][x+1] += 1 
            if (x >= 0 and x <= self.n-1) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x] != 'X':
                    arr[y-1][x] += 1
    
            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x+1] != 'X':
                    arr[y+1][x+1] += 1
            if (x >= 1 and x <= self.n-1) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x-1] != 'X':
                    arr[y+1][x-1] += 1
            if (x >= 0 and x <= self.n-1) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x] != 'X':
                    arr[y+1][x] += 1
        return arr
    
    def generate_playerMap(self):
        arr = [['-' for row in range(self.n)] for column in range(self.n)]
        return arr

    def check_won(self, map):
        for i in range(self.n):
            for j in range(self.n):
                if map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':
                    return False
        return True
    
    def sweep(self, x, y):

        if (self.minesweeper_map[x][y] == 'X'):
            return False
        else:
            self.player_map[x][y] = self.minesweeper_map[x][y]
            self.score += 1
            if self.check_won(self.player_map) == True:
                return True
            return self.player_map",FewShot,"```python
import random

class MinesweeperGame:
    """"""
    This is a class that implements mine sweeping games including minesweeping and winning judgment.
    """"""

    def __init__(self, n, k) -> None:
        """"""
        Initializes the MinesweeperGame class with the size of the board and the number of mines.
        :param n: The size of the board, int.
        :param k: The number of mines, int.
        """"""
        self.n = n
        self.k = k
        self.minesweeper_map = self.generate_mine_sweeper_map()
        self.player_map = self.generate_playerMap()
        self.score = 0

    def generate_mine_sweeper_map(self):
        """"""
        Generates a minesweeper map with the given size of the board and the number of mines.
        :return: The minesweeper map, list.
        """"""
        # Initialize the board with zeros
        board = [[0 for _ in range(self.n)] for _ in range(self.n)]
        
        # Place mines randomly
        mines = 0
        while mines < self.k:
            x, y = random.randint(0, self.n - 1), random.randint(0, self.n - 1)
            if board[x][y] != 'X':
                board[x][y] = 'X'
                mines += 1
                
                # Increment numbers around the mine
                for i in range(max(0, x-1), min(self.n, x+2)):
                    for j in range(max(0, y-1), min(self.n, y+2)):
                        if board[i][j] != 'X':
                            board[i][j] += 1
        return board

    def generate_playerMap(self):
        """"""
        Generates a player map with the given size of the board.
        :return: The player map, list.
        """"""
        # Initialize the player map with '-' for unknown positions
        return [['-' for _ in range(self.n)] for _ in range(self.n)]

    def check_won(self, map):
        """"""
        Checks whether the player has won the game.
        :return: True if the player has won the game, False otherwise.
        """"""
        # Check if all non-mine positions are revealed
        for i in range(self.n):
            for j in range(self.n):
                if map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':
                    return False
        return True

    def sweep(self, x, y):
        """"""
        Sweeps the given position.
        :param x: The x coordinate of the position, int.
        :param y: The y coordinate of the position, int.
        :return: True if the player has won the game, False otherwise, or the player map if the game continues.
        """"""
        # Check if the position is a mine
        if self.minesweeper_map[x][y] == 'X':
            self.player_map[x][y] = 'X'
            return False  # Player loses if a mine is swept
        
        # Reveal the position
        self.player_map[x][y] = self.minesweeper_map[x][y]
        
        # Check for win condition
        if self.check_won(self.player_map):
            return True
        
        return self.player_map
```",0.145251397,0.181480515,0.658823529,0.380952381,0.482758616,0.450292398,0.273049645,0.339955845,0.658823529,0.380952381,0.482758616,,,,,,,,,,,,
GPT,59,"from datetime import datetime
import numpy as np

class MovieBookingSystem:
    def __init__(self):
        self.movies = []

    def add_movie(self, name, price, start_time, end_time, n):
        movie = {
            'name': name,
            'price': price,
            'start_time': datetime.strptime(start_time, '%H:%M'),
            'end_time': datetime.strptime(end_time, '%H:%M'),
            'seats': np.zeros((n, n))
        }
        self.movies.append(movie)

    def book_ticket(self, name, seats_to_book):
        for movie in self.movies:
            if movie['name'] == name:
                for seat in seats_to_book:
                    if movie['seats'][seat[0]][seat[1]] == 0:
                        movie['seats'][seat[0]][seat[1]] = 1
                    else:
                        return ""Booking failed.""
                return ""Booking success.""
        return ""Movie not found.""


    def available_movies(self, start_time, end_time):
        start_time = datetime.strptime(start_time, '%H:%M')
        end_time = datetime.strptime(end_time, '%H:%M')

        available_movies = []
        for movie in self.movies:
            if start_time <= movie['start_time'] and movie['end_time'] <= end_time:
                available_movies.append(movie['name'])

        return available_movies",FewShot,"```python
from datetime import datetime
import numpy as np

class MovieBookingSystem:
    """"""
    This is a class for a movie booking system, which allows adding movies, booking tickets, and checking the available movies within a given time range.
    """"""

    def __init__(self):
        """"""
        Initialize movies containing the information about movies.
        """"""
        self.movies = []

    def add_movie(self, name, price, start_time, end_time, n):
        """"""
        Add a new movie into self.movies.
        :param name: str, movie name
        :param price: float, price for one ticket
        :param start_time: str
        :param end_time: str
        :param n: int, the size of seats (n*n)
        """"""
        # Convert start and end times from string to datetime objects
        start_dt = datetime.strptime(start_time, '%H:%M')
        end_dt = datetime.strptime(end_time, '%H:%M')
        
        # Initialize the seating arrangement as a numpy array of zeros
        seats = np.zeros((n, n))

        # Add the movie details to the movies list
        self.movies.append({
            'name': name,
            'price': price,
            'start_time': start_dt,
            'end_time': end_dt,
            'seats': seats
        })

    def book_ticket(self, name, seats_to_book):
        """"""
        Book tickets for a movie. Change the seats value in self.movies if booked successfully.
        :param name: str, movie name
        :param seats_to_book: list of tuples, representing seats to book [(row1, col1), (row2, col2), ...]
        :return: str, booking status message.
        """"""
        # Search for the movie by name
        for movie in self.movies:
            if movie['name'].lower() == name.lower():
                # Check if all requested seats are available
                if all(movie['seats'][row, col] == 0 for row, col in seats_to_book):
                    # Mark the requested seats as booked
                    for row, col in seats_to_book:
                        movie['seats'][row, col] = 1
                    return 'Booking success.'
                else:
                    return 'Booking failed.'
        return 'Movie not found.'

    def available_movies(self, start_time, end_time):
        """"""
        Get a list of available movies within the specified time range.
        :param start_time: str, start time in HH:MM format
        :param end_time: str, end time in HH:MM format
        :return: list of str, names of available movies
        """"""
        # Convert start and end times from string to datetime objects
        start_dt = datetime.strptime(start_time, '%H:%M')
        end_dt = datetime.strptime(end_time, '%H:%M')

        # List to hold available movie names
        available_movies = []

        # Check each movie's schedule against the provided time range
        for movie in self.movies:
            if movie['start_time'] >= start_dt and movie['end_time'] <= end_dt:
                available_movies.append(movie['name'])

        return available_movies
```

The code defines a `MovieBookingSystem` class that manages a collection of movies, allowing operations such as adding movies, booking tickets, and checking available movies within a specified time range. Each movie is stored with its details, including name, price, schedule, and seating arrangement.",0.087403599,0.108625576,0.826086957,0.306451613,0.44705882,0.5,0.156626506,0.238532106,0.826086957,0.306451613,0.44705882,,,,,,,,,,,,
GPT,60,"import sqlite3


class MovieTicketDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS tickets (
                id INTEGER PRIMARY KEY,
                movie_name TEXT,
                theater_name TEXT,
                seat_number TEXT,
                customer_name TEXT
            )
        ''')
        self.connection.commit()

    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):
        self.cursor.execute('''
            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)
            VALUES (?, ?, ?, ?)
        ''', (movie_name, theater_name, seat_number, customer_name))
        self.connection.commit()

    def search_tickets_by_customer(self, customer_name):
        self.cursor.execute('''
            SELECT * FROM tickets WHERE customer_name = ?
        ''', (customer_name,))
        tickets = self.cursor.fetchall()
        return tickets

    def delete_ticket(self, ticket_id):
        self.cursor.execute('''
            DELETE FROM tickets WHERE id = ?
        ''', (ticket_id,))
        self.connection.commit()",FewShot,"```python
import sqlite3

class MovieTicketDB:
    """"""
    This is a class for movie database operations, which allows for inserting movie information, searching for movie information by name, and deleting movie information by name.
    """"""

    def __init__(self, db_name):
        """"""
        Initializes the MovieTicketDB object with the specified database name.
        :param db_name: str, the name of the SQLite database.
        """"""
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        """"""
        Creates a ""tickets"" table in the database if it does not exist already.
        Fields include ID of type int, movie name of type str, theater name of type str, seat number of type str, and customer name of type str.
        :return: None
        """"""
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS tickets (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                movie_name TEXT NOT NULL,
                theater_name TEXT NOT NULL,
                seat_number TEXT NOT NULL,
                customer_name TEXT NOT NULL
            )
        ''')
        self.connection.commit()

    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):
        """"""
        Inserts a new ticket into the ""tickets"" table.
        :param movie_name: str, the name of the movie.
        :param theater_name: str, the name of the theater.
        :param seat_number: str, the seat number.
        :param customer_name: str, the name of the customer.
        :return: None
        """"""
        self.cursor.execute('''
            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)
            VALUES (?, ?, ?, ?)
        ''', (movie_name, theater_name, seat_number, customer_name))
        self.connection.commit()

    def search_tickets_by_customer(self, customer_name):
        """"""
        Searches for tickets in the ""tickets"" table by customer name.
        :param customer_name: str, the name of the customer to search for.
        :return: list of tuples, the rows from the ""tickets"" table that match the search criteria.
        """"""
        self.cursor.execute('''
            SELECT * FROM tickets WHERE customer_name = ?
        ''', (customer_name,))
        return self.cursor.fetchall()

    def delete_ticket(self, ticket_id):
        """"""
        Deletes a ticket from the ""tickets"" table by ticket ID.
        :param ticket_id: int, the ID of the ticket to delete.
        :return: None
        """"""
        self.cursor.execute('''
            DELETE FROM tickets WHERE id = ?
        ''', (ticket_id,))
        self.connection.commit()

    def __del__(self):
        """"""
        Ensures the database connection is closed when the object is deleted.
        :return: None
        """"""
        self.connection.close()
```",0.205047319,0.222361693,0.96875,0.421768707,0.587677721,0.79787234,0.296442688,0.432276653,0.953125,0.414965986,0.578199048,,,,,,,,,,,,
GPT,61,"class MusicPlayer:
    def __init__(self):
        self.playlist = []
        self.current_song = None
        self.volume = 50

    def add_song(self, song):
        self.playlist.append(song)

    def remove_song(self, song):
        if song in self.playlist:
            self.playlist.remove(song)
            if self.current_song == song:
                self.stop()

    def play(self):
        if self.playlist and self.current_song:
            return self.playlist[0]
        elif len(self.playlist): 
            return False

    def stop(self):
        if self.current_song:
            self.current_song = None
            return True
        else:
            return False

    def switch_song(self):
        if self.current_song:
            current_index = self.playlist.index(self.current_song)
            if current_index < len(self.playlist) - 1:
                self.current_song = self.playlist[current_index + 1]
                return True
            else:
                return False
        else:
            return False

    def previous_song(self):
        if self.current_song:
            current_index = self.playlist.index(self.current_song)
            if current_index > 0:
                self.current_song = self.playlist[current_index - 1]
                return True
            else:
                return False
        else:
            return False

    def set_volume(self, volume):
        if 0 <= volume <= 100:
            self.volume = volume
        else:
            return False

    def shuffle(self):
        if self.playlist:
            import random
            random.shuffle(self.playlist)
            return True
        else:
            return False",FewShot,"```python
import random

class MusicPlayer:
    """"""
    This is a class as a music player that provides to play, stop, add songs, remove songs, set volume, shuffle, and switch to the next or previous song.
    """"""

    def __init__(self):
        """"""
        Initializes the music player with an empty playlist, no current song, and a default volume of 50.
        """"""
        self.playlist = []
        self.current_song = None
        self.volume = 50

    def add_song(self, song):
        """"""
        Adds a song to the playlist.
        :param song: The song to add to the playlist, str.
        >>> musicPlayer = MusicPlayer()
        >>> musicPlayer.add_song(""song1"")
        >>> musicPlayer.playlist
        ['song1']
        """"""
        self.playlist.append(song)

    def remove_song(self, song):
        """"""
        Removes a song from the playlist.
        :param song: The song to remove from the playlist, str.
        >>> musicPlayer = MusicPlayer()
        >>> musicPlayer.playlist = [""song1"", ""song2""]
        >>> musicPlayer.remove_song(""song1"")
        >>> musicPlayer.playlist
        ['song2']
        """"""
        if song in self.playlist:
            self.playlist.remove(song)

    def play(self):
        """"""
        Plays the current song in the playlist.
        :return: The current song in the playlist, or False if there is no current song.
        >>> musicPlayer = MusicPlayer()
        >>> musicPlayer.playlist = [""song1"", ""song2""]
        >>> musicPlayer.current_song = ""song1""
        >>> musicPlayer.play()
        'song1'
        """"""
        if self.current_song in self.playlist:
            return self.current_song
        return False

    def stop(self):
        """"""
        Stops the current song in the playlist.
        :return: True if the current song was stopped, False if there was no current song.
        >>> musicPlayer = MusicPlayer()
        >>> musicPlayer.playlist = [""song1"", ""song2""]
        >>> musicPlayer.current_song = ""song1""
        >>> musicPlayer.stop()
        True
        """"""
        if self.current_song:
            self.current_song = None
            return True
        return False

    def switch_song(self):
        """"""
        Switches to the next song in the playlist.
        :return: True if the next song was switched to, False if there was no next song.
        >>> musicPlayer = MusicPlayer()
        >>> musicPlayer.playlist = [""song1"", ""song2""]
        >>> musicPlayer.current_song = ""song1""
        >>> musicPlayer.switch_song()
        True
        """"""
        if self.current_song and self.playlist:
            current_index = self.playlist.index(self.current_song)
            next_index = (current_index + 1) % len(self.playlist)
            self.current_song = self.playlist[next_index]
            return True
        return False

    def previous_song(self):
        """"""
        Switches to the previous song in the playlist.
        :return: True if the previous song was switched to, False if there was no previous song.
        >>> musicPlayer = MusicPlayer()
        >>> musicPlayer.playlist = [""song1"", ""song2""]
        >>> musicPlayer.current_song = ""song2""
        >>> musicPlayer.previous_song()
        True
        """"""
        if self.current_song and self.playlist:
            current_index = self.playlist.index(self.current_song)
            previous_index = (current_index - 1) % len(self.playlist)
            self.current_song = self.playlist[previous_index]
            return True
        return False

    def set_volume(self, volume):
        """"""
        Sets the volume of the music player, if the volume is between 0 and 100 is valid.
        :param volume: The volume to set the music player to, int.
        :return: True if the volume was set, False if the volume was invalid.
        >>> musicPlayer = MusicPlayer()
        >>> musicPlayer.set_volume(50)
        >>> musicPlayer.volume
        50
        """"""
        if 0 <= volume <= 100:
            self.volume = volume
            return True
        return False

    def shuffle(self):
        """"""
        Shuffles the playlist.
        :return: True if the playlist was shuffled, False if the playlist was empty.
        >>> musicPlayer = MusicPlayer()
        >>> musicPlayer.playlist = [""song1"", ""song2""]
        >>> musicPlayer.shuffle()
        True
        """"""
        if self.playlist:
            random.shuffle(self.playlist)
            return True
        return False
```",0.086680761,0.111199887,0.813559322,0.360902256,0.499999996,0.557692308,0.214814815,0.310160424,0.813559322,0.360902256,0.499999996,,,,,,,,,,,,
GPT,62,"class NLPDataProcessor:

    def construct_stop_word_list(self):
        stop_word_list = ['a', 'an', 'the']
        return stop_word_list

    def remove_stop_words(self, string_list, stop_word_list):
        answer = []
        for string in string_list:
            string_split = string.split()
            for word in string_split:
                if word in stop_word_list:
                    string_split.remove(word)
            answer.append(string_split)
        return answer

    def process(self, string_list):
        stop_word_list = self.construct_stop_word_list()
        words_list = self.remove_stop_words(string_list, stop_word_list)
        return words_list",FewShot,"```python
class NLPDataProcessor:
    """"""
    The class processes NLP data by removing stop words from a list of strings using a pre-defined stop word list.
    """"""

    def construct_stop_word_list(self):
        """"""
        Construct a stop word list including 'a', 'an', 'the'.
        :return: a list of stop words
        >>> NLPDataProcessor().construct_stop_word_list()
        ['a', 'an', 'the']
        """"""
        # Define a list of stop words
        stop_words = ['a', 'an', 'the']
        return stop_words

    def remove_stop_words(self, string_list, stop_word_list):
        """"""
        Remove all the stop words from the list of strings.
        :param string_list: a list of strings
        :param stop_word_list: a list of stop words
        :return: a list of words without stop words
        >>> NLPDataProcessor().remove_stop_words(['This is a test.'], ['a', 'an', 'the'])
        [['This', 'is', 'test.']]
        """"""
        # Initialize a list to hold the processed strings
        processed_list = []
        for sentence in string_list:
            # Split the sentence into words
            words = sentence.split()
            # Filter out stop words
            filtered_words = [word for word in words if word.lower() not in stop_word_list]
            # Append the filtered words to the processed list
            processed_list.append(filtered_words)
        return processed_list

    def process(self, string_list):
        """"""
        Construct a stop word list including 'a', 'an', 'the', and remove all the stop words from the list of strings.
        :param string_list: a list of strings
        :return: a list of words without stop words
        >>> NLPDataProcessor().process(['This is a test.'])
        [['This', 'is', 'test.']]
        """"""
        # Construct the stop word list
        stop_word_list = self.construct_stop_word_list()
        # Remove stop words from the string list
        return self.remove_stop_words(string_list, stop_word_list)
```

- The `construct_stop_word_list` method defines a list of stop words and returns it.
- The `remove_stop_words` method iterates over each string, splits it into words, filters out the stop words, and returns the processed list.
- The `process` method combines both functionalities: it constructs the stop word list and then removes these stop words from the input string list.",0.031034483,0.040675446,0.823529412,0.24137931,0.37333333,0.44,0.105769231,0.170542633,0.823529412,0.24137931,0.37333333,,,,,,,,,,,,
GPT,63,"from collections import Counter
import re

class NLPDataProcessor2:

    def process_data(self, string_list):
        words_list = []
        for string in string_list:
            # Remove non-English letters and convert to lowercase
            processed_string = re.sub(r'[^a-zA-Z\s]', '', string.lower())
            # Split the string into words
            words = processed_string.split()
            words_list.append(words)
        return words_list

    def calculate_word_frequency(self, words_list):
        word_frequency = Counter()
        for words in words_list:
            word_frequency.update(words)
        sorted_word_frequency = dict(sorted(word_frequency.items(), key=lambda x: x[1], reverse=True))
        top_5_word_frequency = dict(list(sorted_word_frequency.items())[:5])
        return top_5_word_frequency

    def process(self, string_list):
        words_list = self.process_data(string_list)
        word_frequency_dict = self.calculate_word_frequency(words_list)
        return word_frequency_dict",FewShot,"```python
import re
from collections import Counter

class NLPDataProcessor2:
    """"""
    The class processes NLP data by extracting words from a list of strings, calculating the frequency of each word, and returning the top 5 most frequent words.
    """"""

    def process_data(self, string_list):
        """"""
        Keep only English letters and spaces in the string, then convert the string to lower case, and then split the string into a list of words.
        :param string_list: a list of strings
        :return: words_list: a list of words lists
        """"""
        # Initialize an empty list to store lists of words
        words_list = []
        
        # Iterate over each string in the input list
        for string in string_list:
            # Use regex to remove non-letter characters and convert to lowercase
            cleaned_string = re.sub(r'[^a-zA-Z\s]', '', string).lower()
            # Split the cleaned string into words and append to words_list
            words_list.append(cleaned_string.split())
        
        return words_list

    def calculate_word_frequency(self, words_list):
        """"""
        Calculate the word frequency of each word in the list of words list, and sort the word frequency dictionary by value in descending order.
        :param words_list: a list of words lists
        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency
        """"""
        # Flatten the list of lists into a single list of words
        all_words = [word for sublist in words_list for word in sublist]
        
        # Use Counter to count the frequency of each word
        word_count = Counter(all_words)
        
        # Get the 5 most common words and their frequencies
        most_common_words = word_count.most_common(5)
        
        # Convert the list of tuples into a dictionary
        return dict(most_common_words)

    def process(self, string_list):
        """"""
        Keep only English letters and spaces in the string, then convert the string to lower case, and then split the string into a list of words. Calculate the word frequency of each word in the list of words list, and sort the word frequency dictionary by value in descending order.
        :param string_list: a list of strings
        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency
        """"""
        # Process the input strings to get a list of words lists
        words_list = self.process_data(string_list)
        
        # Calculate and return the word frequency dictionary
        return self.calculate_word_frequency(words_list)
```

This code defines the `NLPDataProcessor2` class with methods to process text data, calculate word frequencies, and retrieve the top 5 most frequent words. Each method is designed to handle specific tasks, ensuring the class is modular and easy to use.",0.045801527,0.053062917,0.649122807,0.255172414,0.36633663,0.414634146,0.127340824,0.194842403,0.631578947,0.248275862,0.35643564,,,,,,,,,,,,
GPT,64,"class NumberConverter:
    @staticmethod
    def decimal_to_binary(decimal_num):
        binary_num = bin(decimal_num)[2:]
        return binary_num

    @staticmethod
    def binary_to_decimal(binary_num):
        decimal_num = int(binary_num, 2)
        return decimal_num

    @staticmethod
    def decimal_to_octal(decimal_num):
        octal_num = oct(decimal_num)[2:]
        return octal_num

    @staticmethod
    def octal_to_decimal(octal_num):
        decimal_num = int(octal_num, 8)
        return decimal_num

    @staticmethod
    def decimal_to_hex(decimal_num):
        hex_num = hex(decimal_num)[2:]
        return hex_num

    @staticmethod
    def hex_to_decimal(hex_num):
        decimal_num = int(hex_num, 16)
        return decimal_num",FewShot,"```python
class NumberConverter:
    """"""
    The class allows to convert decimal to binary, octal and hexadecimal respectively and contrarily
    """"""

    @staticmethod
    def decimal_to_binary(decimal_num):
        """"""
        Convert a number from decimal format to binary format.
        :param decimal_num: int, decimal number
        :return: str, the binary representation of an integer.
        >>> NumberConverter.decimal_to_binary(42423)
        '1010010110110111'
        """"""
        # Use Python's built-in bin() function to convert decimal to binary
        # The bin() function returns a string prefixed with '0b', so we slice it off using [2:]
        return bin(decimal_num)[2:]

    @staticmethod
    def binary_to_decimal(binary_num):
        """"""
        Convert a number from binary format to decimal format.
        :param binary_num: str, binary number
        :return: int, the decimal representation of binary number str.
        >>> NumberConverter.binary_to_decimal('1010010110110111')
        42423
        """"""
        # Use Python's int() function with base 2 to convert binary to decimal
        return int(binary_num, 2)

    @staticmethod
    def decimal_to_octal(decimal_num):
        """"""
        Convert a number from decimal format to octal format.
        :param decimal_num: int, decimal number
        :return: str, the octal representation of an integer.
        >>> NumberConverter.decimal_to_octal(42423)
        '122667'
        """"""
        # Use Python's oct() function to convert decimal to octal
        # The oct() function returns a string prefixed with '0o', so we slice it off using [2:]
        return oct(decimal_num)[2:]

    @staticmethod
    def octal_to_decimal(octal_num):
        """"""
        Convert a number from octal format to decimal format.
        :param octal_num: str, octal num
        :return: int, the decimal representation of octal number str.
        >>> NumberConverter.octal_to_decimal('122667')
        42423
        """"""
        # Use Python's int() function with base 8 to convert octal to decimal
        return int(octal_num, 8)

    @staticmethod
    def decimal_to_hex(decimal_num):
        """"""
        Convert a number from decimal format to hex format.
        :param decimal_num: int, decimal number
        :return hex_num: str, the hex representation of an integer.
        >>> NumberConverter.decimal_to_hex(42423)
        'a5b7'
        """"""
        # Use Python's hex() function to convert decimal to hexadecimal
        # The hex() function returns a string prefixed with '0x', so we slice it off using [2:]
        # Also convert it to lowercase to match the expected output
        return hex(decimal_num)[2:].lower()

    @staticmethod
    def hex_to_decimal(hex_num):
        """"""
        Convert a number from hex format to decimal format.
        :param hex_num: str, hex num
        :return: int, the decimal representation of hex number str.
        >>> NumberConverter.hex_to_decimal('a5b7')
        42423
        """"""
        # Use Python's int() function with base 16 to convert hexadecimal to decimal
        return int(hex_num, 16)
```",0.017191977,0.093408713,0.8,0.196078431,0.314960627,0.261904762,0.057291667,0.094017091,0.76,0.18627451,0.299212595,,,,,,,,,,,,
GPT,65,"class NumberWordFormatter:
    def __init__(self):
        self.NUMBER = ["""", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""]
        self.NUMBER_TEEN = [""TEN"", ""ELEVEN"", ""TWELVE"", ""THIRTEEN"", ""FOURTEEN"", ""FIFTEEN"", ""SIXTEEN"", ""SEVENTEEN"",
                            ""EIGHTEEN"",
                            ""NINETEEN""]
        self.NUMBER_TEN = [""TEN"", ""TWENTY"", ""THIRTY"", ""FORTY"", ""FIFTY"", ""SIXTY"", ""SEVENTY"", ""EIGHTY"", ""NINETY""]
        self.NUMBER_MORE = ["""", ""THOUSAND"", ""MILLION"", ""BILLION""]
        self.NUMBER_SUFFIX = [""k"", ""w"", """", ""m"", """", """", ""b"", """", """", ""t"", """", """", ""p"", """", """", ""e""]

    def format(self, x):
        if x is not None:
            return self.format_string(str(x))
        else:
            return """"

    def format_string(self, x):
        lstr, rstr = (x.split('.') + [''])[:2]
        lstrrev = lstr[::-1]
        a = [''] * 5

        if len(lstrrev) % 3 == 1:
            lstrrev += ""00""
        elif len(lstrrev) % 3 == 2:
            lstrrev += ""0""

        lm = """"
        for i in range(len(lstrrev) // 3):
            a[i] = lstrrev[3 * i:3 * i + 3][::-1]
            if a[i] != ""000"":
                lm = self.trans_three(a[i]) + "" "" + self.parse_more(i) + "" "" + lm
            else:
                lm += self.trans_three(a[i])

        xs = f""AND CENTS {self.trans_two(rstr)} "" if rstr else """"
        if not lm.strip():
            return ""ZERO ONLY""
        else:
            return f""{lm.strip()} {xs}ONLY""

    def trans_two(self, s):
        s = s.zfill(2)
        if s[0] == ""0"":
            return self.NUMBER[int(s[-1])]
        elif s[0] == ""1"":
            return self.NUMBER_TEEN[int(s) - 10]
        elif s[1] == ""0"":
            return self.NUMBER_TEN[int(s[0]) - 1]
        else:
            return self.NUMBER_TEN[int(s[0]) - 1] + "" "" + self.NUMBER[int(s[-1])]

    def trans_three(self, s):
        if s[0] == ""0"":
            return self.trans_two(s[1:])
        elif s[1:] == ""00"":
            return f""{self.NUMBER[int(s[0])]} HUNDRED""
        else:
            return f""{self.NUMBER[int(s[0])]} HUNDRED AND {self.trans_two(s[1:])}""

    def parse_more(self, i):
        return self.NUMBER_MORE[i]",FewShot,"```python
class NumberWordFormatter:
    def __init__(self):
        self.NUMBER = ["""", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""]
        self.NUMBER_TEEN = [""TEN"", ""ELEVEN"", ""TWELVE"", ""THIRTEEN"", ""FOURTEEN"", ""FIFTEEN"", ""SIXTEEN"", ""SEVENTEEN"", ""EIGHTEEN"", ""NINETEEN""]
        self.NUMBER_TEN = ["""", ""TEN"", ""TWENTY"", ""THIRTY"", ""FORTY"", ""FIFTY"", ""SIXTY"", ""SEVENTY"", ""EIGHTY"", ""NINETY""]
        self.NUMBER_MORE = ["""", ""THOUSAND"", ""MILLION"", ""BILLION""]
        self.NUMBER_SUFFIX = [""k"", ""w"", """", ""m"", """", """", ""b"", """", """", ""t"", """", """", ""p"", """", """", ""e""]

    def format(self, x):
        if isinstance(x, float):
            integer_part = int(x)
            decimal_part = int(round((x - integer_part) * 100))
            return f""{self.format_string(str(integer_part))} POINT {self.trans_two(str(decimal_part))} ONLY""
        else:
            return f""{self.format_string(str(x))} ONLY""

    def format_string(self, x):
        if x == ""0"":
            return ""ZERO""
        
        x = x.zfill((len(x) + 2) // 3 * 3)  # Pad with zeros to make it a multiple of 3
        parts = [x[i:i+3] for i in range(0, len(x), 3)]
        
        words = []
        for i, part in enumerate(parts):
            if part != ""000"":
                words.append(self.trans_three(part))
                if i < len(parts) - 1:
                    words.append(self.NUMBER_MORE[len(parts) - i - 1])
        
        return "" "".join(word for word in words if word)

    def trans_two(self, s):
        if len(s) == 1:
            return self.NUMBER[int(s)]
        elif s[0] == '1':
            return self.NUMBER_TEEN[int(s[1])]
        else:
            return f""{self.NUMBER_TEN[int(s[0])]} {self.NUMBER[int(s[1])]}"".strip()

    def trans_three(self, s):
        if s[0] == '0':
            return self.trans_two(s[1:])
        else:
            return f""{self.NUMBER[int(s[0])]} HUNDRED {'AND ' + self.trans_two(s[1:]) if s[1:] != '00' else ''}"".strip()

    def parse_more(self, i):
        return self.NUMBER_MORE[i]
```

- `format`: Handles both integer and float numbers, formatting them into words and handling the decimal part if necessary.
- `format_string`: Converts a string representation of a number into its word format, breaking it into groups of three digits and processing each with `trans_three`.
- `trans_two`: Converts two-digit numbers into words, handling numbers below 20 separately.
- `trans_three`: Handles three-digit numbers, utilizing `trans_two` for the last two digits and adding ""HUNDRED"" for the hundreds place.
- `parse_more`: Returns the appropriate suffix for thousands, millions, etc., based on the index.",0.263513514,0.303521111,0.628571429,0.433497537,0.513119529,0.433789954,0.315614618,0.365384611,0.614285714,0.42364532,0.501457721,,,,,,,,,,,,
GPT,66,"class NumericEntityUnescaper:
    def __init__(self):
        pass

    def replace(self, string):
        out = []
        pos = 0
        length = len(string)

        while pos < length - 2:
            if string[pos] == '&' and string[pos + 1] == '#':
                start = pos + 2
                is_hex = False
                first_char = string[start]

                if first_char == 'x' or first_char == 'X':
                    start += 1
                    is_hex = True

                if start == length:
                    return ''.join(out)

                end = start
                while end < length and self.is_hex_char(string[end]):
                    end += 1

                if end < length and string[end] == ';':
                    try:
                        entity_value = int(string[start:end], 16 if is_hex else 10)
                    except:
                        return ''.join(out)

                    out.append(chr(entity_value))
                    pos = end + 1
                    continue

            out.append(string[pos])
            pos += 1

        return ''.join(out)

    @staticmethod
    def is_hex_char(char):
        return char.isdigit() or ('a' <= char.lower() <= 'f')",FewShot,"```python
import html

class NumericEntityUnescaper:
    """"""
    This is a class that provides functionality to replace numeric entities with their corresponding characters in a given string.
    """"""

    def __init__(self):
        pass

    def replace(self, string):
        """"""
        Replaces numeric character references (HTML entities) in the input string with their corresponding Unicode characters.
        :param string: str, the input string containing numeric character references.
        :return: str, the input string with numeric character references replaced with their corresponding Unicode characters.
        >>> unescaper = NumericEntityUnescaper()
        >>> unescaper.replace(""&#65;&#66;&#67;"")
        'ABC'
        """"""
        # Use the html.unescape function to replace numeric character references
        return html.unescape(string)

    @staticmethod
    def is_hex_char(char):
        """"""
        Determines whether a given character is a hexadecimal digit.
        :param char: str, the character to check.
        :return: bool, True if the character is a hexadecimal digit, False otherwise.
        >>> NumericEntityUnescaper.is_hex_char('a')
        True
        >>> NumericEntityUnescaper.is_hex_char('G')
        False
        """"""
        # Check if the character is a valid hexadecimal digit
        return char.lower() in '0123456789abcdef'
```

- The `replace` method uses Python's built-in `html.unescape()` function to convert numeric character references to their corresponding Unicode characters.
- The `is_hex_char` method checks if a character is a valid hexadecimal digit by comparing it against the set of valid hexadecimal characters.",0.026737968,0.03891748,0.257575758,0.178947368,0.211180119,0.096491228,0.074829932,0.084291183,0.257575758,0.178947368,0.211180119,,,,,,,,,,,,
GPT,67,"class Order:

    def __init__(self):
        self.menu = []
        # menu = [{""dish"": dish name, ""price"": price, ""count"": count}, ...]
        self.selected_dishes = []
        # selected_dish = {""dish"": dish name, ""count"": count, price: price}
        self.sales = {}
        # 


    def add_dish(self, dish):
        for menu_dish in self.menu:
            if dish[""dish""] == menu_dish[""dish""]:
                if menu_dish[""count""] < dish[""count""]:
                    return False
                else:
                    menu_dish[""count""] -= dish[""count""]
                    break
        self.selected_dishes.append(dish)
        return True

    def calculate_total(self):
        total = 0
        for dish in self.selected_dishes:
            total += dish[""price""] * dish[""count""] * self.sales[dish[""dish""]]
        return total

    def checkout(self):
        if len(self.selected_dishes) == 0:
            return False
        total = self.calculate_total()
        self.selected_dishes = []
        return total",FewShot,"```python
class Order:
    """"""
    The class manages restaurant orders by allowing the addition of dishes, calculation of the total cost, and checkout.
    """"""

    def __init__(self):
        """"""
        Initialize the order management system
        self.menu stores the dishes of restaurant inventory
        menu = [{""dish"": dish name, ""price"": price, ""count"": count}, ...]
        self.selected_dishes stores the dishes selected by customer
        selected_dish = {""dish"": dish name, ""count"": count, price: price}
        self.sales stores the sales of each dish
        sales = {dish name: sales}
        """"""
        self.menu = []
        self.selected_dishes = []
        self.sales = {}

    def add_dish(self, dish):
        """"""
        Check the self.menu and add into self.selected_dish if the dish count is valid.
        And if the dish has successfully been added, change the count in self.menu.
        :param dish: dict, the information of dish. dish = {""dish"": dish name, ""count"": count, price: price}
        :return: True if successfully added, or False otherwise.
        """"""
        for menu_item in self.menu:
            if menu_item[""dish""] == dish[""dish""] and menu_item[""count""] >= dish[""count""]:
                # Reduce the count in menu
                menu_item[""count""] -= dish[""count""]
                # Add to selected_dishes
                self.selected_dishes.append(dish)
                return True
        return False

    def calculate_total(self):
        """"""
        Calculate the total price of dishes that have been ordered. Multiply the count, price and sales.
        :return total: float, the final total price.
        """"""
        total = 0
        for dish in self.selected_dishes:
            # Calculate the cost of each dish considering the sales discount
            discount = self.sales.get(dish[""dish""], 1)
            total += dish[""count""] * dish[""price""] * discount
        return total

    def checkout(self):
        """"""
        Check out the dishes ordered. If the self.selected_dishes is not empty, invoke the calculate_total
        method to check out.
        :return False if the self.selected_dishes is empty, or total (return value of calculate_total) otherwise.
        """"""
        if not self.selected_dishes:
            return False
        return self.calculate_total()
```

- The `add_dish` method checks if the dish exists in the menu and if there is enough count available. If so, it reduces the count in the menu and adds the dish to `selected_dishes`.
- The `calculate_total` method calculates the total cost of the selected dishes, applying any sales discounts.
- The `checkout` method returns the total cost if there are selected dishes, otherwise returns False.",0.089020772,0.116753229,0.830508475,0.324503311,0.466666663,0.565217391,0.176870748,0.269430048,0.796610169,0.311258278,0.447619044,,,,,,,,,,,,
GPT,68,"class PageUtil:
    def __init__(self, data, page_size):
        self.data = data
        self.page_size = page_size
        self.total_items = len(data)
        self.total_pages = (self.total_items + page_size - 1) // page_size

    def get_page(self, page_number):
        if page_number < 1 or page_number > self.total_pages:
            return []

        start_index = (page_number - 1) * self.page_size
        end_index = start_index + self.page_size
        return self.data[start_index:end_index]

    def get_page_info(self, page_number):
        if page_number < 1 or page_number > self.total_pages:
            return {}

        start_index = (page_number - 1) * self.page_size
        end_index = min(start_index + self.page_size, self.total_items)
        page_data = self.data[start_index:end_index]

        page_info = {
            ""current_page"": page_number,
            ""per_page"": self.page_size,
            ""total_pages"": self.total_pages,
            ""total_items"": self.total_items,
            ""has_previous"": page_number > 1,
            ""has_next"": page_number < self.total_pages,
            ""data"": page_data
        }
        return page_info

    def search(self, keyword):
        results = [item for item in self.data if keyword in str(item)]
        num_results = len(results)
        num_pages = (num_results + self.page_size - 1) // self.page_size

        search_info = {
            ""keyword"": keyword,
            ""total_results"": num_results,
            ""total_pages"": num_pages,
            ""results"": results
        }
        return search_info",FewShot,"```python
class PageUtil:
    """"""
    PageUtil class is a versatile utility for handling pagination and search functionalities in an efficient and convenient manner.
    """"""

    def __init__(self, data, page_size):
        """"""
        Initialize the PageUtil object with the given data and page size.
        :param data: list, the data to be paginated
        :param page_size: int, the number of items per page
        """"""
        self.data = data
        self.page_size = page_size
        self.total_items = len(data)
        self.total_pages = (self.total_items + page_size - 1) // page_size

    def get_page(self, page_number):
        """"""
        Retrieve a specific page of data.
        :param page_number: int, the page number to fetch
        :return: list, the data on the specified page
        >>> page_util = PageUtil([1, 2, 3, 4], 1)
        >>> page_util.get_page(1)
        [1]
        """"""
        if page_number < 1 or page_number > self.total_pages:
            return []
        start_index = (page_number - 1) * self.page_size
        end_index = start_index + self.page_size
        return self.data[start_index:end_index]

    def get_page_info(self, page_number):
        """"""
        Retrieve information about a specific page.
        :param page_number: int, the page number to fetch information about
        :return: dict, containing page information such as current page number, total pages, etc.
        >>> page_util = PageUtil([1, 2, 3, 4], 1)
        >>> page_util.get_page_info(1)
        >>> {
        >>>     ""current_page"": 1,
        >>>     ""per_page"": 1,
        >>>     ""total_pages"": 4,
        >>>     ""total_items"": 4,
        >>>     ""has_previous"": False,
        >>>     ""has_next"": True,
        >>>     ""data"": [1]
        >>> }
        """"""
        if page_number < 1 or page_number > self.total_pages:
            return {}
        page_data = self.get_page(page_number)
        return {
            ""current_page"": page_number,
            ""per_page"": self.page_size,
            ""total_pages"": self.total_pages,
            ""total_items"": self.total_items,
            ""has_previous"": page_number > 1,
            ""has_next"": page_number < self.total_pages,
            ""data"": page_data
        }

    def search(self, keyword):
        """"""
        Search for items in the data that contain the given keyword.
        :param keyword: str, the keyword to search for
        :return: dict, containing search information such as total results and matching items
        >>> page_util = PageUtil([1, 2, 3, 4], 1)
        >>> page_util.search(""1"")
        >>> search_info = {
        >>>     ""keyword"": ""1"",
        >>>     ""total_results"": 1,
        >>>     ""total_pages"": 1,
        >>>     ""results"": [1]
        >>> }
        """"""
        # Convert all items to string and search for the keyword
        results = [item for item in self.data if keyword in str(item)]
        total_results = len(results)
        total_pages = (total_results + self.page_size - 1) // self.page_size
        return {
            ""keyword"": keyword,
            ""total_results"": total_results,
            ""total_pages"": total_pages,
            ""results"": results
        }
```",0.25862069,0.281353739,0.891891892,0.445945946,0.59459459,0.787401575,0.342465753,0.477326965,0.891891892,0.445945946,0.59459459,,,,,,,,,,,,
GPT,69,"import PyPDF2


class PDFHandler:
    def __init__(self, filepaths):
        self.filepaths = filepaths
        # PdfFileReader is deprecated and was removed in PyPDF2 3.0.0. Use PdfReader instead.
        self.readers = [PyPDF2.PdfReader(fp) for fp in filepaths]

    def merge_pdfs(self, output_filepath):
        pdf_writer = PyPDF2.PdfWriter()

        for reader in self.readers:
            # reader.getNumPages is deprecated and was removed in PyPDF2 3.0.0. Use len(reader.pages) instead.
            for page_num in range(len(reader.pages)):
                # reader.getPage(pageNumber) is deprecated and was removed in PyPDF2 3.0.0. Use reader.pages[page_number] instead.
                page = reader.pages[page_num]
                # addPage is deprecated and was removed in PyPDF2 3.0.0. Use add_page instead.
                pdf_writer.add_page(page)

        with open(output_filepath, 'wb') as out:
            pdf_writer.write(out)
        return f""Merged PDFs saved at {output_filepath}""

    def extract_text_from_pdfs(self):
        pdf_texts = []
        for reader in self.readers:
            for page_num in range(len(reader.pages)):
                page = reader.pages[page_num]
                pdf_texts.append(page.extract_text())
        return pdf_texts",FewShot,"```python
import PyPDF2

class PDFHandler:
    """"""
    The class allows merging multiple PDF files into one and extracting text from PDFs using PyPDF2 library.
    """"""

    def __init__(self, filepaths):
        """"""
        Takes a list of file paths filepaths as a parameter.
        It creates a list named readers using PyPDF2, where each reader opens a file from the given paths.
        """"""
        self.filepaths = filepaths
        self.readers = [PyPDF2.PdfReader(fp) for fp in filepaths]

    def merge_pdfs(self, output_filepath):
        """"""
        Read files in self.readers which stores handles to multiple PDF files.
        Merge them to one pdf and update the page number, then save in disk.
        :param output_filepath: str, output file path to save to
        :return: str, ""Merged PDFs saved at {output_filepath}"" if successfully merged
        >>> handler = PDFHandler(['a.pdf', 'b.pdf'])
        >>> handler.merge_pdfs('out.pdf')
        Merged PDFs saved at out.pdf
        """"""
        # Create a PdfWriter object to write the merged PDF
        pdf_writer = PyPDF2.PdfWriter()

        # Iterate over each PdfReader object in self.readers
        for reader in self.readers:
            # Iterate over each page in the current PDF
            for page_num in range(len(reader.pages)):
                # Add each page to the PdfWriter object
                pdf_writer.add_page(reader.pages[page_num])

        # Write the merged PDF to the specified output file path
        with open(output_filepath, 'wb') as output_file:
            pdf_writer.write(output_file)

        return f""Merged PDFs saved at {output_filepath}""

    def extract_text_from_pdfs(self):
        """"""
        Extract text from pdf files in self.readers
        :return pdf_texts: list of str, each element is the text of one pdf file
        >>> handler = PDFHandler(['a.pdf', 'b.pdf'])
        >>> handler.extract_text_from_pdfs()
        ['Test a.pdf', 'Test b.pdf']
        """"""
        pdf_texts = []

        # Iterate over each PdfReader object in self.readers
        for reader in self.readers:
            pdf_text = """"
            # Iterate over each page in the current PDF
            for page_num in range(len(reader.pages)):
                # Extract text from each page and append it to pdf_text
                page = reader.pages[page_num]
                pdf_text += page.extract_text()

            # Append the extracted text of the current PDF to pdf_texts list
            pdf_texts.append(pdf_text)

        return pdf_texts
```

### Comments:
- **PDFHandler Class**: This class is designed to handle PDF files by merging them into a single PDF and extracting text from them using the PyPDF2 library.
- **`__init__` Method**: Initializes the class with a list of file paths and creates a list of `PdfReader` objects for each file.
- **`merge_pdfs` Method**: Merges multiple PDF files into one by iterating through each page of each PDF and adding it to a `PdfWriter` object, then writes the merged PDF to a specified output file.
- **`extract_text_from_pdfs` Method**: Extracts text from each PDF by iterating through each page and concatenating the text, returning a list of strings where each string represents the text of one PDF file.",0.079903148,0.095380627,0.692307692,0.260115607,0.378151257,0.475247525,0.145015106,0.222222219,0.692307692,0.260115607,0.378151257,,,,,,,,,,,,
GPT,70,"class PersonRequest:
    def __init__(self, name: str, sex: str, phoneNumber: str):
        self.name = self._validate_name(name)
        self.sex = self._validate_sex(sex)
        self.phoneNumber = self._validate_phoneNumber(phoneNumber)

    def _validate_name(self, name: str) -> str:
        if not name:
            return None
        if len(name) > 33:
            return None
        return name

    def _validate_sex(self, sex: str) -> str:
        if sex not in [""Man"", ""Woman"", ""UGM""]:
            return None
        return sex

    def _validate_phoneNumber(self, phoneNumber: str) -> str:
        if not phoneNumber:
            return None
        if len(phoneNumber) != 11 or not phoneNumber.isdigit():
            return None
        return phoneNumber",FewShot,"```python
class PersonRequest:
    """"""
    This class validates input personal information data and sets invalid fields to None based on specific rules.
    """"""

    def __init__(self, name: str, sex: str, phoneNumber: str):
        """"""
        Initialize PersonRequest object with the provided information.
        :param name: str, the name of the person
        :param sex: str, the sex of the person
        :param phoneNumber: str, the phone number of the person
        """"""
        self.name = self._validate_name(name)
        self.sex = self._validate_sex(sex)
        self.phoneNumber = self._validate_phoneNumber(phoneNumber)

    def _validate_name(self, name: str) -> str:
        """"""
        Validate the name and return it. If name is empty or exceeds 33 characters in length, set to None.
        :param name: str, the name to validate
        :return: str, the validated name or None if invalid
        """"""
        # Check if the name is not empty and does not exceed 33 characters
        if name and len(name) <= 33:
            return name
        return None

    def _validate_sex(self, sex: str) -> str:
        """"""
        Validate the sex and return it. If sex is not 'Man', 'Woman', or 'UGM', set to None.
        :param sex: str, the sex to validate
        :return: str, the validated sex or None if invalid
        """"""
        # Check if the sex is one of the allowed values
        if sex in ['Man', 'Woman', 'UGM']:
            return sex
        return None

    def _validate_phoneNumber(self, phoneNumber: str) -> str:
        """"""
        Validate the phone number and return it. If phoneNumber is empty or not an 11 digit number, set to None.
        :param phoneNumber: str, the phone number to validate
        :return: str, the validated phone number or None if invalid
        """"""
        # Check if the phone number is exactly 11 digits long
        if phoneNumber.isdigit() and len(phoneNumber) == 11:
            return phoneNumber
        return None
```",0.100746269,0.13820192,0.846153846,0.340206186,0.485294114,0.597014925,0.21978022,0.321285137,0.820512821,0.329896907,0.470588231,,,,,,,,,,,,
GPT,71,"class PushBoxGame:
    def __init__(self, map):
        self.map = map
        self.player_row = 0
        self.player_col = 0
        self.targets = []
        self.boxes = []
        self.target_count = 0
        self.is_game_over = False

        self.init_game()

    def init_game(self):
        for row in range(len(self.map)):
            for col in range(len(self.map[row])):
                if self.map[row][col] == ""O"":
                    self.player_row = row
                    self.player_col = col
                elif self.map[row][col] == ""G"":
                    self.targets.append((row, col))
                    self.target_count += 1
                elif self.map[row][col] == ""X"":
                    self.boxes.append((row, col))

    def check_win(self):
        box_on_target_count = 0
        for box in self.boxes:
            if box in self.targets:
                box_on_target_count += 1
        if box_on_target_count == self.target_count:
            self.is_game_over = True
        return self.is_game_over

    def move(self, direction):
        new_player_row = self.player_row
        new_player_col = self.player_col

        if direction == ""w"":
            new_player_row -= 1
        elif direction == ""s"":
            new_player_row += 1
        elif direction == ""a"":
            new_player_col -= 1
        elif direction == ""d"":
            new_player_col += 1

        if self.map[new_player_row][new_player_col] != ""#"":
            if (new_player_row, new_player_col) in self.boxes:
                new_box_row = new_player_row + (new_player_row - self.player_row)
                new_box_col = new_player_col + (new_player_col - self.player_col)

                if self.map[new_box_row][new_box_col] != ""#"":
                    self.boxes.remove((new_player_row, new_player_col))
                    self.boxes.append((new_box_row, new_box_col))
                    self.player_row = new_player_row
                    self.player_col = new_player_col
            else:
                self.player_row = new_player_row
                self.player_col = new_player_col

        return self.check_win()",FewShot,"```python
class PushBoxGame:
    def __init__(self, map):
        self.map = map
        self.player_row = 0
        self.player_col = 0
        self.targets = []
        self.boxes = []
        self.target_count = 0
        self.is_game_over = False
        self.init_game()

    def init_game(self):
        """"""
        Initialize the game by setting the positions of the player, targets, and boxes based on the map.
        """"""
        for r, row in enumerate(self.map):
            for c, char in enumerate(row):
                if char == 'O':
                    self.player_row, self.player_col = r, c
                elif char == 'G':
                    self.targets.append((r, c))
                    self.target_count += 1
                elif char == 'X':
                    self.boxes.append((r, c))

    def check_win(self):
        """"""
        Check if the game is won. The game is won when all the boxes are placed on target positions.
        """"""
        if all(box in self.targets for box in self.boxes):
            self.is_game_over = True
        return self.is_game_over

    def move(self, direction):
        """"""
        Move the player based on the specified direction and check if the game is won.
        """"""
        if self.is_game_over:
            return True

        # Determine movement direction
        move_row, move_col = 0, 0
        if direction == 'w':  # Up
            move_row = -1
        elif direction == 's':  # Down
            move_row = 1
        elif direction == 'a':  # Left
            move_col = -1
        elif direction == 'd':  # Right
            move_col = 1

        new_row = self.player_row + move_row
        new_col = self.player_col + move_col

        # Check if the player can move to the new position
        if self.map[new_row][new_col] == '#':
            return False

        # Check if there is a box in the new position
        if (new_row, new_col) in self.boxes:
            box_new_row = new_row + move_row
            box_new_col = new_col + move_col

            # Check if the box can be moved
            if self.map[box_new_row][box_new_col] == '#' or (box_new_row, box_new_col) in self.boxes:
                return False

            # Move the box
            self.boxes.remove((new_row, new_col))
            self.boxes.append((box_new_row, box_new_col))

        # Move the player
        self.player_row, self.player_col = new_row, new_col

        # Check if the game is won
        return self.check_win()

    def print_map(self):
        """"""
        Print the current state of the map.
        """"""
        for r, row in enumerate(self.map):
            row_list = list(row)
            if (r, self.player_col) == (self.player_row, self.player_col):
                row_list[self.player_col] = 'O'
            for box in self.boxes:
                if (r, box[1]) == box:
                    row_list[box[1]] = 'X'
            print(''.join(row_list))
```

### Explanation:
- **init_game**: Initializes the positions of the player, targets, and boxes by iterating over the map.
- **check_win**: Checks if all boxes are on target positions, updating `self.is_game_over`.
- **move**: Handles player movement, box pushing, and checks for game win conditions.
- **print_map**: Displays the current map state, showing player and box positions.",0.112860892,0.145454307,0.52,0.234939759,0.323651448,0.363013699,0.169329073,0.230936815,0.52,0.234939759,0.323651448,,,,,,,,,,,,
GPT,72,"import re


class RegexUtils:

    def match(self, pattern, text):
        ans = re.match(pattern, text)
        if ans:
            return True
        else:
            return False

    def findall(self, pattern, text):
        return re.findall(pattern, text)

    def split(self, pattern, text):
        return re.split(pattern, text)

    def sub(self, pattern, replacement, text):
        return re.sub(pattern, replacement, text)

    def generate_email_pattern(self):
        pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        return pattern

    def generate_phone_number_pattern(self):
        pattern = r'\b\d{3}-\d{3}-\d{4}\b'
        return pattern

    def generate_split_sentences_pattern(self):
        pattern = r'[.!?][\s]{1,2}(?=[A-Z])'
        return pattern

    def split_sentences(self, text):
        pattern = self.generate_split_sentences_pattern()
        return self.split(pattern, text)

    def validate_phone_number(self, phone_number):
        pattern = self.generate_phone_number_pattern()
        return self.match(pattern, phone_number)

    def extract_email(self, text):
        pattern = self.generate_email_pattern()
        return self.findall(pattern, text)",FewShot,"```python
import re

class RegexUtils:
    """"""
    The class provides methods to match, find all occurrences, split, and substitute text using regular expressions. 
    It also includes predefined patterns for validating phone numbers and extracting email addresses.
    """"""

    def match(self, pattern, text):
        """"""
        Check if the text matches the regular expression
        :param pattern: string, Regular expression pattern
        :param text: string, Text to match
        :return: True or False, representing whether the text matches the regular expression or not
        """"""
        return re.fullmatch(pattern, text) is not None

    def findall(self, pattern, text):
        """"""
        Find all matching substrings and return a list of all matching substrings
        :param pattern: string, Regular expression pattern
        :param text: string, Text to match
        :return: list of string, List of all matching substrings
        """"""
        return re.findall(pattern, text)

    def split(self, pattern, text):
        """"""
        Split text based on regular expression patterns and return a list of substrings
        :param pattern: string, Regular expression pattern
        :param text: string, Text to be split
        :return: list of string, List of substrings after splitting
        """"""
        return re.split(pattern, text)

    def sub(self, pattern, replacement, text):
        """"""
        Replace the substring matched by a regular expression with the specified string
        :param pattern: string, Regular expression pattern
        :param replacement: Text to replace with
        :param text: string, Text to be replaced
        :return: string, Text after replacement
        """"""
        return re.sub(pattern, replacement, text)

    def generate_email_pattern(self):
        """"""
        Generate regular expression patterns that match email addresses
        :return: string, regular expression patterns that match email addresses
        """"""
        return r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'

    def generate_phone_number_pattern(self):
        """"""
        Generate regular expression patterns that match phone numbers
        :return: string, regular expression patterns that match phone numbers
        """"""
        return r'\b\d{3}-\d{3}-\d{4}\b'

    def generate_split_sentences_pattern(self):
        """"""
        Generate regular expression patterns that match the middle characters of two sentences
        :return: string, regular expression patterns that match the middle characters of two sentences
        """"""
        return r'[.!?][\s]{1,2}(?=[A-Z])'

    def split_sentences(self, text):
        """"""
        Split the text into a list of sentences without Punctuation except the last sentence
        :param text: Text to be split
        :return: Split Text List
        """"""
        pattern = self.generate_split_sentences_pattern()
        return re.split(pattern, text)

    def validate_phone_number(self, phone_number):
        """"""
        Verify if the phone number is valid
        :param phone_number: Phone number to be verified
        :return: True or False, indicating whether the phone number is valid
        """"""
        pattern = self.generate_phone_number_pattern()
        return self.match(pattern, phone_number)

    def extract_email(self, text):
        """"""
        Extract all email addresses from the text
        :param text: string, input text
        :return: list of string, All extracted email addresses
        """"""
        pattern = self.generate_email_pattern()
        return self.findall(pattern, text)
```",0.094147583,0.111845093,0.911111111,0.292857143,0.44324324,0.628205128,0.198380567,0.301538458,0.888888889,0.285714286,0.432432429,,,,,,,,,,,,
GPT,73,"class RPGCharacter:
    def __init__(self, name, hp, attack_power, defense, level=1):
        self.name = name
        self.hp = hp
        self.attack_power = attack_power
        self.defense = defense
        self.level = level
        self.exp = 0

    def attack(self, other_character):
        damage = max(self.attack_power - other_character.defense, 1)
        other_character.hp -= damage

    def heal(self):
        self.hp += 10
        if self.hp > 100:
            self.hp = 100
        return self.hp

    def gain_exp(self, amount):
        while amount != 0:
            if self.exp + amount >= self.level * 100:
                amount -= (self.level * 100 - self.exp)
                self.level_up()
            else:
                self.exp += amount
                amount = 0

    def level_up(self):
        if self.level < 100:
            self.level += 1
            self.exp = 0
            self.hp += 20
            self.attack_power += 5
            self.defense += 5
        return self.level, self.hp, self.attack_power, self.defense

    def is_alive(self):
        return self.hp > 0",FewShot,"```python
class RPGCharacter:
    """"""
    The class represents a role-playing game character, which allows to attack other characters, heal, gain experience, level up, and check if the character is alive.
    """"""

    def __init__(self, name, hp, attack_power, defense, level=1):
        """"""
        Initialize an RPG character object.
        :param name: str, the name of the character.
        :param hp: int, The health points of the character.
        :param attack_power: int, the attack power of the character.
        :param defense: int, the defense points of the character.
        :param level: int, the level of the character. Default is 1.
        """"""
        self.name = name
        self.hp = hp
        self.attack_power = attack_power
        self.defense = defense
        self.level = level
        self.exp = 0

    def attack(self, other_character):
        """"""
        Attack another character. The damage caused needs to offset the defense value.
        :param other_character: RPGCharacter, The character being attacked.
        """"""
        # Calculate damage considering the defense of the other character
        damage = self.attack_power - other_character.defense
        if damage < 0:
            damage = 0
        # Reduce the other character's hp by the calculated damage
        other_character.hp -= damage

    def heal(self):
        """"""
        Heal the character with 10 hp and the max hp is 100.
        :return: int, the current health points after healing.
        """"""
        # Increase hp by 10 but do not exceed 100
        self.hp = min(self.hp + 10, 100)
        return self.hp

    def gain_exp(self, amount):
        """"""
        Gain experience points for the character and level_up when the exp has reached the value that is 100 times the current level.
        The experience that overflows should be used to calculate the next level up until exhausted.
        :param amount: int, the amount of experience points to gain.
        """"""
        self.exp += amount
        # Check if the experience is enough for a level-up
        while self.exp >= 100 * self.level and self.level < 100:
            # Level up the character
            self.level_up()

    def level_up(self):
        """"""
        Level up the character and return to zero experience points, increase hp by 20 points, attack power and defense points by 5 points.
        Max level is 100.
        :return: tuple[int, int, int, int], the new level, health points, attack power, and defense points after leveling up.
        """"""
        if self.level < 100:
            # Increase level
            self.level += 1
            # Reset experience
            self.exp = 0
            # Increase stats
            self.hp += 20
            self.attack_power += 5
            self.defense += 5
            return self.level, self.hp, self.attack_power, self.defense

    def is_alive(self):
        """"""
        Check if player is alive.
        :return: True if the hp is larger than 0, or False otherwise.
        """"""
        return self.hp > 0
```",0.128787879,0.152554829,0.888888889,0.292682927,0.440366969,0.626086957,0.208092486,0.312364421,0.851851852,0.280487805,0.422018345,,,,,,,,,,,,
GPT,74,"class Server:

    def __init__(self):
        self.white_list = []
        self.send_struct = {}
        self.receive_struct = {}

    def add_white_list(self, addr):
        if addr in self.white_list:
            return False
        else:
            self.white_list.append(addr)
            return self.white_list

    def del_white_list(self, addr):
        if addr not in self.white_list:
            return False
        else:
            self.white_list.remove(addr)
            return self.white_list

    def recv(self, info):
        if not isinstance(info, dict) or ""addr"" not in info or ""content"" not in info:
            return -1
        addr = info[""addr""]
        content = info[""content""]
        if addr not in self.white_list:
            return False
        else:
            self.receive_struct = {""addr"": addr, ""content"": content}
            return self.receive_struct[""content""]

    def send(self, info):
        if not isinstance(info, dict) or ""addr"" not in info or ""content"" not in info:
            return ""info structure is not correct""
        self.send_struct = {""addr"": info[""addr""], ""content"": info[""content""]}

    def show(self, type):
        if type == ""send"":
            return self.send_struct
        elif type == ""receive"":
            return self.receive_struct
        else:
            return False",FewShot,"```python
class Server:
    """"""
    This is a class as a server, which handles a white list, message sending and receiving, and information display.
    """"""

    def __init__(self):
        """"""
        Initialize the whitelist as an empty list, and initialize the sending and receiving information as an empty dictionary.
        """"""
        self.white_list = []
        self.send_struct = {}
        self.receive_struct = {}

    def add_white_list(self, addr):
        """"""
        Add an address to the whitelist and do nothing if it already exists.
        :param addr: int, address to be added.
        :return: new whitelist, return False if the address already exists.
        """"""
        if addr not in self.white_list:
            self.white_list.append(addr)
            return self.white_list
        return False

    def del_white_list(self, addr):
        """"""
        Remove an address from the whitelist and do nothing if it does not exist.
        :param addr: int, address to be deleted.
        :return: new whitelist, return False if the address does not exist.
        """"""
        if addr in self.white_list:
            self.white_list.remove(addr)
            return self.white_list
        return False

    def recv(self, info):
        """"""
        Receive information containing address and content. If the address is on the whitelist, receive the content; otherwise, do not receive it.
        :param info: dict, information dictionary containing address and content.
        :return: if successfully received, return the content of the information; otherwise, return False.
        """"""
        addr = info.get(""addr"")
        content = info.get(""content"")
        if addr in self.white_list:
            self.receive_struct = info
            return content
        return False

    def send(self, info):
        """"""
        Send information containing address and content.
        :param info: dict, information dictionary containing address and content.
        :return: if successfully sent, return nothing; otherwise, return a string indicating an error message.
        """"""
        addr = info.get(""addr"")
        content = info.get(""content"")
        if addr is not None and content is not None:
            self.send_struct = info
        else:
            return ""Error: Missing address or content""

    def show(self, type):
        """"""
        Returns struct of the specified type.
        :param type: string, the type of struct to be returned, which can be 'send' or 'receive'.
        :return: if type is equal to 'send' or 'receive', return the corresponding struct; otherwise, return False.
        """"""
        if type == ""send"":
            return self.send_struct
        elif type == ""receive"":
            return self.receive_struct
        return False
```",0.094801223,0.130785353,0.696428571,0.317073171,0.435754186,0.516483516,0.195020747,0.283132526,0.696428571,0.317073171,0.435754186,,,,,,,,,,,,
GPT,75,"class ShoppingCart:
    def __init__(self):
        self.items = {}

    def add_item(self, item, price, quantity=1):
        if item in self.items:
            self.items[item] = {'price': price, 'quantity': quantity}
        else:
            self.items[item] = {'price': price, 'quantity': quantity}

    def remove_item(self, item, quantity=1):
        if item in self.items:
            self.items[item]['quantity'] -= quantity
        else:
            pass

    def view_items(self) -> dict:
        return self.items

    def total_price(self) -> float:
        return sum([item['quantity'] * item['price'] for item in self.items.values()])",FewShot,"```python
class ShoppingCart:
    """"""
    The class manages items, their prices, quantities, and allows for adding, removing, viewing items, and calculating the total price.
    """"""

    def __init__(self):
        """"""
        Initialize the items representing the shopping list as an empty dictionary
        """"""
        self.items = {}

    def add_item(self, item, price, quantity=1):
        """"""
        Add item information to the shopping list items, including price and quantity. The default quantity is 1
        :param item: string, Item to be added
        :param price: float, The price of the item
        :param quantity: int, The number of items, defaults to 1
        :return: None
        """"""
        if item in self.items:
            # If the item already exists, update the quantity
            self.items[item]['quantity'] += quantity
        else:
            # Add new item with price and quantity
            self.items[item] = {'price': price, 'quantity': quantity}

    def remove_item(self, item, quantity=1):
        """"""
        Subtract the specified quantity of item from the shopping list items
        :param item: string, Item to be subtracted in quantity
        :param quantity: int, Quantity to be subtracted
        :return: None
        """"""
        if item in self.items:
            if self.items[item]['quantity'] <= quantity:
                # If quantity to remove is greater or equal, remove the item completely
                del self.items[item]
            else:
                # Otherwise, just decrease the quantity
                self.items[item]['quantity'] -= quantity

    def view_items(self) -> dict:
        """"""
        Return the current shopping list items
        :return: dict, the current shopping list items
        """"""
        return self.items

    def total_price(self) -> float:
        """"""
        Calculate the total price of all items in the shopping list, which is the quantity of each item multiplied by the price
        :return: float, the total price of all items in the shopping list
        """"""
        total = 0.0
        for item in self.items.values():
            total += item['price'] * item['quantity']
        return total
```",0.097744361,0.116141511,0.918918919,0.288135593,0.438709674,0.711538462,0.167420814,0.271062268,0.891891892,0.279661017,0.425806448,,,,,,,,,,,,
GPT,76,"class SignInSystem:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username in self.users:
            return False
        else:
            self.users[username] = False
            return True

    def sign_in(self, username):
        if username not in self.users:
            return False
        else:
            self.users[username] = True
            return True

    def check_sign_in(self, username):
        if username not in self.users:
            return False
        else:
            if self.users[username]:
                return True
            else:
                return False

    def all_signed_in(self):
        if all(self.users.values()):
            return True
        else:
            return False

    def all_not_signed_in(self):
        not_signed_in_users = []
        for username, signed_in in self.users.items():
            if not signed_in:
                not_signed_in_users.append(username)
        return not_signed_in_users",FewShot,"```python
class SignInSystem:
    """"""
    This is a class as sign-in system, including adding users, signing in/out, checking sign-in status, and retrieving signed-in/not signed-in users.
    """"""

    def __init__(self):
        """"""
        Initialize the sign-in system.
        """"""
        self.users = {}

    def add_user(self, username):
        """"""
        Add a user to the sign-in system if the user wasn't in the self.users.
        And the initial state is False.
        :param username: str, the username to be added.
        :return: bool, True if the user is added successfully, False if the user already exists.
        """"""
        if username in self.users:
            return False
        self.users[username] = False
        return True

    def sign_in(self, username):
        """"""
        Sign in a user if the user was in the self.users and change the state to True.
        :param username: str, the username to be signed in.
        :return: bool, True if the user is signed in successfully, False if the user does not exist.
        """"""
        if username in self.users:
            self.users[username] = True
            return True
        return False

    def check_sign_in(self, username):
        """"""
        Check if a user is signed in.
        :param username: str, the username to be checked.
        :return: bool, True if the user is signed in, False if the user does not exist or is not signed in.
        """"""
        return self.users.get(username, False)

    def all_signed_in(self):
        """"""
        Check if all users are signed in.
        :return: bool, True if all users are signed in, False otherwise.
        """"""
        return all(self.users.values())

    def all_not_signed_in(self):
        """"""
        Get a list of usernames that are not signed in.
        :return: list[str], a list of usernames that are not signed in.
        """"""
        return [username for username, signed_in in self.users.items() if not signed_in]
```",0.08203125,0.110625625,0.771428571,0.293478261,0.425196846,0.548387097,0.195402299,0.288135589,0.771428571,0.293478261,0.425196846,,,,,,,,,,,,
GPT,77,"import random


class Snake:
    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):
        self.length = 1
        self.SCREEN_WIDTH = SCREEN_WIDTH
        self.SCREEN_HEIGHT = SCREEN_HEIGHT
        self.BLOCK_SIZE = BLOCK_SIZE
        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]
        self.score = 0
        self.food_position = food_position

    def move(self, direction):
        cur = self.positions[0]
        x, y = direction

        new = (
            ((cur[0] + (x * self.BLOCK_SIZE)) % self.SCREEN_WIDTH),
            (cur[1] + (y * self.BLOCK_SIZE)) % self.SCREEN_HEIGHT,
        )

        if new == self.food_position:
            self.eat_food()

        if len(self.positions) > 2 and new in self.positions[2:]:
            self.reset()
        else:
            self.positions.insert(0, new)
            if len(self.positions) > self.length:
                self.positions.pop()

    def random_food_position(self):
        while self.food_position in self.positions:
            self.food_position = (random.randint(0, self.SCREEN_WIDTH // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE,
                                  random.randint(0, self.SCREEN_HEIGHT // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE)

    def reset(self):
        self.length = 1
        self.positions = [((self.SCREEN_WIDTH / 2), (self.SCREEN_HEIGHT / 2))]
        self.score = 0
        self.random_food_position()

    def eat_food(self):
        self.length += 1
        self.score += 100
        self.random_food_position()",FewShot,"```python
import random

class Snake:
    """"""
    The class is a snake game, with allows snake to move and eat food, and also enables to reset, and generate a random food position.
    """"""

    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):
        """"""
        Initialize the length of the snake, screen width, screen height, block size, snake head position, score, and food position.
        :param SCREEN_WIDTH: int
        :param SCREEN_HEIGHT: int
        :param BLOCK_SIZE: int, Size of moving units
        :param food_position: tuple, representing the position(x, y) of food.
        """"""
        self.length = 1
        self.SCREEN_WIDTH = SCREEN_WIDTH
        self.SCREEN_HEIGHT = SCREEN_HEIGHT
        self.BLOCK_SIZE = BLOCK_SIZE
        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]
        self.score = 0
        self.food_position = food_position

    def move(self, direction):
        """"""
        Move the snake in the specified direction. If the new position of the snake's head is equal to the position of the food, then eat the food; If the position of the snake's head is equal to the position of its body, then start over, otherwise its own length plus one.
        :param direction: tuple, representing the direction of movement (x, y).
        :return: None
        """"""
        # Calculate new head position
        new_head = (self.positions[0][0] + direction[0] * self.BLOCK_SIZE, 
                    self.positions[0][1] + direction[1] * self.BLOCK_SIZE)
        
        # Check if the new head position is the same as the food position
        if new_head == self.food_position:
            self.eat_food()
        else:
            # Move the snake: add new head and remove the tail
            self.positions.insert(0, new_head)
            self.positions.pop()
        
        # Check for collision with itself
        if new_head in self.positions[1:]:
            self.reset()

    def random_food_position(self):
        """"""
        Randomly generate a new food position, but don't place it on the snake.
        :return: None, Change the food position
        """"""
        while True:
            new_food_position = (
                random.randint(0, (self.SCREEN_WIDTH // self.BLOCK_SIZE) - 1) * self.BLOCK_SIZE,
                random.randint(0, (self.SCREEN_HEIGHT // self.BLOCK_SIZE) - 1) * self.BLOCK_SIZE
            )
            if new_food_position not in self.positions:
                self.food_position = new_food_position
                break

    def reset(self):
        """"""
        Reset the snake to its initial state. Set the length to 1, the snake head position to ((SCREEN_WIDTH/2), (SCREEN_HEIGHT/2)), the score to 0, and randomly generate new food position.
        :return: None
        """"""
        self.length = 1
        self.positions = [((self.SCREEN_WIDTH / 2), (self.SCREEN_HEIGHT / 2))]
        self.score = 0
        self.random_food_position()

    def eat_food(self):
        """"""
        Increase the length of the snake by 1 and increase the score by 100. Randomly generate a new food position, but
        don't place it on the snake.
        :return: None
        """"""
        self.length += 1
        self.score += 100
        self.positions.insert(0, self.food_position)  # Add the new head position
        self.random_food_position()
```",0.152061856,0.178752833,0.756410256,0.349112426,0.477732789,0.591240876,0.249230769,0.350649346,0.756410256,0.349112426,0.477732789,,,,,,,,,,,,
GPT,78,"import re


class SplitSentence:

    def split_sentences(self, sentences_string):
        sentences = re.split(r'(?<!\w\.\w.)(?<![A-Z][a-z]\.)(?<=\.|\?)\s', sentences_string)
        return sentences

    def count_words(self, sentence):
        sentence = re.sub(r'[^a-zA-Z\s]', '', sentence)
        words = sentence.split()
        return len(words)

    def process_text_file(self, sentences_string):
        sentences = self.split_sentences(sentences_string)
        max_count = 0
        for sentence in sentences:
            count = self.count_words(sentence)
            if count > max_count:
                max_count = count

        return max_count",FewShot,"```python
import re

class SplitSentence:
    """"""
    The class allows to split sentences, count words in a sentence, and process a text file to find the maximum word count.
    """"""

    def split_sentences(self, sentences_string):
        """"""
        Split a string into a list of sentences. Sentences end with . or ? and with a space after that. 
        Please note that Mr. also ends with . but are not sentences.
        :param sentences_string: string, string to split
        :return: list, split sentence list
        >>> ss = SplitSentence()
        >>> ss.split_sentences(""aaa aaaa. bb bbbb bbb? cccc cccc. dd ddd?"")
        ['aaa aaaa.', 'bb bbbb bbb?', 'cccc cccc.', 'dd ddd?']
        """"""
        # Use regex to split sentences, considering punctuation followed by a space
        # Negative lookbehind to ensure ""Mr."" is not treated as a sentence end
        sentences = re.split(r'(?<!Mr)(?<=\.|\?)\s', sentences_string)
        return sentences

    def count_words(self, sentence):
        """"""
        Count the number of words in a sentence. Note that words are separated by spaces and that punctuation marks 
        and numbers are not counted as words.
        :param sentence: string, sentence to be counted, where words are separated by spaces
        :return: int, number of words in the sentence
        >>> ss = SplitSentence()
        >>> ss.count_words(""abc def"")
        2
        """"""
        # Use regex to find all words, which are sequences of alphabetic characters
        words = re.findall(r'\b[a-zA-Z]+\b', sentence)
        return len(words)

    def process_text_file(self, sentences_string):
        """"""
        Given a text, return the number of words in the longest sentence
        :param sentences_string: string, undivided long sentence
        :return: int, the number of words in the longest sentence
        >>> ss = SplitSentence()
        >>> ss.process_text_file(""aaa aaaa. bb bbbb bbb? cccc ccccccc cc ccc. dd ddd?"")
        4
        """"""
        # Split the text into sentences
        sentences = self.split_sentences(sentences_string)
        # Calculate the word count for each sentence
        word_counts = [self.count_words(sentence) for sentence in sentences]
        # Return the maximum word count found
        return max(word_counts)
```",0.04109589,0.05228942,0.657894737,0.173611111,0.274725271,0.407407407,0.090909091,0.148648646,0.657894737,0.173611111,0.274725271,,,,,,,,,,,,
GPT,79,"class SQLGenerator:
    def __init__(self, table_name):
        self.table_name = table_name

    def select(self, fields=None, condition=None):
        if fields is None:
            fields = ""*""
        else:
            fields = "", "".join(fields)
        sql = f""SELECT {fields} FROM {self.table_name}""
        if condition is not None:
            sql += f"" WHERE {condition}""
        return sql + "";""

    def insert(self, data):
        fields = "", "".join(data.keys())
        values = "", "".join([f""'{value}'"" for value in data.values()])
        sql = f""INSERT INTO {self.table_name} ({fields}) VALUES ({values})""
        return sql + "";""

    def update(self, data, condition):
        set_clause = "", "".join([f""{field} = '{value}'"" for field, value in data.items()])
        sql = f""UPDATE {self.table_name} SET {set_clause} WHERE {condition}""
        return sql + "";""

    def delete(self, condition):
        sql = f""DELETE FROM {self.table_name} WHERE {condition}""
        return sql + "";""

    def select_female_under_age(self, age):
        condition = f""age < {age} AND gender = 'female'""
        return self.select(condition=condition)

    def select_by_age_range(self, min_age, max_age):
        condition = f""age BETWEEN {min_age} AND {max_age}""
        return self.select(condition=condition)",FewShot,"```python
class SQLGenerator:
    """"""
    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.
    """"""

    def __init__(self, table_name):
        """"""
        Initialize the table name.
        :param table_name: str
        """"""
        self.table_name = table_name

    def select(self, fields=None, condition=None):
        """"""
        Generates a SELECT SQL statement based on the specified fields and conditions.
        :param fields: list, optional. Default is None. The list of fields to be queried.
        :param condition: str, optional. Default is None. The condition expression for the query.
        :return: str. The generated SQL statement.
        """"""
        fields_part = "", "".join(fields) if fields else ""*""
        condition_part = f"" WHERE {condition}"" if condition else """"
        return f""SELECT {fields_part} FROM {self.table_name}{condition_part};""

    def insert(self, data):
        """"""
        Generates an INSERT SQL statement based on the given data.
        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.
        :return: str. The generated SQL statement.
        """"""
        keys = "", "".join(data.keys())
        values = "", "".join(f""'{v}'"" for v in data.values())
        return f""INSERT INTO {self.table_name} ({keys}) VALUES ({values});""

    def update(self, data, condition):
        """"""
        Generates an UPDATE SQL statement based on the given data and condition.
        :param data: dict. The data to be updated, in dictionary form where keys are field names and values are new field values.
        :param condition: str. The condition expression for the update.
        :return: str. The generated SQL statement.
        """"""
        set_part = "", "".join(f""{k} = '{v}'"" for k, v in data.items())
        return f""UPDATE {self.table_name} SET {set_part} WHERE {condition};""

    def delete(self, condition):
        """"""
        Generates a DELETE SQL statement based on the given condition.
        :param condition: str. The condition expression for the delete.
        :return: str. The generated SQL statement.
        """"""
        return f""DELETE FROM {self.table_name} WHERE {condition};""

    def select_female_under_age(self, age):
        """"""
        Generates a SQL statement to select females under a specified age.
        :param age: int. The specified age.
        :return: str. The generated SQL statement.
        """"""
        return f""SELECT * FROM {self.table_name} WHERE age < {age} AND gender = 'female';""

    def select_by_age_range(self, min_age, max_age):
        """"""
        Generates a SQL statement to select records within a specified age range.
        :param min_age: int. The minimum age.
        :param max_age: int. The maximum age.
        :return: str. The generated SQL statement.
        """"""
        return f""SELECT * FROM {self.table_name} WHERE age BETWEEN {min_age} AND {max_age};""
```",0.073369565,0.091835561,0.7,0.356687898,0.472573835,0.413793103,0.19047619,0.260869561,0.7,0.356687898,0.472573835,,,,,,,,,,,,
GPT,80,"class SQLQueryBuilder:

    @staticmethod
    def select(table, columns='*', where=None):
        if columns != '*':
            columns = ', '.join(columns)
        query = f""SELECT {columns} FROM {table}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query

    @staticmethod
    def insert(table, data):
        keys = ', '.join(data.keys())
        values = ', '.join(f""'{v}'"" for v in data.values())
        return f""INSERT INTO {table} ({keys}) VALUES ({values})""

    @staticmethod
    def delete(table, where=None):
        query = f""DELETE FROM {table}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query

    @staticmethod
    def update(table, data, where=None):
        update_str = ', '.join(f""{k}='{v}'"" for k, v in data.items())
        query = f""UPDATE {table} SET {update_str}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query",FewShot,"```python
class SQLQueryBuilder:
    """"""
    This class provides to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements. 
    """"""

    @staticmethod
    def select(table, columns='*', where=None):
        """"""
        Generate the SELECT SQL statement from the given parameters.
        :param table: str, the query table in database.
        :param columns: list of str, ['col1', 'col2'] or '*'.
        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.
        :return query: str, the SQL query statement.
        """"""
        # If columns is a list, join them with a comma, otherwise use '*'
        columns_str = ', '.join(columns) if isinstance(columns, list) else columns
        query = f""SELECT {columns_str} FROM {table}""
        
        # If where condition is provided, append it to the query
        if where:
            conditions = [f""{k}='{v}'"" for k, v in where.items()]
            query += "" WHERE "" + "" AND "".join(conditions)
        
        return query

    @staticmethod
    def insert(table, data):
        """"""
        Generate the INSERT SQL statement from the given parameters.
        :param table: str, the table to be inserted in database.
        :param data: dict, the key and value in SQL insert statement
        :return query: str, the SQL insert statement.
        """"""
        # Extract columns and values from the data dictionary
        columns = ', '.join(data.keys())
        values = ', '.join(f""'{v}'"" for v in data.values())
        
        query = f""INSERT INTO {table} ({columns}) VALUES ({values})""
        return query

    @staticmethod
    def delete(table, where=None):
        """"""
        Generate the DELETE SQL statement from the given parameters.
        :param table: str, the table that will be executed with DELETE operation in database
        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.
        :return query: str, the SQL delete statement.
        """"""
        query = f""DELETE FROM {table}""
        
        # If where condition is provided, append it to the query
        if where:
            conditions = [f""{k}='{v}'"" for k, v in where.items()]
            query += "" WHERE "" + "" AND "".join(conditions)
        
        return query

    @staticmethod
    def update(table, data, where=None):
        """"""
        Generate the UPDATE SQL statement from the given parameters.
        :param table: str, the table that will be executed with UPDATE operation in database
        :param data: dict, the key and value in SQL update statement
        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.
        :return query: str, the SQL update statement.
        """"""
        # Create the SET part of the query from the data dictionary
        set_clause = ', '.join(f""{k}='{v}'"" for k, v in data.items())
        query = f""UPDATE {table} SET {set_clause}""
        
        # If where condition is provided, append it to the query
        if where:
            conditions = [f""{k}='{v}'"" for k, v in where.items()]
            query += "" WHERE "" + "" AND "".join(conditions)
        
        return query
```

This implementation of the `SQLQueryBuilder` class provides methods to build SQL queries for SELECT, INSERT, UPDATE, and DELETE operations. Each method constructs a SQL statement based on the provided parameters and handles optional `where` conditions appropriately.",0.133484163,0.155739094,0.877192982,0.324675325,0.473933645,0.65,0.207171315,0.314199392,0.877192982,0.324675325,0.473933645,,,,,,,,,,,,
GPT,81,"import math
class Statistics3:
    @staticmethod
    def median(data):
        sorted_data = sorted(data)
        n = len(sorted_data)
        if n % 2 == 1:
            return sorted_data[n // 2]
        else:
            return (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2

    @staticmethod
    def mode(data):
        counts = {}
        for value in data:
            counts[value] = counts.get(value, 0) + 1
        max_count = max(counts.values())
        mode_values = [value for value, count in counts.items() if count == max_count]
        return mode_values

    @staticmethod
    def correlation(x, y):
        n = len(x)
        mean_x = sum(x) / n
        mean_y = sum(y) / n
        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))
        denominator = math.sqrt(sum((xi - mean_x) ** 2 for xi in x) * sum((yi - mean_y) ** 2 for yi in y))
        if denominator == 0:
            return None
        return numerator / denominator

    @staticmethod
    def mean(data):
        if len(data) == 0:
            return None
        return sum(data) / len(data)

    @staticmethod
    def correlation_matrix(data):
        matrix = []
        for i in range(len(data[0])):
            row = []
            for j in range(len(data[0])):
                column1 = [row[i] for row in data]
                column2 = [row[j] for row in data]
                correlation = Statistics3.correlation(column1, column2)
                row.append(correlation)
            matrix.append(row)
        return matrix

    @staticmethod
    def standard_deviation(data):
        n = len(data)
        if n < 2:
            return None
        mean_value = Statistics3.mean(data)
        variance = sum((x - mean_value) ** 2 for x in data) / (n - 1)
        return math.sqrt(variance)

    @staticmethod
    def z_score(data):
        mean = Statistics3.mean(data)
        std_deviation = Statistics3.standard_deviation(data)
        if std_deviation is None or std_deviation == 0:
            return None
        return [(x - mean) / std_deviation for x in data]",FewShot,"```python
import math
from collections import Counter

class Statistics3:
    """"""
    This is a class that implements methods for calculating indicators such as median, mode, correlation matrix, and Z-score in statistics.
    """"""

    @staticmethod
    def median(data):
        """"""
        Calculates the median of the given list.
        :param data: the given list, list.
        :return: the median of the given list, float.
        >>> statistics3 = Statistics3()
        >>> statistics3.median([1, 2, 3, 4])
        2.5
        """"""
        n = len(data)
        sorted_data = sorted(data)
        mid = n // 2
        
        if n % 2 == 0:
            return (sorted_data[mid - 1] + sorted_data[mid]) / 2.0
        else:
            return sorted_data[mid]

    @staticmethod
    def mode(data):
        """"""
        Calculates the mode of the given list.
        :param data: the given list, list.
        :return: the mode of the given list, list.
        >>> statistics3 = Statistics3()
        >>> statistics3.mode([1, 2, 3, 3])
        [3]
        """"""
        data_counter = Counter(data)
        max_count = max(data_counter.values())
        return [k for k, v in data_counter.items() if v == max_count]

    @staticmethod
    def correlation(x, y):
        """"""
        Calculates the correlation of the given list.
        :param x: the given list, list.
        :param y: the given list, list.
        :return: the correlation of the given list, float.
        >>> statistics3 = Statistics3()
        >>> statistics3.correlation([1, 2, 3], [4, 5, 6])
        1.0
        """"""
        n = len(x)
        mean_x = Statistics3.mean(x)
        mean_y = Statistics3.mean(y)
        
        num = sum((x[i] - mean_x) * (y[i] - mean_y) for i in range(n))
        den = math.sqrt(sum((x[i] - mean_x) ** 2 for i in range(n)) * sum((y[i] - mean_y) ** 2 for i in range(n)))
        
        return num / den if den != 0 else 0

    @staticmethod
    def mean(data):
        """"""
        Calculates the mean of the given list.
        :param data: the given list, list.
        :return: the mean of the given list, float.
        >>> statistics3 = Statistics3()
        >>> statistics3.mean([1, 2, 3])
        2.0
        """"""
        return sum(data) / len(data) if data else 0

    @staticmethod
    def correlation_matrix(data):
        """"""
        Calculates the correlation matrix of the given list.
        :param data: the given list, list.
        :return: the correlation matrix of the given list, list.
        >>> statistics3 = Statistics3()
        >>> statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
        [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
        """"""
        size = len(data)
        matrix = [[0] * size for _ in range(size)]
        
        for i in range(size):
            for j in range(size):
                matrix[i][j] = Statistics3.correlation(data[i], data[j])
        
        return matrix

    @staticmethod
    def standard_deviation(data):
        """"""
        Calculates the standard deviation of the given list.
        :param data: the given list, list.
        :return: the standard deviation of the given list, float.
        >>> statistics3 = Statistics3()
        >>> statistics3.standard_deviation([1, 2, 3])
        1.0
        """"""
        mean = Statistics3.mean(data)
        variance = sum((x - mean) ** 2 for x in data) / len(data)
        return math.sqrt(variance)

    @staticmethod
    def z_score(data):
        """"""
        Calculates the z-score of the given list.
        :param data: the given list, list.
        :return: the z-score of the given list, list.
        >>> statistics3 = Statistics3()
        >>> statistics3.z_score([1, 2, 3, 4])
        [-1.161895003862225, -0.3872983346207417, 0.387298334620741",0.096491228,0.122222646,0.530434783,0.374233129,0.438848916,0.31627907,0.244604317,0.275862064,0.504347826,0.355828221,0.417266182,,,,,,,,,,,,
GPT,82,"class StockPortfolioTracker:
    def __init__(self, cash_balance):
        self.portfolio = []
        self.cash_balance = cash_balance

    def add_stock(self, stock):
        for pf in self.portfolio:
            if pf['name'] == stock['name']:
                pf['quantity'] += stock['quantity']
                return

        self.portfolio.append(stock)

    def remove_stock(self, stock):
        for pf in self.portfolio:
            if pf['name'] == stock['name'] and pf['quantity'] >= stock['quantity']:
                pf['quantity'] -= stock['quantity']
                if pf['quantity'] == 0:
                    self.portfolio.remove(pf)
                return True
        return False

    def buy_stock(self, stock):
        if stock['price'] * stock['quantity'] > self.cash_balance:
            return False
        else:
            self.add_stock(stock)
            self.cash_balance -= stock['price'] * stock['quantity']
            return True

    def sell_stock(self, stock):
        if self.remove_stock(stock) == False:
            return False
        self.cash_balance += stock['price'] * stock['quantity']
        return True

    def calculate_portfolio_value(self):
        total_value = self.cash_balance
        for stock in self.portfolio:
            total_value += stock['price'] * stock['quantity']
        return total_value

    def get_portfolio_summary(self):
        summary = []
        for stock in self.portfolio:
            value = self.get_stock_value(stock)
            summary.append({""name"": stock[""name""], ""value"": value})
        portfolio_value = self.calculate_portfolio_value()
        return portfolio_value, summary

    def get_stock_value(self, stock):
        return stock['price'] * stock['quantity']",FewShot,"```python
class StockPortfolioTracker:
    """"""
    This is a class as StockPortfolioTracker that allows to add stocks, remove stocks, buy stocks, sell stocks, calculate the total value of the portfolio, and obtain a summary of the portfolio.
    """"""

    def __init__(self, cash_balance):
        """"""
        Initialize the StockPortfolioTracker class with a cash balance and an empty portfolio.
        """"""
        self.portfolio = []
        self.cash_balance = cash_balance

    def add_stock(self, stock):
        """"""
        Add a stock to the portfolio.
        :param stock: a dictionary with keys ""name"", ""price"", and ""quantity""
        """"""
        self.portfolio.append(stock)

    def remove_stock(self, stock):
        """"""
        Remove a stock from the portfolio.
        :param stock: a dictionary with keys ""name"", ""price"", and ""quantity""
        :return: True if the stock was removed successfully, False otherwise.
        """"""
        for s in self.portfolio:
            if s['name'] == stock['name']:
                self.portfolio.remove(s)
                return True
        return False

    def buy_stock(self, stock):
        """"""
        Buy a stock and add it to the portfolio.
        :param stock: a dictionary with keys ""name"", ""price"", and ""quantity""
        :return: True if the stock was bought successfully, False if the cash balance is not enough.
        """"""
        total_cost = stock['price'] * stock['quantity']
        if self.cash_balance >= total_cost:
            self.cash_balance -= total_cost
            self.add_stock(stock)
            return True
        return False

    def sell_stock(self, stock):
        """"""
        Sell a stock and remove it from the portfolio and add the cash to the cash balance.
        :param stock: a dictionary with keys ""name"", ""price"", and ""quantity""
        :return: True if the stock was sold successfully, False if the quantity of the stock is not enough.
        """"""
        for s in self.portfolio:
            if s['name'] == stock['name'] and s['quantity'] >= stock['quantity']:
                s['quantity'] -= stock['quantity']
                self.cash_balance += stock['price'] * stock['quantity']
                if s['quantity'] == 0:
                    self.portfolio.remove(s)
                return True
        return False

    def calculate_portfolio_value(self):
        """"""
        Calculate the total value of the portfolio.
        :return: the total value of the portfolio, float.
        """"""
        total_value = self.cash_balance
        for stock in self.portfolio:
            total_value += stock['price'] * stock['quantity']
        return total_value

    def get_portfolio_summary(self):
        """"""
        Get a summary of the portfolio.
        :return: a tuple of the total value of the portfolio and a list of dictionaries with keys ""name"" and ""value""
        """"""
        summary = []
        for stock in self.portfolio:
            stock_value = stock['price'] * stock['quantity']
            summary.append({'name': stock['name'], 'value': stock_value})
        return self.calculate_portfolio_value(), summary

    def get_stock_value(self, stock):
        """"""
        Get the value of a stock.
        :param stock: a dictionary with keys ""name"", ""price"", and ""quantity""
        :return: the value of the stock, float.
        """"""
        return stock['price'] * stock['quantity']
```",0.125668449,0.157589264,0.716666667,0.373913043,0.491428567,0.548672566,0.262711864,0.355300855,0.716666667,0.373913043,0.491428567,,,,,,,,,,,,
GPT,83,"import sqlite3


class StudentDatabaseProcessor:

    def __init__(self, database_name):
        self.database_name = database_name

    def create_student_table(self):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        create_table_query = """"""
        CREATE TABLE IF NOT EXISTS students (
            id INTEGER PRIMARY KEY,
            name TEXT,
            age INTEGER,
            gender TEXT,
            grade INTEGER
        )
        """"""
        cursor.execute(create_table_query)

        conn.commit()
        conn.close()

    def insert_student(self, student_data):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        insert_query = """"""
        INSERT INTO students (name, age, gender, grade)
        VALUES (?, ?, ?, ?)
        """"""
        cursor.execute(insert_query,
                       (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))

        conn.commit()
        conn.close()

    def search_student_by_name(self, name):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        select_query = ""SELECT * FROM students WHERE name = ?""
        cursor.execute(select_query, (name,))
        result = cursor.fetchall()

        conn.close()

        return result

    def delete_student_by_name(self, name):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        delete_query = ""DELETE FROM students WHERE name = ?""
        cursor.execute(delete_query, (name,))

        conn.commit()
        conn.close()",FewShot,"```python
import sqlite3

class StudentDatabaseProcessor:
    """"""
    This is a class with database operation, including inserting student information, searching for student information by name, and deleting student information by name.
    """"""

    def __init__(self, database_name):
        """"""
        Initializes the StudentDatabaseProcessor object with the specified database name.
        :param database_name: str, the name of the SQLite database.
        """"""
        self.database_name = database_name

    def create_student_table(self):
        """"""
        Creates a ""students"" table in the database if it does not exist already.
        Fields include ID of type int, name of type str, age of type int, gender of type str, and grade of type int.
        :return: None
        """"""
        # Connect to the SQLite database
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        # SQL command to create the students table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS students (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                age INTEGER,
                gender TEXT,
                grade INTEGER
            )
        ''')

        # Commit the transaction and close the connection
        conn.commit()
        conn.close()

    def insert_student(self, student_data):
        """"""
        Inserts a new student into the ""students"" table.
        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).
        :return: None
        """"""
        # Connect to the SQLite database
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        # SQL command to insert a new student
        cursor.execute('''
            INSERT INTO students (name, age, gender, grade)
            VALUES (:name, :age, :gender, :grade)
        ''', student_data)

        # Commit the transaction and close the connection
        conn.commit()
        conn.close()

    def search_student_by_name(self, name):
        """"""
        Searches for a student in the ""students"" table by their name.
        :param name: str, the name of the student to search for.
        :return: list of tuples, the rows from the ""students"" table that match the search criteria.
        """"""
        # Connect to the SQLite database
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        # SQL command to search for a student by name
        cursor.execute('''
            SELECT * FROM students WHERE name = ?
        ''', (name,))

        # Fetch all matching rows
        result = cursor.fetchall()

        # Close the connection
        conn.close()

        return result

    def delete_student_by_name(self, name):
        """"""
        Deletes a student from the ""students"" table by their name.
        :param name: str, the name of the student to delete.
        :return: None
        """"""
        # Connect to the SQLite database
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        # SQL command to delete a student by name
        cursor.execute('''
            DELETE FROM students WHERE name = ?
        ''', (name,))

        # Commit the transaction and close the connection
        conn.commit()
        conn.close()
```",0.154046997,0.172790552,0.743243243,0.359477124,0.484581493,0.559633028,0.237354086,0.333333329,0.743243243,0.359477124,0.484581493,,,,,,,,,,,,
GPT,84,"import json


class TextFileProcessor:
    def __init__(self, file_path):
        self.file_path = file_path

    def read_file_as_json(self):
        with open(self.file_path, 'r') as file:
            data = json.load(file)

        return data

    def read_file(self):
        with open(self.file_path, 'r') as file:
            return file.read()

    def write_file(self, content):
        with open(self.file_path, 'w') as file:
            file.write(content)

    def process_file(self):
        content = self.read_file()
        content = ''.join([char for char in content if char.isalpha()])
        self.write_file(content)
        return content",FewShot,"```python
import json

class TextFileProcessor:
    """"""
    The class handles reading, writing, and processing text files. It can read the file as JSON, read the raw text, write content to the file, and process the file by removing non-alphabetic characters.
    """"""

    def __init__(self, file_path):
        """"""
        Initialize the file path.
        :param file_path: str
        """"""
        self.file_path = file_path

    def read_file_as_json(self):
        """"""
        Read the self.file_path file as json format.
        if the file content doesn't obey json format, the code will raise error.
        :return data: dict if the file is stored as json format, or str/int/float.. according to the file content otherwise.
        >>> textFileProcessor = TextFileProcessor('test.json')
        >>> textFileProcessor.read_file_as_json()
        {'name': 'test', 'age': 12}
        >>> type(textFileProcessor.read_file_as_json())
        <class 'dict'>
        """"""
        with open(self.file_path, 'r') as file:
            data = json.load(file)
        return data

    def read_file(self):
        """"""
        Read and return the content of self.file_path file.
        :return: the same return as the read() method
        >>> textFileProcessor = TextFileProcessor('test.json')
        >>> textFileProcessor.read_file()
        '{\n    ""name"": ""test"",\n    ""age"": 12\n}'
        """"""
        with open(self.file_path, 'r') as file:
            content = file.read()
        return content

    def write_file(self, content):
        """"""
        Write content into the self.file_path file, and overwrite if the file has already existed.
        :param content: any content
        >>> textFileProcessor = TextFileProcessor('test.json')
        >>> textFileProcessor.write_file('Hello world!')
        >>> textFileProcessor.read_file()
        'Hello world!'
        """"""
        with open(self.file_path, 'w') as file:
            file.write(content)

    def process_file(self):
        """"""
        Read the self.file_path file and filter out non-alphabetic characters from the content string.
        Overwrite the after-processed data into the same self.file_path file.
        >>> textFileProcessor = TextFileProcessor('test.json')
        >>> textFileProcessor.read_file()
        '{\n    ""name"": ""test"",\n    ""age"": 12\n}'
        >>> textFileProcessor.process_file()
        'nametestage'
        """"""
        content = self.read_file()
        processed_content = ''.join(filter(str.isalpha, content))
        self.write_file(processed_content)
        return processed_content
```

- The `read_file_as_json` method reads the file content as JSON and returns it as a Python object.
- The `read_file` method reads and returns the raw text content of the file.
- The `write_file` method writes the given content to the file, overwriting any existing content.
- The `process_file` method processes the file content to remove non-alphabetic characters and writes the processed content back to the file.",0.084639498,0.098175724,0.842105263,0.216216216,0.344086018,0.637931034,0.14453125,0.235668787,0.842105263,0.216216216,0.344086018,,,,,,,,,,,,
GPT,85,"import time

class Thermostat:
    def __init__(self, current_temperature, target_temperature, mode):
        self.current_temperature = current_temperature
        self.target_temperature = target_temperature
        self.mode = mode

    def get_target_temperature(self):
        return self.target_temperature

    def set_target_temperature(self, temperature):
        self.target_temperature = temperature

    def get_mode(self):
        return self.mode

    def set_mode(self, mode):
        if mode in ['heat', 'cool']:
            self.mode = mode
        else:
            return False

    def auto_set_mode(self):
        if self.current_temperature < self.target_temperature:
            self.mode = 'heat'
        else:
            self.mode = 'cool'

    def auto_check_conflict(self):
        if self.current_temperature > self.target_temperature:
            if self.mode == 'cool':
                return True
            else:
                self.auto_set_mode()
                return False
        else:
            if self.mode == 'heat':
                return True
            else:
                self.auto_set_mode()
                return False

    def simulate_operation(self):
        self.auto_set_mode()
        use_time = 0
        if self.mode == 'heat':
            while(self.current_temperature < self.target_temperature):
                self.current_temperature += 1
                use_time += 1
        else:
            while(self.current_temperature > self.target_temperature):
                self.current_temperature -= 1
                use_time += 1
        return use_time",FewShot,"```python
import time

class Thermostat:
    """"""
    The class manages temperature control, including setting and retrieving the target temperature, adjusting the mode, and simulating temperature operation.
    """"""

    def __init__(self, current_temperature, target_temperature, mode):
        """"""
        initialize instances of the Thermostat class, including the current temperature, target temperature, and operating mode.
        :param current_temperature: float
        :param target_temperature: float
        :param mode: str, the work mode
        """"""
        self.current_temperature = current_temperature
        self.target_temperature = target_temperature
        self.mode = mode

    def get_target_temperature(self):
        """"""
        Get the target temperature of an instance of the Thermostat class.
        :return self.target_temperature: float
        """"""
        return self.target_temperature

    def set_target_temperature(self, temperature):
        """"""
        Set the target temperature
        :param temperature: float, the target temperature
        """"""
        self.target_temperature = temperature

    def get_mode(self):
        """"""
        Get the current work mode
        :return mode: str, working mode. only ['heat', 'cool']
        """"""
        return self.mode

    def set_mode(self, mode):
        """"""
        Set the current work mode
        :param mode: str, working mode. only ['heat', 'cool']
        """"""
        if mode in ['heat', 'cool']:
            self.mode = mode

    def auto_set_mode(self):
        """"""
        Automatically set the operating mode by comparing with the current temperature and target temperature. 
        If the current temperature is lower than the target temperature, the operating mode is set to 'heat', 
        otherwise it is set to 'cool'.
        """"""
        if self.current_temperature < self.target_temperature:
            self.mode = 'heat'
        else:
            self.mode = 'cool'

    def auto_check_conflict(self):
        """"""
        Check if there is a conflict between the operating mode and the relationship between the current temperature 
        and the target temperature. If there is a conflict, the operating mode will be adjusted automatically.
        :return: True if mode isn't conflict with the relationship between the current temperature and the target temperature, or False otherwise.
        """"""
        if (self.current_temperature < self.target_temperature and self.mode != 'heat') or \
           (self.current_temperature >= self.target_temperature and self.mode != 'cool'):
            self.auto_set_mode()
            return False
        return True

    def simulate_operation(self):
        """"""
        Simulate the operation of Thermostat. It will automatically start the auto_set_mode method to set the operating mode,
        and then automatically adjust the current temperature according to the operating mode until the target temperature is reached.
        :return time: int, the time it took to complete the simulation.
        """"""
        self.auto_set_mode()
        start_time = time.time()

        while self.current_temperature != self.target_temperature:
            if self.mode == 'heat':
                self.current_temperature += 0.1  # Simulate heating
            elif self.mode == 'cool':
                self.current_temperature -= 0.1  # Simulate cooling

            # Ensure that the temperature does not overshoot
            if self.mode == 'heat' and self.current_temperature > self.target_temperature:
                self.current_temperature = self.target_temperature
            elif self.mode == 'cool' and self.current_temperature < self.target_temperature:
                self.current_temperature = self.target_temperature

            time.sleep(0.1)  # Simulate time delay for temperature change
        
        end_time = time.time()
        return int(end_time - start_time)
```

This completed `Thermostat` class includes methods for setting and retrieving temperature and mode, automatically adjusting mode based on temperature, checking for mode conflicts, and simulating the operation of the thermostat.",0.108045977,0.12696863,0.936170213,0.26993865,0.419047616,0.641304348,0.180981595,0.282296647,0.936170213,0.26993865,0.419047616,,,,,,,,,,,,
GPT,86,"class TicTacToe:
    def __init__(self, N=3):
        self.board = [[' ' for _ in range(N)] for _ in range(3)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        else:
            return False

    def check_winner(self):
        for row in self.board:
            if row[0] == row[1] == row[2] != ' ':
                return row[0]
        for col in range(3):
            if self.board[0][col] == self.board[1][col] == self.board[2][col] != ' ':
                return self.board[0][col]
        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':
            return self.board[0][0]
        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':
            return self.board[0][2]
        return None

    def is_board_full(self):
        for row in self.board:
            if ' ' in row:
                return False
        return True",FewShot,"```python
class TicTacToe:
    """"""
    The class represents a game of Tic-Tac-Toe and its functions include making a move on the board, checking for a winner, and determining if the board is full.
    """"""

    def __init__(self, N=3):
        """"""
        Initialize a 3x3 game board with all empty spaces and current symbol player, default is 'X'.
        """"""
        self.board = [[' ' for _ in range(N)] for _ in range(N)]
        self.current_player = 'X'

    def make_move(self, row, col):
        """"""
        Place the current player's mark at the specified position on the board and switch the mark.
        :param row: int, the row index of the position
        :param col: int, the column index of the position
        :return: bool, indicating whether the move was successful or not
        """"""
        if self.board[row][col] == ' ':
            # Place the current player's mark on the board
            self.board[row][col] = self.current_player
            # Switch to the other player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        return False

    def check_winner(self):
        """"""
        Check if there is a winner on the board in rows, columns and diagonals three directions
        :return: str or None, the mark of the winner ('X' or 'O'), or None if there is no winner yet
        """"""
        # Check rows and columns for a winner
        for i in range(3):
            if self.board[i][0] == self.board[i][1] == self.board[i][2] != ' ':
                return self.board[i][0]
            if self.board[0][i] == self.board[1][i] == self.board[2][i] != ' ':
                return self.board[0][i]

        # Check diagonals for a winner
        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':
            return self.board[0][0]
        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':
            return self.board[0][2]

        # If no winner, return None
        return None

    def is_board_full(self):
        """"""
        Check if the game board is completely filled.
        :return: bool, indicating whether the game board is full or not
        """"""
        for row in self.board:
            if ' ' in row:
                return False
        return True
```",0.226666667,0.250684348,0.82,0.330645161,0.471264364,0.701030928,0.27755102,0.397660815,0.82,0.330645161,0.471264364,,,,,,,,,,,,
GPT,87,"import datetime
import time

class TimeUtils:

    def __init__(self):
        self.datetime = datetime.datetime.now()

    def get_current_time(self):
        format = ""%H:%M:%S""
        return self.datetime.strftime(format)

    def get_current_date(self):
        format = ""%Y-%m-%d""
        return self.datetime.strftime(format)

    def add_seconds(self, seconds):
        new_datetime = self.datetime + datetime.timedelta(seconds=seconds)
        format = ""%H:%M:%S""
        return new_datetime.strftime(format)

    def string_to_datetime(self, string):
        return datetime.datetime.strptime(string, ""%Y-%m-%d %H:%M:%S"")

    def datetime_to_string(self, datetime):
        return datetime.strftime(""%Y-%m-%d %H:%M:%S"")

    def get_minutes(self, string_time1, string_time2):
        time1 = self.string_to_datetime(string_time1)
        time2 = self.string_to_datetime(string_time2)
        return round((time2 - time1).seconds / 60)

    def get_format_time(self, year, month, day, hour, minute, second):
        format = ""%Y-%m-%d %H:%M:%S""
        time_item = datetime.datetime(year, month, day, hour, minute, second)
        return time_item.strftime(format)",FewShot,"```python
import datetime
import time

class TimeUtils:
    """"""
    This is a time util class, including getting the current time and date, adding seconds to a datetime, converting between strings and datetime objects, calculating the time difference in minutes, and formatting a datetime object.
    """"""

    def __init__(self):
        """"""
        Get the current datetime
        """"""
        self.datetime = datetime.datetime.now()

    def get_current_time(self):
        """"""
        Return the current time in the format of '%H:%M:%S'
        :return: string
        """"""
        # Format the current time as a string in the desired format
        return self.datetime.strftime('%H:%M:%S')

    def get_current_date(self):
        """"""
        Return the current date in the format of ""%Y-%m-%d""
        :return: string
        """"""
        # Format the current date as a string in the desired format
        return self.datetime.strftime('%Y-%m-%d')

    def add_seconds(self, seconds):
        """"""
        Add the specified number of seconds to the current time
        :param seconds: int, number of seconds to add
        :return: string, time after adding the specified number of seconds in the format '%H:%M:%S'
        """"""
        # Add the specified number of seconds to the current datetime
        new_time = self.datetime + datetime.timedelta(seconds=seconds)
        # Format the new time as a string in the desired format
        return new_time.strftime('%H:%M:%S')

    def string_to_datetime(self, string):
        """"""
        Convert the time string to a datetime instance
        :param string: string, string before converting format
        :return: datetime instance
        """"""
        # Parse the string into a datetime object using the specified format
        return datetime.datetime.strptime(string, '%Y-%m-%d %H:%M:%S')

    def datetime_to_string(self, dt):
        """"""
        Convert a datetime instance to a string
        :param datetime: the datetime instance to convert
        :return: string, converted time string
        """"""
        # Format the datetime object as a string in the desired format
        return dt.strftime('%Y-%m-%d %H:%M:%S')

    def get_minutes(self, string_time1, string_time2):
        """"""
        Calculate how many minutes have passed between two times, and round the results to the nearest
        :return: int, the number of minutes between two times, rounded off
        """"""
        # Convert the string times to datetime objects
        dt1 = self.string_to_datetime(string_time1)
        dt2 = self.string_to_datetime(string_time2)
        # Calculate the difference in minutes and round to the nearest integer
        return round((dt2 - dt1).total_seconds() / 60)

    def get_format_time(self, year, month, day, hour, minute, second):
        """"""
        Get format time
        :param year: int
        :param month: int
        :param day: int
        :param hour: int
        :param minute: int
        :param second: int
        :return: formatted time string
        """"""
        # Create a datetime object from the provided parameters
        dt = datetime.datetime(year, month, day, hour, minute, second)
        # Format the datetime object as a string in the desired format
        return dt.strftime('%Y-%m-%d %H:%M:%S')
```",0.066838046,0.085596651,0.759259259,0.292857143,0.422680408,0.505882353,0.159851301,0.242937849,0.759259259,0.292857143,0.422680408,,,,,,,,,,,,
GPT,88,"from math import pi, fabs


class TriCalculator:

    def __init__(self):
        pass

    def cos(self, x):
        return round(self.taylor(x, 50), 10)

    def factorial(self, a):
        b = 1
        while a != 1:
            b *= a
            a -= 1
        return b

    def taylor(self, x, n):
        a = 1
        x = x / 180 * pi
        count = 1
        for k in range(1, n):
            if count % 2 != 0:
                a -= (x ** (2 * k)) / self.factorial(2 * k)
            else:
                a += (x ** (2 * k)) / self.factorial(2 * k)
            count += 1
        return a

    def sin(self, x):
        x = x / 180 * pi
        g = 0
        t = x
        n = 1

        while fabs(t) >= 1e-15:
            g += t
            n += 1
            t = -t * x * x / (2 * n - 1) / (2 * n - 2)
        return round(g, 10)

    def tan(self, x):
        if self.cos(x) != 0:
            result = self.sin(x) / self.cos(x)
            return round(result, 10)
        else:
            return False",FewShot,"```python
from math import pi, fabs

class TriCalculator:
    """"""
    The class allows to calculate trigonometric values, including cosine, sine, and tangent, using Taylor series approximations.
    """"""

    def __init__(self):
        pass

    def cos(self, x):
        """"""
        Calculate the cos value of the x-degree angle
        :param x: float
        :return: float
        >>> tricalculator = TriCalculator()
        >>> tricalculator.cos(60)
        0.5
        """"""
        # Convert degrees to radians
        x_rad = x * pi / 180
        # Use the Taylor series approximation
        return self.taylor(x_rad, 50)

    def factorial(self, a):
        """"""
        Calculate the factorial of a
        :param a: int
        :return: int
        >>> tricalculator.factorial(5)
        120
        """"""
        if a == 0:
            return 1
        else:
            result = 1
            for i in range(1, a + 1):
                result *= i
            return result

    def taylor(self, x, n):
        """"""
        Finding the n-order Taylor expansion value of cos (x/180 * pi)
        :param x: int
        :param n: int
        :return: float
        >>> tricalculator.taylor(60, 50)
        0.5000000000000001
        """"""
        # Initialize the Taylor series sum
        sum = 0
        # Calculate the Taylor series up to n terms
        for i in range(n):
            term = ((-1) ** i) * (x ** (2 * i)) / self.factorial(2 * i)
            sum += term
        return sum

    def sin(self, x):
        """"""
        Calculate the sin value of the x-degree angle
        :param x: float
        :return: float
        >>> tricalculator.sin(30)
        0.5
        """"""
        # Convert degrees to radians
        x_rad = x * pi / 180
        # Use the Taylor series approximation for sine
        sum = 0
        for i in range(50):
            term = ((-1) ** i) * (x_rad ** (2 * i + 1)) / self.factorial(2 * i + 1)
            sum += term
        return sum

    def tan(self, x):
        """"""
        Calculate the tan value of the x-degree angle
        :param x: float
        :return: float
        >>> tricalculator.tan(45)
        1.0
        """"""
        # Use the sine and cosine functions to calculate tangent
        cos_val = self.cos(x)
        if cos_val == 0:
            raise ValueError(""Tangent undefined for this angle."")
        sin_val = self.sin(x)
        return sin_val / cos_val
```",0.064935065,0.093355193,0.643835616,0.350746269,0.454106276,0.292307692,0.165217391,0.211111106,0.575342466,0.313432836,0.405797097,,,,,,,,,,,,
GPT,89,"import random


class TwentyFourPointGame:
    def __init__(self) -> None:
        self.nums = []

    def _generate_cards(self):
        for i in range(4):
            self.nums.append(random.randint(1, 9))
        assert len(self.nums) == 4

    def get_my_cards(self):
        self.nums = []
        self._generate_cards()
        return self.nums

    def answer(self, expression):
        if expression == 'pass':
            return self.get_my_cards()
        statistic = {}
        for c in expression:
            if c.isdigit() and int(c) in self.nums:
                statistic[c] = statistic.get(c, 0) + 1

        nums_used = statistic.copy()

        for num in self.nums:
            if nums_used.get(str(num), -100) != -100 and nums_used[str(num)] > 0:
                nums_used[str(num)] -= 1
            else:
                return False

        if all(count == 0 for count in nums_used.values()) == True:
            return self.evaluate_expression(expression)
        else:
            return False

    def evaluate_expression(self, expression):
        try:
            if eval(expression) == 24:
                return True
            else:
                return False
        except Exception as e:
            return False",FewShot,"```python
import random

class TwentyFourPointGame:
    """"""
    This is a game of twenty-four points, which provides to generate four numbers and check whether player's expression is equal to 24.
    """"""

    def __init__(self) -> None:
        self.nums = []

    def _generate_cards(self):
        """"""
        Generate random numbers between 1 and 9 for the cards.
        """"""
        self.nums = [random.randint(1, 9) for _ in range(4)]

    def get_my_cards(self):
        """"""
        Get a list of four random numbers between 1 and 9 representing the player's cards.
        :return: list of integers, representing the player's cards
        >>> game = TwentyFourPointGame()
        >>> game.get_my_cards()
        [5, 3, 8, 7]  # Example output, actual output will vary
        """"""
        self._generate_cards()
        return self.nums

    def answer(self, expression):
        """"""
        Check if a given mathematical expression using the cards can evaluate to 24.
        :param expression: string, mathematical expression using the cards
        :return: bool, True if the expression evaluates to 24, False otherwise
        >>> game = TwentyFourPointGame()
        >>> game.nums = [4, 3, 6, 6]
        >>> ans = ""4*3+6+6""
        >>> ret = game.answer(ans)
        True
        """"""
        try:
            # Evaluate the expression and check if it equals 24
            result = eval(expression)
            # Check if only the given numbers are used
            numbers_used = [int(n) for n in expression if n.isdigit()]
            return result == 24 and sorted(numbers_used) == sorted(self.nums)
        except:
            return False

    def evaluate_expression(self, expression):
        """"""
        Evaluate a mathematical expression and check if the result is 24.
        :param expression: string, mathematical expression
        :return: bool, True if the expression evaluates to 24, False otherwise
        >>> game = TwentyFourPointGame()
        >>> nums = [4, 3, 6, 6]
        >>> ans = ""4*3+6+6""
        >>> ret = game.evaluate_expression(ans)
        True
        """"""
        try:
            # Evaluate the expression and check if it equals 24
            result = eval(expression)
            return result == 24
        except:
            return False
```",0.057761733,0.081416196,0.453333333,0.293103448,0.356020938,0.198275862,0.115,0.145569616,0.453333333,0.293103448,0.356020938,,,,,,,,,,,,
GPT,90,"class URLHandler:
    def __init__(self, url):
        self.url = url

    def get_scheme(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            return self.url[:scheme_end]
        return None

    def get_host(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            url_without_scheme = self.url[scheme_end + 3:]
            host_end = url_without_scheme.find(""/"")
            if host_end != -1:
                return url_without_scheme[:host_end]
            return url_without_scheme
        return None

    def get_path(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            url_without_scheme = self.url[scheme_end + 3:]
            host_end = url_without_scheme.find(""/"")
            if host_end != -1:
                return url_without_scheme[host_end:]
        return None

    def get_query_params(self):
        query_start = self.url.find(""?"")
        fragment_start = self.url.find(""#"")
        if query_start != -1:
            query_string = self.url[query_start + 1:fragment_start]
            params = {}
            if len(query_string) > 0:
                param_pairs = query_string.split(""&"")
                for pair in param_pairs:
                    key_value = pair.split(""="")
                    if len(key_value) == 2:
                        key, value = key_value
                        params[key] = value
            return params
        return None

    def get_fragment(self):
        fragment_start = self.url.find(""#"")
        if fragment_start != -1:
            return self.url[fragment_start + 1:]
        return None",FewShot,"```python
from urllib.parse import urlparse, parse_qs

class URLHandler:
    """"""
    The class supports handling URLs, including extracting the scheme, host, path, query parameters, and fragment.
    """"""

    def __init__(self, url):
        """"""
        Initialize URLHandler's URL
        """"""
        self.url = url
        self.parsed_url = urlparse(url)  # Parse the URL once during initialization

    def get_scheme(self):
        """"""
        Get the scheme of the URL
        :return: string, If successful, return the scheme of the URL
        >>> urlhandler = URLHandler(""https://www.baidu.com/s?wd=aaa&rsv_spt=1#page"")
        >>> urlhandler.get_scheme()
        ""https""
        """"""
        return self.parsed_url.scheme  # Return the scheme part of the parsed URL

    def get_host(self):
        """"""
        Get the second part of the URL, which is the host domain name
        :return: string, If successful, return the host domain name of the URL
        >>> urlhandler = URLHandler(""https://www.baidu.com/s?wd=aaa&rsv_spt=1#page"")
        >>> urlhandler.get_host()
        ""www.baidu.com""
        """"""
        return self.parsed_url.netloc  # Return the network location part of the parsed URL

    def get_path(self):
        """"""
        Get the third part of the URL, which is the address of the resource
        :return: string, If successful, return the address of the resource of the URL
        >>> urlhandler = URLHandler(""https://www.baidu.com/s?wd=aaa&rsv_spt=1#page"")
        >>> urlhandler.get_path()
        ""/s""
        """"""
        return self.parsed_url.path  # Return the path part of the parsed URL

    def get_query_params(self):
        """"""
        Get the request parameters for the URL
        :return: dict, If successful, return the request parameters of the URL
        >>> urlhandler = URLHandler(""https://www.baidu.com/s?wd=aaa&rsv_spt=1#page"")
        >>> urlhandler.get_query_params()
        {""wd"": ""aaa"", ""rsv_spt"": ""1""}
        """"""
        query_params = parse_qs(self.parsed_url.query)  # Parse the query part of the parsed URL
        return {k: v[0] for k, v in query_params.items()}  # Convert lists to single values

    def get_fragment(self):
        """"""
        Get the fragment after '#' in the URL
        :return: string, If successful, return the fragment after '#' of the URL
        >>> urlhandler = URLHandler(""https://www.baidu.com/s?wd=aaa&rsv_spt=1#page"")
        >>> urlhandler.get_fragment()
        ""page""
        """"""
        return self.parsed_url.fragment  # Return the fragment part of the parsed URL
```

This implementation uses Python's `urllib.parse` library to handle URL parsing, which simplifies extracting the different components of a URL. Each method in the `URLHandler` class retrieves a specific part of the URL by accessing the appropriate attribute of the `parsed_url` object, which is created during initialization.",0.006134969,0.067826301,0.280701754,0.118518519,0.166666662,0.117647059,0.055813953,0.075709775,0.280701754,0.118518519,0.166666662,,,,,,,,,,,,
GPT,91,"import urllib.parse


class UrlPath:
    def __init__(self):
        self.segments = []
        self.with_end_tag = False

    def add(self, segment):
        self.segments.append(self.fix_path(segment))

    def parse(self, path, charset):
        if path:
            if path.endswith('/'):
                self.with_end_tag = True

            path = self.fix_path(path)
            if path:
                split = path.split('/')
                for seg in split:
                    decoded_seg = urllib.parse.unquote(seg, encoding=charset)
                    self.segments.append(decoded_seg)

    @staticmethod
    def fix_path(path):
        if not path:
            return ''

        segment_str = path.strip('/')
        return segment_str",FewShot,"```python
import urllib.parse

class UrlPath:
    """"""
    The UrlPath class is a utility for encapsulating and manipulating the path component of a URL, including adding nodes, parsing path strings, and building path strings with optional encoding.
    """"""

    def __init__(self):
        """"""
        Initializes the UrlPath object with an empty list of segments and a flag indicating the presence of an end tag.
        """"""
        self.segments = []
        self.with_end_tag = False

    def add(self, segment):
        """"""
        Adds a segment to the list of segments in the UrlPath.
        :param segment: str, the segment to add.
        >>> url_path = UrlPath()
        >>> url_path.add('foo')
        >>> url_path.add('bar')

        url_path.segments = ['foo', 'bar']
        """"""
        # Add the segment to the segments list
        self.segments.append(segment)

    def parse(self, path, charset='utf-8'):
        """"""
        Parses a given path string and populates the list of segments in the UrlPath.
        :param path: str, the path string to parse.
        :param charset: str, the character encoding of the path string.
        >>> url_path = UrlPath()
        >>> url_path.parse('/foo/bar/', 'utf-8')

        url_path.segments = ['foo', 'bar']
        """"""
        # Fix the path to remove leading and trailing slashes
        fixed_path = self.fix_path(path)
        # Decode the path using the specified charset
        decoded_path = urllib.parse.unquote(fixed_path, encoding=charset)
        # Split the path into segments and set it to self.segments
        self.segments = decoded_path.split('/')
        # Check if the original path had a trailing slash to set the end tag flag
        self.with_end_tag = path.endswith('/')

    @staticmethod
    def fix_path(path):
        """"""
        Fixes the given path string by removing leading and trailing slashes.
        :param path: str, the path string to fix.
        :return: str, the fixed path string.
        >>> url_path = UrlPath()
        >>> url_path.fix_path('/foo/bar/')
        'foo/bar'
        """"""
        # Strip leading and trailing slashes from the path
        return path.strip('/')

    def build(self, charset='utf-8'):
        """"""
        Builds the path string from the list of segments with optional encoding.
        :param charset: str, the character encoding to use when encoding the path string.
        :return: str, the constructed path string.
        >>> url_path = UrlPath()
        >>> url_path.add('foo')
        >>> url_path.add('bar')
        >>> url_path.build()
        '/foo/bar/'
        """"""
        # Join the segments into a single path string
        path = '/'.join(self.segments)
        # Encode the path using the specified charset
        encoded_path = urllib.parse.quote(path, encoding=charset)
        # Add leading and possibly trailing slashes
        if self.with_end_tag:
            return f'/{encoded_path}/'
        else:
            return f'/{encoded_path}'
```",0.031518625,0.044221378,0.674418605,0.205673759,0.315217388,0.390625,0.09469697,0.152439021,0.674418605,0.205673759,0.315217388,,,,,,,,,,,,
GPT,92,"import sqlite3


class UserLoginDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()

    def insert_user(self, username, password):
        self.cursor.execute('''
            INSERT INTO users (username, password)
            VALUES (?, ?)
        ''', (username, password))
        self.connection.commit()

    def search_user_by_username(self, username):
        self.cursor.execute('''
            SELECT * FROM users WHERE username = ?
        ''', (username,))
        user = self.cursor.fetchone()
        return user

    def delete_user_by_username(self, username):
        self.cursor.execute('''
            DELETE FROM users WHERE username = ?
        ''', (username,))
        self.connection.commit()

    def validate_user_login(self, username, password):
        user = self.search_user_by_username(username)
        if user is not None and user[1] == password:
            return True
        return False",FewShot,"```python
import sqlite3

class UserLoginDB:
    """"""
    This is a database management class for user login verification, providing functions for inserting user information, searching user information, deleting user information, and validating user login.
    """"""

    def __init__(self, db_name):
        """"""
        Initializes the UserLoginDB object with the specified database name.
        :param db_name: str, the name of the SQLite database.
        """"""
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()

    def create_table(self):
        """"""
        Creates the 'users' table in the database if it does not exist.
        :return: None
        """"""
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT NOT NULL UNIQUE,
                password TEXT NOT NULL
            )
        ''')
        self.connection.commit()

    def insert_user(self, username, password):
        """"""
        Inserts a new user into the ""users"" table.
        :param username: str, the username of the user.
        :param password: str, the password of the user.
        :return: None
        """"""
        try:
            self.cursor.execute(""INSERT INTO users (username, password) VALUES (?, ?)"", (username, password))
            self.connection.commit()
        except sqlite3.IntegrityError:
            print(f""User '{username}' already exists."")

    def search_user_by_username(self, username):
        """"""
        Searches for users in the ""users"" table by username.
        :param username: str, the username of the user to search for.
        :return: list of tuples, the rows from the ""users"" table that match the search criteria.
        """"""
        self.cursor.execute(""SELECT * FROM users WHERE username = ?"", (username,))
        return self.cursor.fetchall()

    def delete_user_by_username(self, username):
        """"""
        Deletes a user from the ""users"" table by username.
        :param username: str, the username of the user to delete.
        :return: None
        """"""
        self.cursor.execute(""DELETE FROM users WHERE username = ?"", (username,))
        self.connection.commit()

    def validate_user_login(self, username, password):
        """"""
        Determine whether the user can log in, that is, the user is in the database and the password is correct.
        :param username: str, the username of the user to validate.
        :param password: str, the password of the user to validate.
        :return: bool, representing whether the user can log in correctly.
        """"""
        self.cursor.execute(""SELECT * FROM users WHERE username = ? AND password = ?"", (username, password))
        return self.cursor.fetchone() is not None

    def __del__(self):
        """"""
        Ensures the database connection is closed when the instance is deleted.
        """"""
        self.connection.close()
```

- **`create_table`**: This method ensures that the `users` table exists in the database, creating it if necessary.
- **`insert_user`**: Inserts a new user into the database, handling the case where the username already exists.
- **`search_user_by_username`**: Searches for and returns users with the specified username.
- **`delete_user_by_username`**: Deletes a user with the specified username from the database.
- **`validate_user_login`**: Checks if the provided username and password match a record in the database.
- **`__del__`**: Ensures the database connection is properly closed when the object is deleted.",0.071942446,0.08507959,0.814814815,0.257309942,0.391111107,0.584415584,0.144230769,0.231362465,0.814814815,0.257309942,0.391111107,,,,,,,,,,,,
GPT,93,"import numpy as np
from gensim import matutils
from numpy import dot, array


class VectorUtil:
    @staticmethod
    def similarity(vector_1, vector_2):
        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))

    @staticmethod
    def cosine_similarities(vector_1, vectors_all):
        norm = np.linalg.norm(vector_1)
        all_norms = np.linalg.norm(vectors_all, axis=1)
        dot_products = dot(vectors_all, vector_1)
        similarities = dot_products / (norm * all_norms)
        return similarities

    @staticmethod
    def n_similarity(vector_list_1, vector_list_2):
        if not (len(vector_list_1) and len(vector_list_2)):
            raise ZeroDivisionError('At least one of the passed list is empty.')

        return dot(matutils.unitvec(array(vector_list_1).mean(axis=0)),
                   matutils.unitvec(array(vector_list_2).mean(axis=0)))

    @staticmethod
    def compute_idf_weight_dict(total_num, number_dict):
        index_2_key_map = {}

        index = 0

        count_list = []
        for key, count in number_dict.items():
            index_2_key_map[index] = key
            count_list.append(count)
            index = index + 1

        a = np.array(count_list)
        ## smooth, in case the divide by zero error
        a = np.log((total_num + 1) / (a + 1))
        result = {}

        for index, w in enumerate(a):
            key = index_2_key_map[index]
            result[key] = w

        return result",FewShot,"```python
import numpy as np
from gensim import matutils
from numpy import dot, array

class VectorUtil:
    """"""
    The class provides vector operations, including calculating similarity, cosine similarities, average similarity, and IDF weights.
    """"""

    @staticmethod
    def similarity(vector_1, vector_2):
        """"""
        Compute the cosine similarity between one vector and another vector.
        :param vector_1: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).
        :param vector_2: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).
        :return: numpy.ndarray, Contains cosine distance between `vector_1` and `vector_2`
        >>> vector_1 = np.array([1, 1])
        >>> vector_2 = np.array([1, 0])
        >>> VectorUtil.similarity(vector_1, vector_2)
        0.7071067811865475
        """"""
        # Normalize the vectors using gensim's matutils
        vector_1_norm = matutils.unitvec(vector_1)
        vector_2_norm = matutils.unitvec(vector_2)
        # Calculate and return the dot product (cosine similarity)
        return dot(vector_1_norm, vector_2_norm)

    @staticmethod
    def cosine_similarities(vector_1, vectors_all):
        """"""
        Compute cosine similarities between one vector and a set of other vectors.
        :param vector_1: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).
        :param vectors_all: list of numpy.ndarray, For each row in vectors_all, distance from vector_1 is computed, expected shape (num_vectors, dim).
        :return: numpy.ndarray, Contains cosine distance between `vector_1` and each row in `vectors_all`, shape (num_vectors,).
        >>> vector1 = np.array([1, 2, 3])
        >>> vectors_all = [np.array([4, 5, 6]), np.array([7, 8, 9])]
        >>> VectorUtil.cosine_similarities(vector1, vectors_all)
        [0.97463185 0.95941195]
        """"""
        # Normalize the input vector
        vector_1_norm = matutils.unitvec(vector_1)
        # Normalize the list of vectors and compute dot products
        return np.array([dot(vector_1_norm, matutils.unitvec(vector)) for vector in vectors_all])

    @staticmethod
    def n_similarity(vector_list_1, vector_list_2):
        """"""
        Compute cosine similarity between two sets of vectors.
        :param vector_list_1: list of numpy vector
        :param vector_list_2: list of numpy vector
        :return: numpy.ndarray, Similarities between vector_list_1 and vector_list_2.
        >>> vector_list1 = [np.array([1, 2, 3]), np.array([4, 5, 6])]
        >>> vector_list2 = [np.array([7, 8, 9]), np.array([10, 11, 12])]
        >>> VectorUtil.n_similarity(vector_list1, vector_list2)
        0.9897287473881233
        """"""
        # Convert lists of vectors to numpy arrays
        mean_vector_1 = np.mean([matutils.unitvec(vec) for vec in vector_list_1], axis=0)
        mean_vector_2 = np.mean([matutils.unitvec(vec) for vec in vector_list_2], axis=0)
        # Compute and return the cosine similarity of the mean vectors
        return dot(mean_vector_1, mean_vector_2)

    @staticmethod
    def compute_idf_weight_dict(total_num, number_dict):
        """"""
        Calculate log(total_num+1/count+1) for each count in number_dict
        :param total_num: int
        :param number_dict: dict
        :return: dict
        >>> num_dict = {'key1':0.1, 'key2':0.5}
        >>> VectorUtil.compute_idf_weight_dict(2, num_dict)
        {'key1': 1.0033021088637848, 'key2': 0.6931471805599453}
        """"""
        # Calculate IDF weights for each key in the dictionary
        return {key: np.log((total_num + 1) / (count + 1)) for key, count in number_dict.items()}
```",0.065104167,0.083963965,0.463157895,0.230366492,0.307692303,0.251851852,0.105919003,0.149122803,0.463157895,0.230366492,0.307692303,,,,,,,,,,,,
GPT,94,"class VendingMachine:
    def __init__(self):
        self.inventory = {}
        self.balance = 0

    def add_item(self, item_name, price, quantity):
        if not self.restock_item(item_name, quantity):
            self.inventory[item_name] = {'price': price, 'quantity': quantity}

    def insert_coin(self, amount):
        self.balance += amount
        return self.balance

    def purchase_item(self, item_name):
        if item_name in self.inventory:
            item = self.inventory[item_name]
            if item['quantity'] > 0 and self.balance >= item['price']:
                self.balance -= item['price']
                item['quantity'] -= 1
                return self.balance
            else:
                return False
        else:
            return False

    def restock_item(self, item_name, quantity):
        if item_name in self.inventory:
            self.inventory[item_name]['quantity'] += quantity
            return True
        else:
            return False

    def display_items(self):
        if not self.inventory:
            return False
        else:
            items = []
            for item_name, item_info in self.inventory.items():
                items.append(f""{item_name} - ${item_info['price']} [{item_info['quantity']}]"")
            return ""\n"".join(items)",FewShot,"```python
class VendingMachine:
    """"""
    This is a class to simulate a vending machine, including adding products, inserting coins, purchasing products, viewing balance, replenishing product inventory, and displaying product information.
    """"""

    def __init__(self):
        """"""
        Initializes the vending machine's inventory and balance.
        """"""
        self.inventory = {}
        self.balance = 0

    def add_item(self, item_name, price, quantity):
        """"""
        Adds a product to the vending machine's inventory.
        :param item_name: The name of the product to be added, str.
        :param price: The price of the product to be added, float.
        :param quantity: The quantity of the product to be added, int.
        :return: None
        """"""
        # Add the item to the inventory with its price and quantity
        self.inventory[item_name] = {'price': price, 'quantity': quantity}

    def insert_coin(self, amount):
        """"""
        Inserts coins into the vending machine.
        :param amount: The amount of coins to be inserted, float.
        :return: The balance of the vending machine after the coins are inserted, float.
        """"""
        # Increase the balance by the inserted amount
        self.balance += amount
        return self.balance

    def purchase_item(self, item_name):
        """"""
        Purchases a product from the vending machine.
        :param item_name: The name of the product to be purchased, str.
        :return: If successful, returns the balance of the vending machine after the product is purchased, float, otherwise, returns False.
        """"""
        # Check if the item is in the inventory
        if item_name in self.inventory:
            item = self.inventory[item_name]
            # Check if the item is in stock and if the balance is sufficient
            if item['quantity'] > 0 and self.balance >= item['price']:
                # Deduct the item price from the balance and decrease the item quantity
                self.balance -= item['price']
                item['quantity'] -= 1
                return self.balance
        # Return False if the purchase cannot be completed
        return False

    def restock_item(self, item_name, quantity):
        """"""
        Replenishes the inventory of a product already in the vending machine.
        :param item_name: The name of the product to be replenished, str.
        :param quantity: The quantity of the product to be replenished, int.
        :return: If the product is already in the vending machine, returns True, otherwise, returns False.
        """"""
        # Check if the item is in the inventory
        if item_name in self.inventory:
            # Increase the item quantity
            self.inventory[item_name]['quantity'] += quantity
            return True
        # Return False if the item is not in the inventory
        return False

    def display_items(self):
        """"""
        Displays the products in the vending machine.
        :return: If the vending machine is empty, returns False, otherwise, returns a list of the products in the vending machine, str.
        """"""
        # Check if the inventory is empty
        if not self.inventory:
            return False
        # Create a list of item details
        display_list = []
        for item_name, details in self.inventory.items():
            display_list.append(f""{item_name} - ${details['price']} [{details['quantity']}]"")
        # Return the list of items as a string
        return ', '.join(display_list)
```

This code completes the `VendingMachine` class by implementing methods for adding items, inserting coins, purchasing items, restocking items, and displaying the inventory. Each method includes necessary checks and updates to the machine's state, ensuring correct operation as described in the docstrings.",0.114822547,0.129928736,0.879310345,0.31097561,0.459459456,0.71875,0.207207207,0.321678318,0.879310345,0.31097561,0.459459456,,,,,,,,,,,,
GPT,95,"class Warehouse:
    def __init__(self):
        self.inventory = {}  # Product ID: Product
        self.orders = {}  # Order ID: Order

    def add_product(self, product_id, name, quantity):
        if product_id not in self.inventory:
            self.inventory[product_id] = {'name': name, 'quantity': quantity}
        else:
            self.inventory[product_id]['quantity'] += quantity

    def update_product_quantity(self, product_id, quantity):
        if product_id in self.inventory:
            self.inventory[product_id]['quantity'] += quantity

    def get_product_quantity(self, product_id):
        if product_id in self.inventory:
            return self.inventory[product_id]['quantity']
        else:
            return False

    def create_order(self, order_id, product_id, quantity):
        if self.get_product_quantity(product_id) >= quantity:
            self.update_product_quantity(product_id, -quantity)
            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}
        else:
            return False

    def change_order_status(self, order_id, status):
        if order_id in self.orders:
            self.orders[order_id]['status'] = status
        else:
            return False

    def track_order(self, order_id):
        if order_id in self.orders:
            return self.orders[order_id]['status']
        else:
            return False",FewShot,"```python
class Warehouse:
    """"""
    The class manages inventory and orders, including adding products, updating product quantities, retrieving product quantities, creating orders, changing order statuses, and tracking orders.
    """"""

    def __init__(self):
        """"""
        Initialize two fields.
        self.inventory is a dict that stores the products.
        self.inventory = {Product ID: Product}
        self.orders is a dict that stores the products in a order.
        self.orders = {Order ID: Order}
        """"""
        self.inventory = {}  # Product ID: Product
        self.orders = {}  # Order ID: Order

    def add_product(self, product_id, name, quantity):
        """"""
        Add product to inventory and plus the quantity if it has existed in inventory.
        Or just add new product to dict otherwise.
        :param product_id: int
        :param name: str, product name
        :param quantity: int, product quantity
        >>> warehouse.add_product(1, ""product1"", 3)
        >>> warehouse.inventory
        {1: {'name': 'product1', 'quantity': 3}}
        """"""
        if product_id in self.inventory:
            self.inventory[product_id]['quantity'] += quantity
        else:
            self.inventory[product_id] = {'name': name, 'quantity': quantity}

    def update_product_quantity(self, product_id, quantity):
        """"""
        According to product_id, add the quantity to the corresponding product in inventory.
        >>> warehouse.add_product(1, ""product1"", 3)
        >>> warehouse.update_product_quantity(1, -1)
        >>> warehouse.inventory
        {1: {'name': 'product1', 'quantity': 2}}
        """"""
        if product_id in self.inventory:
            self.inventory[product_id]['quantity'] += quantity

    def get_product_quantity(self, product_id):
        """"""
        Get the quantity of specific product by product_id.
        :param product_id, int
        :return: if the product_id is in inventory then return the corresponding quantity,
                or False otherwise.
        >>> warehouse.add_product(1, ""product1"", 3)
        >>> warehouse.get_product_quantity(1)
        3
        >>> warehouse.get_product_quantity(2)
        False
        """"""
        if product_id in self.inventory:
            return self.inventory[product_id]['quantity']
        return False

    def create_order(self, order_id, product_id, quantity):
        """"""
        Create a order which includes the infomation of product, like id and quantity.
        And put the new order into self.orders.
        The default value of status is 'Shipped'.
        :param order_id: int
        :param product_id: int
        :param quantity: the quantity of product that be selected.
        :return False: only if product_id is not in inventory or the quantity is not adequate
        >>> warehouse.add_product(1, ""product1"", 3)
        >>> warehouse.create_order(1, 1, 2)
        >>> warehouse.orders
        {1: {'product_id': 1, 'quantity': 2, 'status': 'Shipped'}}
        >>> warehouse.create_order(1, 2, 2)
        False
        """"""
        if product_id not in self.inventory or self.inventory[product_id]['quantity'] < quantity:
            return False
        self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}
        self.inventory[product_id]['quantity'] -= quantity

    def change_order_status(self, order_id, status):
        """"""
        Change the status of order if the input order_id is in self.orders.
        :param order_id: int
        :param status: str, the state that is going to change to
        :return False: only if the order_id is not in self.orders
        >>> warehouse.add_product(1, ""product1"", 3)
        >>> warehouse.create_order(1, 1, 2)
        >>> warehouse.change_order_status(1, ""done"")
        >>> warehouse.orders
        {1: {'product_id': 1, 'quantity': 2, 'status': 'done'}}
        """"""
        if order_id in self.orders:
            self.orders[order_id]['status'] = status
        else:
            return False

    def track_order(self, order_id):
        """"""
        Get the status of specific order.
        :param order_id: int
        :return False: only if the order_id is not in self.orders.
        >>> warehouse.add_product(1, ""product1"", 3)
        >>> warehouse.create_order(1, 1, 2)
        >>> warehouse.track_order(1)
        'Shipped'
        """"""
        if order_id in self.orders:",0.142222222,0.159946089,0.927272727,0.316770186,0.472222218,0.791208791,0.220183486,0.344497604,0.927272727,0.316770186,0.472222218,,,,,,,,,,,,
GPT,96,"class WeatherSystem:
    def __init__(self, city) -> None:
        self.temperature = None
        self.weather = None
        self.city = city
        self.weather_list = {}
    
    def query(self, weather_list, tmp_units = 'celsius'):
        self.weather_list = weather_list
        if self.city not in weather_list:
            return False
        else:
            self.temperature = self.weather_list[self.city]['temperature']
            self.weather = self.weather_list[self.city]['weather']
        if self.weather_list[self.city]['temperature units'] != tmp_units:
            if tmp_units == 'celsius':
                return self.fahrenheit_to_celsius(), self.weather
            elif tmp_units == 'fahrenheit':
                return self.celsius_to_fahrenheit(), self.weather
        else:
            return self.temperature, self.weather
    
    def set_city(self, city):
        self.city = city

    def celsius_to_fahrenheit(self):
        return (self.temperature * 9/5) + 32

    def fahrenheit_to_celsius(self):
        return (self.temperature - 32) * 5/9",FewShot,"```python
class WeatherSystem:
    """"""
    This is a class representing a weather system that provides functionality to query weather information for a specific city and convert temperature units between Celsius and Fahrenheit.
    """"""

    def __init__(self, city) -> None:
        """"""
        Initialize the weather system with a city name.
        """"""
        self.temperature = None
        self.weather = None
        self.city = city
        self.weather_list = {}

    def query(self, weather_list, tmp_units='celsius'):
        """"""
        Query the weather system for the weather and temperature of the city, and convert the temperature units based on the input parameter.
        :param weather_list: a dictionary of weather information for different cities, dict.
        :param tmp_units: the temperature units to convert to, str.
        :return: the temperature and weather of the city, tuple.
        """"""
        self.weather_list = weather_list
        city_weather = self.weather_list.get(self.city)

        if city_weather:
            self.temperature = city_weather['temperature']
            self.weather = city_weather['weather']
            if tmp_units == 'fahrenheit':
                self.temperature = self.celsius_to_fahrenheit()
            return (self.temperature, self.weather)
        else:
            return None

    def set_city(self, city):
        """"""
        Set the city of the weather system.
        :param city: the city to set, str.
        :return: None
        """"""
        self.city = city

    def celsius_to_fahrenheit(self):
        """"""
        Convert the temperature from Celsius to Fahrenheit.
        :return: the temperature in Fahrenheit, float.
        """"""
        return self.temperature * 9/5 + 32

    def fahrenheit_to_celsius(self):
        """"""
        Convert the temperature from Fahrenheit to Celsius.
        :return: the temperature in Celsius, float.
        """"""
        return (self.temperature - 32) * 5/9
```

- The `query` method accesses the `weather_list` dictionary to find the weather data for the specified city. If the city is found, it converts the temperature to Fahrenheit if specified and returns the temperature and weather as a tuple.
- The `set_city` method allows changing the city for which the weather is queried.
- The `celsius_to_fahrenheit` and `fahrenheit_to_celsius` methods perform unit conversions as required.",0.105072464,0.126025753,0.730769231,0.308943089,0.43428571,0.505882353,0.184549356,0.270440248,0.730769231,0.308943089,0.43428571,,,,,,,,,,,,
GPT,97,"class Words2Numbers:

    def __init__(self):
        self.numwords = {}
        self.units = [
            ""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"",
            ""nine"", ""ten"", ""eleven"", ""twelve"", ""thirteen"", ""fourteen"", ""fifteen"",
            ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen"",
        ]
        self.tens = ["""", """", ""twenty"", ""thirty"", ""forty"", ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""]
        self.scales = [""hundred"", ""thousand"", ""million"", ""billion"", ""trillion""]

        self.numwords[""and""] = (1, 0)
        for idx, word in enumerate(self.units):
            self.numwords[word] = (1, idx)
        for idx, word in enumerate(self.tens):
            self.numwords[word] = (1, idx * 10)
        for idx, word in enumerate(self.scales):
            self.numwords[word] = (10 ** (idx * 3 or 2), 0)

        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}
        self.ordinal_endings = [('ieth', 'y'), ('th', '')]

    def text2int(self, textnum):
        textnum = textnum.replace('-', ' ')

        current = result = 0
        curstring = """"
        onnumber = False
        for word in textnum.split():
            if word in self.ordinal_words:
                scale, increment = (1, self.ordinal_words[word])
                current = current * scale + increment
                onnumber = True
            else:
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = ""%s%s"" % (word[:-len(ending)], replacement)

                if word not in self.numwords:
                    if onnumber:
                        curstring += repr(result + current) + "" ""
                    curstring += word + "" ""
                    result = current = 0
                    onnumber = False
                else:
                    scale, increment = self.numwords[word]
                    current = current * scale + increment
                    if scale > 100:
                        result += current
                        current = 0
                    onnumber = True

        if onnumber:
            curstring += repr(result + current)

        return curstring

    def is_valid_input(self, textnum):

        textnum = textnum.replace('-', ' ')

        for word in textnum.split():
            if word in self.ordinal_words:
                continue
            else:
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = ""%s%s"" % (word[:-len(ending)], replacement)

                if word not in self.numwords:
                    return False

        return True",FewShot,"```python
class Words2Numbers:
    """"""
    The class provides a text-to-number conversion utility, allowing conversion of written numbers (in words) to their numerical representation.
    """"""

    def __init__(self):
        """"""
        Initialize the word lists and dictionaries required for conversion
        """"""
        self.numwords = {}
        self.units = [
            ""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"",
            ""nine"", ""ten"", ""eleven"", ""twelve"", ""thirteen"", ""fourteen"", ""fifteen"",
            ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen"",
        ]
        self.tens = ["""", """", ""twenty"", ""thirty"", ""forty"", ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""]
        self.scales = [""hundred"", ""thousand"", ""million"", ""billion"", ""trillion""]

        self.numwords[""and""] = (1, 0)
        for idx, word in enumerate(self.units):
            self.numwords[word] = (1, idx)
        for idx, word in enumerate(self.tens):
            self.numwords[word] = (1, idx * 10)
        for idx, word in enumerate(self.scales):
            self.numwords[word] = (10 ** (idx * 3 or 2), 0)

        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}
        self.ordinal_endings = [('ieth', 'y'), ('th', '')]

    def text2int(self, textnum):
        """"""
        Convert the word string to the corresponding integer string
        :param textnum: string, the word string to be converted
        :return: string, the final converted integer string
        >>> w2n = Words2Numbers()
        >>> w2n.text2int(""thirty-two"")
        ""32""
        """"""
        current = result = 0
        for word in textnum.replace('-', ' ').split():
            if word in self.ordinal_words:
                scale, increment = (1, self.ordinal_words[word])
            else:
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = word[:-len(ending)] + replacement
                if word not in self.numwords:
                    raise ValueError(f""Invalid word: {word}"")

                scale, increment = self.numwords[word]

            current = current * scale + increment
            if scale > 100:
                result += current
                current = 0

        return str(result + current)

    def is_valid_input(self, textnum):
        """"""
        Check if the input text contains only valid words that can be converted into numbers.
        :param textnum: The input text containing words representing numbers.
        :return: True if input is valid, False otherwise.
        >>> w2n = Words2Numbers()
        >>> w2n.is_valid_input(""thirty-two"")
        True
        """"""
        for word in textnum.replace('-', ' ').split():
            if word in self.ordinal_words:
                continue
            for ending, replacement in self.ordinal_endings:
                if word.endswith(ending):
                    word = word[:-len(ending)] + replacement
            if word not in self.numwords:
                return False
        return True
```",0.52173913,0.556614477,0.92481203,0.661290323,0.77115987,0.788461538,0.589928058,0.674897114,0.92481203,0.661290323,0.77115987,,,,,,,,,,,,
GPT,98,"import xml.etree.ElementTree as ET


class XMLProcessor:
    def __init__(self, file_name):
        self.file_name = file_name
        self.root = None

    def read_xml(self):
        try:
            tree = ET.parse(self.file_name)
            self.root = tree.getroot()
            return self.root
        except:
            return None

    def write_xml(self, file_name):
        try:
            tree = ET.ElementTree(self.root)
            tree.write(file_name)
            return True
        except:
            return False

    def process_xml_data(self, file_name):
        for element in self.root.iter('item'):
            text = element.text
            element.text = text.upper()
        return self.write_xml(file_name)

    def find_element(self, element_name):
        elements = self.root.findall(element_name)
        return elements",FewShot,"```python
import xml.etree.ElementTree as ET

class XMLProcessor:
    """"""
    This is a class as XML files handler, including reading, writing, processing as well as finding elements in a XML file.
    """"""

    def __init__(self, file_name):
        """"""
        Initialize the XMLProcessor object with the given file name.
        :param file_name:string, the name of the XML file to be processed.
        """"""
        self.file_name = file_name
        self.root = None

    def read_xml(self):
        """"""
        Reads the XML file and returns the root element.
        :return: Element, the root element of the XML file.
        >>> xml_processor = XMLProcessor('test.xml')
        >>> root_element = xml_processor.read_xml()
        >>> print(root_element)
        <Element 'root' at 0x7f8e3b7eb180>
        """"""
        try:
            # Parse the XML file and set the root element
            tree = ET.parse(self.file_name)
            self.root = tree.getroot()
            return self.root
        except Exception as e:
            # Return None if there is an error in parsing
            print(f""Error reading XML file: {e}"")
            return None

    def write_xml(self, file_name):
        """"""
        Writes the XML data to the specified file.
        :param file_name: string, the name of the file to write the XML data.
        :return: bool, True if the write operation is successful, False otherwise.
        >>> xml_processor = XMLProcessor('test.xml')
        >>> root = xml_processor.read_xml()
        >>> success = xml_processor.write_xml('output.xml')
        >>> print(success)
        True
        """"""
        try:
            # Create an ElementTree object from the root and write it to a file
            tree = ET.ElementTree(self.root)
            tree.write(file_name)
            return True
        except Exception as e:
            # Return False if there is an error in writing
            print(f""Error writing XML file: {e}"")
            return False

    def process_xml_data(self, file_name):
        """"""
        Modifies the data in XML elements and writes the updated XML data to a new file.
        :param file_name: string, the name of the file to write the modified XML data.
        :return: bool, True if the write operation is successful, False otherwise.
        >>> xml_processor = XMLProcessor('test.xml')
        >>> root = xml_processor.read_xml()
        >>> success = xml_processor.process_xml_data('processed.xml')
        >>> print(success)
        True
        """"""
        try:
            # Iterate over each 'item' element and modify its text
            for element in self.root.iter('item'):
                if element.text:
                    element.text = element.text.upper()
            # Write the modified XML to the specified file
            return self.write_xml(file_name)
        except Exception as e:
            # Return False if there is an error in processing
            print(f""Error processing XML data: {e}"")
            return False

    def find_element(self, element_name):
        """"""
        Finds the XML elements with the specified name.
        :param element_name: string, the name of the elements to find.
        :return: list, a list of found elements with the specified name.
        >>> xml_processor = XMLProcessor('test.xml')
        >>> root = xml_processor.read_xml()
        >>> items = xml_processor.find_element('item')
        >>> for item in items:
        >>>     print(item.text)
        apple
        banana
        orange
        """"""
        try:
            # Find all elements with the specified name
            elements = self.root.findall(element_name)
            return elements
        except Exception as e:
            # Return an empty list if there is an error in finding elements
            print(f""Error finding elements: {e}"")
            return []
```",0.075688073,0.087038863,0.976190476,0.266233766,0.418367344,0.788732394,0.183606557,0.297872337,0.976190476,0.266233766,0.418367344,,,,,,,,,,,,
