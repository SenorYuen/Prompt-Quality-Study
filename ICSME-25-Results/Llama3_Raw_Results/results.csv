Question Source,Question ID,Original Code,Prompt Version,Output Code,BLEU-3,CodeBLEU,Rouge 1-r,Rouge 1-p,Rouge 1-f,Rouge 2-r,Rouge 2-p,Rouge 2-f,Rouge L-r,Rouge L-p,Rouge L-f
Llama,0,"import logging
import datetime


class AccessGatewayFilter:

    def __init__(self):
        pass

    def filter(self, request):
        request_uri = request['path']
        method = request['method']

        if self.is_start_with(request_uri):
            return True

        try:
            token = self.get_jwt_user(request)
            user = token['user']
            if user['level'] > 2:
                self.set_current_user_info_and_log(user)
                return True
        except:
            return False

    def is_start_with(self, request_uri):
        start_with = [""/api"", '/login']
        for s in start_with:
            if request_uri.startswith(s):
                return True
        return False

    def get_jwt_user(self, request):
        token = request['headers']['Authorization']
        user = token['user']
        if token['jwt'].startswith(user['name']):
            jwt_str_date = token['jwt'].split(user['name'])[1]
            jwt_date = datetime.datetime.strptime(jwt_str_date, ""%Y-%m-%d"")
            if datetime.datetime.today() - jwt_date >= datetime.timedelta(days=3):
                return None
        return token

    def set_current_user_info_and_log(self, user):
        host = user['address']
        logging.log(msg=user['name'] + host + str(datetime.datetime.now()), level=1)",COT,"

```python
import logging
from datetime import datetime

class AccessGatewayFilter:
    def __init__(self):
        # Initialize the logger
        self.logger = logging.getLogger(__name__)

    def filter(self, request: dict) -> bool:
        # Check if the request path starts with '/api' or '/login'
        if self.is_start_with(request.get('path', '')):
            # If the request path starts with '/api' or '/login', check if the request method is 'POST' or 'GET'
            if request.get('method', '') in ['POST', 'GET']:
                # If the request method is 'POST' or 'GET', return True
                return True
        # If none of the above conditions are met, return False
        return False

    def is_start_with(self, request_uri: str) -> bool:
        # Define the prefixes to check
        prefixes = ['/api', '/login']
        # Check if the request URI starts with any of the prefixes
        for prefix in prefixes:
            if request_uri.startswith(prefix):
                # If the request URI starts with any of the prefixes, return True
                return True
        # If none of the prefixes match, return False
        return False

    def get_jwt_user(self, request: dict) -> dict:
        # Get the JWT token from the request headers
        jwt_token = request.get('headers', {}).get('Authorization', {}).get('jwt')
        # Get the user information from the JWT token
        user_info = request.get('headers', {}).get('Authorization', {}).get('user')
        # If the JWT token is valid, return the user information
        if jwt_token and user_info:
            return user_info
        # If the JWT token is not valid, return None
        return None

    def set_current_user_info_and_log(self, user: dict) -> None:
        # Set the current user information
        self.current_user = user
        # Log the access
        self.logger.info(f'User {user.get(""name"")} accessed from {user.get(""address"")}')
        # Log the access with timestamp
        self.logger.info(f'Access logged at {datetime.now()}')
```",0.040816326530612235,0.06029250340453597,0.390625,0.22321428571428573,0.28409090446281,0.18,0.09782608695652174,0.12676055881769507,0.375,0.21428571428571427,0.2727272680991736
Llama,10,"class BinaryDataProcessor:
    def __init__(self, binary_string):
        self.binary_string = binary_string
        self.clean_non_binary_chars()

    def clean_non_binary_chars(self):
        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))

    def calculate_binary_info(self):
        zeroes_count = self.binary_string.count('0')
        ones_count = self.binary_string.count('1')
        total_length = len(self.binary_string)

        zeroes_percentage = (zeroes_count / total_length)
        ones_percentage = (ones_count / total_length)

        return {
            'Zeroes': zeroes_percentage,
            'Ones': ones_percentage,
            'Bit length': total_length
        }

    def convert_to_ascii(self):
        byte_array = bytearray()
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            decimal = int(byte, 2)
            byte_array.append(decimal)

        return byte_array.decode('ascii')

    def convert_to_utf8(self):
        byte_array = bytearray()
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            decimal = int(byte, 2)
            byte_array.append(decimal)

        return byte_array.decode('utf-8')",COT,"

```python
class BinaryDataProcessor:
    def __init__(self, binary_string):
        """"""
        Initialize the class with a binary string and clean it by removing all non 0 or 1 characters.
        
        Args:
            binary_string (str): The binary string to be processed.
        """"""
        self.binary_string = binary_string
        self.clean_non_binary_chars()

    def clean_non_binary_chars(self):
        """"""
        Clean the binary string by removing all non 0 or 1 characters.
        """"""
        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))

    def calculate_binary_info(self):
        """"""
        Calculate the binary string information, including the percentage of 0 and 1, and the total length of the binary string.
        
        Returns:
            dict: A dictionary containing the percentage of 0 and 1, and the total length of the binary string.
        """"""
        zero_count = self.binary_string.count('0')
        one_count = self.binary_string.count('1')
        total_length = len(self.binary_string)
        
        zero_percentage = zero_count / total_length if total_length > 0 else 0
        one_percentage = one_count / total_length if total_length > 0 else 0
        
        return {'Zeroes': zero_percentage, 'Ones': one_percentage, 'Bit length': total_length}

    def convert_to_ascii(self):
        """"""
        Convert the binary string to ascii string.
        
        Returns:
            str: The ascii string converted from the binary string.
        """"""
        ascii_string = ''
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            ascii_string += chr(int(byte, 2))
        return ascii_string

    def convert_to_utf8(self):
        """"""
        Convert the binary string to utf-8 string.
        
        Returns:
            str: The utf-8 string converted from the binary string.
        """"""
        utf8_string = ''
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            utf8_string += chr(int(byte, 2))
        return utf8_string
```",0.14414414414414414,0.17312259734260932,0.6491228070175439,0.37373737373737376,0.4743589697214005,0.49382716049382713,0.25316455696202533,0.3347280289917894,0.6491228070175439,0.37373737373737376,0.4743589697214005
Llama,11,"class BitStatusUtil:
    @staticmethod
    def add(states, stat):
        BitStatusUtil.check([states, stat])
        return states | stat

    @staticmethod
    def has(states, stat):
        BitStatusUtil.check([states, stat])
        return (states & stat) == stat

    @staticmethod
    def remove(states, stat):
        BitStatusUtil.check([states, stat])
        if BitStatusUtil.has(states, stat):
            return states ^ stat
        return states

    @staticmethod
    def check(args):
        for arg in args:
            if arg < 0:
                raise ValueError(f""{arg} must be greater than or equal to 0"")
            if arg % 2 != 0:
                raise ValueError(f""{arg} not even"")",COT,"

```python
class BitStatusUtil:
    @staticmethod
    def add(states, stat):
        # Check if parameters are legal
        BitStatusUtil.check([states, stat])
        
        # Add the status to the current status using bitwise OR operation
        return states | stat

    @staticmethod
    def has(states, stat):
        # Check if parameters are legal
        BitStatusUtil.check([states, stat])
        
        # Check if the current status contains the specified status using bitwise AND operation
        return (states & stat) == stat

    @staticmethod
    def remove(states, stat):
        # Check if parameters are legal
        BitStatusUtil.check([states, stat])
        
        # Remove the specified status from the current status using bitwise AND and NOT operations
        return states & ~stat

    @staticmethod
    def check(args):
        # Check if all parameters are greater than or equal to 0 and even
        for arg in args:
            if arg < 0:
                raise ValueError(f""{arg} not greater than or equal to 0"")
            if arg % 2 != 0:
                raise ValueError(f""{arg} not even"")
```",0.29927007299270075,0.3356719883545738,0.9302325581395349,0.5970149253731343,0.7272727225107439,0.75,0.46153846153846156,0.5714285667120181,0.9302325581395349,0.5970149253731343,0.7272727225107439
Llama,12,"import random


class BlackjackGame:
    def __init__(self):
        self.deck = self.create_deck()
        self.player_hand = []
        self.dealer_hand = []

    def create_deck(self):
        deck = []
        suits = ['S', 'C', 'D', 'H']
        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
        for suit in suits:
            for rank in ranks:
                deck.append(rank + suit)
        random.shuffle(deck)
        return deck

    def calculate_hand_value(self, hand):
        value = 0
        num_aces = 0
        for card in hand:
            rank = card[:-1]
            if rank.isdigit():
                value += int(rank)
            elif rank in ['J', 'Q', 'K']:
                value += 10
            elif rank == 'A':
                value += 11
                num_aces += 1
        while value > 21 and num_aces > 0:
            value -= 10
            num_aces -= 1
        return value

    def check_winner(self, player_hand, dealer_hand):
        player_value = self.calculate_hand_value(player_hand)
        dealer_value = self.calculate_hand_value(dealer_hand)
        if player_value > 21 and dealer_value > 21:
            if player_value <= dealer_value:
                return 'Player wins'
            else:
                return 'Dealer wins'
        elif player_value > 21:
            return 'Dealer wins'
        elif dealer_value > 21:
            return 'Player wins'
        else:
            if player_value <= dealer_value:
                return 'Dealer wins'
            else:
                return 'Player wins'",COT,"

```python
class BlackjackGame:
    def __init__(self):
        # Initialize the Blackjack Game with the attribute deck, player_hand and dealer_hand
        self.deck = self.create_deck()
        self.player_hand = []
        self.dealer_hand = []

    def create_deck(self):
        # Create a deck of 52 cards, which stores 52 random order poker with the Jokers removed
        suits = ['S', 'H', 'C', 'D']
        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
        deck = [rank + suit for suit in suits for rank in ranks]
        # Shuffle the deck to ensure randomness
        import random
        random.shuffle(deck)
        return deck

    def calculate_hand_value(self, hand):
        # Calculate the value of the poker cards stored in the hand list according to the rules of the Blackjack Game
        values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 10, 'Q': 10, 'K': 10, 'A': 11}
        total_value = sum([values[card[0]] for card in hand])
        # Adjust the value of Aces if the total hand value exceeds 21
        num_aces = sum([1 for card in hand if card[0] == 'A'])
        while total_value > 21 and num_aces:
            total_value -= 10
            num_aces -= 1
        return total_value

    def check_winner(self, player_hand, dealer_hand):
        # Determine the winner of a game by comparing the hand values of the player and dealer
        player_value = self.calculate_hand_value(player_hand)
        dealer_value = self.calculate_hand_value(dealer_hand)
        # Check if either player has busted
        if player_value > 21:
            return 'Dealer wins'
        elif dealer_value > 21:
            return 'Player wins'
        # Compare the hand values to determine the winner
        elif player_value > dealer_value:
            return 'Player wins'
        elif player_value < dealer_value:
            return 'Dealer wins'
        else:
            # If the hand values are equal, the result is a push (tie)
            return 'Push'
```",0.22627737226277375,0.26032393575513935,0.7976190476190477,0.42138364779874216,0.5514403246944065,0.5357142857142857,0.2964426877470356,0.3816793847263499,0.7857142857142857,0.41509433962264153,0.5432098720195093
Llama,13,"class BookManagement:
    def __init__(self):
        self.inventory = {}

    def add_book(self, title, quantity=1):
        if title in self.inventory:
            self.inventory[title] += quantity
        else:
            self.inventory[title] = quantity

    def remove_book(self, title, quantity):
        if title not in self.inventory or self.inventory[title] < quantity:
            raise False
        self.inventory[title] -= quantity
        if self.inventory[title] == 0:
            del (self.inventory[title])

    def view_inventory(self):
        return self.inventory

    def view_book_quantity(self, title):
        if title not in self.inventory:
            return 0
        return self.inventory[title]",COT,"

```python
class BookManagement:
    # Constructor to initialize the inventory
    def __init__(self):
        # Initialize an empty dictionary to store the inventory
        self.inventory = {}

    # Method to add one or several books to the inventory
    def add_book(self, title, quantity=1):
        # Check if the title already exists in the inventory
        if title in self.inventory:
            # If it exists, increment the quantity
            self.inventory[title] += quantity
        else:
            # If it does not exist, add it to the inventory with the given quantity
            self.inventory[title] = quantity
        # Sort the inventory by title
        self.inventory = dict(sorted(self.inventory.items()))

    # Method to remove one or several books from the inventory
    def remove_book(self, title, quantity):
        # Check if the title exists in the inventory
        if title in self.inventory:
            # Check if the quantity to remove is less than or equal to the available quantity
            if quantity <= self.inventory[title]:
                # If it is, decrement the quantity
                self.inventory[title] -= quantity
                # If the quantity reaches zero, remove the book from the inventory
                if self.inventory[title] == 0:
                    del self.inventory[title]
                return True
            else:
                # If the quantity to remove is more than the available quantity, return False
                return False
        else:
            # If the title does not exist in the inventory, return False
            return False

    # Method to get the inventory of the Book Management
    def view_inventory(self):
        # Return the current inventory
        return self.inventory

    # Method to get the quantity of a book
    def view_book_quantity(self, title):
        # Check if the title exists in the inventory
        if title in self.inventory:
            # If it exists, return the quantity
            return self.inventory[title]
        else:
            # If it does not exist, return 0
            return 0
```",0.0608365019011407,0.07973795761659028,0.868421052631579,0.3626373626373626,0.511627902820744,0.603448275862069,0.2023121387283237,0.3030302992695039,0.868421052631579,0.3626373626373626,0.511627902820744
Llama,14,"import sqlite3

class BookManagementDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS books (
                id INTEGER PRIMARY KEY,
                title TEXT,
                author TEXT,
                available INTEGER
            )
        ''')
        self.connection.commit()

    def add_book(self, title, author):
        self.cursor.execute('''
            INSERT INTO books (title, author, available)
            VALUES (?, ?, 1)
        ''', (title, author))
        self.connection.commit()

    def remove_book(self, book_id):
        self.cursor.execute('''
            DELETE FROM books WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def borrow_book(self, book_id):
        self.cursor.execute('''
            UPDATE books SET available = 0 WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def return_book(self, book_id):
        self.cursor.execute('''
            UPDATE books SET available = 1 WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def search_books(self):
        self.cursor.execute('''
            SELECT * FROM books
        ''')
        books = self.cursor.fetchall()
        return books",COT,"

```python
import sqlite3

class BookManagementDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS books
            (id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT, author TEXT, available INTEGER)
        ''')
        self.connection.commit()

    def add_book(self, title, author):
        self.cursor.execute('''
            INSERT INTO books (title, author, available)
            VALUES (?, ?, 1)
        ''', (title, author))
        self.connection.commit()

    def remove_book(self, book_id):
        self.cursor.execute('''
            DELETE FROM books
            WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def borrow_book(self, book_id):
        self.cursor.execute('''
            UPDATE books
            SET available = 0
            WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def return_book(self, book_id):
        self.cursor.execute('''
            UPDATE books
            SET available = 1
            WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def search_books(self):
        self.cursor.execute('''
            SELECT * FROM books
        ''')
        return self.cursor.fetchall()
```",0.861001292903393,0.8800651034758359,0.9545454545454546,0.9130434782608695,0.9333333283358024,0.8787878787878788,0.8877551020408163,0.8832487259645959,0.9393939393939394,0.8985507246376812,0.9185185135209877
Llama,15,"class BoyerMooreSearch:
    def __init__(self, text, pattern):
        self.text, self.pattern = text, pattern
        self.textLen, self.patLen = len(text), len(pattern)

    def match_in_pattern(self, char):
        for i in range(self.patLen - 1, -1, -1):
            if char == self.pattern[i]:
                return i
        return -1

    def mismatch_in_text(self, currentPos):
        for i in range(self.patLen - 1, -1, -1):
            if self.pattern[i] != self.text[currentPos + i]:
                return currentPos + i
        return -1

    def bad_character_heuristic(self):
        positions = []
        for i in range(self.textLen - self.patLen + 1):
            mismatch_index = self.mismatch_in_text(i)
            if mismatch_index == -1:
                positions.append(i)
            else:
                match_index = self.match_in_pattern(self.text[mismatch_index])
                i = (mismatch_index - match_index)
        return positions",COT,"

```python
class BoyerMooreSearch:
    def __init__(self, text, pattern):
        self.text = text
        self.pattern = pattern
        self.textLen = len(text)
        self.patLen = len(pattern)

    def match_in_pattern(self, char):
        for i in range(self.patLen - 1, -1, -1):
            if self.pattern[i] == char:
                return i
        return -1

    def mismatch_in_text(self, currentPos):
        for i in range(self.patLen):
            if currentPos + i >= self.textLen or self.text[currentPos + i] != self.pattern[i]:
                return currentPos + i
        return -1

    def bad_character_heuristic(self):
        positions = []
        i = 0
        while i <= self.textLen - self.patLen:
            mismatch_pos = self.mismatch_in_text(i)
            if mismatch_pos == -1:
                positions.append(i)
                i += self.patLen
            else:
                char = self.text[mismatch_pos]
                match_pos = self.match_in_pattern(char)
                if match_pos == -1:
                    i += mismatch_pos + 1
                else:
                    i += mismatch_pos - match_pos
        return positions
```",0.3153153153153153,0.3834091318921372,0.8076923076923077,0.6885245901639344,0.7433628268901246,0.632183908045977,0.49107142857142855,0.5527638141743896,0.8076923076923077,0.6885245901639344,0.7433628268901246
Llama,16,"class Calculator:
    def __init__(self):
        self.operators = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '/': lambda x, y: x / y,
            '^': lambda x, y: x ** y
        }

    def calculate(self, expression):
        operand_stack = []
        operator_stack = []
        num_buffer = ''

        for char in expression:
            if char.isdigit() or char == '.':
                num_buffer += char
            else:
                if num_buffer:
                    operand_stack.append(float(num_buffer))
                    num_buffer = ''

                if char in '+-*/^':
                    while (
                            operator_stack and
                            operator_stack[-1] != '(' and
                            self.precedence(operator_stack[-1]) >= self.precedence(char)
                    ):
                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

                    operator_stack.append(char)
                elif char == '(':
                    operator_stack.append(char)
                elif char == ')':
                    while operator_stack and operator_stack[-1] != '(':
                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

                    operator_stack.pop()

        if num_buffer:
            operand_stack.append(float(num_buffer))

        while operator_stack:
            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

        return operand_stack[-1] if operand_stack else None

    def precedence(self, operator):
        precedences = {
            '+': 1,
            '-': 1,
            '*': 2,
            '/': 2,
            '^': 3
        }
        return precedences.get(operator, 0)

    def apply_operator(self, operand_stack, operator_stack):
        operator = operator_stack.pop()
        if operator == '^':
            operand2 = operand_stack.pop()
            operand1 = operand_stack.pop()
            result = self.operators[operator](operand1, operand2)
            operand_stack.append(result)
        else:
            operand2 = operand_stack.pop()
            operand1 = operand_stack.pop()
            result = self.operators[operator](operand1, operand2)
            operand_stack.append(result)
        return operand_stack, operator_stack",COT,"

```python
class Calculator:
    def __init__(self):
        self.operators = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '/': lambda x, y: x / y,
            '^': lambda x, y: x ** y
        }

    def calculate(self, expression):
        operand_stack = []
        operator_stack = []
        i = 0
        while i < len(expression):
            if expression[i].isdigit():
                num = 0
                while i < len(expression) and expression[i].isdigit():
                    num = num * 10 + int(expression[i])
                    i += 1
                operand_stack.append(num)
            elif expression[i] in self.operators:
                while (operator_stack and 
                       self.precedence(operator_stack[-1]) >= self.precedence(expression[i])):
                    operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)
                operator_stack.append(expression[i])
                i += 1
            elif expression[i] == ' ':
                i += 1
            else:
                return None
        while operator_stack:
            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)
        return operand_stack[0]

    def precedence(self, operator):
        if operator == '^':
            return 3
        elif operator in ['*', '/']:
            return 2
        elif operator in ['+', '-']:
            return 1
        else:
            return 0

    def apply_operator(self, operand_stack, operator_stack):
        if len(operand_stack) < 2 or not operator_stack:
            return None
        operand2 = operand_stack.pop()
        operand1 = operand_stack.pop()
        operator = operator_stack.pop()
        result = self.operators[operator](operand1, operand2)
        operand_stack.append(result)
        return operand_stack, operator_stack
```",0.4014050095044273,0.44297004558892317,0.7126436781609196,0.7045454545454546,0.708571423571592,0.5099337748344371,0.506578947368421,0.5082508200825628,0.7011494252873564,0.6931818181818182,0.6971428521430205
Llama,17,"from datetime import datetime, timedelta

class CalendarUtil:
    def __init__(self):
        self.events = []

    def add_event(self, event):
        self.events.append(event)

    def remove_event(self, event):
        if event in self.events:
            self.events.remove(event)

    def get_events(self, date):
        events_on_date = []
        for event in self.events:
            if event['date'].date() == date.date():
                events_on_date.append(event)
        return events_on_date

    def is_available(self, start_time, end_time):
        for event in self.events:
            if start_time < event['end_time'] and end_time > event['start_time']:
                return False
        return True

    def get_available_slots(self, date):
        available_slots = []
        start_time = datetime(date.year, date.month, date.day, 0, 0)
        end_time = datetime(date.year, date.month, date.day, 23, 59)

        while start_time < end_time:
            slot_end_time = start_time + timedelta(minutes=60)
            if self.is_available(start_time, slot_end_time):
                available_slots.append((start_time, slot_end_time))
            start_time += timedelta(minutes=60)


        return available_slots

    def get_upcoming_events(self, num_events):
        now = datetime.now()
        upcoming_events = []
        for event in self.events:
            if event['start_time'] >= now:
                upcoming_events.append(event)
            if len(upcoming_events) == num_events:
                break
        return upcoming_events",COT,"

```python
from datetime import datetime, timedelta

class CalendarUtil:
    def __init__(self):
        self.events = []

    def add_event(self, event):
        self.events.append(event)

    def get_events(self, date):
        return [event for event in self.events if event['date'].date() == date.date()]

    def remove_event(self, event):
        self.events = [e for e in self.events if e != event]

    def is_available(self, start_time, end_time):
        for event in self.events:
            if (start_time >= event['start_time'] and start_time < event['end_time']) or (end_time > event['start_time'] and end_time <= event['end_time']) or (start_time <= event['start_time'] and end_time >= event['end_time']):
                return False
        return True

    def get_available_slots(self, date):
        available_slots = []
        start_time = datetime.combine(date, datetime.min.time())
        end_time = datetime.combine(date, datetime.min.time())
        for event in sorted(self.events, key=lambda x: x['start_time']):
            if event['date'].date() == date.date():
                if start_time < event['start_time']:
                    available_slots.append((start_time, event['start_time']))
                start_time = event['end_time']
        available_slots.append((start_time, datetime.combine(date, datetime.max.time())))
        return available_slots

    def get_upcoming_events(self, num_events):
        upcoming_events = sorted(self.events, key=lambda x: x['start_time'])
        return upcoming_events[:num_events]
```",0.32558139534883723,0.3872247102509472,0.6666666666666666,0.6493506493506493,0.6578947318429711,0.475,0.4789915966386555,0.47698744269883236,0.6533333333333333,0.6363636363636364,0.644736837106129
Llama,18,"class CamelCaseMap:
    def __init__(self):
        self._data = {}

    def __getitem__(self, key):
        return self._data[self._convert_key(key)]

    def __setitem__(self, key, value):
        self._data[self._convert_key(key)] = value

    def __delitem__(self, key):
        del self._data[self._convert_key(key)]

    def __iter__(self):
        return iter(self._data)

    def __len__(self):
        return len(self._data)

    def _convert_key(self, key):
        if isinstance(key, str):
            return self._to_camel_case(key)
        return key

    @staticmethod
    def _to_camel_case(key):
        parts = key.split('_')
        return parts[0] + ''.join(part.title() for part in parts[1:])",COT,"

```python
class CamelCaseMap:
    def __init__(self):
        self._data = {}

    def __getitem__(self, key):
        return self._data[self._convert_key(key)]

    def __setitem__(self, key, value):
        self._data[self._convert_key(key)] = value

    def __delitem__(self, key):
        del self._data[self._convert_key(key)]

    def __iter__(self):
        return iter(self._data)

    def __len__(self):
        return len(self._data)

    def _convert_key(self, key):
        return CamelCaseMap._to_camel_case(key)

    @staticmethod
    def _to_camel_case(key):
        words = key.split('_')
        return words[0] + ''.join(word.capitalize() for word in words[1:])
```",0.648507736914327,0.6827567120925123,0.7906976744186046,0.7906976744186046,0.7906976694186046,0.7049180327868853,0.7413793103448276,0.72268907063343,0.7906976744186046,0.7906976744186046,0.7906976694186046
Llama,19,"class ChandrasekharSieve:
    def __init__(self, n):
        self.n = n
        self.primes = self.generate_primes()

    def generate_primes(self):
        if self.n < 2:
            return []

        sieve = [True] * (self.n + 1)
        sieve[0] = sieve[1] = False

        p = 2
        while p * p <= self.n:
            if sieve[p]:
                for i in range(p * p, self.n + 1, p):
                    sieve[i] = False
            p += 1

        primes = []
        for i in range(2, self.n + 1):
            if sieve[i]:
                primes.append(i)

        return primes

    def get_primes(self):
        return self.primes",COT,"

```python
class ChandrasekharSieve:
    def __init__(self, n):
        self.n = n
        self.primes = self.generate_primes()

    def generate_primes(self):
        sieve = [True] * (self.n + 1)
        sieve[0:2] = [False, False]  # 0 and 1 are not prime numbers
        for current_prime in range(2, int(self.n ** 0.5) + 1):
            if sieve[current_prime]:
                for multiple in range(current_prime * current_prime, self.n + 1, current_prime):
                    sieve[multiple] = False
        return [num for num, is_prime in enumerate(sieve) if is_prime]

    def get_primes(self):
        return self.primes
```",0.26636671993282407,0.31937729417167887,0.5869565217391305,0.5,0.5399999950320001,0.4,0.4,0.3999999950000001,0.5869565217391305,0.5,0.5399999950320001
Llama,1,"import math


class AreaCalculator:

    def __init__(self, radius):
        self.radius = radius

    def calculate_circle_area(self):
        return math.pi * self.radius ** 2

    def calculate_sphere_area(self):
        return 4 * math.pi * self.radius ** 2

    def calculate_cylinder_area(self, height):
        return 2 * math.pi * self.radius * (self.radius + height)

    def calculate_sector_area(self, angle):
        return self.radius ** 2 * angle / 2

    def calculate_annulus_area(self, inner_radius, outer_radius):
        return math.pi * (outer_radius ** 2 - inner_radius ** 2)",COT,"

```python
import math

class AreaCalculator:
    # Constructor method to initialize the radius
    def __init__(self, radius):
        # Initialize the radius for shapes
        self.radius = radius

    # Method to calculate the area of a circle
    def calculate_circle_area(self):
        # Calculate the area of circle based on self.radius
        # The formula for the area of a circle is πr^2
        area = math.pi * (self.radius ** 2)
        return area

    # Method to calculate the area of a sphere
    def calculate_sphere_area(self):
        # Calculate the area of sphere based on self.radius
        # The formula for the area of a sphere is 4πr^2
        area = 4 * math.pi * (self.radius ** 2)
        return area

    # Method to calculate the area of a cylinder
    def calculate_cylinder_area(self, height):
        # Calculate the area of cylinder based on self.radius and height
        # The formula for the area of a cylinder is 2πr^2 + 2πrh
        area = 2 * math.pi * (self.radius ** 2) + 2 * math.pi * self.radius * height
        return area

    # Method to calculate the area of a sector
    def calculate_sector_area(self, angle):
        # Calculate the area of sector based on self.radius and angle
        # The formula for the area of a sector is (angle/360) * πr^2
        # However, since the angle is given in radians, we use the formula (angle/2π) * πr^2 = (angle/2) * r^2
        area = (angle / 2) * (self.radius ** 2)
        return area

    # Method to calculate the area of an annulus
    def calculate_annulus_area(self, inner_radius, outer_radius):
        # Calculate the area of annulus based on inner_radius and outer_radius
        # The formula for the area of an annulus is π(outer_radius^2 - inner_radius^2)
        area = math.pi * ((outer_radius ** 2) - (inner_radius ** 2))
        return area
```",0.050541516245487354,0.071060537017871,0.9411764705882353,0.38095238095238093,0.5423728772536627,0.5471698113207547,0.18471337579617833,0.2761904724167801,0.9117647058823529,0.36904761904761907,0.52542372471129
Llama,20,"from datetime import datetime

class Chat:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username in self.users:
            return False
        else:
            self.users[username] = []
            return True

    def remove_user(self, username):
        if username in self.users:
            del self.users[username]
            return True
        else:
            return False

    def send_message(self, sender, receiver, message):
        if sender not in self.users or receiver not in self.users:
            return False

        timestamp = datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
        message_info = {
            'sender': sender,
            'receiver': receiver,
            'message': message,
            'timestamp': timestamp
        }
        self.users[sender].append(message_info)
        self.users[receiver].append(message_info)
        return True

    def get_messages(self, username):
        if username not in self.users:
            return []
        return self.users[username]",COT,"

```python
from datetime import datetime

class Chat:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username in self.users:
            return False
        self.users[username] = []
        return True

    def remove_user(self, username):
        if username in self.users:
            del self.users[username]
            return True
        return False

    def send_message(self, sender, receiver, message):
        if sender not in self.users or receiver not in self.users:
            return False
        timestamp = datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
        self.users[receiver].append({'sender': sender, 'receiver': receiver, 'message': message, 'timestamp': timestamp})
        self.users[sender].append({'sender': sender, 'receiver': receiver, 'message': message, 'timestamp': timestamp})
        return True

    def get_messages(self, username):
        if username in self.users:
            return self.users[username]
        return []
```",0.7159090909090909,0.7546289791903719,0.8775510204081632,0.9148936170212766,0.8958333283355034,0.782051282051282,0.8472222222222222,0.8133333283413333,0.8775510204081632,0.9148936170212766,0.8958333283355034
Llama,21,"from datetime import datetime


class Classroom:
    def __init__(self, id):
        self.id = id
        self.courses = []

    def add_course(self, course):

        if course not in self.courses:
            self.courses.append(course)

    def remove_course(self, course):
        if course in self.courses:
            self.courses.remove(course)

    def is_free_at(self, check_time):
        check_time = datetime.strptime(check_time, '%H:%M')

        for course in self.courses:
            if datetime.strptime(course['start_time'], '%H:%M') <= check_time <= datetime.strptime(course['end_time'],
                                                                                                   '%H:%M'):
                return False
        return True

    def check_course_conflict(self, new_course):
        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M')
        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M')

        flag = True
        for course in self.courses:
            start_time = datetime.strptime(course['start_time'], '%H:%M')
            end_time = datetime.strptime(course['end_time'], '%H:%M')
            if start_time <= new_start_time and end_time >= new_start_time:
                flag = False
            if start_time <= new_end_time and end_time >= new_end_time:
                flag = False
        return flag",COT,"

```python
class ClassRegistrationSystem:
    def __init__(self):
        self.students = []
        self.students_registration_classes = {}

    def register_student(self, student):
        if student in self.students:
            return 0
        else:
            self.students.append(student)
            self.students_registration_classes[student[""name""]] = []
            return 1

    def register_class(self, student_name, class_name):
        if student_name in self.students_registration_classes:
            self.students_registration_classes[student_name].append(class_name)
        return self.students_registration_classes[student_name]

    def get_students_by_major(self, major):
        return [student[""name""] for student in self.students if student[""major""] == major]

    def get_all_major(self):
        return list(set([student[""major""] for student in self.students]))

    def get_most_popular_class_in_major(self, major):
        students_in_major = [student for student in self.students if student[""major""] == major]
        classes = []
        for student in students_in_major:
            classes.extend(self.students_registration_classes[student[""name""]])
        if classes:
            return max(set(classes), key=classes.count)
        else:
            return None
```",0.0009619110510120617,0.20204718046864986,0.1836734693877551,0.16981132075471697,0.17647058324298362,0.021739130434782608,0.023809523809523808,0.022727267737604397,0.1836734693877551,0.16981132075471697,0.17647058324298362
Llama,22,"class ClassRegistrationSystem:

    def __init__(self):
        self.students = []
        self.students_registration_classes = {}

    def register_student(self, student):
        if student in self.students:
            return 0
        else:
            self.students.append(student)
            return 1

    def register_class(self, student_name, class_name):
        if student_name in self.students_registration_classes:
            self.students_registration_classes[student_name].append(class_name)
        else:
            self.students_registration_classes[student_name] = [class_name]
        return self.students_registration_classes[student_name]

    def get_students_by_major(self, major):
        student_list = []
        for student in self.students:
            if student[""major""] == major:
                student_list.append(student[""name""])
        return student_list

    def get_all_major(self):
        major_list = []
        for student in self.students:
            if student[""major""] not in major_list:
                major_list.append(student[""major""])
        return major_list

    def get_most_popular_class_in_major(self, major):
        class_list = []
        for student in self.students:
            if student[""major""] == major:
                class_list += self.students_registration_classes[student[""name""]]
        most_popular_class = max(set(class_list), key=class_list.count)
        return most_popular_class",COT,"

```python
from datetime import datetime

class Classroom:
    def __init__(self, id):
        self.id = id
        self.courses = []

    def add_course(self, course):
        if course not in self.courses:
            self.courses.append(course)

    def remove_course(self, course):
        if course in self.courses:
            self.courses.remove(course)

    def is_free_at(self, check_time):
        check_time = datetime.strptime(check_time, '%H:%M')
        for course in self.courses:
            start_time = datetime.strptime(course['start_time'], '%H:%M')
            end_time = datetime.strptime(course['end_time'], '%H:%M')
            if start_time <= check_time < end_time:
                return False
        return True

    def check_course_conflict(self, new_course):
        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M')
        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M')
        for course in self.courses:
            start_time = datetime.strptime(course['start_time'], '%H:%M')
            end_time = datetime.strptime(course['end_time'], '%H:%M')
            if (new_start_time < end_time and new_end_time > start_time) or (new_start_time == start_time) or (new_end_time == end_time):
                return False
        return True
```",0.0009615384615384615,0.2731958710173677,0.22,0.2,0.20952380453514752,0.03571428571428571,0.03409090909090909,0.03488371593293744,0.22,0.2,0.20952380453514752
Llama,23,"import math
from typing import List

class CombinationCalculator:
    def __init__(self, datas: List[str]):
        self.datas = datas

    @staticmethod
    def count(n: int, m: int) -> int:
        if m == 0 or n == m:
            return 1
        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))

    @staticmethod
    def count_all(n: int) -> int:
        if n < 0 or n > 63:
            return False
        return (1 << n) - 1 if n != 63 else float(""inf"")

    def select(self, m: int) -> List[List[str]]:
        result = []
        self._select(0, [None] * m, 0, result)
        return result

    def select_all(self) -> List[List[str]]:
        result = []
        for i in range(1, len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):
        resultLen = len(resultList)
        resultCount = resultIndex + 1
        if resultCount > resultLen:
            result.append(resultList.copy())
            return

        for i in range(dataIndex, len(self.datas) + resultCount - resultLen):
            resultList[resultIndex] = self.datas[i]
            self._select(i + 1, resultList, resultIndex + 1, result)",COT,"

```python
import math
from typing import List

class CombinationCalculator:
    def __init__(self, datas: List[str]):
        self.datas = datas

    @staticmethod
    def count(n: int, m: int) -> int:
        return math.comb(n, m)

    @staticmethod
    def count_all(n: int) -> int:
        total_combinations = sum(math.comb(n, i) for i in range(n + 1))
        return total_combinations if total_combinations <= 2**63 - 1 else float(""inf"")

    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):
        if resultIndex == len(resultList):
            result.append(resultList[:])
            return
        for i in range(dataIndex, len(self.datas)):
            resultList[resultIndex] = self.datas[i]
            self._select(i + 1, resultList, resultIndex + 1, result)

    def select(self, m: int) -> List[List[str]]:
        result = []
        self._select(0, [None] * m, 0, result)
        return result

    def select_all(self) -> List[List[str]]:
        result = []
        for i in range(1, len(self.datas) + 1):
            result.extend(self.select(i))
        return result
```",0.5278327547731475,0.5625972643384419,0.7222222222222222,0.8333333333333334,0.7738095188350341,0.5985401459854015,0.7130434782608696,0.6507936458317587,0.7222222222222222,0.8333333333333334,0.7738095188350341
Llama,24,"class ComplexCalculator:
    def __init__(self):
        pass

    @staticmethod
    def add(c1, c2):
        real = c1.real + c2.real
        imaginary = c1.imag + c2.imag
        answer = complex(real, imaginary)
        return answer
    
    @staticmethod
    def subtract(c1, c2):
        real = c1.real - c2.real
        imaginary = c1.imag - c2.imag
        return complex(real, imaginary)
    
    @staticmethod
    def multiply(c1, c2):
        real = c1.real * c2.real - c1.imag * c2.imag
        imaginary = c1.real * c2.imag + c1.imag * c2.real
        return complex(real, imaginary)
    
    @staticmethod
    def divide(c1, c2):
        denominator = c2.real**2 + c2.imag**2
        real = (c1.real * c2.real + c1.imag * c2.imag) / denominator
        imaginary = (c1.imag * c2.real - c1.real * c2.imag) / denominator
        return complex(real, imaginary)",COT,"

```python
class ComplexCalculator:
    def __init__(self):
        pass

    @staticmethod
    def add(c1, c2):
        return c1 + c2

    @staticmethod
    def subtract(c1, c2):
        return c1 - c2

    @staticmethod
    def multiply(c1, c2):
        return c1 * c2

    @staticmethod
    def divide(c1, c2):
        if c2 == 0:
            raise ZeroDivisionError(""Cannot divide by zero"")
        return c1 / c2
```",0.09368111048915667,0.11050892255546778,0.6,0.6428571428571429,0.6206896501783592,0.2786885245901639,0.4594594594594595,0.3469387708100792,0.6,0.6428571428571429,0.6206896501783592
Llama,25,"import json

class CookiesUtil:
    def __init__(self, cookies_file):
        self.cookies_file = cookies_file
        self.cookies = None

    def get_cookies(self, reponse):
        self.cookies = reponse['cookies']
        self._save_cookies()

    def load_cookies(self):
        try:
            with open(self.cookies_file, 'r') as file:
                cookies_data = json.load(file)
                return cookies_data
        except FileNotFoundError:
            return {}

    def _save_cookies(self):
        try:
            with open(self.cookies_file, 'w') as file:
                json.dump(self.cookies, file)
            return True
        except:
            return False

    def set_cookies(self, request):
        request['cookies'] = '; '.join([f'{key}={value}' for key, value in self.cookies.items()])",COT,"

```python
import json

class CookiesUtil:
    def __init__(self, cookies_file):
        self.cookies_file = cookies_file
        self.cookies = None

    def get_cookies(self, response):
        if 'cookies' in response:
            self.cookies = response['cookies']
            self._save_cookies()

    def load_cookies(self):
        try:
            with open(self.cookies_file, 'r') as file:
                self.cookies = json.load(file)
                return self.cookies
        except FileNotFoundError:
            return {}

    def _save_cookies(self):
        if self.cookies is not None:
            try:
                with open(self.cookies_file, 'w') as file:
                    json.dump(self.cookies, file)
                    return True
            except Exception as e:
                print(f""Error saving cookies: {e}"")
                return False
        else:
            return False
```",0.4647887323943662,0.5104936727641279,0.7142857142857143,0.6730769230769231,0.6930693019351046,0.6323529411764706,0.589041095890411,0.6099290730204718,0.7142857142857143,0.6730769230769231,0.6930693019351046
Llama,26,"import csv


class CSVProcessor:

    def __init__(self):
        pass

    def read_csv(self, file_name):
        data = []
        with open(file_name, 'r') as file:
            reader = csv.reader(file)
            title = next(reader)
            for row in reader:
                data.append(row)
        return title, data

    def write_csv(self, data, file_name):
        try:
            with open(file_name, 'w', newline='') as file:
                writer = csv.writer(file)
                writer.writerows(data)
            return 1
        except:
            return 0

    def process_csv_data(self, N, save_file_name):
        title, data = self.read_csv(save_file_name)
        column_data = [row[N] for row in data]
        column_data = [row.upper() for row in column_data]
        new_data = [title, column_data]
        return self.write_csv(new_data, save_file_name.split('.')[0] + '_process.csv')",COT,"

```python
import csv

class CSVProcessor:
    def __init__(self):
        pass

    def read_csv(self, file_name):
        try:
            with open(file_name, 'r') as file:
                csv_reader = csv.reader(file)
                data = list(csv_reader)
                if len(data) > 0:
                    title = data[0]
                    data = data[1:]
                    return title, data
                else:
                    return [], []
        except FileNotFoundError:
            return [], []

    def write_csv(self, data, file_name):
        try:
            with open(file_name, 'w', newline='') as file:
                csv_writer = csv.writer(file)
                csv_writer.writerows(data)
            return 1
        except Exception as e:
            print(f""Error writing to file: {e}"")
            return 0

    def process_csv_data(self, N, save_file_name):
        title, data = self.read_csv(save_file_name)
        if len(title) > 0 and len(data) > 0:
            new_data = [[row[N].upper()] for row in data]
            new_data.insert(0, [title[N]])
            new_file_name = save_file_name.split('.')[0] + '_process.csv'
            result = self.write_csv(new_data, new_file_name)
            return result
        else:
            return 0
```",0.2792792792792793,0.3420058105338254,0.7796610169491526,0.5974025974025974,0.6764705833228807,0.573170731707317,0.4392523364485981,0.497354492441981,0.7796610169491526,0.5974025974025974,0.6764705833228807
Llama,27,"class CurrencyConverter:
    def __init__(self):
        self.rates = {
            'USD': 1.0,
            'EUR': 0.85,
            'GBP': 0.72,
            'JPY': 110.15,
            'CAD': 1.23,
            'AUD': 1.34,
            'CNY': 6.40,
        }

    def convert(self, amount, from_currency, to_currency):
        if from_currency == to_currency:
            return amount

        if from_currency not in self.rates or to_currency not in self.rates:
            return False

        from_rate = self.rates[from_currency]
        to_rate = self.rates[to_currency]

        converted_amount = (amount / from_rate) * to_rate
        return converted_amount

    def get_supported_currencies(self):
        return list(self.rates.keys())

    def add_currency_rate(self, currency, rate):
        if currency in self.rates:
            return False
        self.rates[currency] = rate

    def update_currency_rate(self, currency, new_rate):
        if currency not in self.rates:
            return False
        self.rates[currency] = new_rate",COT,"

```python
class CurrencyConverter:
    def __init__(self):
        self.rates = {
            'USD': 1.0,
            'EUR': 0.85,
            'GBP': 0.72,
            'JPY': 110.15,
            'CAD': 1.23,
            'AUD': 1.34,
            'CNY': 6.40,
        }

    def convert(self, amount, from_currency, to_currency):
        if from_currency not in self.rates or to_currency not in self.rates:
            raise ValueError(""Unsupported currency"")
        return amount / self.rates[from_currency] * self.rates[to_currency]

    def get_supported_currencies(self):
        return list(self.rates.keys())

    def add_currency_rate(self, currency, rate):
        if currency in self.rates:
            return False
        self.rates[currency] = rate

    def update_currency_rate(self, currency, new_rate):
        if currency not in self.rates:
            return False
        self.rates[currency] = new_rate
```",0.7140365891330048,0.7353240964042186,0.890625,0.9193548387096774,0.9047618997631645,0.7888888888888889,0.8658536585365854,0.8255813903596539,0.875,0.9032258064516129,0.8888888838901486
Llama,28,"import sqlite3
import pandas as pd


class DatabaseProcessor:

    def __init__(self, database_name):
        self.database_name = database_name

    def create_table(self, table_name, key1, key2):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        create_table_query = f""CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)""
        cursor.execute(create_table_query)

        conn.commit()
        conn.close()

    def insert_into_database(self, table_name, data):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        for item in data:
            insert_query = f""INSERT INTO {table_name} (name, age) VALUES (?, ?)""
            cursor.execute(insert_query, (item['name'], item['age']))

        conn.commit()
        conn.close()

    def search_database(self, table_name, name):

        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        select_query = f""SELECT * FROM {table_name} WHERE name = ?""
        cursor.execute(select_query, (name,))
        result = cursor.fetchall()

        if result:
            return result
        else:
            return None

    def delete_from_database(self, table_name, name):

        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        delete_query = f""DELETE FROM {table_name} WHERE name = ?""
        cursor.execute(delete_query, (name,))

        conn.commit()
        conn.close()",COT,"

```python
import sqlite3
import pandas as pd

class DatabaseProcessor:
    def __init__(self, database_name):
        self.database_name = database_name
        self.conn = sqlite3.connect(database_name)
        self.cursor = self.conn.cursor()

    def create_table(self, table_name, key1, key2):
        self.cursor.execute(f""""""
            CREATE TABLE IF NOT EXISTS {table_name} (
                id INTEGER PRIMARY KEY,
                {key1} TEXT,
                {key2} INTEGER
            )
        """""")
        self.conn.commit()

    def insert_into_database(self, table_name, data):
        for row in data:
            self.cursor.execute(f""""""
                INSERT INTO {table_name} ({list(row.keys())[0]}, {list(row.keys())[1]})
                VALUES (?, ?)
            """""", (row[list(row.keys())[0]], row[list(row.keys())[1]]))
        self.conn.commit()

    def search_database(self, table_name, name):
        self.cursor.execute(f""""""
            SELECT * FROM {table_name}
            WHERE {list({'name': 'name', 'age': 'age'}.keys())[0]} = ?
        """""", (name,))
        return self.cursor.fetchall()

    def delete_from_database(self, table_name, name):
        self.cursor.execute(f""""""
            DELETE FROM {table_name}
            WHERE {list({'name': 'name', 'age': 'age'}.keys())[0]} = ?
        """""", (name,))
        self.conn.commit()
```",0.24176492655463086,0.2861555437401907,0.620253164556962,0.6282051282051282,0.6242038166562538,0.41964285714285715,0.4519230769230769,0.4351851801920439,0.6075949367088608,0.6153846153846154,0.6114649631530692
Llama,29,"from collections import Counter


class DataStatistics:
    def mean(self, data):
        return round(sum(data) / len(data), 2)

    def median(self, data):
        sorted_data = sorted(data)
        n = len(sorted_data)
        if n % 2 == 0:
            middle = n // 2
            return round((sorted_data[middle - 1] + sorted_data[middle]) / 2, 2)
        else:
            middle = n // 2
            return sorted_data[middle]

    def mode(self, data):
        counter = Counter(data)
        mode_count = max(counter.values())
        mode = [x for x, count in counter.items() if count == mode_count]
        return mode",COT,"

```python
from collections import Counter
import statistics

class DataStatistics:
    def mean(self, data):
        return round(sum(data) / len(data), 2)

    def median(self, data):
        sorted_data = sorted(data)
        return round(statistics.median(sorted_data), 2)

    def mode(self, data):
        counter = Counter(data)
        max_count = max(counter.values())
        modes = [num for num, count in counter.items() if count == max_count]
        return modes
```",0.3093916959030704,0.3464083200248995,0.5918367346938775,0.7435897435897436,0.6590909041554753,0.44285714285714284,0.6078431372549019,0.5123966893381601,0.5918367346938775,0.7435897435897436,0.6590909041554753
Llama,2,"class ArgumentParser:
    def __init__(self):
        self.arguments = {}
        self.required = set()
        self.types = {}

    def parse_arguments(self, command_string):
        args = command_string.split()[1:]
        for i in range(len(args)):
            arg = args[i]
            if arg.startswith('--'):
                key_value = arg[2:].split('=')
                if len(key_value) == 2:
                    self.arguments[key_value[0]] = self._convert_type(key_value[0], key_value[1])
                else:
                    self.arguments[key_value[0]] = True
            elif arg.startswith('-'):
                key = arg[1:]
                if i + 1 < len(args) and not args[i + 1].startswith('-'):
                    self.arguments[key] = self._convert_type(key, args[i + 1])
                else:
                    self.arguments[key] = True
        missing_args = self.required - set(self.arguments.keys())
        if missing_args:
            return False, missing_args

        return True, None

    def get_argument(self, key):
        return self.arguments.get(key)

    def add_argument(self, arg, required=False, arg_type=str):
        if required:
            self.required.add(arg)
        self.types[arg] = arg_type

    def _convert_type(self, arg, value):
        try:
            return self.types[arg](value)
        except (ValueError, KeyError):
            return value",COT,"

```python
class ArgumentParser:
    def __init__(self):
        # Initialize the fields
        self.arguments = {}
        self.required = set()
        self.types = {}

    def parse_arguments(self, command_string):
        # Split the command string into parts
        parts = command_string.split()
        
        # Initialize an index to track the current part
        i = 1
        
        # Iterate over the parts
        while i < len(parts):
            # Check if the part is an argument
            if parts[i].startswith('-'):
                # Extract the argument name
                arg_name = parts[i].lstrip('-')
                
                # Check if the argument has a value
                if '=' in arg_name:
                    # Split the argument name and value
                    arg_name, value = arg_name.split('=')
                elif i + 1 < len(parts) and not parts[i + 1].startswith('-'):
                    # The value is the next part
                    value = parts[i + 1]
                    i += 1
                else:
                    # The argument is a flag
                    value = True
                # Convert the value to the specified type
                value = self._convert_type(arg_name, value)
                
                # Add the argument to the arguments dictionary
                self.arguments[arg_name] = value
            i += 1
        
        # Check for missing required arguments
        missing_args = self.required - set(self.arguments.keys())
        
        # Return the result
        if missing_args:
            return False, missing_args
        else:
            return True, None

    def get_argument(self, key):
        # Return the value of the argument
        return self.arguments.get(key)

    def add_argument(self, arg, required=False, arg_type=str):
        # Add the argument to the types dictionary
        self.types[arg] = arg_type
        
        # Add the argument to the required set if it is required
        if required:
            self.required.add(arg)

    def _convert_type(self, arg, value):
        # Get the type of the argument
        arg_type = self.types.get(arg)
        
        # Try to convert the value to the specified type
        if arg_type == int:
            try:
                return int(value)
            except ValueError:
                pass
        elif arg_type == bool:
            if value.lower() == 'true':
                return True
            elif value.lower() == 'false':
                return False
        # If the conversion fails, return the original value
        return value
```",0.1170212765957447,0.14837609469385887,0.7051282051282052,0.4330708661417323,0.5365853611393219,0.4915254237288136,0.23107569721115537,0.3143631392809983,0.6794871794871795,0.41732283464566927,0.5170731660173707
Llama,30,"import numpy as np


class DataStatistics2:
    def __init__(self, data):
        self.data = np.array(data)

    def get_sum(self):
        return np.sum(self.data)

    def get_min(self):
        return np.min(self.data)

    def get_max(self):
        return np.max(self.data)

    def get_variance(self):
        return round(np.var(self.data), 2)

    def get_std_deviation(self):
        return round(np.std(self.data), 2)

    def get_correlation(self):
        return np.corrcoef(self.data, rowvar=False)",COT,"

```python
import numpy as np

class DataStatistics2:
    def __init__(self, data):
        self.data = np.array(data)

    def get_sum(self):
        return float(np.sum(self.data))

    def get_min(self):
        return float(np.min(self.data))

    def get_max(self):
        return float(np.max(self.data))

    def get_variance(self):
        return round(np.var(self.data), 2)

    def get_std_deviation(self):
        return round(np.std(self.data), 2)

    def get_correlation(self):
        return round(np.corrcoef(self.data, self.data)[0, 1], 2)
```",0.6341463414634146,0.6662061716642775,0.9375,0.8333333333333334,0.8823529361937716,0.7727272727272727,0.6938775510204082,0.7311827907133773,0.9375,0.8333333333333334,0.8823529361937716
Llama,31,"import math

class DataStatistics4:

    @staticmethod
    def correlation_coefficient(data1, data2):
        n = len(data1)
        mean1 = sum(data1) / n
        mean2 = sum(data2) / n

        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))
        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n))) * math.sqrt(sum((data2[i] - mean2) ** 2 for i in range(n)))

        return numerator / denominator if denominator != 0 else 0
    
    @staticmethod
    def skewness(data):
        n = len(data)
        mean = sum(data) / n
        variance = sum((x - mean) ** 2 for x in data) / n
        std_deviation = math.sqrt(variance)

        skewness = sum((x - mean) ** 3 for x in data) * n / ((n - 1) * (n - 2) * std_deviation ** 3) if std_deviation != 0 else 0

        return skewness
    
    @staticmethod
    def kurtosis(data):

        n = len(data)
        mean = sum(data) / n
        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / n)

        if std_dev == 0:
            return math.nan

        centered_data = [(x - mean) for x in data]
        fourth_moment = sum(x ** 4 for x in centered_data) / n

        kurtosis_value = (fourth_moment / std_dev ** 4) - 3

        return kurtosis_value
    
    @staticmethod
    def pdf(data, mu, sigma):
        pdf_values = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]
        return pdf_values",COT,"

```python
import math

class DataStatistics4:
    @staticmethod
    def correlation_coefficient(data1, data2):
        n = len(data1)
        mean1 = sum(data1) / n
        mean2 = sum(data2) / n
        numerator = sum((x - mean1) * (y - mean2) for x, y in zip(data1, data2))
        denominator = math.sqrt(sum((x - mean1) ** 2 for x in data1)) * math.sqrt(sum((y - mean2) ** 2 for y in data2))
        return numerator / denominator

    @staticmethod
    def skewness(data):
        n = len(data)
        mean = sum(data) / n
        variance = sum((x - mean) ** 2 for x in data) / n
        std_dev = math.sqrt(variance)
        numerator = sum((x - mean) ** 3 for x in data)
        return numerator / (n * std_dev ** 3)

    @staticmethod
    def kurtosis(data):
        n = len(data)
        mean = sum(data) / n
        variance = sum((x - mean) ** 2 for x in data) / n
        std_dev = math.sqrt(variance)
        numerator = sum((x - mean) ** 4 for x in data)
        return numerator / (n * std_dev ** 4) - 3

    @staticmethod
    def pdf(data, mu, sigma):
        return [math.exp(-((x - mu) ** 2) / (2 * sigma ** 2)) / (sigma * math.sqrt(2 * math.pi)) for x in data]
```",0.44327207215695713,0.5010530683637031,0.627906976744186,0.7941176470588235,0.7012986963670096,0.47305389221556887,0.6752136752136753,0.5563380233239933,0.627906976744186,0.7941176470588235,0.7012986963670096
Llama,32,"class DecryptionUtils:
    def __init__(self, key):
        self.key = key
    
    def caesar_decipher(self, ciphertext, shift):
        plaintext = """"
        for char in ciphertext:
            if char.isalpha():
                if char.isupper():
                    ascii_offset = 65
                else:
                    ascii_offset = 97
                shifted_char = chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)
                plaintext += shifted_char
            else:
                plaintext += char
        return plaintext
    
    def vigenere_decipher(self, ciphertext):
        decrypted_text = """"
        key_index = 0
        for char in ciphertext:
            if char.isalpha():
                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')
                decrypted_char = chr((ord(char.lower()) - ord('a') - shift) % 26 + ord('a'))
                decrypted_text += decrypted_char.upper() if char.isupper() else decrypted_char
                key_index += 1
            else:
                decrypted_text += char
        return decrypted_text
    
    def rail_fence_decipher(self, encrypted_text, rails):
        fence = [['\n' for _ in range(len(encrypted_text))] for _ in range(rails)]
        direction = -1
        row, col = 0, 0

        for _ in range(len(encrypted_text)):
            if row == 0 or row == rails - 1:
                direction = -direction

            fence[row][col] = ''
            col += 1
            row += direction

        index = 0
        for i in range(rails):
            for j in range(len(encrypted_text)):
                if fence[i][j] == '':
                    fence[i][j] = encrypted_text[index]
                    index += 1

        plain_text = ''
        direction = -1
        row, col = 0, 0
        for _ in range(len(encrypted_text)):
            if row == 0 or row == rails - 1:
                direction = -direction

            plain_text += fence[row][col]
            col += 1
            row += direction

        return plain_text",COT,"

```python
class DecryptionUtils:
    def __init__(self, key):
        self.key = key

    def caesar_decipher(self, ciphertext, shift):
        alphabet = 'abcdefghijklmnopqrstuvwxyz'
        shifted_alphabet = alphabet[shift:] + alphabet[:shift]
        table = str.maketrans(shifted_alphabet, alphabet)
        return ciphertext.translate(table)

    def vigenere_decipher(self, ciphertext):
        alphabet = 'abcdefghijklmnopqrstuvwxyz'
        key = self.key.lower()
        plaintext = ''
        key_index = 0
        for char in ciphertext:
            if char.isalpha():
                shift = alphabet.index(key[key_index % len(key)])
                if char.isupper():
                    plaintext += alphabet[(alphabet.index(char.lower()) - shift) % 26].upper()
                else:
                    plaintext += alphabet[(alphabet.index(char) - shift) % 26]
                key_index += 1
            else:
                plaintext += char
        return plaintext

    def rail_fence_decipher(self, encrypted_text, rails):
        # Calculate the length of the ciphertext
        length = len(encrypted_text)
        
        # Create a list to store the decrypted text
        decrypted_text = [''] * length
        
        # Calculate the index steps for each rail
        index_steps = []
        for i in range(rails):
            step = (rails - 1 - i) * 2
            if step == 0:
                step = rails * 2 - 2
            index_steps.append(step)
        
        # Initialize the index and the rail index
        index = 0
        rail_index = 0
        
        # Iterate over the rails
        for i in range(rails):
            # Iterate over the indices
            while index < length:
                decrypted_text[index] = encrypted_text[rail_index]
                index += index_steps[i]
                rail_index += 1
        
        # Join the decrypted text into a string
        return ''.join(decrypted_text)
```",0.16480433933199484,0.21501579384313585,0.5301204819277109,0.41509433962264153,0.46560846068251177,0.3181818181818182,0.2722222222222222,0.29341316868299333,0.5301204819277109,0.41509433962264153,0.46560846068251177
Llama,33,"class DiscountStrategy:
    def __init__(self, customer, cart, promotion=None):
        self.customer = customer
        self.cart = cart
        self.promotion = promotion
        self.__total = self.total()

    def total(self):
        self.__total = sum(item['quantity'] * item['price'] for item in self.cart)
        return self.__total

    def due(self):
        if self.promotion is None:
            discount = 0
        else:
            discount = self.promotion(self)
        return self.__total - discount

    @staticmethod
    def FidelityPromo(order):
        return order.total() * 0.05 if order.customer['fidelity'] >= 1000 else 0

    @staticmethod
    def BulkItemPromo(order):
        discount = 0
        for item in order.cart:
            if item['quantity'] >= 20:
                discount += item['quantity'] * item['price'] * 0.1
        return discount

    @staticmethod
    def LargeOrderPromo(order):
        return order.total() * 0.07 if len({item['product'] for item in order.cart}) >= 10 else 0",COT,"

```python
class DiscountStrategy:
    def __init__(self, customer, cart, promotion=None):
        self.customer = customer
        self.cart = cart
        self.promotion = promotion
        self.total_cost = self.total()

    def total(self):
        total_cost = sum(item['quantity'] * item['price'] for item in self.cart)
        return total_cost

    def due(self):
        if self.promotion:
            discount = self.promotion(self)
            return self.total_cost - discount
        else:
            return self.total_cost

    @staticmethod
    def FidelityPromo(order):
        if order.customer['fidelity'] > 1000:
            return order.total_cost * 0.05
        else:
            return 0.0

    @staticmethod
    def BulkItemPromo(order):
        discount = 0
        for item in order.cart:
            if item['quantity'] >= 20:
                discount += item['quantity'] * item['price'] * 0.1
        return discount

    @staticmethod
    def LargeOrderPromo(order):
        unique_products = len(set(item['product'] for item in order.cart))
        if unique_products >= 10:
            return order.total_cost * 0.07
        else:
            return 0.0
```",0.5,0.5633405708633454,0.8431372549019608,0.8113207547169812,0.8269230719249261,0.7263157894736842,0.6764705882352942,0.700507609219511,0.8431372549019608,0.8113207547169812,0.8269230719249261
Llama,34,"from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT


class DocFileHandler:
    def __init__(self, file_path):
        self.file_path = file_path

    def read_text(self):
        doc = Document(self.file_path)
        text = []
        for paragraph in doc.paragraphs:
            text.append(paragraph.text)
        return ""\n"".join(text)

    def write_text(self, content, font_size=12, alignment='left'):
        try:
            doc = Document()
            paragraph = doc.add_paragraph()
            run = paragraph.add_run(content)
            font = run.font
            font.size = Pt(font_size)
            alignment_value = self._get_alignment_value(alignment)
            paragraph.alignment = alignment_value
            doc.save(self.file_path)
            return True
        except:
            return False

    def add_heading(self, heading, level=1):
        try:
            doc = Document(self.file_path)
            doc.add_heading(heading, level)
            doc.save(self.file_path)
            return True
        except:
            return False

    def add_table(self, data):
        try:
            doc = Document(self.file_path)
            table = doc.add_table(rows=len(data), cols=len(data[0]))
            for i, row in enumerate(data):
                for j, cell_value in enumerate(row):
                    table.cell(i, j).text = str(cell_value)
            doc.save(self.file_path)
            return True
        except:
            return False

    def _get_alignment_value(self, alignment):
        alignment_options = {
            'left': WD_PARAGRAPH_ALIGNMENT.LEFT,
            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,
            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT
        }
        return alignment_options.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)",COT,"

```python
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT

class DocFileHandler:
    def __init__(self, file_path):
        """"""
        Initializes the DocFileHandler object with the specified file path.

        Args:
            file_path (str): The path to the Word document file.
        """"""
        self.file_path = file_path

    def read_text(self):
        """"""
        Reads the content of a Word document and returns it as a string.

        Returns:
            str: The content of the Word document.
        """"""
        doc = Document(self.file_path)
        text = []
        for para in doc.paragraphs:
            text.append(para.text)
        return '\n'.join(text)

    def write_text(self, content, font_size=12, alignment='left'):
        """"""
        Writes the specified content to a Word document.

        Args:
            content (str): The text content to write.
            font_size (int, optional): The font size of the text. Defaults to 12.
            alignment (str, optional): The alignment of the text ('left', 'center', or 'right'). Defaults to 'left'.

        Returns:
            bool: True if the write operation is successful, False otherwise.
        """"""
        try:
            doc = Document()
            para = doc.add_paragraph()
            run = para.add_run(content)
            font = run.font
            font.size = Pt(font_size)
            para.alignment = self._get_alignment_value(alignment)
            doc.save(self.file_path)
            return True
        except Exception as e:
            print(f""Error: {e}"")
            return False

    def add_heading(self, heading, level=1):
        """"""
        Adds a heading to the Word document with the specified text.

        Args:
            heading (str): The text of the heading.
            level (int, optional): The level of the heading. Defaults to 1.

        Returns:
            bool: True if the heading is successfully added, False otherwise.
        """"""
        try:
            doc = Document()
            doc.add_heading(heading, level=level)
            doc.save(self.file_path)
            return True
        except Exception as e:
            print(f""Error: {e}"")
            return False

    def add_table(self, data):
        """"""
        Adds a table to the Word document with the specified data.

        Args:
            data (list of lists): The data to populate the table.

        Returns:
            bool: True if the table is successfully added, False otherwise.
        """"""
        try:
            doc = Document()
            table = doc.add_table(rows=len(data), cols=len(data[0]))
            for i, row in enumerate(data):
                for j, cell in enumerate(row):
                    table.cell(i, j).text = str(cell)
            doc.save(self.file_path)
            return True
        except Exception as e:
            print(f""Error: {e}"")
            return False

    def _get_alignment_value(self, alignment):
        """"""
        Returns the alignment value corresponding to the given alignment string.

        Args:
            alignment (str): The alignment string ('left', 'center', or 'right').

        Returns:
            int: The alignment value.
        """"""
        if alignment == 'left':
            return WD_PARAGRAPH_ALIGNMENT.LEFT
        elif alignment == 'center':
            return WD_PARAGRAPH_ALIGNMENT.CENTER
        elif alignment == 'right':
            return WD_PARAGRAPH_ALIGNMENT.RIGHT
        else:
            raise ValueError(""Invalid alignment value"")
```",0.17039106145251395,0.19266709220375242,0.8072289156626506,0.4527027027027027,0.5800865754824686,0.6343283582089553,0.302491103202847,0.40963854984421544,0.8072289156626506,0.4527027027027027,0.5800865754824686
Llama,35,"class EightPuzzle:
    def __init__(self, initial_state):
        self.initial_state = initial_state
        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

    def find_blank(self, state):
        for i in range(3):
            for j in range(3):
                if state[i][j] == 0:
                    return i, j

    def move(self, state, direction):
        i, j = self.find_blank(state)
        new_state = [row[:] for row in state]

        if direction == 'up':
            new_state[i][j], new_state[i - 1][j] = new_state[i - 1][j], new_state[i][j]
        elif direction == 'down':
            new_state[i][j], new_state[i + 1][j] = new_state[i + 1][j], new_state[i][j]
        elif direction == 'left':
            new_state[i][j], new_state[i][j - 1] = new_state[i][j - 1], new_state[i][j]
        elif direction == 'right':
            new_state[i][j], new_state[i][j + 1] = new_state[i][j + 1], new_state[i][j]

        return new_state

    def get_possible_moves(self, state):
        moves = []
        i, j = self.find_blank(state)

        if i > 0:
            moves.append('up')
        if i < 2:
            moves.append('down')
        if j > 0:
            moves.append('left')
        if j < 2:
            moves.append('right')

        return moves

    def solve(self):
        open_list = [(self.initial_state, [])]
        closed_list = []

        while open_list:
            current_state, path = open_list.pop(0)
            closed_list.append(current_state)

            if current_state == self.goal_state:
                return path

            for move in self.get_possible_moves(current_state):
                new_state = self.move(current_state, move)
                if new_state not in closed_list:
                    open_list.append((new_state, path + [move]))

        return None",COT,"

```python
class EightPuzzle:
    def __init__(self, initial_state):
        self.initial_state = initial_state
        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

    def find_blank(self, state):
        for i in range(3):
            for j in range(3):
                if state[i][j] == 0:
                    return i, j

    def move(self, state, direction):
        new_state = [row[:] for row in state]
        i, j = self.find_blank(state)
        if direction == 'up' and i > 0:
            new_state[i][j], new_state[i-1][j] = new_state[i-1][j], new_state[i][j]
        elif direction == 'down' and i < 2:
            new_state[i][j], new_state[i+1][j] = new_state[i+1][j], new_state[i][j]
        elif direction == 'left' and j > 0:
            new_state[i][j], new_state[i][j-1] = new_state[i][j-1], new_state[i][j]
        elif direction == 'right' and j < 2:
            new_state[i][j], new_state[i][j+1] = new_state[i][j+1], new_state[i][j]
        return new_state

    def get_possible_moves(self, state):
        i, j = self.find_blank(state)
        moves = []
        if i > 0:
            moves.append('up')
        if i < 2:
            moves.append('down')
        if j > 0:
            moves.append('left')
        if j < 2:
            moves.append('right')
        return moves

    def solve(self):
        open_list = [(self.initial_state, [])]
        visited = set()
        while open_list:
            state, path = open_list.pop(0)
            state_tuple = tuple(map(tuple, state))
            if state_tuple in visited:
                continue
            visited.add(state_tuple)
            if state == self.goal_state:
                return path
            for direction in self.get_possible_moves(state):
                new_state = self.move(state, direction)
                new_path = path + [direction]
                open_list.append((new_state, new_path))
        return None
```",0.489247311827957,0.5437993412066662,0.75,0.6875,0.717391299357278,0.6352201257861635,0.5976331360946746,0.615853653541233,0.7159090909090909,0.65625,0.6847826037051041
Llama,36,"from datetime import datetime

class EmailClient:
    def __init__(self, addr, capacity) -> None:
        self.addr = addr
        self.capacity = capacity
        self.inbox = []
    
    def send_to(self, recv, content, size):
        if not recv.is_full_with_one_more_email(size):
            timestamp = datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
            email = {
                ""sender"": self.addr,
                ""receiver"": recv.addr,
                ""content"": content,
                ""size"": size,
                ""time"": timestamp,
                ""state"": ""unread""
            }
            recv.inbox.append(email)
            return True
        else:
            self.clear_inbox(size)
            return False
    
    def fetch(self):
        if len(self.inbox) == 0:
            return None
        for i in range(len(self.inbox)):
            if self.inbox[i]['state'] == ""unread"":
                self.inbox[i]['state'] = ""read""
                return self.inbox[i]
        return None

    def is_full_with_one_more_email(self, size):
        occupied_size = self.get_occupied_size()
        return True if occupied_size + size > self.capacity else False
        
    def get_occupied_size(self):
        occupied_size = 0
        for email in self.inbox:
            occupied_size += email[""size""]
        return occupied_size

    def clear_inbox(self, size):
        if len(self.addr) == 0:
            return
        freed_space = 0
        while freed_space < size and self.inbox:
            email = self.inbox[0]
            freed_space += email['size']
            del self.inbox[0]",COT,"

```python
from datetime import datetime

class EmailClient:
    def __init__(self, addr, capacity):
        self.addr = addr
        self.capacity = capacity
        self.inbox = []

    def send_to(self, recv, content, size):
        if recv.is_full_with_one_more_email(size):
            return False
        email = {
            'sender': self.addr,
            'receiver': recv.addr,
            'content': content,
            'size': size,
            'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'state': 'unread'
        }
        recv.inbox.append(email)
        return True

    def fetch(self):
        for email in self.inbox:
            if email['state'] == 'unread':
                email['state'] = 'read'
                return email
        return None

    def is_full_with_one_more_email(self, size):
        return self.get_occupied_size() + size > self.capacity

    def get_occupied_size(self):
        return sum(email['size'] for email in self.inbox)

    def clear_inbox(self, size):
        while self.get_occupied_size() + size > self.capacity:
            self.inbox.pop(0)
```",0.22017484738203136,0.2688085307396381,0.5421686746987951,0.7142857142857143,0.6164383512582099,0.3829787234042553,0.5346534653465347,0.4462809868721399,0.5421686746987951,0.7142857142857143,0.6164383512582099
Llama,37,"class EncryptionUtils:
    def __init__(self, key):
        self.key = key

    def caesar_cipher(self, plaintext, shift):
        ciphertext = """"
        for char in plaintext:
            if char.isalpha():
                if char.isupper():
                    ascii_offset = 65
                else:
                    ascii_offset = 97
                shifted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)
                ciphertext += shifted_char
            else:
                ciphertext += char
        return ciphertext
    
    def vigenere_cipher(self, plain_text):
        encrypted_text = """"
        key_index = 0
        for char in plain_text:
            if char.isalpha():
                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')
                encrypted_char = chr((ord(char.lower()) - ord('a') + shift) % 26 + ord('a'))
                encrypted_text += encrypted_char.upper() if char.isupper() else encrypted_char
                key_index += 1
            else:
                encrypted_text += char
        return encrypted_text

    def rail_fence_cipher(self, plain_text, rails):
        fence = [['\n' for _ in range(len(plain_text))] for _ in range(rails)]
        direction = -1
        row, col = 0, 0

        for char in plain_text:
            if row == 0 or row == rails-1:
                direction = -direction

            fence[row][col] = char
            col += 1
            row += direction

        encrypted_text = ''
        for i in range(rails):
            for j in range(len(plain_text)):
                if fence[i][j] != '\n':
                    encrypted_text += fence[i][j]

        return encrypted_text",COT,"

```python
class EncryptionUtils:
    def __init__(self, key):
        self.key = key

    def caesar_cipher(self, plaintext, shift):
        ciphertext = """"
        for char in plaintext:
            if char.isalpha():
                ascii_offset = 97 if char.islower() else 65
                ciphertext += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)
            else:
                ciphertext += char
        return ciphertext

    def vigenere_cipher(self, plaintext):
        key = self.key
        key_index = 0
        ciphertext = """"
        for char in plaintext:
            if char.isalpha():
                ascii_offset = 97 if char.islower() else 65
                shift = ord(key[key_index % len(key)].lower()) - 97
                ciphertext += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)
                key_index += 1
            else:
                ciphertext += char
        return ciphertext

    def rail_fence_cipher(self, plaintext, rails):
        if rails == 1:
            return plaintext
        fence = [[] for _ in range(rails)]
        dir = 1
        rail = 0
        for char in plaintext:
            fence[rail].append(char)
            if rail == 0:
                dir = 1
            elif rail == rails - 1:
                dir = -1
            rail += dir
        ciphertext = """"
        for rail in fence:
            ciphertext += """".join(rail)
        return ciphertext
```",0.28031325812753416,0.350029424483886,0.5679012345679012,0.71875,0.6344827536894174,0.3680555555555556,0.45689655172413796,0.40769230275029594,0.5555555555555556,0.703125,0.6206896502411415
Llama,38,"import openpyxl


class ExcelProcessor:
    def __init__(self):
        pass

    def read_excel(self, file_name):
        data = []
        try:
            workbook = openpyxl.load_workbook(file_name)
            sheet = workbook.active
            for row in sheet.iter_rows(values_only=True):
                data.append(row)
            workbook.close()
            return data
        except:
            return None

    def write_excel(self, data, file_name):
        try:
            workbook = openpyxl.Workbook()
            sheet = workbook.active
            for row in data:
                sheet.append(row)
            workbook.save(file_name)
            workbook.close()
            return 1
        except:
            return 0

    def process_excel_data(self, N, save_file_name):
        data = self.read_excel(save_file_name)
        if data is None or N >= len(data[0]):
            return 0
        new_data = []
        for row in data:
            new_row = list(row[:])
            if not str(row[N]).isdigit():
                new_row.append(str(row[N]).upper())
            else:
                new_row.append(row[N])
            new_data.append(new_row)
        new_file_name = save_file_name.split('.')[0] + '_process.xlsx'
        success = self.write_excel(new_data, new_file_name)
        return success, new_file_name",COT,"

```python
import openpyxl

class ExcelProcessor:
    def __init__(self):
        pass

    def read_excel(self, file_name):
        try:
            wb = openpyxl.load_workbook(file_name)
            sheet = wb.active
            data = []
            for row in sheet.rows:
                row_data = []
                for cell in row:
                    row_data.append(cell.value)
                data.append(tuple(row_data))
            return data
        except Exception as e:
            print(f""Error reading Excel file: {e}"")
            return None

    def write_excel(self, data, file_name):
        try:
            wb = openpyxl.Workbook()
            sheet = wb.active
            for row in data:
                sheet.append(row)
            wb.save(file_name)
            return 1
        except Exception as e:
            print(f""Error writing Excel file: {e}"")
            return 0

    def process_excel_data(self, N, save_file_name):
        data = self.read_excel(save_file_name)
        if data is None:
            return 0, None
        processed_data = []
        for row in data:
            processed_row = list(row)
            if N <= len(processed_row):
                processed_row[N-1] = str(processed_row[N-1]).upper()
            processed_data.append(tuple(processed_row))
        write_result = self.write_excel(processed_data, 'processed_' + save_file_name)
        return write_result, 'processed_' + save_file_name
```",0.3025210084033613,0.35133333856700366,0.5909090909090909,0.52,0.5531914843820736,0.4444444444444444,0.4074074074074074,0.4251207679563117,0.5757575757575758,0.5066666666666667,0.5390070872189529
Llama,39,"import re
from collections import deque
from decimal import Decimal


class ExpressionCalculator:
    def __init__(self):
        self.postfix_stack = deque()
        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]

    def calculate(self, expression):
        self.prepare(self.transform(expression))

        result_stack = deque()
        self.postfix_stack.reverse()

        while self.postfix_stack:
            current_op = self.postfix_stack.pop()
            if not self.is_operator(current_op):
                current_op = current_op.replace(""~"", ""-"")
                result_stack.append(current_op)
            else:
                second_value = result_stack.pop()
                first_value = result_stack.pop()

                first_value = first_value.replace(""~"", ""-"")
                second_value = second_value.replace(""~"", ""-"")

                temp_result = self._calculate(first_value, second_value, current_op)
                result_stack.append(str(temp_result))

        return float(eval(""*"".join(result_stack)))

    def prepare(self, expression):
        op_stack = deque([','])
        arr = list(expression)
        current_index = 0
        count = 0

        for i, current_op in enumerate(arr):
            if self.is_operator(current_op):
                if count > 0:
                    self.postfix_stack.append("""".join(arr[current_index: current_index + count]))
                peek_op = op_stack[-1]
                if current_op == ')':
                    while op_stack[-1] != '(':
                        self.postfix_stack.append(str(op_stack.pop()))
                    op_stack.pop()
                else:
                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):
                        self.postfix_stack.append(str(op_stack.pop()))
                        peek_op = op_stack[-1]
                    op_stack.append(current_op)

                count = 0
                current_index = i + 1
            else:
                count += 1

        if count > 1 or (count == 1 and not self.is_operator(arr[current_index])):
            self.postfix_stack.append("""".join(arr[current_index: current_index + count]))

        while op_stack[-1] != ',':
            self.postfix_stack.append(str(op_stack.pop()))

    @staticmethod
    def is_operator(c):
        return c in {'+', '-', '*', '/', '(', ')', '%'}

    def compare(self, cur, peek):
        if cur == '%':
            cur = '/'
        if peek == '%':
            peek = '/'
        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]

    @staticmethod
    def _calculate(first_value, second_value, current_op):
        if current_op == '+':
            return Decimal(first_value) + Decimal(second_value)
        elif current_op == '-':
            return Decimal(first_value) - Decimal(second_value)
        elif current_op == '*':
            return Decimal(first_value) * Decimal(second_value)
        elif current_op == '/':
            return Decimal(first_value) / Decimal(second_value)
        elif current_op == '%':
            return Decimal(first_value) % Decimal(second_value)
        else:
            raise ValueError(""Unexpected operator: {}"".format(current_op))

    @staticmethod
    def transform(expression):
        expression = re.sub(r""\s+"", """", expression)
        expression = re.sub(r""=$"", """", expression)
        arr = list(expression)

        for i, c in enumerate(arr):
            if c == '-':
                if i == 0:
                    arr[i] = '~'
                else:
                    prev_c = arr[i - 1]
                    if prev_c in {'+', '-', '*', '/', '(', 'E', 'e'}:
                        arr[i] = '~'

        if arr[0] == '~' and (len(arr) > 1 and arr[1] == '('):
            arr[0] = '-'
            return ""0"" + """".join(arr)
        else:
            return """".join(arr)",COT,"

```python
import re
from collections import deque
from decimal import Decimal

class ExpressionCalculator:
    def __init__(self):
        self.postfix_stack = deque()
        self.operat_priority = {'+': 3, '-': 2, '*': 1, '/': -1, '%': 1, '(': 0, ')': 2}

    def calculate(self, expression):
        self.postfix_stack = deque(self.prepare(expression))
        stack = []
        while self.postfix_stack:
            token = self.postfix_stack.popleft()
            if token not in self.operat_priority:
                stack.append(float(token))
            else:
                second_value = stack.pop()
                first_value = stack.pop()
                result = self._calculate(first_value, second_value, token)
                stack.append(result)
        return stack[0]

    def prepare(self, expression):
        expression = self.transform(expression)
        output = []
        operator_stack = []
        for token in expression:
            if token not in self.operat_priority:
                output.append(token)
            elif token == '(':
                operator_stack.append(token)
            elif token == ')':
                while operator_stack and operator_stack[-1] != '(':
                    output.append(operator_stack.pop())
                if operator_stack and operator_stack[-1] == '(':
                    operator_stack.pop()
            else:
                while operator_stack and operator_stack[-1] != '(' and self.compare(token, operator_stack[-1]):
                    output.append(operator_stack.pop())
                operator_stack.append(token)
        while operator_stack:
            output.append(operator_stack.pop())
        return output

    @staticmethod
    def is_operator(c):
        return c in {'+', '-', '*', '/', '(', ')', '%'}

    def compare(self, cur, peek):
        return self.operat_priority[cur] <= self.operat_priority[peek]

    @staticmethod
    def _calculate(first_value, second_value, current_op):
        if current_op == '+':
            return first_value + second_value
        elif current_op == '-':
            return first_value - second_value
        elif current_op == '*':
            return first_value * second_value
        elif current_op == '/':
            if second_value != 0:
                return first_value / second_value
            else:
                raise ZeroDivisionError(""Cannot divide by zero"")
        elif current_op == '%':
            if second_value != 0:
                return first_value % second_value
            else:
                raise ZeroDivisionError(""Cannot divide by zero"")

    @staticmethod
    def transform(expression):
        return re.sub(r'\s', '', expression)
```",0.16388915758075073,0.2078523120871269,0.5034013605442177,0.6727272727272727,0.5758754814849582,0.2638888888888889,0.38578680203045684,0.3134020570316931,0.4965986394557823,0.6636363636363637,0.5680933803176431
Llama,3,"import itertools


class ArrangementCalculator:
    def __init__(self, datas):
        self.datas = datas

    @staticmethod
    def count(n, m=None):
        if m is None or n == m:
            return ArrangementCalculator.factorial(n)
        else:
            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)

    @staticmethod
    def count_all(n):
        total = 0
        for i in range(1, n + 1):
            total += ArrangementCalculator.count(n, i)
        return total

    def select(self, m=None):
        if m is None:
            m = len(self.datas)
        result = []
        for permutation in itertools.permutations(self.datas, m):
            result.append(list(permutation))
        return result

    def select_all(self):
        result = []
        for i in range(1, len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    @staticmethod
    def factorial(n):
        result = 1
        for i in range(2, n + 1):
            result *= i
        return result",COT,"

```python
class ArrangementCalculator:
    def __init__(self, datas):
        # Initialize the ArrangementCalculator object with a list of datas
        self.datas = datas

    @staticmethod
    def count(n, m=None):
        # Count the number of arrangements by choosing m items from n items (permutations)
        if m is None:
            m = n
        # Calculate the permutation using the formula n! / (n-m)!
        return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)

    @staticmethod
    def count_all(n):
        # Count the total number of all possible arrangements by choosing at least 1 item and at most n items from n items
        total = 0
        for m in range(1, n + 1):
            total += ArrangementCalculator.count(n, m)
        return total

    def select(self, m=None):
        # Generate a list of arrangements by selecting m items from the internal datas
        if m is None:
            m = len(self.datas)
        # Use recursion to generate all permutations
        def permute(datas, m):
            if m == 1:
                return [[data] for data in datas]
            result = []
            for i, data in enumerate(datas):
                rest = datas[:i] + datas[i + 1:]
                for p in permute(rest, m - 1):
                    result.append([data] + p)
            return result
        return permute(self.datas, m)

    def select_all(self):
        # Generate a list of all arrangements by selecting at least 1 item and at most the number of internal datas
        total = []
        for m in range(1, len(self.datas) + 1):
            total.extend(self.select(m))
        return total

    @staticmethod
    def factorial(n):
        # Calculate the factorial of a given number
        result = 1
        for i in range(2, n + 1):
            result *= i
        return result
```",0.21940928270042195,0.24829866712560925,0.8275862068965517,0.4528301886792453,0.5853658490868531,0.6521739130434783,0.3157894736842105,0.4255319104974599,0.8275862068965517,0.4528301886792453,0.5853658490868531
Llama,40,"class FitnessTracker:
    def __init__(self, height, weight, age, sex) -> None:
        self.height = height
        self.weight = weight
        self.age = age
        self.sex = sex
        self.BMI_std = [
            {""male"": [20, 25]},
            {""female"": [19, 24]}
        ]

    def get_BMI(self):
        return self.weight / self.height ** 2

    def condition_judge(self):
        BMI = self.get_BMI()
        if self.sex == ""male"":
            BMI_range = self.BMI_std[0][""male""]
        else:
            BMI_range = self.BMI_std[1][""female""]
        if BMI > BMI_range[1]:
            # too fat
            return 1
        elif BMI < BMI_range[0]:
            # too thin
            return -1
        else:
            # normal
            return 0

    def calculate_calorie_intake(self):
        if self.sex == ""male"":
            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5
        else:
            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161
        if self.condition_judge() == 1:
            calorie_intake = BMR * 1.2  # Sedentary lifestyle
        elif self.condition_judge() == -1:
            calorie_intake = BMR * 1.6  # Active lifestyle
        else:
            calorie_intake = BMR * 1.4  # Moderate lifestyle
        return calorie_intake",COT,"

```python
class FitnessTracker:
    def __init__(self, height, weight, age, sex):
        self.height = height
        self.weight = weight
        self.age = age
        self.sex = sex
        self.BMI_std = {
            ""male"": [20, 25],
            ""female"": [19, 24]
        }
        self.BMI = self.get_BMI()

    def get_BMI(self):
        return self.weight / (self.height ** 2)

    def condition_judge(self):
        if self.sex == ""male"":
            if self.BMI < self.BMI_std[""male""][0]:
                return -1
            elif self.BMI > self.BMI_std[""male""][1]:
                return 1
            else:
                return 0
        elif self.sex == ""female"":
            if self.BMI < self.BMI_std[""female""][0]:
                return -1
            elif self.BMI > self.BMI_std[""female""][1]:
                return 1
            else:
                return 0

    def calculate_calorie_intake(self):
        if self.sex == ""male"":
            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5
        elif self.sex == ""female"":
            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161
        condition = self.condition_judge()
        if condition == 1:
            return BMR * 1.2
        elif condition == -1:
            return BMR * 1.6
        else:
            return BMR * 1.4
```",0.3959738192696686,0.4616938192239463,0.6666666666666666,0.7619047619047619,0.7111111061333335,0.5227272727272727,0.5798319327731093,0.5498007918261616,0.6666666666666666,0.7619047619047619,0.7111111061333335
Llama,41,"class GomokuGame:
    def __init__(self, board_size):
        self.board_size = board_size
        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        return False

    def check_winner(self):
        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]
        for row in range(self.board_size):
            for col in range(self.board_size):
                if self.board[row][col] != ' ':
                    for direction in directions:
                        if self._check_five_in_a_row(row, col, direction):
                            return self.board[row][col]
        return None

    def _check_five_in_a_row(self, row, col, direction):
        dx, dy = direction
        count = 1
        symbol = self.board[row][col]
        for i in range(1, 5):
            new_row = row + dx * i
            new_col = col + dy * i
            if not (0 <= new_row < self.board_size and 0 <= new_col < self.board_size):
                return False
            if self.board[new_row][new_col] != symbol:
                return False
            count += 1
        return count == 5",COT,"

```python
class GomokuGame:
    def __init__(self, board_size):
        self.board_size = board_size
        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if self.board[row][col] != ' ':
            return False
        self.board[row][col] = self.current_player
        self.current_player = 'O' if self.current_player == 'X' else 'X'
        return True

    def check_winner(self):
        for row in range(self.board_size):
            for col in range(self.board_size):
                if self.board[row][col] != ' ':
                    for direction in [(0, 1), (1, 0), (1, 1), (1, -1)]:
                        if self._check_five_in_a_row(row, col, direction):
                            return self.board[row][col]
        return None

    def _check_five_in_a_row(self, row, col, direction):
        symbol = self.board[row][col]
        count = 1
        for i in range(1, 5):
            new_row, new_col = row + i * direction[0], col + i * direction[1]
            if (0 <= new_row < self.board_size and 0 <= new_col < self.board_size and
                    self.board[new_row][new_col] == symbol):
                count += 1
            else:
                break
        for i in range(1, 5):
            new_row, new_col = row - i * direction[0], col - i * direction[1]
            if (0 <= new_row < self.board_size and 0 <= new_col < self.board_size and
                    self.board[new_row][new_col] == symbol):
                count += 1
            else:
                break
        return count >= 5
```",0.48,0.5397571577919544,0.8857142857142857,0.8493150684931506,0.8671328621350678,0.7007299270072993,0.7384615384615385,0.7191011185989424,0.8857142857142857,0.8493150684931506,0.8671328621350678
Llama,42,"class Hotel:
    def __init__(self, name, rooms):
        self.name = name
        self.available_rooms = rooms
        # available_rooms = {room_type1: room_number1, room_type2: room_number2, ...}
        # available_rooms = {'single': 5, 'double': 3}
        self.booked_rooms = {}
        # booked_rooms = {room_type1: {name1: room_number1, name2: room_number2, ...}, room_type2: {...}, ...}
        # booked_rooms = {'single': {'name1': 2, 'name2':1}, 'double': {}}

    def book_room(self, room_type, room_number, name):
        # Check if there are any rooms of the specified type available
        if room_type not in self.available_rooms.keys():
            return False

        if room_number <= self.available_rooms[room_type]:
            # Book the room by adding it to the booked_rooms dictionary
            if room_type not in self.booked_rooms.keys():
                self.booked_rooms[room_type] = {}
            self.booked_rooms[room_type][name] = room_number
            self.available_rooms[room_type] -= room_number
            return ""Success!""
        elif self.available_rooms[room_type] != 0:
            return self.available_rooms[room_type]
        else:
            return False

    def check_in(self, room_type, room_number, name):
        # Check if the room of the specified type and number is booked
        if room_type not in self.booked_rooms.keys():
            return False
        if name in self.booked_rooms[room_type]:
            if room_number > self.booked_rooms[room_type][name]:
                return False
            elif room_number == self.booked_rooms[room_type][name]:
                # Check in the room by removing it from the booked_rooms dictionary
                self.booked_rooms[room_type].pop(name)
            else:
                self.booked_rooms[room_type][name] -= room_number


    def check_out(self, room_type, room_number):
        if room_type in self.available_rooms:
            self.available_rooms[room_type] += room_number
        else:
            self.available_rooms[room_type] = room_number

    def get_available_rooms(self, room_type):
        return self.available_rooms[room_type]",COT,"

```python
class Hotel:
    def __init__(self, name, rooms):
        self.name = name
        self.available_rooms = rooms
        self.booked_rooms = {}

    def book_room(self, room_type, room_number, name):
        if room_type not in self.available_rooms:
            return False
        if self.available_rooms[room_type] < room_number:
            return self.available_rooms[room_type]
        if room_type not in self.booked_rooms:
            self.booked_rooms[room_type] = {}
        if name in self.booked_rooms[room_type]:
            self.booked_rooms[room_type][name] += room_number
        else:
            self.booked_rooms[room_type][name] = room_number
        self.available_rooms[room_type] -= room_number
        if self.available_rooms[room_type] == 0 and room_type not in self.booked_rooms:
            return False
        return 'Success!'

    def check_in(self, room_type, room_number, name):
        if room_type not in self.booked_rooms or name not in self.booked_rooms[room_type]:
            return False
        if self.booked_rooms[room_type][name] < room_number:
            return False
        if self.booked_rooms[room_type][name] == room_number:
            del self.booked_rooms[room_type][name]
            if len(self.booked_rooms[room_type]) == 0:
                del self.booked_rooms[room_type]
        else:
            self.booked_rooms[room_type][name] -= room_number
        return True

    def check_out(self, room_type, room_number):
        if room_type not in self.available_rooms:
            self.available_rooms[room_type] = room_number
        else:
            self.available_rooms[room_type] += room_number

    def get_available_rooms(self, room_type):
        if room_type not in self.available_rooms:
            return 0
        return self.available_rooms[room_type]
```",0.23097628206767618,0.26188539426557705,0.45454545454545453,0.7692307692307693,0.5714285667591837,0.36075949367088606,0.5533980582524272,0.4367816044174337,0.45454545454545453,0.7692307692307693,0.5714285667591837
Llama,43,"class HRManagementSystem:
    def __init__(self):
        self.employees = {}

    def add_employee(self, employee_id, name, position, department, salary):
        if employee_id in self.employees:
            return False
        else:
            self.employees[employee_id] = {
                'name': name,
                'position': position,
                'department': department,
                'salary': salary
            }
            return True

    def remove_employee(self, employee_id):
        if employee_id in self.employees:
            del self.employees[employee_id]
            return True
        else:
            return False

    def update_employee(self, employee_id: int, employee_info: dict):
        employee = self.get_employee(employee_id)
        if employee == False:
            return False
        else:
            for key, value in employee_info.items():
                if key not in employee:
                    return False
            for key, value in employee_info.items():
                employee[key] = value
            return True

    def get_employee(self, employee_id):
        if employee_id in self.employees:
            return self.employees[employee_id]
        else:
            return False

    def list_employees(self):
        employee_data = {}
        if self.employees:
            for employee_id, employee_info in self.employees.items():
                employee_details = {}
                employee_details[""employee_ID""] = employee_id
                for key, value in employee_info.items():
                    employee_details[key] = value
                employee_data[employee_id] = employee_details
        return employee_data",COT,"

```python
class HRManagementSystem:
    def __init__(self):
        self.employees = {}

    def add_employee(self, employee_id, name, position, department, salary):
        if employee_id in self.employees:
            return False
        else:
            self.employees[employee_id] = {
                'name': name,
                'position': position,
                'department': department,
                'salary': salary
            }
            return True

    def remove_employee(self, employee_id):
        if employee_id in self.employees:
            del self.employees[employee_id]
            return True
        else:
            return False

    def update_employee(self, employee_id, employee_info):
        if employee_id in self.employees:
            self.employees[employee_id] = employee_info
            return True
        else:
            return False

    def get_employee(self, employee_id):
        if employee_id in self.employees:
            return self.employees[employee_id]
        else:
            return False

    def list_employees(self):
        result = {}
        for employee_id, employee_info in self.employees.items():
            result[employee_id] = {
                'employee_ID': employee_id,
                'name': employee_info['name'],
                'position': employee_info['position'],
                'department': employee_info['department'],
                'salary': employee_info['salary']
            }
        return result
```",0.4897103706378631,0.5271125142557526,0.6724137931034483,0.7959183673469388,0.7289719576521968,0.5428571428571428,0.6951219512195121,0.6096256635248363,0.6724137931034483,0.7959183673469388,0.7289719576521968
Llama,44,"import re
import string
import gensim
from bs4 import BeautifulSoup


class HtmlUtil:

    def __init__(self):
        self.SPACE_MARK = '-SPACE-'
        self.JSON_MARK = '-JSON-'
        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'
        self.URL_MARK = '-URL-'
        self.NUMBER_MARK = '-NUMBER-'
        self.TRACE_MARK = '-TRACE-'
        self.COMMAND_MARK = '-COMMAND-'
        self.COMMENT_MARK = '-COMMENT-'
        self.CODE_MARK = '-CODE-'

    @staticmethod
    def __format_line_feed(text):
        return re.sub(re.compile(r'\n+'), '\n', text)

    def format_line_html_text(self, html_text):
        if html_text is None or len(html_text) == 0:
            return ''
        soup = BeautifulSoup(html_text, 'lxml')

        code_tag = soup.find_all(name=['pre', 'blockquote'])
        for tag in code_tag:
            tag.string = self.CODE_MARK

        ul_ol_group = soup.find_all(name=['ul', 'ol'])
        for ul_ol_item in ul_ol_group:
            li_group = ul_ol_item.find_all('li')
            for li_item in li_group:
                li_item_text = li_item.get_text().strip()
                if len(li_item_text) == 0:
                    continue
                if li_item_text[-1] in string.punctuation:
                    li_item.string = '[{0}]{1}'.format('-', li_item_text)
                    continue
                li_item.string = '[{0}]{1}.'.format('-', li_item_text)

        p_group = soup.find_all(name=['p'])
        for p_item in p_group:
            p_item_text = p_item.get_text().strip()
            if p_item_text:
                if p_item_text[-1] in string.punctuation:
                    p_item.string = p_item_text
                    continue
                next_sibling = p_item.find_next_sibling()
                if next_sibling and self.CODE_MARK in next_sibling.get_text():
                    p_item.string = p_item_text + ':'
                    continue
                p_item.string = p_item_text + '.'

        clean_text = gensim.utils.decode_htmlentities(soup.get_text())
        return self.__format_line_feed(clean_text)

    def extract_code_from_html_text(self, html_text):
        text_with_code_tag = self.format_line_html_text(html_text)

        if self.CODE_MARK not in text_with_code_tag:
            return []

        code_index_start = 0
        soup = BeautifulSoup(html_text, 'lxml')
        code_tag = soup.find_all(name=['pre', 'blockquote'])
        code_count = text_with_code_tag.count(self.CODE_MARK)
        code_list = []
        for code_index in range(code_index_start, code_index_start + code_count):
            code = code_tag[code_index].get_text()
            if code:
                code_list.append(code)
        return code_list",COT,"

```python
import re
import string
import gensim
from bs4 import BeautifulSoup

class HtmlUtil:
    def __init__(self):
        self.SPACE_MARK = '-SPACE-'
        self.JSON_MARK = '-JSON-'
        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'
        self.URL_MARK = '-URL-'
        self.NUMBER_MARK = '-NUMBER-'
        self.TRACE_MARK = '-TRACE-'
        self.COMMAND_MARK = '-COMMAND-'
        self.COMMENT_MARK = '-COMMENT-'
        self.CODE_MARK = '-CODE-'

    @staticmethod
    def __format_line_feed(text):
        return re.sub(r'\n+', '\n', text)

    def format_line_html_text(self, html_text):
        soup = BeautifulSoup(html_text, 'html.parser')
        for pre in soup.find_all('pre'):
            pre.replace_with(self.CODE_MARK)
        return self.__format_line_feed(soup.get_text())

    def extract_code_from_html_text(self, html_text):
        soup = BeautifulSoup(html_text, 'html.parser')
        codes = []
        for pre in soup.find_all('pre'):
            code = pre.get_text()
            if pre.code:
                code = pre.code.get_text()
            codes.append(code)
        return codes
```",0.1614518965970804,0.17539159397607118,0.4358974358974359,0.8360655737704918,0.5730337033600557,0.31627906976744186,0.68,0.4317460274124465,0.4358974358974359,0.8360655737704918,0.5730337033600557
Llama,45,"from PIL import Image, ImageEnhance, ImageChops


class ImageProcessor:
    def __init__(self):
        self.image = None

    def load_image(self, image_path):
        self.image = Image.open(image_path)

    def save_image(self, save_path):
        if self.image:
            self.image.save(save_path)

    def resize_image(self, width, height):
        if self.image:
            self.image = self.image.resize((width, height))

    def rotate_image(self, degrees):
        if self.image:
            self.image = self.image.rotate(degrees)

    def adjust_brightness(self, factor):
        if self.image:
            enhancer = ImageEnhance.Brightness(self.image)
            self.image = enhancer.enhance(factor)",COT,"

```python
from PIL import Image, ImageEnhance

class ImageProcessor:
    def __init__(self):
        self.image = None

    def load_image(self, image_path):
        self.image = Image.open(image_path)

    def save_image(self, save_path):
        if self.image is not None:
            self.image.save(save_path)
        else:
            raise ValueError(""No image loaded"")

    def resize_image(self, width, height):
        if self.image is not None:
            self.image = self.image.resize((width, height))
        else:
            raise ValueError(""No image loaded"")

    def rotate_image(self, degrees):
        if self.image is not None:
            self.image = self.image.rotate(degrees)
        else:
            raise ValueError(""No image loaded"")

    def adjust_brightness(self, factor):
        if self.image is not None:
            enhancer = ImageEnhance.Brightness(self.image)
            self.image = enhancer.enhance(factor)
        else:
            raise ValueError(""No image loaded"")
```",0.3647058823529412,0.3975757296472802,0.9210526315789473,0.7954545454545454,0.8536585316121357,0.8269230769230769,0.7049180327868853,0.7610619419343724,0.9210526315789473,0.7954545454545454,0.8536585316121357
Llama,46,"class Interpolation:
    def __init__(self):
        pass

    @staticmethod
    def interpolate_1d(x, y, x_interp):
        y_interp = []
        for xi in x_interp:
            for i in range(len(x) - 1):
                if x[i] <= xi <= x[i+1]:
                    yi = y[i] + (y[i+1] - y[i]) * (xi - x[i]) / (x[i+1] - x[i])
                    y_interp.append(yi)
                    break
        return y_interp
    
    @staticmethod
    def interpolate_2d(x, y, z, x_interp, y_interp):
        z_interp = []
        for xi, yi in zip(x_interp, y_interp):
            for i in range(len(x) - 1):
                if x[i] <= xi <= x[i+1]:
                    for j in range(len(y) - 1):
                        if y[j] <= yi <= y[j+1]:
                            z00 = z[i][j]
                            z01 = z[i][j+1]
                            z10 = z[i+1][j]
                            z11 = z[i+1][j+1]
                            zi = (z00 * (x[i+1] - xi) * (y[j+1] - yi) +
                                  z10 * (xi - x[i]) * (y[j+1] - yi) +
                                  z01 * (x[i+1] - xi) * (yi - y[j]) +
                                  z11 * (xi - x[i]) * (yi - y[j])) / ((x[i+1] - x[i]) * (y[j+1] - y[j]))
                            z_interp.append(zi)
                            break
                    break
        return z_interp",COT,"

```python
class Interpolation:
    def __init__(self):
        pass

    @staticmethod
    def interpolate_1d(x, y, x_interp):
        y_interp = []
        for x_val in x_interp:
            for i in range(len(x) - 1):
                if x[i] <= x_val <= x[i + 1]:
                    slope = (y[i + 1] - y[i]) / (x[i + 1] - x[i])
                    y_val = y[i] + slope * (x_val - x[i])
                    y_interp.append(y_val)
                    break
        return y_interp

    @staticmethod
    def interpolate_2d(x, y, z, x_interp, y_interp):
        z_interp = []
        for x_val, y_val in zip(x_interp, y_interp):
            for i in range(len(x) - 1):
                for j in range(len(y) - 1):
                    if x[i] <= x_val <= x[i + 1] and y[j] <= y_val <= y[j + 1]:
                        q11 = z[i][j]
                        q12 = z[i][j + 1]
                        q21 = z[i + 1][j]
                        q22 = z[i + 1][j + 1]
                        r1 = q11 + (q12 - q11) * (y_val - y[j]) / (y[j + 1] - y[j])
                        r2 = q21 + (q22 - q21) * (y_val - y[j]) / (y[j + 1] - y[j])
                        z_val = r1 + (r2 - r1) * (x_val - x[i]) / (x[i + 1] - x[i])
                        z_interp.append(z_val)
                        break
                else:
                    continue
                break
        return z_interp
```",0.27932960893854747,0.34031193270140503,0.6212121212121212,0.5256410256410257,0.5694444394791668,0.43859649122807015,0.36764705882352944,0.39999999503872,0.6060606060606061,0.5128205128205128,0.555555550590278
Llama,47,"class IPAddress:
    def __init__(self, ip_address):
        self.ip_address = ip_address

    def is_valid(self):
        octets = self.ip_address.split('.')
        if len(octets) != 4:
            return False
        for octet in octets:
            if not octet.isdigit() or int(octet) < 0 or int(octet) > 255:
                return False
        return True

    def get_octets(self):
        if self.is_valid():
            return self.ip_address.split('.')
        else:
            return []

    def get_binary(self):
        if self.is_valid():
            binary_octets = []
            for octet in self.get_octets():
                binary_octets.append(format(int(octet), '08b'))
            return '.'.join(binary_octets)
        else:
            return ''",COT,"

```python
class IPAddress:
    def __init__(self, ip_address):
        self.ip_address = ip_address

    def is_valid(self):
        parts = self.ip_address.split(""."")
        if len(parts) != 4:
            return False
        for part in parts:
            if not part.isdigit():
                return False
            if not 0 <= int(part) <= 255:
                return False
        return True

    def get_octets(self):
        if not self.is_valid():
            return []
        return self.ip_address.split(""."")

    def get_binary(self):
        if not self.is_valid():
            return ''
        binary_parts = []
        for part in self.ip_address.split("".""):
            binary_part = format(int(part), '08b')
            binary_parts.append(binary_part)
        return ""."".join(binary_parts)
```",0.2753623188405797,0.34430591844407127,0.5813953488372093,0.5681818181818182,0.5747126386788216,0.47761194029850745,0.45714285714285713,0.46715327967393044,0.5813953488372093,0.5681818181818182,0.5747126386788216
Llama,48,"import socket


class IpUtil:

    @staticmethod
    def is_valid_ipv4(ip_address):
        try:
            socket.inet_pton(socket.AF_INET, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def is_valid_ipv6(ip_address):
        try:
            socket.inet_pton(socket.AF_INET6, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def get_hostname(ip_address):
        try:
            hostname = socket.gethostbyaddr(ip_address)[0]
            return hostname
        except socket.herror:
            return None",COT,"

```python
import socket
import ipaddress

class IpUtil:
    @staticmethod
    def is_valid_ipv4(ip_address):
        try:
            ipaddress.IPv4Address(ip_address)
            return True
        except ipaddress.AddressValueError:
            return False

    @staticmethod
    def is_valid_ipv6(ip_address):
        try:
            ipaddress.IPv6Address(ip_address)
            return True
        except ipaddress.AddressValueError:
            return False

    @staticmethod
    def get_hostname(ip_address):
        try:
            return socket.gethostbyaddr(ip_address)[0]
        except socket.herror:
            return None

    @staticmethod
    def get_binary(ip_address):
        if IpUtil.is_valid_ipv4(ip_address):
            return '.'.join(format(int(part), '08b') for part in ip_address.split('.'))
        elif IpUtil.is_valid_ipv6(ip_address):
            return ':'.join(format(int(part, 16), '016b') for part in ip_address.split(':'))
        else:
            return None
```",0.25396825396825395,0.29177162680913576,0.7083333333333334,0.40476190476190477,0.5151515105234161,0.5428571428571428,0.30158730158730157,0.3877550974489796,0.7083333333333334,0.40476190476190477,0.5151515105234161
Llama,49,"class JobMarketplace:
    def __init__(self):
        self.job_listings = []
        self.resumes = []

    def post_job(self, job_title, company, requirements):
        # requirements = ['requirement1', 'requirement2']
        job = {""job_title"": job_title, ""company"": company, ""requirements"": requirements}
        self.job_listings.append(job)

    def remove_job(self, job):
        self.job_listings.remove(job)

    def submit_resume(self, name, skills, experience):
        resume = {""name"": name, ""skills"": skills, ""experience"": experience}
        self.resumes.append(resume)

    def withdraw_resume(self, resume):
        self.resumes.remove(resume)

    def search_jobs(self, criteria):
        matching_jobs = []
        for job_listing in self.job_listings:
            if criteria.lower() in job_listing[""job_title""].lower() or criteria.lower() in [r.lower() for r in job_listing[""requirements""]]:
                matching_jobs.append(job_listing)
        return matching_jobs

    def get_job_applicants(self, job):
        applicants = []
        for resume in self.resumes:
            if self.matches_requirements(resume, job[""requirements""]):
                applicants.append(resume)
        return applicants

    @staticmethod
    def matches_requirements(resume, requirements):
        for skill in resume[""skills""]:
            if skill not in requirements:
                return False
        return True",COT,"

```python
class JobMarketplace:
    def __init__(self):
        self.job_listings = []
        self.resumes = []

    def post_job(self, job_title, company, requirements):
        self.job_listings.append({
            'job_title': job_title,
            'company': company,
            'requirements': requirements
        })

    def remove_job(self, job):
        if job in self.job_listings:
            self.job_listings.remove(job)

    def submit_resume(self, name, skills, experience):
        self.resumes.append({
            'name': name,
            'skills': skills,
            'experience': experience
        })

    def withdraw_resume(self, resume):
        if resume in self.resumes:
            self.resumes.remove(resume)

    def search_jobs(self, criteria):
        return [job for job in self.job_listings if criteria in job['requirements']]

    def matches_requirements(self, resume, job):
        return any(skill in job['requirements'] for skill in resume['skills'])

    def get_job_applicants(self, job):
        return [resume for resume in self.resumes if self.matches_requirements(resume, job)]
```",0.23048655622124353,0.28097882894503906,0.5588235294117647,0.6551724137931034,0.6031745982060973,0.35344827586206895,0.45054945054945056,0.39613526077341366,0.5588235294117647,0.6551724137931034,0.6031745982060973
Llama,4,"class AssessmentSystem:
    def __init__(self):
        self.students = {}

    def add_student(self, name, grade, major):
        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}

    def add_course_score(self, name, course, score):
        if name in self.students:
            self.students[name]['courses'][course] = score

    def get_gpa(self, name):
        if name in self.students and self.students[name]['courses']:
            return sum(self.students[name]['courses'].values()) / len(self.students[name]['courses'])
        else:
            return None

    def get_all_students_with_fail_course(self):
        students = []
        for name, student in self.students.items():
            for course, score in student['courses'].items():
                if score < 60:
                    students.append(name)
                    break
        return students

    def get_course_average(self, course):
        total = 0
        count = 0
        for student in self.students.values():
            if course in student['courses']:
                score = student['courses'][course]
                if score is not None:
                    total += score
                    count += 1
        return total / count if count > 0 else None

    def get_top_student(self):
        top_student = None
        top_gpa = 0
        for name, student in self.students.items():
            gpa = self.get_gpa(name)
            if gpa is not None and gpa > top_gpa:
                top_gpa = gpa
                top_student = name
        return top_student",COT,"

```python
class AssessmentSystem:
    def __init__(self):
        # Initialize the students dictionary in the assessment system
        self.students = {}

    def add_student(self, name, grade, major):
        # Add a new student into self.students dictionary
        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}

    def add_course_score(self, name, course, score):
        # Add score of specific course for student in self.students
        if name in self.students:
            self.students[name]['courses'][course] = score

    def get_gpa(self, name):
        # Get average grade of one student
        if name in self.students and self.students[name]['courses']:
            total_score = sum(self.students[name]['courses'].values())
            return total_score / len(self.students[name]['courses'])
        else:
            return None

    def get_all_students_with_fail_course(self):
        # Get all students who have any score below 60
        students_with_fail_course = []
        for student in self.students.values():
            for score in student['courses'].values():
                if score < 60:
                    students_with_fail_course.append(student['name'])
                    break
        return students_with_fail_course

    def get_course_average(self, course):
        # Get the average score of a specific course
        total_score = 0
        count = 0
        for student in self.students.values():
            if course in student['courses']:
                total_score += student['courses'][course]
                count += 1
        if count > 0:
            return total_score / count
        else:
            return None

    def get_top_student(self):
        # Calculate every student's gpa with get_gpa method, and find the student with highest gpa
        top_student = None
        top_gpa = 0
        for student in self.students.values():
            gpa = self.get_gpa(student['name'])
            if gpa is not None and gpa > top_gpa:
                top_gpa = gpa
                top_student = student['name']
        return top_student
```",0.35096153846153844,0.4070673097476501,0.9178082191780822,0.638095238095238,0.7528089839256407,0.6714285714285714,0.4973544973544973,0.5714285665394814,0.9041095890410958,0.6285714285714286,0.7415730288694609
Llama,50,"import json
import os


class JSONProcessor:
    def read_json(self, file_path):
        if not os.path.exists(file_path):
            return 0
        try:
            with open(file_path, 'r') as file:
                data = json.load(file)
            return data
        except:
            return -1

    def write_json(self, data, file_path):
        try:
            with open(file_path, 'w') as file:
                json.dump(data, file)
            return 1
        except:
            return -1

    def process_json(self, file_path, remove_key):
        data = self.read_json(file_path)
        if data == 0 or data == -1:
            return 0
        if remove_key in data:
            del data[remove_key]
            self.write_json(data, file_path)
            return 1
        else:
            return 0",COT,"

```python
import json
import os

class JSONProcessor:
    def read_json(self, file_path: str) -> dict:
        """"""
        Reads a JSON file and returns the data.
        
        Args:
        file_path (str): The path of the JSON file.
        
        Returns:
        dict: The data from the JSON file if read successfully, -1 if an error occurs during the reading process, 0 if the file does not exist.
        """"""
        try:
            # Check if the file exists
            if not os.path.exists(file_path):
                return 0
            
            # Open and read the JSON file
            with open(file_path, 'r') as file:
                data = json.load(file)
                return data
        
        except json.JSONDecodeError:
            # Return -1 if an error occurs during the reading process
            return -1
    
    def write_json(self, data: dict, file_path: str) -> int:
        """"""
        Writes data to a JSON file and saves it to the given path.
        
        Args:
        data (dict): The data to be written to the JSON file.
        file_path (str): The path of the JSON file.
        
        Returns:
        int: 1 if the writing process is successful, -1 if an error occurs during the writing process.
        """"""
        try:
            # Open and write the JSON file
            with open(file_path, 'w') as file:
                json.dump(data, file)
                return 1
        
        except Exception as e:
            # Return -1 if an error occurs during the writing process
            print(f""An error occurred: {e}"")
            return -1
    
    def process_json(self, file_path: str, remove_key: str) -> int:
        """"""
        Reads a JSON file, removes a specified key, and rewrites the modified data back to the file.
        
        Args:
        file_path (str): The path of the JSON file.
        remove_key (str): The key to be removed.
        
        Returns:
        int: 1 if the specified key is successfully removed and the data is written back, 0 if the file does not exist or the specified key does not exist in the data.
        """"""
        # Read the JSON file
        data = self.read_json(file_path)
        
        # Check if the file exists and the data is not empty
        if data == 0 or data == -1:
            return 0
        
        # Check if the key exists in the data
        if remove_key not in data:
            return 0
        
        # Remove the key from the data
        del data[remove_key]
        
        # Write the modified data back to the file
        result = self.write_json(data, file_path)
        
        # Return 1 if the writing process is successful
        if result == 1:
            return 1
        else:
            return 0
```",0.11019283746556471,0.12708044545916225,0.8936170212765957,0.35,0.5029940079314426,0.7391304347826086,0.21610169491525424,0.3344262260072024,0.8936170212765957,0.35,0.5029940079314426
Llama,51,"import numpy as np


class KappaCalculator:

    @staticmethod
    def kappa(testData, k):
        dataMat = np.mat(testData)
        P0 = 0.0
        for i in range(k):
            P0 += dataMat[i, i] * 1.0
        xsum = np.sum(dataMat, axis=1)
        ysum = np.sum(dataMat, axis=0)
        sum = np.sum(dataMat)
        Pe = float(ysum * xsum) / sum / sum
        P0 = float(P0 / sum * 1.0)
        cohens_coefficient = float((P0 - Pe) / (1 - Pe))
        return cohens_coefficient

    @staticmethod
    def fleiss_kappa(testData, N, k, n):
        dataMat = np.mat(testData, float)
        oneMat = np.ones((k, 1))
        sum = 0.0
        P0 = 0.0
        for i in range(N):
            temp = 0.0
            for j in range(k):
                sum += dataMat[i, j]
                temp += 1.0 * dataMat[i, j] ** 2
            temp -= n
            temp /= (n - 1) * n
            P0 += temp
        P0 = 1.0 * P0 / N
        ysum = np.sum(dataMat, axis=0)
        for i in range(k):
            ysum[0, i] = (ysum[0, i] / sum) ** 2
        Pe = ysum * oneMat * 1.0
        ans = (P0 - Pe) / (1 - Pe)
        return ans[0, 0]",COT,"

```python
import numpy as np

class KappaCalculator:
    @staticmethod
    def kappa(testData, k):
        # Calculate the Cohen's kappa value of a k-dimensional matrix
        # testData: k-dimensional matrix
        # k: Matrix dimension
        # Return the cohen's kappa value of the matrix as float
        
        # Calculate the observed agreement (Po)
        Po = 0
        for i in range(k):
            Po += testData[i][i]
        Po /= sum(sum(row) for row in testData)
        
        # Calculate the expected agreement (Pe)
        Pe = 0
        row_sums = [sum(row) for row in testData]
        col_sums = [sum(col) for col in zip(*testData)]
        total = sum(row_sums)
        for i in range(k):
            Pe += (row_sums[i] * col_sums[i]) / (total ** 2)
        
        # Calculate the Cohen's kappa value
        kappa = (Po - Pe) / (1 - Pe)
        return kappa

    @staticmethod
    def fleiss_kappa(testData, N, k, n):
        # Calculate the Fleiss kappa value of an N * k matrix
        # testData: Input data matrix, N * k
        # N: Number of samples
        # k: Number of categories
        # n: Number of raters
        # Return Fleiss kappa value as float
        
        # Calculate the proportion of raters who assigned each category to each item
        proportions = np.array(testData) / n
        
        # Calculate the average proportion of raters who assigned each category
        average_proportions = np.mean(proportions, axis=0)
        
        # Calculate the observed agreement (P)
        P = (np.sum(np.square(proportions), axis=1) - 1) / (n * (n - 1))
        P_bar = np.mean(P)
        
        # Calculate the expected agreement (Pe)
        Pe = np.sum(np.square(average_proportions))
        
        # Calculate the Fleiss kappa value
        kappa = (P_bar - Pe) / (1 - Pe)
        return kappa
```",0.0975609756097561,0.1309893959765292,0.5138888888888888,0.3274336283185841,0.3999999952455807,0.2076923076923077,0.15168539325842698,0.17532467044611247,0.4861111111111111,0.30973451327433627,0.3783783736239591
Llama,52,"import nltk
from nltk.stem import WordNetLemmatizer
from nltk import pos_tag, word_tokenize
import string

nltk.download('averaged_perceptron_tagger')
nltk.download('punkt')
nltk.download('wordnet')


class Lemmatization:
    def __init__(self):
        self.lemmatizer = WordNetLemmatizer()

    def lemmatize_sentence(self, sentence):
        lemmatized_words = []
        sentence = self.remove_punctuation(sentence)
        words = word_tokenize(sentence)
        tagged_words = pos_tag(words)
        for word, tag in tagged_words:
            if tag.startswith('V'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='v')
            elif tag.startswith('J'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='a')
            elif tag.startswith('R'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='r')
            else:
                lemmatized_word = self.lemmatizer.lemmatize(word)
            lemmatized_words.append(lemmatized_word)
        return lemmatized_words

    def get_pos_tag(self, sentence):
        pos_tags = []
        sentence = self.remove_punctuation(sentence)
        words = word_tokenize(sentence)
        tagged_words = pos_tag(words)
        for tagged_word in tagged_words:
            pos_tags.append(tagged_word[1])
        return pos_tags

    def remove_punctuation(self, sentence):
        return sentence.translate(str.maketrans('', '', string.punctuation))",COT,"

```python
import nltk
from nltk.stem import WordNetLemmatizer
from nltk import pos_tag, word_tokenize
import string

# Download required NLTK data
nltk.download('averaged_perceptron_tagger')
nltk.download('punkt')
nltk.download('wordnet')

class Lemmatization:
    def __init__(self):
        # Create a WordNetLemmatizer object and store it in the self.lemmatizer member variable
        self.lemmatizer = WordNetLemmatizer()

    def remove_punctuation(self, sentence):
        # Remove punctuation from the input text
        return sentence.translate(str.maketrans('', '', string.punctuation))

    def get_pos_tag(self, sentence):
        # Remove punctuations of the sentence
        sentence_without_punctuation = self.remove_punctuation(sentence)
        
        # Tokenize the input sentence
        tokens = word_tokenize(sentence_without_punctuation)
        
        # Mark the part of speech tag of each word
        pos_tags = pos_tag(tokens)
        
        # Return part of speech tag of each word in the sentence as list
        return [tag[1] for tag in pos_tags]

    def lemmatize_sentence(self, sentence):
        # Remove punctuations of the sentence
        sentence_without_punctuation = self.remove_punctuation(sentence)
        
        # Tokenize the input sentence
        tokens = word_tokenize(sentence_without_punctuation)
        
        # Mark the part of speech tag of each word
        pos_tags = pos_tag(tokens)
        
        # Lemmatize the words with different parameters based on their parts of speech
        lemmatized_words = []
        for word, tag in pos_tags:
            if tag.startswith('J'):
                lemmatized_word = self.lemmatizer.lemmatize(word, 'a')
            elif tag.startswith('V'):
                lemmatized_word = self.lemmatizer.lemmatize(word, 'v')
            elif tag.startswith('N'):
                lemmatized_word = self.lemmatizer.lemmatize(word, 'n')
            elif tag.startswith('R'):
                lemmatized_word = self.lemmatizer.lemmatize(word, 'r')
            else:
                lemmatized_word = word
            lemmatized_words.append(lemmatized_word)
        
        # Return a list of words which have been lemmatized
        return lemmatized_words
```",0.16748768472906403,0.2042738156041148,0.8245614035087719,0.46078431372549017,0.5911949639539575,0.6373626373626373,0.3558282208588957,0.4566929087875876,0.8245614035087719,0.46078431372549017,0.5911949639539575
Llama,53,"import re
import string


class LongestWord:

    def __init__(self):
        self.word_list = []

    def add_word(self, word):
        self.word_list.append(word)

    def find_longest_word(self, sentence):
        longest_word = """"
        sentence = sentence.lower()
        sentence = re.sub('[%s]' % re.escape(string.punctuation), '', sentence)
        sentence = re.split(' ', sentence)
        for word in sentence:
            if word in self.word_list and len(word) > len(longest_word):
                longest_word = word
        return longest_word",COT,"

```python
import re
import string

class LongestWord:
    # Constructor to initialize the word list
    def __init__(self):
        # Initialize an empty list to store words
        self.word_list = []

    # Method to add a word to the word list
    def add_word(self, word):
        # Append the input word to the word list
        self.word_list.append(word)

    # Method to find the longest word in a sentence that is in the word list
    def find_longest_word(self, sentence):
        # Remove punctuation marks from the sentence
        sentence_no_punct = re.sub('['+string.punctuation+']', '', sentence)
        
        # Split the sentence into a list of words
        words_in_sentence = sentence_no_punct.split()
        
        # Initialize the longest word and its length
        longest_word = ''
        max_length = 0
        
        # Iterate over each word in the sentence
        for word in words_in_sentence:
            # Check if the word is in the word list and its length is greater than the current max length
            if word in self.word_list and len(word) > max_length:
                # Update the longest word and its length
                longest_word = word
                max_length = len(word)
        
        # Return the longest word that is in the word list, or an empty string if the word list is empty
        return longest_word if self.word_list else ''
```",0.07486631016042782,0.09608709950819472,0.7368421052631579,0.34146341463414637,0.46666666233888904,0.48148148148148145,0.17687074829931973,0.25870646373208583,0.7368421052631579,0.34146341463414637,0.46666666233888904
Llama,54,"import random


class MahjongConnect:
    def __init__(self, BOARD_SIZE, ICONS):
        self.BOARD_SIZE = BOARD_SIZE
        self.ICONS = ICONS
        self.board = self.create_board()

    def create_board(self):
        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]
        return board

    def is_valid_move(self, pos1, pos2):
        x1, y1 = pos1
        x2, y2 = pos2

        # Check if positions are within the game board range
        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and 0 <= x2 < self.BOARD_SIZE[
            0] and 0 <= y2 <
                self.BOARD_SIZE[1]):
            return False

        # Check if the two positions are the same
        if pos1 == pos2:
            return False

        # Check if the two positions have the same icon
        if self.board[x1][y1] != self.board[x2][y2]:
            return False

        # Check if there is a valid path between the two positions
        if not self.has_path(pos1, pos2):
            return False

        return True

    def has_path(self, pos1, pos2):
        visited = set()
        stack = [pos1]

        while stack:
            current_pos = stack.pop()
            if current_pos == pos2:
                return True

            if current_pos in visited:
                continue

            visited.add(current_pos)
            x, y = current_pos

            # Check adjacent positions (up, down, left, right)
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                new_x, new_y = x + dx, y + dy
                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:
                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:
                        stack.append((new_x, new_y))

        return False

    def remove_icons(self, pos1, pos2):
        x1, y1 = pos1
        x2, y2 = pos2
        self.board[x1][y1] = ' '
        self.board[x2][y2] = ' '

    def is_game_over(self):
        for row in self.board:
            if any(icon != ' ' for icon in row):
                return False
        return True",COT,"

```python
import random

class MahjongConnect:
    def __init__(self, BOARD_SIZE, ICONS):
        # Initialize the board size and the icon list
        self.BOARD_SIZE = BOARD_SIZE
        self.ICONS = ICONS
        # Create the game board
        self.board = self.create_board()

    def create_board(self):
        # Create the game board with the given board size and icons
        board = []
        for _ in range(self.BOARD_SIZE[0]):
            row = []
            for _ in range(self.BOARD_SIZE[1]):
                # Randomly select an icon from the icon list
                row.append(random.choice(self.ICONS))
            board.append(row)
        return board

    def is_valid_move(self, pos1, pos2):
        # Check if the move of two icons is valid
        # Check if positions are within the game board range
        if (pos1[0] < 0 or pos1[0] >= self.BOARD_SIZE[0] or 
            pos1[1] < 0 or pos1[1] >= self.BOARD_SIZE[1] or 
            pos2[0] < 0 or pos2[0] >= self.BOARD_SIZE[0] or 
            pos2[1] < 0 or pos2[1] >= self.BOARD_SIZE[1]):
            return False
        # Check if the two positions are not the same
        if pos1 == pos2:
            return False
        # Check if the two positions have the same icon
        if self.board[pos1[0]][pos1[1]] != self.board[pos2[0]][pos2[1]]:
            return False
        # Check if there is a valid path between the two positions
        if not self.has_path(pos1, pos2):
            return False
        return True

    def has_path(self, pos1, pos2):
        # Check if there is a path between two icons
        # Define the possible movements (up, down, left, right)
        movements = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        # Perform a depth-first search to find a path
        def dfs(pos, visited):
            if pos == pos2:
                return True
            visited.add(pos)
            for movement in movements:
                new_pos = (pos[0] + movement[0], pos[1] + movement[1])
                if (0 <= new_pos[0] < self.BOARD_SIZE[0] and 
                    0 <= new_pos[1] < self.BOARD_SIZE[1] and 
                    new_pos not in visited and 
                    self.board[new_pos[0]][new_pos[1]] == self.board[pos1[0]][pos1[1]]):
                    if dfs(new_pos, visited):
                        return True
            return False
        return dfs(pos1, set())

    def remove_icons(self, pos1, pos2):
        # Remove the connected icons on the game board
        self.board[pos1[0]][pos1[1]] = ' '
        self.board[pos2[0]][pos2[1]] = ' '

    def is_game_over(self):
        # Check if the game is over (i.e., if there are no more icons on the game board)
        for row in self.board:
            for icon in row:
                if icon != ' ':
                    return False
        return True
```",0.3074626865671642,0.35378470910395154,0.6341463414634146,0.5306122448979592,0.577777772817284,0.5,0.4051094890510949,0.4475806402162461,0.6341463414634146,0.5306122448979592,0.577777772817284
Llama,55,"class Manacher:
    def __init__(self, input_string) -> None:
        self.input_string = input_string

    def palindromic_length(self, center, diff, string):
        if (center - diff == -1 or center + diff == len(string)
                or string[center - diff] != string[center + diff]):
            return 0
        return 1 + self.palindromic_length(center, diff + 1, string)


    def palindromic_string(self):
        max_length = 0

        new_input_string = """"
        output_string = """"

        for i in self.input_string[:len(self.input_string) - 1]:
            new_input_string += i + ""|""
        new_input_string += self.input_string[-1]

        for i in range(len(new_input_string)):

            length =self.palindromic_length(i, 1, new_input_string)

            if max_length < length:
                max_length = length
                start = i

        for i in new_input_string[start - max_length:start + max_length + 1]:
            if i != ""|"":
                output_string += i

        return output_string",COT,"

```python
class Manacher:
    def __init__(self, input_string):
        # Initialize the Manacher class with the given input_string.
        self.input_string = input_string

    def palindromic_length(self, center, diff, string):
        # Recursively calculate the length of the palindromic substring based on a given center, difference value, and input string.
        if center - diff < 0 or center + diff >= len(string) or string[center - diff] != string[center + diff]:
            return diff * 2 + 1 if string[center] != '|' else diff * 2
        else:
            return self.palindromic_length(center, diff + 1, string)

    def palindromic_string(self):
        # Preprocess the input string to handle even-length palindromes.
        string = '|'.join(self.input_string)
        string = '|' + string + '|'
        
        # Initialize variables to store the maximum length and center of the longest palindromic substring.
        max_length = 0
        center = 0
        
        # Iterate over the preprocessed string to find the longest palindromic substring.
        for i in range(len(string)):
            length = self.palindromic_length(i, 0, string)
            if length > max_length:
                max_length = length
                center = i
        
        # Extract the longest palindromic substring from the preprocessed string.
        longest_palindrome = string[center - max_length // 2 + 1:center + max_length // 2]
        
        # Remove the '|' characters from the longest palindromic substring.
        longest_palindrome = longest_palindrome.replace('|', '')
        
        return longest_palindrome
```",0.12371134020618557,0.15657859085225362,0.6206896551724138,0.3829787234042553,0.4736842058067868,0.34951456310679613,0.20809248554913296,0.260869560539015,0.603448275862069,0.3723404255319149,0.46052631106994457
Llama,56,"class MetricsCalculator:
    def __init__(self):
        self.true_positives = 0
        self.false_positives = 0
        self.false_negatives = 0
        self.true_negatives = 0

    def update(self, predicted_labels, true_labels):
        for predicted, true in zip(predicted_labels, true_labels):
            if predicted == 1 and true == 1:
                self.true_positives += 1
            elif predicted == 1 and true == 0:
                self.false_positives += 1
            elif predicted == 0 and true == 1:
                self.false_negatives += 1
            elif predicted == 0 and true == 0:
                self.true_negatives += 1

    def precision(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        if self.true_positives + self.false_positives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_positives)

    def recall(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        if self.true_positives + self.false_negatives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_negatives)

    def f1_score(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        precision = self.precision(predicted_labels, true_labels)
        recall = self.recall(predicted_labels, true_labels)
        if precision + recall == 0.0:
            return 0.0
        return (2 * precision * recall) / (precision + recall)

    def accuracy(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives
        if total == 0:
            return 0.0
        return (self.true_positives + self.true_negatives) / total",COT,"

```python
class MetricsCalculator:
    def __init__(self):
        # Initialize the number of all four samples to 0
        self.true_positives = 0
        self.false_positives = 0
        self.false_negatives = 0
        self.true_negatives = 0

    def update(self, predicted_labels, true_labels):
        # Update the number of all four samples
        for predicted, true in zip(predicted_labels, true_labels):
            if predicted == 1 and true == 1:
                self.true_positives += 1
            elif predicted == 1 and true == 0:
                self.false_positives += 1
            elif predicted == 0 and true == 1:
                self.false_negatives += 1
            elif predicted == 0 and true == 0:
                self.true_negatives += 1

    def precision(self, predicted_labels, true_labels):
        # Calculate precision
        # Initialize the number of all four samples to 0
        tp = 0
        fp = 0
        fn = 0
        tn = 0
        # Update the number of all four samples
        for predicted, true in zip(predicted_labels, true_labels):
            if predicted == 1 and true == 1:
                tp += 1
            elif predicted == 1 and true == 0:
                fp += 1
            elif predicted == 0 and true == 1:
                fn += 1
            elif predicted == 0 and true == 0:
                tn += 1
        # Calculate precision
        if tp + fp == 0:
            return 0.0
        else:
            return tp / (tp + fp)

    def recall(self, predicted_labels, true_labels):
        # Calculate recall
        # Initialize the number of all four samples to 0
        tp = 0
        fp = 0
        fn = 0
        tn = 0
        # Update the number of all four samples
        for predicted, true in zip(predicted_labels, true_labels):
            if predicted == 1 and true == 1:
                tp += 1
            elif predicted == 1 and true == 0:
                fp += 1
            elif predicted == 0 and true == 1:
                fn += 1
            elif predicted == 0 and true == 0:
                tn += 1
        # Calculate recall
        if tp + fn == 0:
            return 0.0
        else:
            return tp / (tp + fn)

    def f1_score(self, predicted_labels, true_labels):
        # Calculate f1 score
        precision = self.precision(predicted_labels, true_labels)
        recall = self.recall(predicted_labels, true_labels)
        # Calculate f1 score
        if precision + recall == 0:
            return 0.0
        else:
            return 2 * (precision * recall) / (precision + recall)

    def accuracy(self, predicted_labels, true_labels):
        # Calculate accuracy
        # Initialize the number of all four samples to 0
        tp = 0
        fp = 0
        fn = 0
        tn = 0
        # Update the number of all four samples
        for predicted, true in zip(predicted_labels, true_labels):
            if predicted == 1 and true == 1:
                tp += 1
            elif predicted == 1 and true == 0:
                fp += 1
            elif predicted == 0 and true == 1:
                fn += 1
            elif predicted == 0 and true == 0:
                tn += 1
        # Calculate accuracy
        total = tp + fp + fn + tn
        if total == 0:
            return 0.0
        else:
            return (tp + tn) / total
```",0.21603563474387527,0.23864588368251305,0.88,0.6285714285714286,0.7333333284722223,0.6972477064220184,0.49673202614379086,0.5801526668967427,0.88,0.6285714285714286,0.7333333284722223
Llama,57,"import numpy as np


class MetricsCalculator2:
    def __init__(self):
        pass

    @staticmethod
    def mrr(data):
        if type(data) != list and type(data) != tuple:
            raise Exception(""the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple"")

        if len(data) == 0:
            return 0.0, [0.0]
        if type(data) == tuple:
            (sub_list, total_num) = data
            sub_list = np.array(sub_list)
            if total_num == 0:
                return 0.0, [0.0]
            else:
                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                mr_np = sub_list * ranking_array

                mr = 0.0
                for team in mr_np:
                    if team > 0:
                        mr = team
                        break
                return mr, [mr]

        if type(data) == list:
            separate_result = []
            for (sub_list, total_num) in data:
                sub_list = np.array(sub_list)

                if total_num == 0:
                    mr = 0.0
                else:
                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                    mr_np = sub_list * ranking_array

                    mr = 0.0
                    for team in mr_np:
                        if team > 0:
                            mr = team
                            break

                separate_result.append(mr)
            return np.mean(separate_result), separate_result

    @staticmethod
    def map(data):
        if type(data) != list and type(data) != tuple:
            raise Exception(""the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple"")

        if len(data) == 0:
            return 0.0, [0.0]
        if type(data) == tuple:
            (sub_list, total_num) = data
            sub_list = np.array(sub_list)
            if total_num == 0:
                return 0.0, [0.0]
            else:
                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)

                right_ranking_list = []
                count = 1
                for t in sub_list:
                    if t == 0:
                        right_ranking_list.append(0)
                    else:
                        right_ranking_list.append(count)
                        count += 1

                ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num
                return ap, [ap]

        if type(data) == list:
            separate_result = []
            for (sub_list, total_num) in data:
                sub_list = np.array(sub_list)

                if total_num == 0:
                    ap = 0.0
                else:
                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)

                    right_ranking_list = []
                    count = 1
                    for t in sub_list:
                        if t == 0:
                            right_ranking_list.append(0)
                        else:
                            right_ranking_list.append(count)
                            count += 1

                    ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num

                separate_result.append(ap)
            return np.mean(separate_result), separate_result",COT,"

```python
import numpy as np

class MetricsCalculator2:
    def __init__(self):
        pass

    @staticmethod
    def mrr(data):
        # Check if input data is a tuple or a list of tuples
        if isinstance(data, tuple):
            # Calculate MRR for a single tuple
            actual_result, ground_truth_num = data
            reciprocal_ranks = []
            for i, result in enumerate(actual_result):
                if result == 1:
                    reciprocal_ranks.append(1 / (i + 1))
            mrr_value = np.mean(reciprocal_ranks) if reciprocal_ranks else 0
            precision_values = [mrr_value]
            return mrr_value, precision_values
        elif isinstance(data, list):
            # Calculate MRR for a list of tuples
            mrr_values = []
            precision_values = []
            for item in data:
                mrr_value, precision_value = MetricsCalculator2.mrr(item)
                mrr_values.append(mrr_value)
                precision_values.append(precision_value[0])
            average_mrr = np.mean(mrr_values)
            return average_mrr, precision_values
        else:
            raise ValueError(""Invalid input data"")

    @staticmethod
    def map(data):
        # Check if input data is a tuple or a list of tuples
        if isinstance(data, tuple):
            # Calculate MAP for a single tuple
            actual_result, ground_truth_num = data
            precision_values = []
            true_positives = 0
            for i, result in enumerate(actual_result):
                true_positives += result
                precision = true_positives / (i + 1)
                precision_values.append(precision)
            average_precision = np.mean(precision_values) if precision_values else 0
            return average_precision, [average_precision]
        elif isinstance(data, list):
            # Calculate MAP for a list of tuples
            map_values = []
            precision_values = []
            for item in data:
                average_precision, precision_value = MetricsCalculator2.map(item)
                map_values.append(average_precision)
                precision_values.append(precision_value[0])
            average_map = np.mean(map_values)
            return average_map, precision_values
        else:
            raise ValueError(""Invalid input data"")
```",0.042016902070507775,0.07471294683185965,0.38823529411764707,0.3707865168539326,0.37931033983022866,0.15172413793103448,0.1506849315068493,0.15120274414095267,0.3764705882352941,0.3595505617977528,0.36781608695666534
Llama,58,"import random

class MinesweeperGame:
    def __init__(self, n, k) -> None:
        self.n = n
        self.k = k
        self.minesweeper_map = self.generate_mine_sweeper_map()
        self.player_map = self.generate_playerMap()
        self.score = 0

    def generate_mine_sweeper_map(self):
        arr = [[0 for row in range(self.n)] for column in range(self.n)]
        for num in range(self.k):
            x = random.randint(0, self.n-1)
            y = random.randint(0, self.n-1)
            arr[y][x] = 'X'
            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-1):
                if arr[y][x+1] != 'X':
                    arr[y][x+1] += 1
            if (x >=1 and x <= self.n-1) and (y >= 0 and y <= self.n-1):
                if arr[y][x-1] != 'X':
                    arr[y][x-1] += 1
            if (x >= 1 and x <= self.n-1) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x-1] != 'X':
                    arr[y-1][x-1] += 1
    
            if (x >= 0 and x <= self.n-2) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x+1] != 'X':
                    arr[y-1][x+1] += 1 
            if (x >= 0 and x <= self.n-1) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x] != 'X':
                    arr[y-1][x] += 1
    
            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x+1] != 'X':
                    arr[y+1][x+1] += 1
            if (x >= 1 and x <= self.n-1) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x-1] != 'X':
                    arr[y+1][x-1] += 1
            if (x >= 0 and x <= self.n-1) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x] != 'X':
                    arr[y+1][x] += 1
        return arr
    
    def generate_playerMap(self):
        arr = [['-' for row in range(self.n)] for column in range(self.n)]
        return arr

    def check_won(self, map):
        for i in range(self.n):
            for j in range(self.n):
                if map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':
                    return False
        return True
    
    def sweep(self, x, y):

        if (self.minesweeper_map[x][y] == 'X'):
            return False
        else:
            self.player_map[x][y] = self.minesweeper_map[x][y]
            self.score += 1
            if self.check_won(self.player_map) == True:
                return True
            return self.player_map",COT,"

```python
import random

class MinesweeperGame:
    def __init__(self, n, k):
        """"""
        Initializes the MinesweeperGame class with the size of the board and the number of mines.
        
        Args:
            n (int): The size of the board.
            k (int): The number of mines.
        """"""
        self.n = n
        self.k = k
        self.minesweeper_map = self.generate_mine_sweeper_map()
        self.player_map = self.generate_playerMap()
        self.score = 0

    def generate_mine_sweeper_map(self):
        """"""
        Generates a minesweeper map with the given size of the board and the number of mines.
        
        Returns:
            list: The minesweeper map as a 2D list.
        """"""
        # Initialize an empty map with all zeros
        map = [[0 for _ in range(self.n)] for _ in range(self.n)]
        
        # Randomly place the mines
        mines_placed = 0
        while mines_placed < self.k:
            x, y = random.randint(0, self.n-1), random.randint(0, self.n-1)
            if map[x][y] != 'X':
                map[x][y] = 'X'
                mines_placed += 1
        
        # Update the map with the number of mines around each position
        for i in range(self.n):
            for j in range(self.n):
                if map[i][j] != 'X':
                    count = 0
                    for x in range(max(0, i-1), min(self.n, i+2)):
                        for y in range(max(0, j-1), min(self.n, j+2)):
                            if map[x][y] == 'X':
                                count += 1
                    map[i][j] = count
        
        return map

    def generate_playerMap(self):
        """"""
        Generates a player map with the given size of the board.
        
        Returns:
            list: The player map as a 2D list.
        """"""
        # Initialize an empty map with all unknown positions
        return [['-' for _ in range(self.n)] for _ in range(self.n)]

    def check_won(self, map):
        """"""
        Checks whether the player has won the game.
        
        Args:
            map (list): The player map.
        
        Returns:
            bool: True if the player has won, False otherwise.
        """"""
        # Check if all non-mine positions are revealed
        for i in range(self.n):
            for j in range(self.n):
                if self.minesweeper_map[i][j] != 'X' and map[i][j] == '-':
                    return False
        return True

    def sweep(self, x, y):
        """"""
        Sweeps the given position.
        
        Args:
            x (int): The x coordinate of the position.
            y (int): The y coordinate of the position.
        
        Returns:
            list or bool: The updated player map if the game continues, True if the player has won.
        """"""
        # Check if the position is a mine
        if self.minesweeper_map[x][y] == 'X':
            self.player_map[x][y] = 'X'
            return self.player_map
        else:
            # Reveal the position and recursively reveal adjacent positions
            self.player_map[x][y] = self.minesweeper_map[x][y]
            if self.minesweeper_map[x][y] == 0:
                for i in range(max(0, x-1), min(self.n, x+2)):
                    for j in range(max(0, y-1), min(self.n, y+2)):
                        if self.player_map[i][j] == '-':
                            self.sweep(i, j)
            # Check if the player has won
            if self.check_won(self.player_map):
                return True
            else:
                return self.player_map
```",0.10075566750629723,0.14003364491560916,0.6470588235294118,0.38461538461538464,0.48245613567443835,0.4093567251461988,0.23809523809523808,0.3010752641670483,0.6352941176470588,0.3776223776223776,0.47368420584987697
Llama,59,"from datetime import datetime
import numpy as np

class MovieBookingSystem:
    def __init__(self):
        self.movies = []

    def add_movie(self, name, price, start_time, end_time, n):
        movie = {
            'name': name,
            'price': price,
            'start_time': datetime.strptime(start_time, '%H:%M'),
            'end_time': datetime.strptime(end_time, '%H:%M'),
            'seats': np.zeros((n, n))
        }
        self.movies.append(movie)

    def book_ticket(self, name, seats_to_book):
        for movie in self.movies:
            if movie['name'] == name:
                for seat in seats_to_book:
                    if movie['seats'][seat[0]][seat[1]] == 0:
                        movie['seats'][seat[0]][seat[1]] = 1
                    else:
                        return ""Booking failed.""
                return ""Booking success.""
        return ""Movie not found.""


    def available_movies(self, start_time, end_time):
        start_time = datetime.strptime(start_time, '%H:%M')
        end_time = datetime.strptime(end_time, '%H:%M')

        available_movies = []
        for movie in self.movies:
            if start_time <= movie['start_time'] and movie['end_time'] <= end_time:
                available_movies.append(movie['name'])

        return available_movies",COT,"

```python
from datetime import datetime
import numpy as np

class MovieBookingSystem:
    def __init__(self):
        # Initialize an empty list to store movie information
        self.movies = []

    def add_movie(self, name, price, start_time, end_time, n):
        # Convert start_time and end_time to datetime format
        start_time = datetime.strptime(start_time, '%H:%M')
        start_time = start_time.replace(year=1900, month=1, day=1)
        end_time = datetime.strptime(end_time, '%H:%M')
        end_time = end_time.replace(year=1900, month=1, day=1)
        
        # Create a new movie dictionary
        movie = {
            'name': name,
            'price': price,
            'start_time': start_time,
            'end_time': end_time,
            'seats': np.zeros((n, n))
        }
        
        # Add the new movie to the list
        self.movies.append(movie)

    def book_ticket(self, name, seats_to_book):
        # Find the movie with the given name
        for movie in self.movies:
            if movie['name'] == name:
                # Check if the seats are available
                for seat in seats_to_book:
                    row, col = seat
                    if movie['seats'][row, col] == 1:
                        return ""Booking failed.""
                
                # Book the seats
                for seat in seats_to_book:
                    row, col = seat
                    movie['seats'][row, col] = 1
                
                return ""Booking success.""
        
        # If the movie is not found
        return ""Movie not found.""

    def available_movies(self, start_time, end_time):
        # Convert start_time and end_time to datetime format
        start_time = datetime.strptime(start_time, '%H:%M')
        start_time = start_time.replace(year=1900, month=1, day=1)
        end_time = datetime.strptime(end_time, '%H:%M')
        end_time = end_time.replace(year=1900, month=1, day=1)
        
        # Initialize an empty list to store available movie names
        available_movie_names = []
        
        # Iterate over the movies
        for movie in self.movies:
            # Check if the movie is within the given time range
            if start_time <= movie['start_time'] < end_time or start_time < movie['end_time'] <= end_time:
                available_movie_names.append(movie['name'])
        
        return available_movie_names
```",0.23109243697478996,0.2594999258740549,0.927536231884058,0.5818181818181818,0.7150837941450018,0.7211538461538461,0.3968253968253968,0.5119453879122646,0.927536231884058,0.5818181818181818,0.7150837941450018
Llama,5,"class AutomaticGuitarSimulator:
    def __init__(self, text) -> None:
        self.play_text = text

    def interpret(self, display=False):
        if len(self.play_text) == 0:
            return
        else:
            play_list = []
            play_segs = self.play_text.split("" "")
            for play_seg in play_segs:
                pos = 0
                for ele in play_seg:
                    if ele.isalpha():
                        pos += 1
                        continue
                    break
                play_chord = play_seg[0:pos]
                play_value = play_seg[pos:]
                play_list.append({'Chord': play_chord, 'Tune': play_value})
                if display:
                    self.display(play_chord, play_value)
            return play_list

    def display(self, key, value):
        return ""Normal Guitar Playing -- Chord: %s, Play Tune: %s"" % (key, value)",COT,"

```python
class AutomaticGuitarSimulator:
    # Constructor method to initialize the score to be played
    def __init__(self, text):
        """"""
        Initialize the score to be played.
        
        Args:
            text (str): The score to be played.
        """"""
        self.play_text = text

    # Method to interpret the music score to be played
    def interpret(self, display=False):
        """"""
        Interpret the music score to be played.
        
        Args:
            display (bool): Whether to print the interpreted score. Defaults to False.
        
        Returns:
            list: A list of dictionaries containing the chord and tune.
        """"""
        # Split the input text into individual notes
        notes = self.play_text.split()
        
        # Initialize an empty list to store the interpreted notes
        play_list = []
        
        # Iterate over each note
        for note in notes:
            # Extract the chord and tune from the note
            chord = ''
            tune = ''
            for char in note:
                if char.isalpha():
                    chord += char
                else:
                    tune += char
            
            # Add the interpreted note to the list
            play_list.append({'Chord': chord, 'Tune': tune})
        
        # If display is True, print the interpreted score
        if display:
            for note in play_list:
                print(f""Normal Guitar Playing -- Chord: {note['Chord']}, Play Tune: {note['Tune']}"")
        
        # Return the list of interpreted notes
        return play_list

    # Method to print out chord and play tune
    def display(self, key, value):
        """"""
        Print out chord and play tune.
        
        Args:
            key (str): The chord.
            value (str): The play tune.
        
        Returns:
            str: A string representing the chord and play tune.
        """"""
        # Return a string representing the chord and play tune
        return f""Normal Guitar Playing -- Chord: {key}, Play Tune: {value}""
```",0.02845528455284553,0.040072531661017395,0.484375,0.27927927927927926,0.35428570964636735,0.24390243902439024,0.10471204188481675,0.14652014231721894,0.4375,0.25225225225225223,0.31999999536065304
Llama,60,"import sqlite3


class MovieTicketDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS tickets (
                id INTEGER PRIMARY KEY,
                movie_name TEXT,
                theater_name TEXT,
                seat_number TEXT,
                customer_name TEXT
            )
        ''')
        self.connection.commit()

    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):
        self.cursor.execute('''
            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)
            VALUES (?, ?, ?, ?)
        ''', (movie_name, theater_name, seat_number, customer_name))
        self.connection.commit()

    def search_tickets_by_customer(self, customer_name):
        self.cursor.execute('''
            SELECT * FROM tickets WHERE customer_name = ?
        ''', (customer_name,))
        tickets = self.cursor.fetchall()
        return tickets

    def delete_ticket(self, ticket_id):
        self.cursor.execute('''
            DELETE FROM tickets WHERE id = ?
        ''', (ticket_id,))
        self.connection.commit()",COT,"

```python
import sqlite3

class MovieTicketDB:
    def __init__(self, db_name):
        # Initialize the MovieTicketDB object with the specified database name
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        # Create the ""tickets"" table if it does not exist already
        self.create_table()

    def create_table(self):
        # Creates a ""tickets"" table in the database if it does not exist already
        # Fields include ID of type int, movie name of type str, theater name of type str, seat number of type str, and customer name of type str
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS tickets
            (id INTEGER PRIMARY KEY AUTOINCREMENT, 
             movie_name TEXT, 
             theater_name TEXT, 
             seat_number TEXT, 
             customer_name TEXT)
        ''')
        self.connection.commit()

    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):
        # Insert a new ticket into the ""tickets"" table
        self.cursor.execute('''
            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)
            VALUES (?, ?, ?, ?)
        ''', (movie_name, theater_name, seat_number, customer_name))
        self.connection.commit()

    def search_tickets_by_customer(self, customer_name):
        # Search for tickets in the ""tickets"" table by customer name
        self.cursor.execute('''
            SELECT * FROM tickets
            WHERE customer_name = ?
        ''', (customer_name,))
        return self.cursor.fetchall()

    def delete_ticket(self, ticket_id):
        # Delete a ticket from the ""tickets"" table by ticket ID
        self.cursor.execute('''
            DELETE FROM tickets
            WHERE id = ?
        ''', (ticket_id,))
        self.connection.commit()
```",0.3475935828877005,0.37505027299461485,0.9375,0.5454545454545454,0.6896551677632449,0.8085106382978723,0.4662576687116564,0.5914396840763675,0.921875,0.5363636363636364,0.6781609148896817
Llama,61,"class MusicPlayer:
    def __init__(self):
        self.playlist = []
        self.current_song = None
        self.volume = 50

    def add_song(self, song):
        self.playlist.append(song)

    def remove_song(self, song):
        if song in self.playlist:
            self.playlist.remove(song)
            if self.current_song == song:
                self.stop()

    def play(self):
        if self.playlist and self.current_song:
            return self.playlist[0]
        elif len(self.playlist): 
            return False

    def stop(self):
        if self.current_song:
            self.current_song = None
            return True
        else:
            return False

    def switch_song(self):
        if self.current_song:
            current_index = self.playlist.index(self.current_song)
            if current_index < len(self.playlist) - 1:
                self.current_song = self.playlist[current_index + 1]
                return True
            else:
                return False
        else:
            return False

    def previous_song(self):
        if self.current_song:
            current_index = self.playlist.index(self.current_song)
            if current_index > 0:
                self.current_song = self.playlist[current_index - 1]
                return True
            else:
                return False
        else:
            return False

    def set_volume(self, volume):
        if 0 <= volume <= 100:
            self.volume = volume
        else:
            return False

    def shuffle(self):
        if self.playlist:
            import random
            random.shuffle(self.playlist)
            return True
        else:
            return False",COT,"

```python
class MusicPlayer:
    # Constructor to initialize the music player
    def __init__(self):
        # Initialize the playlist as an empty list
        self.playlist = []
        # Initialize the current song as None
        self.current_song = None
        # Initialize the volume to 50
        self.volume = 50

    # Method to add a song to the playlist
    def add_song(self, song):
        # Add the song to the playlist
        self.playlist.append(song)
        # If the playlist had no songs, set the current song to the newly added song
        if len(self.playlist) == 1:
            self.current_song = song

    # Method to remove a song from the playlist
    def remove_song(self, song):
        # Check if the song is in the playlist
        if song in self.playlist:
            # Remove the song from the playlist
            self.playlist.remove(song)
            # If the removed song was the current song, update the current song
            if song == self.current_song:
                # If the playlist is not empty, set the current song to the first song
                if self.playlist:
                    self.current_song = self.playlist[0]
                # If the playlist is empty, set the current song to None
                else:
                    self.current_song = None

    # Method to play the current song
    def play(self):
        # Return the current song if it exists, otherwise return False
        return self.current_song if self.current_song else False

    # Method to stop the current song
    def stop(self):
        # If there is a current song, stop it and return True
        if self.current_song:
            self.current_song = None
            return True
        # If there is no current song, return False
        else:
            return False

    # Method to switch to the next song
    def switch_song(self):
        # Check if there is a current song
        if self.current_song:
            # Find the index of the current song in the playlist
            current_index = self.playlist.index(self.current_song)
            # Check if there is a next song
            if current_index < len(self.playlist) - 1:
                # Switch to the next song
                self.current_song = self.playlist[current_index + 1]
                return True
            # If there is no next song, return False
            else:
                return False
        # If there is no current song, return False
        else:
            return False

    # Method to switch to the previous song
    def previous_song(self):
        # Check if there is a current song
        if self.current_song:
            # Find the index of the current song in the playlist
            current_index = self.playlist.index(self.current_song)
            # Check if there is a previous song
            if current_index > 0:
                # Switch to the previous song
                self.current_song = self.playlist[current_index - 1]
                return True
            # If there is no previous song, return False
            else:
                return False
        # If there is no current song, return False
        else:
            return False

    # Method to set the volume
    def set_volume(self, volume):
        # Check if the volume is between 0 and 100
        if 0 <= volume <= 100:
            # Set the volume
            self.volume = volume
            return True
        # If the volume is invalid, return False
        else:
            return False

    # Method to shuffle the playlist
    def shuffle(self):
        # Check if the playlist is not empty
        if self.playlist:
            # Shuffle the playlist
            import random
            random.shuffle(self.playlist)
            # Update the current song to the first song in the shuffled playlist
            self.current_song = self.playlist[0]
            return True
        # If the playlist is empty, return False
        else:
            return False
```",0.09741550695825048,0.11796845294061392,0.9322033898305084,0.47413793103448276,0.6285714241018775,0.6634615384615384,0.27165354330708663,0.3854748562129771,0.9322033898305084,0.47413793103448276,0.6285714241018775
Llama,62,"class NLPDataProcessor:

    def construct_stop_word_list(self):
        stop_word_list = ['a', 'an', 'the']
        return stop_word_list

    def remove_stop_words(self, string_list, stop_word_list):
        answer = []
        for string in string_list:
            string_split = string.split()
            for word in string_split:
                if word in stop_word_list:
                    string_split.remove(word)
            answer.append(string_split)
        return answer

    def process(self, string_list):
        stop_word_list = self.construct_stop_word_list()
        words_list = self.remove_stop_words(string_list, stop_word_list)
        return words_list",COT,"

```python
class NLPDataProcessor:
    def construct_stop_word_list(self):
        # Construct a stop word list including 'a', 'an', 'the'
        stop_word_list = ['a', 'an', 'the']
        return stop_word_list

    def remove_stop_words(self, string_list, stop_word_list):
        # Remove all the stop words from the list of strings
        result = []
        for string in string_list:
            words = string.split()
            filtered_words = [word for word in words if word.lower() not in stop_word_list]
            result.append(filtered_words)
        return result

    def process(self, string_list):
        # Construct a stop word list including 'a', 'an', 'the', and remove all the stop words from the list of strings
        stop_word_list = self.construct_stop_word_list()
        return self.remove_stop_words(string_list, stop_word_list)
```",0.1978021978021978,0.2379485722109027,0.7941176470588235,0.5,0.6136363588946282,0.58,0.3625,0.4461538414201184,0.7941176470588235,0.5,0.6136363588946282
Llama,63,"from collections import Counter
import re

class NLPDataProcessor2:

    def process_data(self, string_list):
        words_list = []
        for string in string_list:
            # Remove non-English letters and convert to lowercase
            processed_string = re.sub(r'[^a-zA-Z\s]', '', string.lower())
            # Split the string into words
            words = processed_string.split()
            words_list.append(words)
        return words_list

    def calculate_word_frequency(self, words_list):
        word_frequency = Counter()
        for words in words_list:
            word_frequency.update(words)
        sorted_word_frequency = dict(sorted(word_frequency.items(), key=lambda x: x[1], reverse=True))
        top_5_word_frequency = dict(list(sorted_word_frequency.items())[:5])
        return top_5_word_frequency

    def process(self, string_list):
        words_list = self.process_data(string_list)
        word_frequency_dict = self.calculate_word_frequency(words_list)
        return word_frequency_dict",COT,"

```python
from collections import Counter
import re

class NLPDataProcessor2:
    def process_data(self, string_list):
        # Keep only English letters and spaces in the string, 
        # then convert the string to lower case, and then split the string into a list of words.
        words_list = []
        for string in string_list:
            # Remove non-English letters and convert to lower case
            cleaned_string = re.sub('[^a-zA-Z\s]', '', string).lower()
            # Split the string into a list of words
            words = cleaned_string.split()
            words_list.append(words)
        return words_list

    def calculate_word_frequency(self, words_list):
        # Calculate the word frequency of each word in the list of words list, 
        # and sort the word frequency dictionary by value in descending order.
        # Flatten the list of words lists into a single list of words
        words = [word for sublist in words_list for word in sublist]
        # Calculate the word frequency using Counter
        word_frequency = Counter(words)
        # Sort the word frequency dictionary by value in descending order and get the top 5
        top_5_word_frequency = dict(sorted(word_frequency.items(), key=lambda item: item[1], reverse=True)[:5])
        return top_5_word_frequency

    def process(self, string_list):
        # Keep only English letters and spaces in the string, 
        # then convert the string to lower case, and then split the string into a list of words. 
        # Calculate the word frequency of each word in the list of words list, 
        # and sort the word frequency dictionary by value in descending order.
        words_list = self.process_data(string_list)
        top_5_word_frequency = self.calculate_word_frequency(words_list)
        return top_5_word_frequency
```",0.15350877192982457,0.17565751021739276,0.7543859649122807,0.48863636363636365,0.5931034435043997,0.6097560975609756,0.3472222222222222,0.44247787148249673,0.7543859649122807,0.48863636363636365,0.5931034435043997
Llama,64,"class NumberConverter:
    @staticmethod
    def decimal_to_binary(decimal_num):
        binary_num = bin(decimal_num)[2:]
        return binary_num

    @staticmethod
    def binary_to_decimal(binary_num):
        decimal_num = int(binary_num, 2)
        return decimal_num

    @staticmethod
    def decimal_to_octal(decimal_num):
        octal_num = oct(decimal_num)[2:]
        return octal_num

    @staticmethod
    def octal_to_decimal(octal_num):
        decimal_num = int(octal_num, 8)
        return decimal_num

    @staticmethod
    def decimal_to_hex(decimal_num):
        hex_num = hex(decimal_num)[2:]
        return hex_num

    @staticmethod
    def hex_to_decimal(hex_num):
        decimal_num = int(hex_num, 16)
        return decimal_num",COT,"

```python
class NumberConverter:
    @staticmethod
    def decimal_to_binary(decimal_num: int) -> str:
        # Convert a decimal number to binary using built-in bin function
        # The bin function returns a string that starts with '0b' to indicate it's a binary number
        # We use string slicing to remove the '0b' prefix
        return bin(decimal_num)[2:]

    @staticmethod
    def binary_to_decimal(binary_num: str) -> int:
        # Convert a binary number to decimal using built-in int function with base 2
        return int(binary_num, 2)

    @staticmethod
    def decimal_to_octal(decimal_num: int) -> str:
        # Convert a decimal number to octal using built-in oct function
        # The oct function returns a string that starts with '0o' to indicate it's an octal number
        # We use string slicing to remove the '0o' prefix
        return oct(decimal_num)[2:]

    @staticmethod
    def octal_to_decimal(octal_num: str) -> int:
        # Convert an octal number to decimal using built-in int function with base 8
        return int(octal_num, 8)

    @staticmethod
    def decimal_to_hex(decimal_num: int) -> str:
        # Convert a decimal number to hex using built-in hex function
        # The hex function returns a string that starts with '0x' to indicate it's a hex number
        # We use string slicing to remove the '0x' prefix
        return hex(decimal_num)[2:]

    @staticmethod
    def hex_to_decimal(hex_num: str) -> int:
        # Convert a hex number to decimal using built-in int function with base 16
        return int(hex_num, 16)
```",0.009569377990430623,0.023989838643846184,0.56,0.21875,0.3146067375331398,0.14285714285714285,0.05454545454545454,0.07894736442174535,0.44,0.171875,0.24719100719606116
Llama,65,"class NumberWordFormatter:
    def __init__(self):
        self.NUMBER = ["""", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""]
        self.NUMBER_TEEN = [""TEN"", ""ELEVEN"", ""TWELVE"", ""THIRTEEN"", ""FOURTEEN"", ""FIFTEEN"", ""SIXTEEN"", ""SEVENTEEN"",
                            ""EIGHTEEN"",
                            ""NINETEEN""]
        self.NUMBER_TEN = [""TEN"", ""TWENTY"", ""THIRTY"", ""FORTY"", ""FIFTY"", ""SIXTY"", ""SEVENTY"", ""EIGHTY"", ""NINETY""]
        self.NUMBER_MORE = ["""", ""THOUSAND"", ""MILLION"", ""BILLION""]
        self.NUMBER_SUFFIX = [""k"", ""w"", """", ""m"", """", """", ""b"", """", """", ""t"", """", """", ""p"", """", """", ""e""]

    def format(self, x):
        if x is not None:
            return self.format_string(str(x))
        else:
            return """"

    def format_string(self, x):
        lstr, rstr = (x.split('.') + [''])[:2]
        lstrrev = lstr[::-1]
        a = [''] * 5

        if len(lstrrev) % 3 == 1:
            lstrrev += ""00""
        elif len(lstrrev) % 3 == 2:
            lstrrev += ""0""

        lm = """"
        for i in range(len(lstrrev) // 3):
            a[i] = lstrrev[3 * i:3 * i + 3][::-1]
            if a[i] != ""000"":
                lm = self.trans_three(a[i]) + "" "" + self.parse_more(i) + "" "" + lm
            else:
                lm += self.trans_three(a[i])

        xs = f""AND CENTS {self.trans_two(rstr)} "" if rstr else """"
        if not lm.strip():
            return ""ZERO ONLY""
        else:
            return f""{lm.strip()} {xs}ONLY""

    def trans_two(self, s):
        s = s.zfill(2)
        if s[0] == ""0"":
            return self.NUMBER[int(s[-1])]
        elif s[0] == ""1"":
            return self.NUMBER_TEEN[int(s) - 10]
        elif s[1] == ""0"":
            return self.NUMBER_TEN[int(s[0]) - 1]
        else:
            return self.NUMBER_TEN[int(s[0]) - 1] + "" "" + self.NUMBER[int(s[-1])]

    def trans_three(self, s):
        if s[0] == ""0"":
            return self.trans_two(s[1:])
        elif s[1:] == ""00"":
            return f""{self.NUMBER[int(s[0])]} HUNDRED""
        else:
            return f""{self.NUMBER[int(s[0])]} HUNDRED AND {self.trans_two(s[1:])}""

    def parse_more(self, i):
        return self.NUMBER_MORE[i]",COT,"

```python
class NumberWordFormatter:
    def __init__(self):
        # Initialize a NumberWordFormatter object
        # Define lists for numbers, teens, tens, and suffixes
        self.NUMBER = ["""", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""]
        self.NUMBER_TEEN = [""TEN"", ""ELEVEN"", ""TWELVE"", ""THIRTEEN"", ""FOURTEEN"", ""FIFTEEN"", ""SIXTEEN"", ""SEVENTEEN"",
                            ""EIGHTEEN"", ""NINETEEN""]
        self.NUMBER_TEN = [""TEN"", ""TWENTY"", ""THIRTY"", ""FORTY"", ""FIFTY"", ""SIXTY"", ""SEVENTY"", ""EIGHTY"", ""NINETY""]
        self.NUMBER_MORE = ["""", ""THOUSAND"", ""MILLION"", ""BILLION""]
        self.NUMBER_SUFFIX = [""k"", ""w"", """", ""m"", """", """", ""b"", """", """", ""t"", """", """", ""p"", """", """", ""e""]

    def format(self, x):
        # Convert a number into words format
        # Get ""x"" as int or float which is the number to be converted into words format
        # Return the number in words format as str
        if isinstance(x, int):
            return self.format_integer(x) + "" ONLY""
        elif isinstance(x, float):
            integer_part = int(x)
            decimal_part = int((x - integer_part) * 100)
            return self.format_integer(integer_part) + "" POINT "" + self.format_integer(decimal_part) + "" ONLY""

    def format_string(self, x):
        # Convert a string representation of a number into words format
        # Get ""x"" as str which is the string representation of a number
        # Return the number in words format as str
        return self.format(int(x))

    def trans_two(self, s):
        # Convert a two-digit number into words format
        # Get ""s"" as str which is the two-digit number
        # Return the number in words format as str
        num = int(s)
        if num < 10:
            return self.NUMBER[num]
        elif num < 20:
            return self.NUMBER_TEEN[num - 10]
        else:
            tens, ones = divmod(num, 10)
            return self.NUMBER_TEN[tens - 1] + ("" "" + self.NUMBER[ones] if ones != 0 else """")

    def trans_three(self, s):
        # Convert a three-digit number into words format
        # Get ""s"" as str which is the three-digit number
        # Return the number in words format as str
        num = int(s)
        if num < 10:
            return self.NUMBER[num]
        elif num < 20:
            return self.NUMBER_TEEN[num - 10]
        elif num < 100:
            return self.trans_two(s)
        else:
            hundreds, rest = divmod(num, 100)
            return self.NUMBER[hundreds] + "" HUNDRED"" + ("" AND "" + self.trans_two(str(rest)) if rest != 0 else """")

    def parse_more(self, i):
        # Parse the thousand/million/billion suffix based on the index
        # Get ""i"" as int which is the index representing the magnitude (thousand, million, billion)
        # Return the corresponding suffix for the magnitude as str
        return self.NUMBER_MORE[i]

    def format_integer(self, x):
        # Helper function to format integer part
        if x == 0:
            return ""ZERO""
        result = """"
        i = 0
        while x > 0:
            if x % 1000 != 0:
                result = self.trans_three(str(x % 1000)) + "" "" + self.parse_more(i) + ("" "" + result if result != """" else """")
            x //= 1000
            i += 1
        return result.strip()
```",0.1686182669789227,0.20645014520275734,0.6071428571428571,0.45698924731182794,0.521472387737589,0.3972602739726027,0.28618421052631576,0.332695979835703,0.6071428571428571,0.45698924731182794,0.521472387737589
Llama,66,"class NumericEntityUnescaper:
    def __init__(self):
        pass

    def replace(self, string):
        out = []
        pos = 0
        length = len(string)

        while pos < length - 2:
            if string[pos] == '&' and string[pos + 1] == '#':
                start = pos + 2
                is_hex = False
                first_char = string[start]

                if first_char == 'x' or first_char == 'X':
                    start += 1
                    is_hex = True

                if start == length:
                    return ''.join(out)

                end = start
                while end < length and self.is_hex_char(string[end]):
                    end += 1

                if end < length and string[end] == ';':
                    try:
                        entity_value = int(string[start:end], 16 if is_hex else 10)
                    except:
                        return ''.join(out)

                    out.append(chr(entity_value))
                    pos = end + 1
                    continue

            out.append(string[pos])
            pos += 1

        return ''.join(out)

    @staticmethod
    def is_hex_char(char):
        return char.isdigit() or ('a' <= char.lower() <= 'f')",COT,"

```python
class NumericEntityUnescaper:
    def __init__(self):
        # Initialize the class, no actions required
        pass

    def replace(self, string):
        # Initialize an empty string to store the result
        result = """"
        # Initialize a flag to track if we are currently processing a numeric entity
        in_entity = False
        # Initialize a string to store the current entity
        current_entity = """"
        
        # Iterate over each character in the input string
        for char in string:
            # If we are not currently processing an entity and encounter an ampersand
            if not in_entity and char == ""&"":
                # Set the flag to True and append the ampersand to the current entity
                in_entity = True
                current_entity += char
            # If we are currently processing an entity and encounter a semicolon
            elif in_entity and char == "";"":
                # Set the flag to False and append the semicolon to the current entity
                in_entity = False
                current_entity += char
                # If the entity starts with '&#' and the rest of the entity is a decimal number
                if current_entity.startswith(""&#"") and current_entity[2:-1].isdigit():
                    # Replace the entity with the corresponding Unicode character
                    result += chr(int(current_entity[2:-1]))
                # If the entity starts with '&#x' and the rest of the entity is a hexadecimal number
                elif current_entity.startswith(""&#x"") and all(self.is_hex_char(c) for c in current_entity[3:-1]):
                    # Replace the entity with the corresponding Unicode character
                    result += chr(int(current_entity[3:-1], 16))
                # Reset the current entity
                current_entity = """"
            # If we are currently processing an entity
            elif in_entity:
                # Append the character to the current entity
                current_entity += char
            # If we are not currently processing an entity
            else:
                # Append the character to the result
                result += char
        
        # Return the result
        return result

    @staticmethod
    def is_hex_char(char):
        # Check if the character is a hexadecimal digit
        return char.isdigit() or char.lower() in ""abcdef""
```",0.02061855670103093,0.029109241123058415,0.3181818181818182,0.21212121212121213,0.2545454497454546,0.12280701754385964,0.07446808510638298,0.09271522708828583,0.30303030303030304,0.20202020202020202,0.24242423762424248
Llama,67,"class Order:

    def __init__(self):
        self.menu = []
        # menu = [{""dish"": dish name, ""price"": price, ""count"": count}, ...]
        self.selected_dishes = []
        # selected_dish = {""dish"": dish name, ""count"": count, price: price}
        self.sales = {}
        # 


    def add_dish(self, dish):
        for menu_dish in self.menu:
            if dish[""dish""] == menu_dish[""dish""]:
                if menu_dish[""count""] < dish[""count""]:
                    return False
                else:
                    menu_dish[""count""] -= dish[""count""]
                    break
        self.selected_dishes.append(dish)
        return True

    def calculate_total(self):
        total = 0
        for dish in self.selected_dishes:
            total += dish[""price""] * dish[""count""] * self.sales[dish[""dish""]]
        return total

    def checkout(self):
        if len(self.selected_dishes) == 0:
            return False
        total = self.calculate_total()
        self.selected_dishes = []
        return total",COT,"

```python
class Order:
    def __init__(self):
        # Initialize the order management system
        self.menu = []
        self.selected_dishes = []
        self.sales = {}

    def add_dish(self, dish):
        # Check if the dish exists in the menu
        for menu_item in self.menu:
            if menu_item[""dish""] == dish[""dish""] and menu_item[""price""] == dish[""price""]:
                # Check if the count is valid
                if menu_item[""count""] >= dish[""count""]:
                    # Add the dish to the selected dishes
                    self.selected_dishes.append(dish)
                    # Update the count in the menu
                    menu_item[""count""] -= dish[""count""]
                    return True
        return False

    def calculate_total(self):
        # Initialize the total price
        total = 0
        # Calculate the total price of the selected dishes
        for dish in self.selected_dishes:
            # Check if the dish has a sales discount
            if dish[""dish""] in self.sales:
                total += dish[""price""] * dish[""count""] * self.sales[dish[""dish""]]
            else:
                total += dish[""price""] * dish[""count""]
        return total

    def checkout(self):
        # Check if there are selected dishes
        if self.selected_dishes:
            # Calculate the total price and return it
            return self.calculate_total()
        else:
            # Return False if there are no selected dishes
            return False
```",0.10559006211180123,0.13971373078273297,0.6610169491525424,0.52,0.5820895473100914,0.41304347826086957,0.2857142857142857,0.33777777294380257,0.6610169491525424,0.52,0.5820895473100914
Llama,68,"class PageUtil:
    def __init__(self, data, page_size):
        self.data = data
        self.page_size = page_size
        self.total_items = len(data)
        self.total_pages = (self.total_items + page_size - 1) // page_size

    def get_page(self, page_number):
        if page_number < 1 or page_number > self.total_pages:
            return []

        start_index = (page_number - 1) * self.page_size
        end_index = start_index + self.page_size
        return self.data[start_index:end_index]

    def get_page_info(self, page_number):
        if page_number < 1 or page_number > self.total_pages:
            return {}

        start_index = (page_number - 1) * self.page_size
        end_index = min(start_index + self.page_size, self.total_items)
        page_data = self.data[start_index:end_index]

        page_info = {
            ""current_page"": page_number,
            ""per_page"": self.page_size,
            ""total_pages"": self.total_pages,
            ""total_items"": self.total_items,
            ""has_previous"": page_number > 1,
            ""has_next"": page_number < self.total_pages,
            ""data"": page_data
        }
        return page_info

    def search(self, keyword):
        results = [item for item in self.data if keyword in str(item)]
        num_results = len(results)
        num_pages = (num_results + self.page_size - 1) // self.page_size

        search_info = {
            ""keyword"": keyword,
            ""total_results"": num_results,
            ""total_pages"": num_pages,
            ""results"": results
        }
        return search_info",COT,"

```python
class PageUtil:
    # Constructor to initialize the PageUtil object
    def __init__(self, data, page_size):
        """"""
        Initialize the PageUtil object with the given data and page size.

        Args:
            data (list): The data to be paginated.
            page_size (int): The number of items per page.
        """"""
        self.data = data
        self.page_size = page_size
        self.total_items = len(data)
        self.total_pages = (self.total_items + page_size - 1) // page_size

    # Method to retrieve a specific page of data
    def get_page(self, page_number):
        """"""
        Retrieve a specific page of data.

        Args:
            page_number (int): The page number to fetch.

        Returns:
            list: The data on the specified page.
        """"""
        start_index = (page_number - 1) * self.page_size
        end_index = start_index + self.page_size
        return self.data[start_index:end_index]

    # Method to retrieve information about a specific page
    def get_page_info(self, page_number):
        """"""
        Retrieve information about a specific page.

        Args:
            page_number (int): The page number to fetch information about.

        Returns:
            dict: The page information such as current page number, total pages, etc.
        """"""
        has_previous = page_number > 1
        has_next = page_number < self.total_pages
        page_info = {
            ""current_page"": page_number,
            ""per_page"": self.page_size,
            ""total_pages"": self.total_pages,
            ""total_items"": self.total_items,
            ""has_previous"": has_previous,
            ""has_next"": has_next,
            ""data"": self.get_page(page_number)
        }
        return page_info

    # Method to search for items in the data
    def search(self, keyword):
        """"""
        Search for items in the data that contain the given keyword.

        Args:
            keyword (str): The keyword to search for.

        Returns:
            dict: The search information such as total results and matching items.
        """"""
        # Convert the data to string for searching
        str_data = [str(item) for item in self.data]
        # Find the indices of the matching items
        indices = [i for i, item in enumerate(str_data) if keyword in item]
        # Get the matching items
        results = [self.data[i] for i in indices]
        # Calculate the total pages for the search results
        total_pages = (len(results) + self.page_size - 1) // self.page_size
        search_info = {
            ""keyword"": keyword,
            ""total_results"": len(results),
            ""total_pages"": total_pages,
            ""results"": results
        }
        return search_info
```",0.19218241042345274,0.22070418925147062,0.7837837837837838,0.4264705882352941,0.55238094781678,0.6220472440944882,0.3015267175572519,0.4061696614119653,0.7837837837837838,0.4264705882352941,0.55238094781678
Llama,69,"import PyPDF2


class PDFHandler:
    def __init__(self, filepaths):
        self.filepaths = filepaths
        # PdfFileReader is deprecated and was removed in PyPDF2 3.0.0. Use PdfReader instead.
        self.readers = [PyPDF2.PdfReader(fp) for fp in filepaths]

    def merge_pdfs(self, output_filepath):
        pdf_writer = PyPDF2.PdfWriter()

        for reader in self.readers:
            # reader.getNumPages is deprecated and was removed in PyPDF2 3.0.0. Use len(reader.pages) instead.
            for page_num in range(len(reader.pages)):
                # reader.getPage(pageNumber) is deprecated and was removed in PyPDF2 3.0.0. Use reader.pages[page_number] instead.
                page = reader.pages[page_num]
                # addPage is deprecated and was removed in PyPDF2 3.0.0. Use add_page instead.
                pdf_writer.add_page(page)

        with open(output_filepath, 'wb') as out:
            pdf_writer.write(out)
        return f""Merged PDFs saved at {output_filepath}""

    def extract_text_from_pdfs(self):
        pdf_texts = []
        for reader in self.readers:
            for page_num in range(len(reader.pages)):
                page = reader.pages[page_num]
                pdf_texts.append(page.extract_text())
        return pdf_texts",COT,"

```python
import PyPDF2

class PDFHandler:
    # Constructor method to initialize the PDFHandler object
    def __init__(self, filepaths):
        """"""
        Initialize the PDFHandler object with a list of file paths.
        
        Args:
            filepaths (list): A list of file paths to PDF files.
        """"""
        self.filepaths = filepaths
        # Create a list of PyPDF2 readers for each file path
        self.readers = [PyPDF2.PdfFileReader(fp) for fp in filepaths]

    # Method to merge multiple PDF files into one
    def merge_pdfs(self, output_filepath):
        """"""
        Merge multiple PDF files into one and save to disk.
        
        Args:
            output_filepath (str): The output file path to save the merged PDF.
        
        Returns:
            str: A success message with the output file path if merged successfully.
        """"""
        # Create a writer object to store the merged PDF
        writer = PyPDF2.PdfFileWriter()
        
        # Iterate over each reader and add its pages to the writer
        for reader in self.readers:
            for page_num in range(reader.numPages):
                writer.addPage(reader.getPage(page_num))
        
        # Open the output file in write-binary mode and write the merged PDF
        try:
            with open(output_filepath, 'wb') as output_file:
                writer.write(output_file)
            return f""Merged PDFs saved at {output_filepath}""
        except Exception as e:
            return f""Error merging PDFs: {str(e)}""

    # Method to extract text from PDF files
    def extract_text_from_pdfs(self):
        """"""
        Extract text from PDF files.
        
        Returns:
            list: A list of strings, each representing the text of a PDF file.
        """"""
        # Initialize an empty list to store the extracted text
        pdf_texts = []
        
        # Iterate over each reader and extract its text
        for reader in self.readers:
            text = ''
            for page_num in range(reader.numPages):
                page = reader.getPage(page_num)
                text += page.extractText()
            pdf_texts.append(text)
        
        return pdf_texts
```",0.092,0.11426540378529147,0.5692307692307692,0.30327868852459017,0.39572192059824424,0.38613861386138615,0.17889908256880735,0.24451410225567755,0.5692307692307692,0.30327868852459017,0.39572192059824424
Llama,6,"class AvgPartition:
    def __init__(self, lst, limit):
        self.lst = lst
        self.limit = limit

    def setNum(self):
        size = len(self.lst) // self.limit
        remainder = len(self.lst) % self.limit
        return size, remainder

        
    def get(self, index):
        size, remainder = self.setNum()
        start = index * size + min(index, remainder)
        end = start + size
        if index + 1 <= remainder:
            end += 1
        return self.lst[start:end]",COT,"

```python
class AvgPartition:
    # Constructor method to initialize the class with a list and the number of partitions
    def __init__(self, lst, limit):
        # Check if the number of partitions is greater than 0
        if limit <= 0:
            raise ValueError(""Number of partitions must be greater than 0"")
        self.lst = lst
        self.limit = limit

    # Method to calculate the size of each block and the remainder of the division
    def setNum(self):
        # Calculate the size of each block
        block_size = len(self.lst) // self.limit
        # Calculate the remainder of the division
        remainder = len(self.lst) % self.limit
        return block_size, remainder

    # Method to get the corresponding block based on the index of the partition
    def get(self, index):
        # Check if the index is within the valid range
        if index < 0 or index >= self.limit:
            raise IndexError(""Index out of range"")
        # Calculate the size of each block and the remainder of the division
        block_size, remainder = self.setNum()
        # Calculate the start position of the block
        start = index * block_size + min(index, remainder)
        # Calculate the end position of the block
        end = (index + 1) * block_size + min(index + 1, remainder)
        # Return the corresponding block
        return self.lst[start:end]
```",0.08717948717948719,0.11306139706223277,0.8857142857142857,0.36046511627906974,0.512396690103135,0.559322033898305,0.22,0.3157894696321055,0.8857142857142857,0.36046511627906974,0.512396690103135
Llama,70,"class PersonRequest:
    def __init__(self, name: str, sex: str, phoneNumber: str):
        self.name = self._validate_name(name)
        self.sex = self._validate_sex(sex)
        self.phoneNumber = self._validate_phoneNumber(phoneNumber)

    def _validate_name(self, name: str) -> str:
        if not name:
            return None
        if len(name) > 33:
            return None
        return name

    def _validate_sex(self, sex: str) -> str:
        if sex not in [""Man"", ""Woman"", ""UGM""]:
            return None
        return sex

    def _validate_phoneNumber(self, phoneNumber: str) -> str:
        if not phoneNumber:
            return None
        if len(phoneNumber) != 11 or not phoneNumber.isdigit():
            return None
        return phoneNumber",COT,"

```python
class PersonRequest:
    def __init__(self, name: str, sex: str, phoneNumber: str):
        self.name = self._validate_name(name)
        self.sex = self._validate_sex(sex)
        self.phoneNumber = self._validate_phoneNumber(phoneNumber)

    def _validate_name(self, name: str) -> str:
        if not name or len(name) > 33:
            return None
        return name

    def _validate_sex(self, sex: str) -> str:
        valid_sexes = [""Man"", ""Woman"", ""UGM""]
        if sex not in valid_sexes:
            return None
        return sex

    def _validate_phoneNumber(self, phoneNumber: str) -> str:
        if not phoneNumber or not phoneNumber.isdigit() or len(phoneNumber) != 11:
            return None
        return phoneNumber
```",0.6578947368421053,0.7082287716737842,0.9230769230769231,0.8372093023255814,0.8780487754997027,0.7910447761194029,0.7464788732394366,0.7681159370331864,0.8205128205128205,0.7441860465116279,0.7804877998899465
Llama,71,"class PushBoxGame:
    def __init__(self, map):
        self.map = map
        self.player_row = 0
        self.player_col = 0
        self.targets = []
        self.boxes = []
        self.target_count = 0
        self.is_game_over = False

        self.init_game()

    def init_game(self):
        for row in range(len(self.map)):
            for col in range(len(self.map[row])):
                if self.map[row][col] == ""O"":
                    self.player_row = row
                    self.player_col = col
                elif self.map[row][col] == ""G"":
                    self.targets.append((row, col))
                    self.target_count += 1
                elif self.map[row][col] == ""X"":
                    self.boxes.append((row, col))

    def check_win(self):
        box_on_target_count = 0
        for box in self.boxes:
            if box in self.targets:
                box_on_target_count += 1
        if box_on_target_count == self.target_count:
            self.is_game_over = True
        return self.is_game_over

    def move(self, direction):
        new_player_row = self.player_row
        new_player_col = self.player_col

        if direction == ""w"":
            new_player_row -= 1
        elif direction == ""s"":
            new_player_row += 1
        elif direction == ""a"":
            new_player_col -= 1
        elif direction == ""d"":
            new_player_col += 1

        if self.map[new_player_row][new_player_col] != ""#"":
            if (new_player_row, new_player_col) in self.boxes:
                new_box_row = new_player_row + (new_player_row - self.player_row)
                new_box_col = new_player_col + (new_player_col - self.player_col)

                if self.map[new_box_row][new_box_col] != ""#"":
                    self.boxes.remove((new_player_row, new_player_col))
                    self.boxes.append((new_box_row, new_box_col))
                    self.player_row = new_player_row
                    self.player_col = new_player_col
            else:
                self.player_row = new_player_row
                self.player_col = new_player_col

        return self.check_win()",COT,"

```python
class PushBoxGame:
    def __init__(self, map):
        self.map = map
        self.player_row = 0
        self.player_col = 0
        self.targets = []
        self.boxes = []
        self.target_count = 0
        self.is_game_over = False
        self.init_game()

    def init_game(self):
        for i in range(len(self.map)):
            for j in range(len(self.map[i])):
                if self.map[i][j] == 'O':
                    self.player_row = i
                    self.player_col = j
                elif self.map[i][j] == 'G':
                    self.targets.append((i, j))
                    self.target_count += 1
                elif self.map[i][j] == 'X':
                    self.boxes.append((i, j))

    def check_win(self):
        self.is_game_over = all(box in self.targets for box in self.boxes)
        return self.is_game_over

    def move(self, direction):
        new_row = self.player_row
        new_col = self.player_col
        if direction == 'w':
            new_row -= 1
        elif direction == 's':
            new_row += 1
        elif direction == 'a':
            new_col -= 1
        elif direction == 'd':
            new_col += 1

        if self.map[new_row][new_col] == '#':
            return False

        if (new_row, new_col) in self.boxes:
            box_new_row = new_row
            box_new_col = new_col
            if direction == 'w':
                box_new_row -= 1
            elif direction == 's':
                box_new_row += 1
            elif direction == 'a':
                box_new_col -= 1
            elif direction == 'd':
                box_new_col += 1

            if self.map[box_new_row][box_new_col] == '#':
                return False
            elif (box_new_row, box_new_col) in self.boxes:
                return False

            self.boxes.remove((new_row, new_col))
            self.boxes.append((box_new_row, box_new_col))

        self.player_row = new_row
        self.player_col = new_col

        return self.check_win()
```",0.2692307692307693,0.33087560865480886,0.49333333333333335,0.5362318840579711,0.5138888838975696,0.3835616438356164,0.39436619718309857,0.3888888838898535,0.49333333333333335,0.5362318840579711,0.5138888838975696
Llama,72,"import re


class RegexUtils:

    def match(self, pattern, text):
        ans = re.match(pattern, text)
        if ans:
            return True
        else:
            return False

    def findall(self, pattern, text):
        return re.findall(pattern, text)

    def split(self, pattern, text):
        return re.split(pattern, text)

    def sub(self, pattern, replacement, text):
        return re.sub(pattern, replacement, text)

    def generate_email_pattern(self):
        pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        return pattern

    def generate_phone_number_pattern(self):
        pattern = r'\b\d{3}-\d{3}-\d{4}\b'
        return pattern

    def generate_split_sentences_pattern(self):
        pattern = r'[.!?][\s]{1,2}(?=[A-Z])'
        return pattern

    def split_sentences(self, text):
        pattern = self.generate_split_sentences_pattern()
        return self.split(pattern, text)

    def validate_phone_number(self, phone_number):
        pattern = self.generate_phone_number_pattern()
        return self.match(pattern, phone_number)

    def extract_email(self, text):
        pattern = self.generate_email_pattern()
        return self.findall(pattern, text)",COT,"

```python
import re

class RegexUtils:
    def match(self, pattern, text):
        return bool(re.fullmatch(pattern, text))

    def findall(self, pattern, text):
        return re.findall(pattern, text)

    def split(self, pattern, text):
        return re.split(pattern, text)

    def sub(self, pattern, replacement, text):
        return re.sub(pattern, replacement, text)

    def generate_email_pattern(self):
        return r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'

    def generate_phone_number_pattern(self):
        return r'\b\d{3}-\d{3}-\d{4}\b'

    def generate_split_sentences_pattern(self):
        return r'[.!?][\s]{1,2}(?=[A-Z])'

    def split_sentences(self, text):
        return re.split(self.generate_split_sentences_pattern(), text)

    def validate_phone_number(self, phone_number):
        return bool(re.fullmatch(self.generate_phone_number_pattern(), phone_number))

    def extract_email(self, text):
        return re.findall(self.generate_email_pattern(), text)
```",0.3584335880806719,0.41244901329548866,0.6888888888888889,0.7209302325581395,0.7045454495480372,0.48717948717948717,0.59375,0.5352112626542352,0.6666666666666666,0.6976744186046512,0.6818181768207645
Llama,73,"class RPGCharacter:
    def __init__(self, name, hp, attack_power, defense, level=1):
        self.name = name
        self.hp = hp
        self.attack_power = attack_power
        self.defense = defense
        self.level = level
        self.exp = 0

    def attack(self, other_character):
        damage = max(self.attack_power - other_character.defense, 1)
        other_character.hp -= damage

    def heal(self):
        self.hp += 10
        if self.hp > 100:
            self.hp = 100
        return self.hp

    def gain_exp(self, amount):
        while amount != 0:
            if self.exp + amount >= self.level * 100:
                amount -= (self.level * 100 - self.exp)
                self.level_up()
            else:
                self.exp += amount
                amount = 0

    def level_up(self):
        if self.level < 100:
            self.level += 1
            self.exp = 0
            self.hp += 20
            self.attack_power += 5
            self.defense += 5
        return self.level, self.hp, self.attack_power, self.defense

    def is_alive(self):
        return self.hp > 0",COT,"

```python
class RPGCharacter:
    def __init__(self, name, hp, attack_power, defense, level=1):
        self.name = name
        self.hp = hp
        self.attack_power = attack_power
        self.defense = defense
        self.level = level
        self.exp = 0

    def attack(self, other_character):
        damage = max(self.attack_power - other_character.defense, 0)
        other_character.hp -= damage

    def heal(self):
        self.hp = min(self.hp + 10, 100)
        return self.hp

    def gain_exp(self, amount):
        self.exp += amount
        while self.exp >= 100 * self.level and self.level < 100:
            self.exp -= 100 * self.level
            self.level_up()

    def level_up(self):
        self.exp = 0
        self.hp = min(self.hp + 20, 1000)
        self.attack_power += 5
        self.defense += 5
        self.level += 1
        return (self.level, self.hp, self.attack_power, self.defense)

    def is_alive(self):
        return self.hp > 0
```",0.4674559634582263,0.5319550751734758,0.8518518518518519,0.8214285714285714,0.8363636313652894,0.6521739130434783,0.7075471698113207,0.6787330266825005,0.8333333333333334,0.8035714285714286,0.8181818131834713
Llama,74,"class Server:

    def __init__(self):
        self.white_list = []
        self.send_struct = {}
        self.receive_struct = {}

    def add_white_list(self, addr):
        if addr in self.white_list:
            return False
        else:
            self.white_list.append(addr)
            return self.white_list

    def del_white_list(self, addr):
        if addr not in self.white_list:
            return False
        else:
            self.white_list.remove(addr)
            return self.white_list

    def recv(self, info):
        if not isinstance(info, dict) or ""addr"" not in info or ""content"" not in info:
            return -1
        addr = info[""addr""]
        content = info[""content""]
        if addr not in self.white_list:
            return False
        else:
            self.receive_struct = {""addr"": addr, ""content"": content}
            return self.receive_struct[""content""]

    def send(self, info):
        if not isinstance(info, dict) or ""addr"" not in info or ""content"" not in info:
            return ""info structure is not correct""
        self.send_struct = {""addr"": info[""addr""], ""content"": info[""content""]}

    def show(self, type):
        if type == ""send"":
            return self.send_struct
        elif type == ""receive"":
            return self.receive_struct
        else:
            return False",COT,"

```python
class Server:
    def __init__(self):
        self.white_list = []
        self.send_struct = {}
        self.receive_struct = {}

    def add_white_list(self, addr):
        if addr not in self.white_list:
            self.white_list.append(addr)
            return self.white_list
        else:
            return False

    def del_white_list(self, addr):
        if addr in self.white_list:
            self.white_list.remove(addr)
            return self.white_list
        else:
            return False

    def recv(self, info):
        if info[""addr""] in self.white_list:
            self.receive_struct = info
            return info[""content""]
        else:
            return False

    def send(self, info):
        self.send_struct = info
        return None

    def show(self, type):
        if type == 'send':
            return self.send_struct
        elif type == 'receive':
            return self.receive_struct
        else:
            return False
```",0.2799746590667526,0.33619477127955316,0.625,0.875,0.7291666618055557,0.5054945054945055,0.71875,0.5935483822484912,0.625,0.875,0.7291666618055557
Llama,75,"class ShoppingCart:
    def __init__(self):
        self.items = {}

    def add_item(self, item, price, quantity=1):
        if item in self.items:
            self.items[item] = {'price': price, 'quantity': quantity}
        else:
            self.items[item] = {'price': price, 'quantity': quantity}

    def remove_item(self, item, quantity=1):
        if item in self.items:
            self.items[item]['quantity'] -= quantity
        else:
            pass

    def view_items(self) -> dict:
        return self.items

    def total_price(self) -> float:
        return sum([item['quantity'] * item['price'] for item in self.items.values()])",COT,"

```python
class ShoppingCart:
    def __init__(self):
        self.items = {}

    def add_item(self, item, price, quantity=1):
        if item in self.items:
            self.items[item][""quantity""] += quantity
        else:
            self.items[item] = {""price"": price, ""quantity"": quantity}

    def remove_item(self, item, quantity=1):
        if item in self.items:
            if self.items[item][""quantity""] <= quantity:
                del self.items[item]
            else:
                self.items[item][""quantity""] -= quantity

    def view_items(self):
        return self.items

    def total_price(self):
        total = 0
        for item in self.items:
            total += self.items[item][""price""] * self.items[item][""quantity""]
        return total
```",0.375,0.432966499213362,0.6756756756756757,0.6410256410256411,0.6578947318455679,0.5769230769230769,0.47619047619047616,0.5217391254805294,0.6756756756756757,0.6410256410256411,0.6578947318455679
Llama,76,"class SignInSystem:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username in self.users:
            return False
        else:
            self.users[username] = False
            return True

    def sign_in(self, username):
        if username not in self.users:
            return False
        else:
            self.users[username] = True
            return True

    def check_sign_in(self, username):
        if username not in self.users:
            return False
        else:
            if self.users[username]:
                return True
            else:
                return False

    def all_signed_in(self):
        if all(self.users.values()):
            return True
        else:
            return False

    def all_not_signed_in(self):
        not_signed_in_users = []
        for username, signed_in in self.users.items():
            if not signed_in:
                not_signed_in_users.append(username)
        return not_signed_in_users",COT,"

```python
class SignInSystem:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username not in self.users:
            self.users[username] = False
            return True
        return False

    def sign_in(self, username):
        if username in self.users:
            self.users[username] = True
            return True
        return False

    def check_sign_in(self, username):
        if username in self.users and self.users[username]:
            return True
        return False

    def all_signed_in(self):
        return all(status for status in self.users.values())

    def all_not_signed_in(self):
        return [username for username, status in self.users.items() if not status]
```",0.390251306969711,0.4564567774181222,0.7428571428571429,0.7428571428571429,0.742857137857143,0.5806451612903226,0.6545454545454545,0.615384610402513,0.7428571428571429,0.7428571428571429,0.742857137857143
Llama,77,"import random


class Snake:
    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):
        self.length = 1
        self.SCREEN_WIDTH = SCREEN_WIDTH
        self.SCREEN_HEIGHT = SCREEN_HEIGHT
        self.BLOCK_SIZE = BLOCK_SIZE
        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]
        self.score = 0
        self.food_position = food_position

    def move(self, direction):
        cur = self.positions[0]
        x, y = direction

        new = (
            ((cur[0] + (x * self.BLOCK_SIZE)) % self.SCREEN_WIDTH),
            (cur[1] + (y * self.BLOCK_SIZE)) % self.SCREEN_HEIGHT,
        )

        if new == self.food_position:
            self.eat_food()

        if len(self.positions) > 2 and new in self.positions[2:]:
            self.reset()
        else:
            self.positions.insert(0, new)
            if len(self.positions) > self.length:
                self.positions.pop()

    def random_food_position(self):
        while self.food_position in self.positions:
            self.food_position = (random.randint(0, self.SCREEN_WIDTH // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE,
                                  random.randint(0, self.SCREEN_HEIGHT // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE)

    def reset(self):
        self.length = 1
        self.positions = [((self.SCREEN_WIDTH / 2), (self.SCREEN_HEIGHT / 2))]
        self.score = 0
        self.random_food_position()

    def eat_food(self):
        self.length += 1
        self.score += 100
        self.random_food_position()",COT,"

```python
import random

class Snake:
    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):
        self.length = 1
        self.SCREEN_WIDTH = SCREEN_WIDTH
        self.SCREEN_HEIGHT = SCREEN_HEIGHT
        self.BLOCK_SIZE = BLOCK_SIZE
        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]
        self.score = 0
        self.food_position = food_position

    def move(self, direction):
        new_head_position = (self.positions[-1][0] + direction[0] * self.BLOCK_SIZE, self.positions[-1][1] + direction[1] * self.BLOCK_SIZE)
        if new_head_position == self.food_position:
            self.eat_food()
        elif new_head_position in self.positions:
            self.reset()
        else:
            self.positions.append(new_head_position)
            if len(self.positions) > self.length:
                self.positions.pop(0)

    def random_food_position(self):
        while True:
            x = random.randint(0, self.SCREEN_WIDTH - self.BLOCK_SIZE) // self.BLOCK_SIZE * self.BLOCK_SIZE
            y = random.randint(0, self.SCREEN_HEIGHT - self.BLOCK_SIZE) // self.BLOCK_SIZE * self.BLOCK_SIZE
            food_position = (x, y)
            if food_position not in self.positions:
                self.food_position = food_position
                break

    def reset(self):
        self.length = 1
        self.positions = [((self.SCREEN_WIDTH / 2), (self.SCREEN_HEIGHT / 2))]
        self.score = 0
        self.random_food_position()

    def eat_food(self):
        self.length += 1
        self.score += 100
        self.random_food_position()
```",0.5000430447389013,0.5691343652181362,0.717948717948718,0.7777777777777778,0.7466666616746667,0.635036496350365,0.6692307692307692,0.6516853882618636,0.717948717948718,0.7777777777777778,0.7466666616746667
Llama,78,"import re


class SplitSentence:

    def split_sentences(self, sentences_string):
        sentences = re.split(r'(?<!\w\.\w.)(?<![A-Z][a-z]\.)(?<=\.|\?)\s', sentences_string)
        return sentences

    def count_words(self, sentence):
        sentence = re.sub(r'[^a-zA-Z\s]', '', sentence)
        words = sentence.split()
        return len(words)

    def process_text_file(self, sentences_string):
        sentences = self.split_sentences(sentences_string)
        max_count = 0
        for sentence in sentences:
            count = self.count_words(sentence)
            if count > max_count:
                max_count = count

        return max_count",COT,"

```python
import re

class SplitSentence:
    def split_sentences(self, sentences_string):
        sentences = re.split('(?<=[.?\s])\s*', sentences_string)
        return [sentence for sentence in sentences if sentence]

    def count_words(self, sentence):
        words = re.findall(r'[a-zA-Z]+', sentence)
        return len(words)

    def process_text_file(self, sentences_string):
        sentences = self.split_sentences(sentences_string)
        max_word_count = 0
        for sentence in sentences:
            word_count = self.count_words(sentence)
            if word_count > max_word_count:
                max_word_count = word_count
        return max_word_count
```",0.3584905660377358,0.42606021507970665,0.7105263157894737,0.7297297297297297,0.7199999950008891,0.48148148148148145,0.5,0.4905660327376291,0.7105263157894737,0.7297297297297297,0.7199999950008891
Llama,79,"class SQLGenerator:
    def __init__(self, table_name):
        self.table_name = table_name

    def select(self, fields=None, condition=None):
        if fields is None:
            fields = ""*""
        else:
            fields = "", "".join(fields)
        sql = f""SELECT {fields} FROM {self.table_name}""
        if condition is not None:
            sql += f"" WHERE {condition}""
        return sql + "";""

    def insert(self, data):
        fields = "", "".join(data.keys())
        values = "", "".join([f""'{value}'"" for value in data.values()])
        sql = f""INSERT INTO {self.table_name} ({fields}) VALUES ({values})""
        return sql + "";""

    def update(self, data, condition):
        set_clause = "", "".join([f""{field} = '{value}'"" for field, value in data.items()])
        sql = f""UPDATE {self.table_name} SET {set_clause} WHERE {condition}""
        return sql + "";""

    def delete(self, condition):
        sql = f""DELETE FROM {self.table_name} WHERE {condition}""
        return sql + "";""

    def select_female_under_age(self, age):
        condition = f""age < {age} AND gender = 'female'""
        return self.select(condition=condition)

    def select_by_age_range(self, min_age, max_age):
        condition = f""age BETWEEN {min_age} AND {max_age}""
        return self.select(condition=condition)",COT,"

```python
class SQLGenerator:
    def __init__(self, table_name):
        self.table_name = table_name

    def select(self, fields=None, condition=None):
        sql = 'SELECT '
        if fields is None:
            sql += '*'
        else:
            sql += ', '.join(fields)
        sql += f' FROM {self.table_name}'
        if condition is not None:
            sql += f' WHERE {condition}'
        sql += ';'
        return sql

    def insert(self, data):
        fields = ', '.join(data.keys())
        values = ', '.join(f""'{value}'"" for value in data.values())
        sql = f'INSERT INTO {self.table_name} ({fields}) VALUES ({values});'
        return sql

    def update(self, data, condition):
        sets = ', '.join(f'{key} = \'{value}\'' for key, value in data.items())
        sql = f'UPDATE {self.table_name} SET {sets} WHERE {condition};'
        return sql

    def delete(self, condition):
        sql = f'DELETE FROM {self.table_name} WHERE {condition};'
        return sql

    def select_female_under_age(self, age):
        sql = f'SELECT * FROM {self.table_name} WHERE age < {age} AND gender = \'female\';'
        return sql

    def select_by_age_range(self, min_age, max_age):
        sql = f'SELECT * FROM {self.table_name} WHERE age BETWEEN {min_age} AND {max_age};'
        return sql
```",0.24489795918367346,0.3130125716639287,0.675,0.6585365853658537,0.6666666616674289,0.5,0.48333333333333334,0.4915254187302499,0.675,0.6585365853658537,0.6666666616674289
Llama,7,"class BalancedBrackets:
    def __init__(self, expr):
        self.stack = []
        self.left_brackets = [""("", ""{"", ""[""]
        self.right_brackets = ["")"", ""}"", ""]""]
        self.expr = expr

    def clear_expr(self):
        self.expr = ''.join(c for c in self.expr if (c in self.left_brackets or c in self.right_brackets))

    def check_balanced_brackets(self):
        self.clear_expr()
        for Brkt in self.expr:
            if Brkt in self.left_brackets:
                self.stack.append(Brkt)
            else:
                Current_Brkt = self.stack.pop()
                if Current_Brkt == ""("":
                    if Brkt != "")"":
                        return False
                if Current_Brkt == ""{"":
                    if Brkt != ""}"":
                        return False
                if Current_Brkt == ""["":
                    if Brkt != ""]"":
                        return False
        if self.stack:
            return False
        return True",COT,"

```python
class BalancedBrackets:
    def __init__(self, expr):
        # Initialize the class with an expression
        # Accept ""expr"" as str which is the expression to check for balanced bracket
        self.stack = []
        self.left_brackets = [""("", ""{"", ""[""]
        self.right_brackets = ["")"", ""}"", ""]""]
        self.expr = expr

    def clear_expr(self):
        # Clear the expression of all characters that are not brackets
        self.expr = ''.join([char for char in self.expr if char in self.left_brackets or char in self.right_brackets])

    def check_balanced_brackets(self):
        # Check if the expression has balanced brackets
        # Return True if the expression has balanced brackets, False otherwise
        self.clear_expr()
        for char in self.expr:
            if char in self.left_brackets:
                # If the character is a left bracket, push it to the stack
                self.stack.append(char)
            elif char in self.right_brackets:
                # If the character is a right bracket, check if the stack is empty or the top of the stack does not match
                if not self.stack:
                    return False
                top = self.stack.pop()
                if (char == ')' and top != '(') or (char == '}' and top != '{') or (char == ']' and top != '['):
                    return False
        # If the stack is empty after iterating through the expression, the brackets are balanced
        return not self.stack
```",0.12435233160621763,0.1602883962292114,0.7142857142857143,0.3645833333333333,0.48275861621498223,0.5125,0.2469879518072289,0.3333333289444114,0.7142857142857143,0.3645833333333333,0.48275861621498223
Llama,80,"class SQLQueryBuilder:

    @staticmethod
    def select(table, columns='*', where=None):
        if columns != '*':
            columns = ', '.join(columns)
        query = f""SELECT {columns} FROM {table}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query

    @staticmethod
    def insert(table, data):
        keys = ', '.join(data.keys())
        values = ', '.join(f""'{v}'"" for v in data.values())
        return f""INSERT INTO {table} ({keys}) VALUES ({values})""

    @staticmethod
    def delete(table, where=None):
        query = f""DELETE FROM {table}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query

    @staticmethod
    def update(table, data, where=None):
        update_str = ', '.join(f""{k}='{v}'"" for k, v in data.items())
        query = f""UPDATE {table} SET {update_str}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query",COT,"

```python
class SQLQueryBuilder:
    @staticmethod
    def select(table, columns='*', where=None):
        query = f""SELECT {', '.join(columns) if isinstance(columns, list) else columns} FROM {table}""
        if where:
            conditions = [f""{key}='{value}'"" for key, value in where.items()]
            query += f"" WHERE {' AND '.join(conditions)}""
        return query

    @staticmethod
    def insert(table, data):
        columns = ', '.join(data.keys())
        values = ', '.join(f""'{value}'"" for value in data.values())
        return f""INSERT INTO {table} ({columns}) VALUES ({values})""

    @staticmethod
    def delete(table, where=None):
        query = f""DELETE FROM {table}""
        if where:
            conditions = [f""{key}='{value}'"" for key, value in where.items()]
            query += f"" WHERE {' AND '.join(conditions)}""
        return query

    @staticmethod
    def update(table, data, where=None):
        sets = ', '.join(f""{key}='{value}'"" for key, value in data.items())
        query = f""UPDATE {table} SET {sets}""
        if where:
            conditions = [f""{key}='{value}'"" for key, value in where.items()]
            query += f"" WHERE {' AND '.join(conditions)}""
        return query
```",0.328125,0.39767596577928505,0.7719298245614035,0.6875,0.7272727222894612,0.5875,0.5595238095238095,0.5731707267102915,0.7719298245614035,0.6875,0.7272727222894612
Llama,81,"import math
class Statistics3:
    @staticmethod
    def median(data):
        sorted_data = sorted(data)
        n = len(sorted_data)
        if n % 2 == 1:
            return sorted_data[n // 2]
        else:
            return (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2

    @staticmethod
    def mode(data):
        counts = {}
        for value in data:
            counts[value] = counts.get(value, 0) + 1
        max_count = max(counts.values())
        mode_values = [value for value, count in counts.items() if count == max_count]
        return mode_values

    @staticmethod
    def correlation(x, y):
        n = len(x)
        mean_x = sum(x) / n
        mean_y = sum(y) / n
        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))
        denominator = math.sqrt(sum((xi - mean_x) ** 2 for xi in x) * sum((yi - mean_y) ** 2 for yi in y))
        if denominator == 0:
            return None
        return numerator / denominator

    @staticmethod
    def mean(data):
        if len(data) == 0:
            return None
        return sum(data) / len(data)

    @staticmethod
    def correlation_matrix(data):
        matrix = []
        for i in range(len(data[0])):
            row = []
            for j in range(len(data[0])):
                column1 = [row[i] for row in data]
                column2 = [row[j] for row in data]
                correlation = Statistics3.correlation(column1, column2)
                row.append(correlation)
            matrix.append(row)
        return matrix

    @staticmethod
    def standard_deviation(data):
        n = len(data)
        if n < 2:
            return None
        mean_value = Statistics3.mean(data)
        variance = sum((x - mean_value) ** 2 for x in data) / (n - 1)
        return math.sqrt(variance)

    @staticmethod
    def z_score(data):
        mean = Statistics3.mean(data)
        std_deviation = Statistics3.standard_deviation(data)
        if std_deviation is None or std_deviation == 0:
            return None
        return [(x - mean) / std_deviation for x in data]",COT,"

```python
import math
import statistics
from scipy.stats import pearsonr
import numpy as np

class Statistics3:
    @staticmethod
    def median(data):
        return statistics.median(data)

    @staticmethod
    def mode(data):
        return statistics.multimode(data)

    @staticmethod
    def correlation(x, y):
        return pearsonr(x, y)[0]

    @staticmethod
    def mean(data):
        return statistics.mean(data)

    @staticmethod
    def correlation_matrix(data):
        return np.corrcoef(data).tolist()

    @staticmethod
    def standard_deviation(data):
        return statistics.stdev(data)

    @staticmethod
    def z_score(data):
        mean = statistics.mean(data)
        std_dev = statistics.stdev(data)
        return [(x - mean) / std_dev for x in data]
```",0.0183543193777125,0.021483920654899798,0.22608695652173913,0.5909090909090909,0.32704402115422654,0.09767441860465116,0.3333333333333333,0.15107913318539423,0.21739130434782608,0.5681818181818182,0.3144654048020253
Llama,82,"class StockPortfolioTracker:
    def __init__(self, cash_balance):
        self.portfolio = []
        self.cash_balance = cash_balance

    def add_stock(self, stock):
        for pf in self.portfolio:
            if pf['name'] == stock['name']:
                pf['quantity'] += stock['quantity']
                return

        self.portfolio.append(stock)

    def remove_stock(self, stock):
        for pf in self.portfolio:
            if pf['name'] == stock['name'] and pf['quantity'] >= stock['quantity']:
                pf['quantity'] -= stock['quantity']
                if pf['quantity'] == 0:
                    self.portfolio.remove(pf)
                return True
        return False

    def buy_stock(self, stock):
        if stock['price'] * stock['quantity'] > self.cash_balance:
            return False
        else:
            self.add_stock(stock)
            self.cash_balance -= stock['price'] * stock['quantity']
            return True

    def sell_stock(self, stock):
        if self.remove_stock(stock) == False:
            return False
        self.cash_balance += stock['price'] * stock['quantity']
        return True

    def calculate_portfolio_value(self):
        total_value = self.cash_balance
        for stock in self.portfolio:
            total_value += stock['price'] * stock['quantity']
        return total_value

    def get_portfolio_summary(self):
        summary = []
        for stock in self.portfolio:
            value = self.get_stock_value(stock)
            summary.append({""name"": stock[""name""], ""value"": value})
        portfolio_value = self.calculate_portfolio_value()
        return portfolio_value, summary

    def get_stock_value(self, stock):
        return stock['price'] * stock['quantity']",COT,"

```python
class StockPortfolioTracker:
    def __init__(self, cash_balance):
        self.portfolio = []
        self.cash_balance = cash_balance

    def add_stock(self, stock):
        self.portfolio.append(stock)

    def remove_stock(self, stock):
        for s in self.portfolio:
            if s['name'] == stock['name'] and s['price'] == stock['price'] and s['quantity'] == stock['quantity']:
                self.portfolio.remove(s)
                return True
        return False

    def buy_stock(self, stock):
        total_cost = stock['price'] * stock['quantity']
        if self.cash_balance >= total_cost:
            self.cash_balance -= total_cost
            self.add_stock(stock)
            return True
        return False

    def sell_stock(self, stock):
        for s in self.portfolio:
            if s['name'] == stock['name'] and s['price'] == stock['price'] and s['quantity'] <= stock['quantity']:
                total_revenue = s['price'] * s['quantity']
                self.cash_balance += total_revenue
                self.portfolio.remove(s)
                return True
        return False

    def calculate_portfolio_value(self):
        total_value = self.cash_balance
        for stock in self.portfolio:
            total_value += stock['price'] * stock['quantity']
        return total_value

    def get_portfolio_summary(self):
        total_value = self.calculate_portfolio_value()
        stock_values = [{'name': stock['name'], 'value': stock['price'] * stock['quantity']} for stock in self.portfolio]
        return (total_value, stock_values)

    def get_stock_value(self, stock):
        return stock['price'] * stock['quantity']
```",0.35074626865671643,0.4308504567929211,0.6666666666666666,0.6779661016949152,0.6722689025633783,0.5221238938053098,0.5412844036697247,0.5315315265331548,0.65,0.6610169491525424,0.6554621798743028
Llama,83,"import sqlite3


class StudentDatabaseProcessor:

    def __init__(self, database_name):
        self.database_name = database_name

    def create_student_table(self):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        create_table_query = """"""
        CREATE TABLE IF NOT EXISTS students (
            id INTEGER PRIMARY KEY,
            name TEXT,
            age INTEGER,
            gender TEXT,
            grade INTEGER
        )
        """"""
        cursor.execute(create_table_query)

        conn.commit()
        conn.close()

    def insert_student(self, student_data):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        insert_query = """"""
        INSERT INTO students (name, age, gender, grade)
        VALUES (?, ?, ?, ?)
        """"""
        cursor.execute(insert_query,
                       (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))

        conn.commit()
        conn.close()

    def search_student_by_name(self, name):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        select_query = ""SELECT * FROM students WHERE name = ?""
        cursor.execute(select_query, (name,))
        result = cursor.fetchall()

        conn.close()

        return result

    def delete_student_by_name(self, name):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        delete_query = ""DELETE FROM students WHERE name = ?""
        cursor.execute(delete_query, (name,))

        conn.commit()
        conn.close()",COT,"

```python
import sqlite3

class StudentDatabaseProcessor:
    def __init__(self, database_name):
        self.database_name = database_name
        self.conn = sqlite3.connect(database_name)
        self.cursor = self.conn.cursor()

    def create_student_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS students
            (ID INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, age INTEGER, gender TEXT, grade INTEGER)
        ''')
        self.conn.commit()

    def insert_student(self, student_data):
        self.cursor.execute('''
            INSERT INTO students (name, age, gender, grade)
            VALUES (?, ?, ?, ?)
        ''', (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))
        self.conn.commit()

    def search_student_by_name(self, name):
        self.cursor.execute('''
            SELECT * FROM students
            WHERE name = ?
        ''', (name,))
        return self.cursor.fetchall()

    def delete_student_by_name(self, name):
        self.cursor.execute('''
            DELETE FROM students
            WHERE name = ?
        ''', (name,))
        self.conn.commit()
```",0.301600355892447,0.3423185926279942,0.7297297297297297,0.8059701492537313,0.765957441820834,0.4954128440366973,0.5869565217391305,0.5373134278715874,0.7162162162162162,0.7910447761194029,0.7517730446577136
Llama,84,"import json


class TextFileProcessor:
    def __init__(self, file_path):
        self.file_path = file_path

    def read_file_as_json(self):
        with open(self.file_path, 'r') as file:
            data = json.load(file)

        return data

    def read_file(self):
        with open(self.file_path, 'r') as file:
            return file.read()

    def write_file(self, content):
        with open(self.file_path, 'w') as file:
            file.write(content)

    def process_file(self):
        content = self.read_file()
        content = ''.join([char for char in content if char.isalpha()])
        self.write_file(content)
        return content",COT,"

```python
import json

class TextFileProcessor:
    def __init__(self, file_path):
        self.file_path = file_path

    def read_file_as_json(self):
        try:
            with open(self.file_path, 'r') as file:
                data = json.load(file)
            return data
        except json.JSONDecodeError as e:
            raise Exception(f""Failed to parse JSON: {e}"")

    def read_file(self):
        try:
            with open(self.file_path, 'r') as file:
                content = file.read()
            return content
        except FileNotFoundError:
            raise Exception(f""File '{self.file_path}' not found"")

    def write_file(self, content):
        with open(self.file_path, 'w') as file:
            file.write(str(content))

    def process_file(self):
        try:
            content = self.read_file()
            processed_content = ''.join(filter(str.isalpha, content))
            self.write_file(processed_content)
            return processed_content
        except Exception as e:
            raise Exception(f""Failed to process file: {e}"")
```",0.3294117647058823,0.38251919072413254,0.7894736842105263,0.5357142857142857,0.6382978675237664,0.6379310344827587,0.43529411764705883,0.5174825126607658,0.7894736842105263,0.5357142857142857,0.6382978675237664
Llama,85,"import time

class Thermostat:
    def __init__(self, current_temperature, target_temperature, mode):
        self.current_temperature = current_temperature
        self.target_temperature = target_temperature
        self.mode = mode

    def get_target_temperature(self):
        return self.target_temperature

    def set_target_temperature(self, temperature):
        self.target_temperature = temperature

    def get_mode(self):
        return self.mode

    def set_mode(self, mode):
        if mode in ['heat', 'cool']:
            self.mode = mode
        else:
            return False

    def auto_set_mode(self):
        if self.current_temperature < self.target_temperature:
            self.mode = 'heat'
        else:
            self.mode = 'cool'

    def auto_check_conflict(self):
        if self.current_temperature > self.target_temperature:
            if self.mode == 'cool':
                return True
            else:
                self.auto_set_mode()
                return False
        else:
            if self.mode == 'heat':
                return True
            else:
                self.auto_set_mode()
                return False

    def simulate_operation(self):
        self.auto_set_mode()
        use_time = 0
        if self.mode == 'heat':
            while(self.current_temperature < self.target_temperature):
                self.current_temperature += 1
                use_time += 1
        else:
            while(self.current_temperature > self.target_temperature):
                self.current_temperature -= 1
                use_time += 1
        return use_time",COT,"

```python
import time

class Thermostat:
    def __init__(self, current_temperature, target_temperature, mode):
        self.current_temperature = current_temperature
        self.target_temperature = target_temperature
        self.mode = mode

    def get_target_temperature(self):
        return int(self.target_temperature)

    def set_target_temperature(self, temperature):
        self.target_temperature = temperature

    def get_mode(self):
        return self.mode

    def set_mode(self, mode):
        if mode in ['heat', 'cool']:
            self.mode = mode
        else:
            raise ValueError(""Invalid mode. Mode must be 'heat' or 'cool'."")

    def auto_set_mode(self):
        if self.current_temperature < self.target_temperature:
            self.mode = 'heat'
        else:
            self.mode = 'cool'

    def auto_check_conflict(self):
        if self.mode == 'heat' and self.current_temperature < self.target_temperature:
            return True
        elif self.mode == 'cool' and self.current_temperature > self.target_temperature:
            return True
        else:
            self.auto_set_mode()
            return False

    def simulate_operation(self):
        start_time = time.time()
        while abs(self.current_temperature - self.target_temperature) > 0.1:
            self.auto_set_mode()
            if self.mode == 'heat':
                self.current_temperature += 0.1
            else:
                self.current_temperature -= 0.1
            time.sleep(0.1)
        end_time = time.time()
        return int(end_time - start_time)
```",0.5121951219512195,0.5637694539823418,0.9148936170212766,0.6417910447761194,0.7543859600661742,0.7391304347826086,0.5666666666666667,0.6415094290494838,0.9148936170212766,0.6417910447761194,0.7543859600661742
Llama,86,"class TicTacToe:
    def __init__(self, N=3):
        self.board = [[' ' for _ in range(N)] for _ in range(3)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        else:
            return False

    def check_winner(self):
        for row in self.board:
            if row[0] == row[1] == row[2] != ' ':
                return row[0]
        for col in range(3):
            if self.board[0][col] == self.board[1][col] == self.board[2][col] != ' ':
                return self.board[0][col]
        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':
            return self.board[0][0]
        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':
            return self.board[0][2]
        return None

    def is_board_full(self):
        for row in self.board:
            if ' ' in row:
                return False
        return True",COT,"

```python
class TicTacToe:
    def __init__(self, N=3):
        self.board = [[' ' for _ in range(N)] for _ in range(3)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        return False

    def check_winner(self):
        # Check rows
        for row in self.board:
            if row[0] == row[1] == row[2] and row[0] != ' ':
                return row[0]

        # Check columns
        for col in range(3):
            if self.board[0][col] == self.board[1][col] == self.board[2][col] and self.board[0][col] != ' ':
                return self.board[0][col]

        # Check diagonals
        if self.board[0][0] == self.board[1][1] == self.board[2][2] and self.board[0][0] != ' ':
            return self.board[0][0]
        if self.board[0][2] == self.board[1][1] == self.board[2][0] and self.board[0][2] != ' ':
            return self.board[0][2]

        return None

    def is_board_full(self):
        for row in self.board:
            for cell in row:
                if cell == ' ':
                    return False
        return True
```",0.6642335766423357,0.7013224887270781,0.98,0.8448275862068966,0.9074074024348423,0.865979381443299,0.7433628318584071,0.7999999950290251,0.98,0.8448275862068966,0.9074074024348423
Llama,87,"import datetime
import time

class TimeUtils:

    def __init__(self):
        self.datetime = datetime.datetime.now()

    def get_current_time(self):
        format = ""%H:%M:%S""
        return self.datetime.strftime(format)

    def get_current_date(self):
        format = ""%Y-%m-%d""
        return self.datetime.strftime(format)

    def add_seconds(self, seconds):
        new_datetime = self.datetime + datetime.timedelta(seconds=seconds)
        format = ""%H:%M:%S""
        return new_datetime.strftime(format)

    def string_to_datetime(self, string):
        return datetime.datetime.strptime(string, ""%Y-%m-%d %H:%M:%S"")

    def datetime_to_string(self, datetime):
        return datetime.strftime(""%Y-%m-%d %H:%M:%S"")

    def get_minutes(self, string_time1, string_time2):
        time1 = self.string_to_datetime(string_time1)
        time2 = self.string_to_datetime(string_time2)
        return round((time2 - time1).seconds / 60)

    def get_format_time(self, year, month, day, hour, minute, second):
        format = ""%Y-%m-%d %H:%M:%S""
        time_item = datetime.datetime(year, month, day, hour, minute, second)
        return time_item.strftime(format)",COT,"

```python
import datetime
import time

class TimeUtils:
    def __init__(self):
        self.datetime = datetime.datetime.now()

    def get_current_time(self):
        return self.datetime.strftime('%H:%M:%S')

    def get_current_date(self):
        return self.datetime.strftime('%Y-%m-%d')

    def add_seconds(self, seconds):
        new_datetime = self.datetime + datetime.timedelta(seconds=seconds)
        return new_datetime.strftime('%H:%M:%S')

    def string_to_datetime(self, string):
        return datetime.datetime.strptime(string, '%Y-%m-%d %H:%M:%S')

    def datetime_to_string(self, datetime):
        return datetime.strftime('%Y-%m-%d %H:%M:%S')

    def get_minutes(self, string_time1, string_time2):
        datetime1 = self.string_to_datetime(string_time1)
        datetime2 = self.string_to_datetime(string_time2)
        time_diff = datetime2 - datetime1
        minutes = round(time_diff.total_seconds() / 60)
        return minutes

    def get_format_time(self, year, month, day, hour, minute, second):
        return f'{year:04d}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:02d}'
```",0.34227701386440434,0.4074961766102925,0.7037037037037037,0.7169811320754716,0.7102803688322126,0.5529411764705883,0.573170731707317,0.5628742464986196,0.7037037037037037,0.7169811320754716,0.7102803688322126
Llama,88,"from math import pi, fabs


class TriCalculator:

    def __init__(self):
        pass

    def cos(self, x):
        return round(self.taylor(x, 50), 10)

    def factorial(self, a):
        b = 1
        while a != 1:
            b *= a
            a -= 1
        return b

    def taylor(self, x, n):
        a = 1
        x = x / 180 * pi
        count = 1
        for k in range(1, n):
            if count % 2 != 0:
                a -= (x ** (2 * k)) / self.factorial(2 * k)
            else:
                a += (x ** (2 * k)) / self.factorial(2 * k)
            count += 1
        return a

    def sin(self, x):
        x = x / 180 * pi
        g = 0
        t = x
        n = 1

        while fabs(t) >= 1e-15:
            g += t
            n += 1
            t = -t * x * x / (2 * n - 1) / (2 * n - 2)
        return round(g, 10)

    def tan(self, x):
        if self.cos(x) != 0:
            result = self.sin(x) / self.cos(x)
            return round(result, 10)
        else:
            return False",COT,"

```python
from math import pi, fabs

class TriCalculator:
    def __init__(self):
        pass

    def cos(self, x):
        return self.taylor(x, 50)

    def factorial(self, a):
        result = 1
        for i in range(1, a + 1):
            result *= i
        return result

    def taylor(self, x, n):
        result = 0
        for i in range(n):
            sign = (-1) ** i
            result += ((x / 180 * pi) ** (2 * i)) / self.factorial(2 * i) * sign
        return result

    def sin(self, x):
        result = 0
        for i in range(50):
            sign = (-1) ** i
            result += ((x / 180 * pi) ** (2 * i + 1)) / self.factorial(2 * i + 1) * sign
        return result

    def tan(self, x):
        return self.sin(x) / self.cos(x)
```",0.1500730702715709,0.18206799812350452,0.5616438356164384,0.7321428571428571,0.6356589098155159,0.2846153846153846,0.44047619047619047,0.3457943877543891,0.5205479452054794,0.6785714285714286,0.5891472819085392
Llama,89,"import random


class TwentyFourPointGame:
    def __init__(self) -> None:
        self.nums = []

    def _generate_cards(self):
        for i in range(4):
            self.nums.append(random.randint(1, 9))
        assert len(self.nums) == 4

    def get_my_cards(self):
        self.nums = []
        self._generate_cards()
        return self.nums

    def answer(self, expression):
        if expression == 'pass':
            return self.get_my_cards()
        statistic = {}
        for c in expression:
            if c.isdigit() and int(c) in self.nums:
                statistic[c] = statistic.get(c, 0) + 1

        nums_used = statistic.copy()

        for num in self.nums:
            if nums_used.get(str(num), -100) != -100 and nums_used[str(num)] > 0:
                nums_used[str(num)] -= 1
            else:
                return False

        if all(count == 0 for count in nums_used.values()) == True:
            return self.evaluate_expression(expression)
        else:
            return False

    def evaluate_expression(self, expression):
        try:
            if eval(expression) == 24:
                return True
            else:
                return False
        except Exception as e:
            return False",COT,"

```python
import random

class TwentyFourPointGame:
    def __init__(self):
        self.nums = []

    def _generate_cards(self):
        self.nums = random.sample(range(1, 10), 4)

    def get_my_cards(self):
        self._generate_cards()
        return self.nums

    def evaluate_expression(self, expression):
        try:
            result = eval(expression)
            return result == 24
        except Exception:
            return False

    def answer(self, expression):
        return self.evaluate_expression(expression)
```",0.054853788658375625,0.06752044157521973,0.29333333333333333,0.7096774193548387,0.4150943354841582,0.19827586206896552,0.5227272727272727,0.28749999601250004,0.28,0.6774193548387096,0.39622641095585626
Llama,8,"class BankAccount:
    def __init__(self, balance=0):
        self.balance = balance

    def deposit(self, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        self.balance += amount
        return self.balance

    def withdraw(self, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient balance."")
        self.balance -= amount
        return self.balance

    def view_balance(self):
        return self.balance

    def transfer(self, other_account, amount):
        self.withdraw(amount)
        other_account.deposit(amount)",COT,"

```python
class BankAccount:
    # Constructor to initialize a bank account object with an attribute balance
    def __init__(self, balance=0):
        """"""
        Initialize a bank account object with an attribute balance.
        
        Args:
            balance (int): The initial balance of the account. Defaults to 0.
        """"""
        self.balance = balance

    # Method to deposit a certain amount into the account
    def deposit(self, amount):
        """"""
        Deposit a certain amount into the account, increasing the account balance.
        
        Args:
            amount (int): The amount to be deposited.
        
        Returns:
            int: The current account balance.
        
        Raises:
            ValueError: If the amount is negative.
        """"""
        if amount < 0:
            raise ValueError(""Invalid amount"")
        self.balance += amount
        return self.balance

    # Method to withdraw a certain amount from the account
    def withdraw(self, amount):
        """"""
        Withdraw a certain amount from the account, decreasing the account balance.
        
        Args:
            amount (int): The amount to be withdrawn.
        
        Returns:
            int: The current account balance.
        
        Raises:
            ValueError: If the amount is negative or exceeds the account balance.
        """"""
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient funds"")
        self.balance -= amount
        return self.balance

    # Method to return the account balance
    def view_balance(self):
        """"""
        Return the account balance.
        
        Returns:
            int: The current account balance.
        """"""
        return self.balance

    # Method to transfer a certain amount from the current account to another account
    def transfer(self, other_account, amount):
        """"""
        Transfer a certain amount from the current account to another account.
        
        Args:
            other_account (BankAccount): The account where the money will be transferred.
            amount (int): The amount to be transferred.
        
        Returns:
            None
        """"""
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient funds"")
        self.balance -= amount
        other_account.balance += amount
```",0.11235955056179775,0.12953261984685932,0.9032258064516129,0.32558139534883723,0.4786324747373804,0.7555555555555555,0.22666666666666666,0.34871794516765287,0.9032258064516129,0.32558139534883723,0.4786324747373804
Llama,90,"class URLHandler:
    def __init__(self, url):
        self.url = url

    def get_scheme(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            return self.url[:scheme_end]
        return None

    def get_host(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            url_without_scheme = self.url[scheme_end + 3:]
            host_end = url_without_scheme.find(""/"")
            if host_end != -1:
                return url_without_scheme[:host_end]
            return url_without_scheme
        return None

    def get_path(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            url_without_scheme = self.url[scheme_end + 3:]
            host_end = url_without_scheme.find(""/"")
            if host_end != -1:
                return url_without_scheme[host_end:]
        return None

    def get_query_params(self):
        query_start = self.url.find(""?"")
        fragment_start = self.url.find(""#"")
        if query_start != -1:
            query_string = self.url[query_start + 1:fragment_start]
            params = {}
            if len(query_string) > 0:
                param_pairs = query_string.split(""&"")
                for pair in param_pairs:
                    key_value = pair.split(""="")
                    if len(key_value) == 2:
                        key, value = key_value
                        params[key] = value
            return params
        return None

    def get_fragment(self):
        fragment_start = self.url.find(""#"")
        if fragment_start != -1:
            return self.url[fragment_start + 1:]
        return None",COT,"

```python
class URLHandler:
    def __init__(self, url):
        self.url = url

    def _get_scheme(self):
        return self.url.split('://')[0]

    def get_host(self):
        return self.url.split('://')[1].split('/')[0]

    def get_path(self):
        path = self.url.split('://')[1].split('/', 1)
        if len(path) > 1:
            return '/' + path[1]
        else:
            return ''

    def get_query_params(self):
        query = self.url.split('?')
        if len(query) > 1:
            params = query[1].split('#')[0].split('&')
            query_params = {}
            for param in params:
                key_value = param.split('=')
                if len(key_value) > 1:
                    query_params[key_value[0]] = key_value[1]
            return query_params
        else:
            return {}

    def get_fragment(self):
        fragment = self.url.split('#')
        if len(fragment) > 1:
            return fragment[1]
        else:
            return ''

    def get_scheme(self):
        return self._get_scheme()
```",0.04635371908117683,0.0886319903597056,0.40350877192982454,0.41818181818181815,0.4107142807158801,0.19607843137254902,0.23529411764705882,0.21390373835683044,0.40350877192982454,0.41818181818181815,0.4107142807158801
Llama,91,"import urllib.parse


class UrlPath:
    def __init__(self):
        self.segments = []
        self.with_end_tag = False

    def add(self, segment):
        self.segments.append(self.fix_path(segment))

    def parse(self, path, charset):
        if path:
            if path.endswith('/'):
                self.with_end_tag = True

            path = self.fix_path(path)
            if path:
                split = path.split('/')
                for seg in split:
                    decoded_seg = urllib.parse.unquote(seg, encoding=charset)
                    self.segments.append(decoded_seg)

    @staticmethod
    def fix_path(path):
        if not path:
            return ''

        segment_str = path.strip('/')
        return segment_str",COT,"

```python
import urllib.parse

class UrlPath:
    def __init__(self, url=None):
        self.segments = []
        self.with_end_tag = False
        if url:
            self.parse(url, 'utf-8')

    def add(self, segment):
        self.segments.append(segment)

    def parse(self, path, charset):
        fixed_path = UrlPath.fix_path(path)
        self.segments = fixed_path.split('/')

    @staticmethod
    def fix_path(path):
        return path.strip('/')

# Example usage
url_path = UrlPath()
url_path.add('foo')
url_path.add('bar')
print(url_path.segments)  # Output: ['foo', 'bar']

url_path = UrlPath()
url_path.parse('/foo/bar/', 'utf-8')
print(url_path.segments)  # Output: ['foo', 'bar']

url_path = UrlPath()
print(UrlPath.fix_path('/foo/bar/'))  # Output: 'foo/bar'
```",0.16666666666666669,0.19895516909653987,0.5813953488372093,0.49019607843137253,0.5319148886532369,0.328125,0.3088235294117647,0.3181818131864096,0.5813953488372093,0.49019607843137253,0.5319148886532369
Llama,92,"import sqlite3


class UserLoginDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()

    def insert_user(self, username, password):
        self.cursor.execute('''
            INSERT INTO users (username, password)
            VALUES (?, ?)
        ''', (username, password))
        self.connection.commit()

    def search_user_by_username(self, username):
        self.cursor.execute('''
            SELECT * FROM users WHERE username = ?
        ''', (username,))
        user = self.cursor.fetchone()
        return user

    def delete_user_by_username(self, username):
        self.cursor.execute('''
            DELETE FROM users WHERE username = ?
        ''', (username,))
        self.connection.commit()

    def validate_user_login(self, username, password):
        user = self.search_user_by_username(username)
        if user is not None and user[1] == password:
            return True
        return False",COT,"

```python
import sqlite3

class UserLoginDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS users
            (username TEXT PRIMARY KEY, password TEXT)
        ''')
        self.connection.commit()

    def insert_user(self, username, password):
        self.cursor.execute('INSERT INTO users VALUES (?, ?)', (username, password))
        self.connection.commit()

    def search_user_by_username(self, username):
        self.cursor.execute('SELECT * FROM users WHERE username = ?', (username,))
        return self.cursor.fetchall()

    def delete_user_by_username(self, username):
        self.cursor.execute('DELETE FROM users WHERE username = ?', (username,))
        self.connection.commit()

    def validate_user_login(self, username, password):
        self.cursor.execute('SELECT * FROM users WHERE username = ? AND password = ?', (username, password))
        return len(self.cursor.fetchall()) > 0
```",0.34065934065934067,0.3909401134663573,0.6481481481481481,0.5737704918032787,0.6086956471924386,0.5454545454545454,0.49411764705882355,0.5185185135307119,0.6481481481481481,0.5737704918032787,0.6086956471924386
Llama,93,"import numpy as np
from gensim import matutils
from numpy import dot, array


class VectorUtil:
    @staticmethod
    def similarity(vector_1, vector_2):
        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))

    @staticmethod
    def cosine_similarities(vector_1, vectors_all):
        norm = np.linalg.norm(vector_1)
        all_norms = np.linalg.norm(vectors_all, axis=1)
        dot_products = dot(vectors_all, vector_1)
        similarities = dot_products / (norm * all_norms)
        return similarities

    @staticmethod
    def n_similarity(vector_list_1, vector_list_2):
        if not (len(vector_list_1) and len(vector_list_2)):
            raise ZeroDivisionError('At least one of the passed list is empty.')

        return dot(matutils.unitvec(array(vector_list_1).mean(axis=0)),
                   matutils.unitvec(array(vector_list_2).mean(axis=0)))

    @staticmethod
    def compute_idf_weight_dict(total_num, number_dict):
        index_2_key_map = {}

        index = 0

        count_list = []
        for key, count in number_dict.items():
            index_2_key_map[index] = key
            count_list.append(count)
            index = index + 1

        a = np.array(count_list)
        ## smooth, in case the divide by zero error
        a = np.log((total_num + 1) / (a + 1))
        result = {}

        for index, w in enumerate(a):
            key = index_2_key_map[index]
            result[key] = w

        return result",COT,"

```python
import numpy as np
from gensim import matutils

class VectorUtil:
    @staticmethod
    def similarity(vector_1, vector_2):
        return np.dot(vector_1, vector_2) / (np.linalg.norm(vector_1) * np.linalg.norm(vector_2))

    @staticmethod
    def cosine_similarities(vector_1, vectors_all):
        return [np.dot(vector_1, vector) / (np.linalg.norm(vector_1) * np.linalg.norm(vector)) for vector in vectors_all]

    @staticmethod
    def n_similarity(vector_list_1, vector_list_2):
        return np.mean([np.dot(vector_1, vector_2) / (np.linalg.norm(vector_1) * np.linalg.norm(vector_2)) for vector_1, vector_2 in zip(vector_list_1, vector_list_2)])

    @staticmethod
    def compute_idf_weight_dict(total_num, number_dict):
        return {key: np.log(total_num + 1) / (np.log(count + 1) + 1) for key, count in number_dict.items()}
```",0.12812778822189294,0.15001910010006972,0.3263157894736842,0.6078431372549019,0.42465752970069437,0.2,0.38028169014084506,0.2621359178127063,0.3263157894736842,0.6078431372549019,0.42465752970069437
Llama,94,"class VendingMachine:
    def __init__(self):
        self.inventory = {}
        self.balance = 0

    def add_item(self, item_name, price, quantity):
        if not self.restock_item(item_name, quantity):
            self.inventory[item_name] = {'price': price, 'quantity': quantity}

    def insert_coin(self, amount):
        self.balance += amount
        return self.balance

    def purchase_item(self, item_name):
        if item_name in self.inventory:
            item = self.inventory[item_name]
            if item['quantity'] > 0 and self.balance >= item['price']:
                self.balance -= item['price']
                item['quantity'] -= 1
                return self.balance
            else:
                return False
        else:
            return False

    def restock_item(self, item_name, quantity):
        if item_name in self.inventory:
            self.inventory[item_name]['quantity'] += quantity
            return True
        else:
            return False

    def display_items(self):
        if not self.inventory:
            return False
        else:
            items = []
            for item_name, item_info in self.inventory.items():
                items.append(f""{item_name} - ${item_info['price']} [{item_info['quantity']}]"")
            return ""\n"".join(items)",COT,"

```python
class VendingMachine:
    def __init__(self):
        self.inventory = {}
        self.balance = 0

    def add_item(self, item_name, price, quantity):
        self.inventory[item_name] = {'price': price, 'quantity': quantity}

    def insert_coin(self, amount):
        self.balance += amount
        return self.balance

    def purchase_item(self, item_name):
        if item_name in self.inventory and self.inventory[item_name]['quantity'] > 0 and self.balance >= self.inventory[item_name]['price']:
            self.balance -= self.inventory[item_name]['price']
            self.inventory[item_name]['quantity'] -= 1
            return self.balance
        else:
            print(""Purchase unsuccessful"")
            return False

    def restock_item(self, item_name, quantity):
        if item_name in self.inventory:
            self.inventory[item_name]['quantity'] += quantity
            return True
        else:
            return False

    def display_items(self):
        if not self.inventory:
            return False
        items = []
        for item, details in self.inventory.items():
            items.append(f""{item} - ${details['price']} [{details['quantity']}]"")
        return items
```",0.6230822648865788,0.6611838227702482,0.8103448275862069,0.8103448275862069,0.8103448225862069,0.7395833333333334,0.7473684210526316,0.7434554923823361,0.8103448275862069,0.8103448275862069,0.8103448225862069
Llama,95,"class Warehouse:
    def __init__(self):
        self.inventory = {}  # Product ID: Product
        self.orders = {}  # Order ID: Order

    def add_product(self, product_id, name, quantity):
        if product_id not in self.inventory:
            self.inventory[product_id] = {'name': name, 'quantity': quantity}
        else:
            self.inventory[product_id]['quantity'] += quantity

    def update_product_quantity(self, product_id, quantity):
        if product_id in self.inventory:
            self.inventory[product_id]['quantity'] += quantity

    def get_product_quantity(self, product_id):
        if product_id in self.inventory:
            return self.inventory[product_id]['quantity']
        else:
            return False

    def create_order(self, order_id, product_id, quantity):
        if self.get_product_quantity(product_id) >= quantity:
            self.update_product_quantity(product_id, -quantity)
            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}
        else:
            return False

    def change_order_status(self, order_id, status):
        if order_id in self.orders:
            self.orders[order_id]['status'] = status
        else:
            return False

    def track_order(self, order_id):
        if order_id in self.orders:
            return self.orders[order_id]['status']
        else:
            return False",COT,"

```python
class Warehouse:
    def __init__(self):
        self.inventory = {}
        self.orders = {}

    def add_product(self, product_id, name, quantity):
        if product_id in self.inventory:
            self.inventory[product_id]['quantity'] += quantity
        else:
            self.inventory[product_id] = {'name': name, 'quantity': quantity}

    def update_product_quantity(self, product_id, quantity):
        if product_id in self.inventory:
            self.inventory[product_id]['quantity'] += quantity

    def get_product_quantity(self, product_id):
        if product_id in self.inventory:
            return self.inventory[product_id]['quantity']
        else:
            return False

    def create_order(self, order_id, product_id, quantity):
        if product_id in self.inventory and self.inventory[product_id]['quantity'] >= quantity:
            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}
            self.inventory[product_id]['quantity'] -= quantity
            return True
        else:
            return False

    def change_order_status(self, order_id, status):
        if order_id in self.orders:
            self.orders[order_id]['status'] = status
            return True
        else:
            return False

    def track_order(self, order_id):
        if order_id in self.orders:
            return self.orders[order_id]['status']
        else:
            return False
```",0.6788990825688074,0.7247570602511764,0.8545454545454545,0.9038461538461539,0.8785046679011268,0.7802197802197802,0.8160919540229885,0.797752803991289,0.8545454545454545,0.9038461538461539,0.8785046679011268
Llama,96,"class WeatherSystem:
    def __init__(self, city) -> None:
        self.temperature = None
        self.weather = None
        self.city = city
        self.weather_list = {}
    
    def query(self, weather_list, tmp_units = 'celsius'):
        self.weather_list = weather_list
        if self.city not in weather_list:
            return False
        else:
            self.temperature = self.weather_list[self.city]['temperature']
            self.weather = self.weather_list[self.city]['weather']
        if self.weather_list[self.city]['temperature units'] != tmp_units:
            if tmp_units == 'celsius':
                return self.fahrenheit_to_celsius(), self.weather
            elif tmp_units == 'fahrenheit':
                return self.celsius_to_fahrenheit(), self.weather
        else:
            return self.temperature, self.weather
    
    def set_city(self, city):
        self.city = city

    def celsius_to_fahrenheit(self):
        return (self.temperature * 9/5) + 32

    def fahrenheit_to_celsius(self):
        return (self.temperature - 32) * 5/9",COT,"

```python
class WeatherSystem:
    def __init__(self, city):
        self.temperature = None
        self.weather = None
        self.city = city
        self.weather_list = {}

    def query(self, weather_list, tmp_units='celsius'):
        if self.city in weather_list:
            self.weather = weather_list[self.city]['weather']
            self.temperature = weather_list[self.city]['temperature']
            if tmp_units == 'fahrenheit' and weather_list[self.city]['temperature units'] == 'celsius':
                self.temperature = self.celsius_to_fahrenheit()
            elif tmp_units == 'celsius' and weather_list[self.city]['temperature units'] == 'fahrenheit':
                self.temperature = self.fahrenheit_to_celsius()
            return (self.temperature, self.weather)
        else:
            return None

    def set_city(self, city):
        self.city = city

    def celsius_to_fahrenheit(self):
        if self.temperature is not None:
            return (self.temperature * 9/5) + 32
        else:
            return None

    def fahrenheit_to_celsius(self):
        if self.temperature is not None:
            return (self.temperature - 32) * 5/9
        else:
            return None
```",0.3131313131313132,0.394002795737561,0.8461538461538461,0.8148148148148148,0.830188674247063,0.5764705882352941,0.5833333333333334,0.5798816518049089,0.8461538461538461,0.8148148148148148,0.830188674247063
Llama,97,"class Words2Numbers:

    def __init__(self):
        self.numwords = {}
        self.units = [
            ""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"",
            ""nine"", ""ten"", ""eleven"", ""twelve"", ""thirteen"", ""fourteen"", ""fifteen"",
            ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen"",
        ]
        self.tens = ["""", """", ""twenty"", ""thirty"", ""forty"", ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""]
        self.scales = [""hundred"", ""thousand"", ""million"", ""billion"", ""trillion""]

        self.numwords[""and""] = (1, 0)
        for idx, word in enumerate(self.units):
            self.numwords[word] = (1, idx)
        for idx, word in enumerate(self.tens):
            self.numwords[word] = (1, idx * 10)
        for idx, word in enumerate(self.scales):
            self.numwords[word] = (10 ** (idx * 3 or 2), 0)

        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}
        self.ordinal_endings = [('ieth', 'y'), ('th', '')]

    def text2int(self, textnum):
        textnum = textnum.replace('-', ' ')

        current = result = 0
        curstring = """"
        onnumber = False
        for word in textnum.split():
            if word in self.ordinal_words:
                scale, increment = (1, self.ordinal_words[word])
                current = current * scale + increment
                onnumber = True
            else:
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = ""%s%s"" % (word[:-len(ending)], replacement)

                if word not in self.numwords:
                    if onnumber:
                        curstring += repr(result + current) + "" ""
                    curstring += word + "" ""
                    result = current = 0
                    onnumber = False
                else:
                    scale, increment = self.numwords[word]
                    current = current * scale + increment
                    if scale > 100:
                        result += current
                        current = 0
                    onnumber = True

        if onnumber:
            curstring += repr(result + current)

        return curstring

    def is_valid_input(self, textnum):

        textnum = textnum.replace('-', ' ')

        for word in textnum.split():
            if word in self.ordinal_words:
                continue
            else:
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = ""%s%s"" % (word[:-len(ending)], replacement)

                if word not in self.numwords:
                    return False

        return True",COT,"

```python
class Words2Numbers:
    def __init__(self):
        self.numwords = {}
        self.units = [
            ""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"",
            ""nine"", ""ten"", ""eleven"", ""twelve"", ""thirteen"", ""fourteen"", ""fifteen"",
            ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen"",
        ]
        self.tens = ["""", """", ""twenty"", ""thirty"", ""forty"", ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""]
        self.scales = [""hundred"", ""thousand"", ""million"", ""billion"", ""trillion""]

        self.numwords[""and""] = (1, 0)
        for idx, word in enumerate(self.units):
            self.numwords[word] = (1, idx)
        for idx, word in enumerate(self.tens):
            self.numwords[word] = (1, idx * 10)
        for idx, word in enumerate(self.scales):
            self.numwords[word] = (10 ** (idx * 3 or 2), 0)

        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}
        self.ordinal_endings = [('ieth', 'y'), ('th', '')]

    def text2int(self, textnum):
        current = result = 0
        for word in textnum.replace('-', ' ').split():
            if word in self.numwords:
                scale, increment = self.numwords[word]
                current = current * scale + increment
                if scale > 100:
                    result += current
                    current = 0
            elif word in self.ordinal_words:
                scale = self.ordinal_words[word]
                current = current * scale
            else:
                return None
        return str(result + current)

    def is_valid_input(self, textnum):
        for word in textnum.replace('-', ' ').split():
            if word not in self.numwords and word not in self.ordinal_words:
                return False
        return True
```",0.5174639787379963,0.5477497569118122,0.8796992481203008,0.9435483870967742,0.9105058315820074,0.7259615384615384,0.867816091954023,0.7905759112699763,0.8796992481203008,0.9435483870967742,0.9105058315820074
Llama,98,"import xml.etree.ElementTree as ET


class XMLProcessor:
    def __init__(self, file_name):
        self.file_name = file_name
        self.root = None

    def read_xml(self):
        try:
            tree = ET.parse(self.file_name)
            self.root = tree.getroot()
            return self.root
        except:
            return None

    def write_xml(self, file_name):
        try:
            tree = ET.ElementTree(self.root)
            tree.write(file_name)
            return True
        except:
            return False

    def process_xml_data(self, file_name):
        for element in self.root.iter('item'):
            text = element.text
            element.text = text.upper()
        return self.write_xml(file_name)

    def find_element(self, element_name):
        elements = self.root.findall(element_name)
        return elements",COT,"

```python
import xml.etree.ElementTree as ET

class XMLProcessor:
    def __init__(self, file_name):
        self.file_name = file_name
        self.root = None

    def read_xml(self):
        try:
            tree = ET.parse(self.file_name)
            self.root = tree.getroot()
            return self.root
        except FileNotFoundError:
            print(""File not found."")
            return None
        except ET.ParseError:
            print(""Error parsing XML file."")
            return None

    def write_xml(self, output_file_name):
        if self.root is not None:
            try:
                tree = ET.ElementTree(self.root)
                tree.write(output_file_name)
                return True
            except Exception as e:
                print(f""Error writing XML file: {e}"")
                return False
        else:
            print(""No XML data to write."")
            return False

    def process_xml_data(self, output_file_name):
        if self.root is not None:
            # Modify the data in XML elements
            for elem in self.root.iter():
                if elem.text:
                    elem.text = elem.text.upper()
            return self.write_xml(output_file_name)
        else:
            print(""No XML data to process."")
            return False

    def find_element(self, element_name):
        if self.root is not None:
            return self.root.findall("".//{}"".format(element_name))
        else:
            print(""No XML data to search."")
            return []
```",0.24409448818897642,0.27270288027891676,0.8571428571428571,0.46153846153846156,0.59999999545,0.647887323943662,0.38333333333333336,0.4816753879992326,0.8571428571428571,0.46153846153846156,0.59999999545
Llama,99,"import zipfile


class ZipFileProcessor:
    def __init__(self, file_name):
        self.file_name = file_name

    def read_zip_file(self):
        try:
            zip_file = zipfile.ZipFile(self.file_name, 'r')
            return zip_file
        except:
            return None

    def extract_all(self, output_path):
        try:
            with zipfile.ZipFile(self.file_name, 'r') as zip_file:
                zip_file.extractall(output_path)
            return True
        except:
            return False

    def extract_file(self, file_name, output_path):
        try:
            with zipfile.ZipFile(self.file_name, 'r') as zip_file:
                zip_file.extract(file_name, output_path)
            return True
        except:
            return False

    def create_zip_file(self, files, output_file_name):
        try:
            with zipfile.ZipFile(output_file_name, 'w') as zip_file:
                for file in files:
                    zip_file.write(file)
            return True
        except:
            return False",COT,"

```python
import zipfile
import os

class ZipFileProcessor:
    def __init__(self, file_name):
        self.file_name = file_name

    def read_zip_file(self):
        try:
            return zipfile.ZipFile(self.file_name, 'r')
        except FileNotFoundError:
            return None

    def extract_all(self, output_path):
        try:
            with zipfile.ZipFile(self.file_name, 'r') as zip_ref:
                zip_ref.extractall(output_path)
            return True
        except Exception as e:
            print(f""An error occurred: {e}"")
            return False

    def extract_file(self, file_name, output_path):
        try:
            with zipfile.ZipFile(self.file_name, 'r') as zip_ref:
                zip_ref.extract(file_name, output_path)
            return True
        except Exception as e:
            print(f""An error occurred: {e}"")
            return False

    def create_zip_file(self, files, output_file_name):
        try:
            with zipfile.ZipFile(output_file_name, 'w') as zip_ref:
                for file in files:
                    if os.path.isfile(file):
                        zip_ref.write(file, os.path.basename(file))
                    else:
                        print(f""{file} is not a valid file."")
            return True
        except Exception as e:
            print(f""An error occurred: {e}"")
            return False
```",0.3619047619047619,0.41389178083957495,0.9,0.5901639344262295,0.7128712823448682,0.711864406779661,0.5060240963855421,0.5915492909174768,0.9,0.5901639344262295,0.7128712823448682
Llama,9,"class BigNumCalculator:
    @staticmethod
    def add(num1, num2):
        max_length = max(len(num1), len(num2))
        num1 = num1.zfill(max_length)
        num2 = num2.zfill(max_length)

        carry = 0
        result = []
        for i in range(max_length - 1, -1, -1):
            digit_sum = int(num1[i]) + int(num2[i]) + carry
            carry = digit_sum // 10
            digit = digit_sum % 10
            result.insert(0, str(digit))

        if carry > 0:
            result.insert(0, str(carry))

        return ''.join(result)

    @staticmethod
    def subtract(num1, num2):

        if len(num1) < len(num2):
            num1, num2 = num2, num1
            negative = True
        elif len(num1) > len(num2):
            negative = False
        else:
            if num1 < num2:
                num1, num2 = num2, num1
                negative = True
            else:
                negative = False

        max_length = max(len(num1), len(num2))
        num1 = num1.zfill(max_length)
        num2 = num2.zfill(max_length)

        borrow = 0
        result = []
        for i in range(max_length - 1, -1, -1):
            digit_diff = int(num1[i]) - int(num2[i]) - borrow

            if digit_diff < 0:
                digit_diff += 10
                borrow = 1
            else:
                borrow = 0

            result.insert(0, str(digit_diff))

        while len(result) > 1 and result[0] == '0':
            result.pop(0)

        if negative:
            result.insert(0, '-')

        return ''.join(result)

    @staticmethod
    def multiply(num1, num2):
        len1, len2 = len(num1), len(num2)
        result = [0] * (len1 + len2)

        for i in range(len1 - 1, -1, -1):
            for j in range(len2 - 1, -1, -1):
                mul = int(num1[i]) * int(num2[j])
                p1, p2 = i + j, i + j + 1
                total = mul + result[p2]

                result[p1] += total // 10
                result[p2] = total % 10

        start = 0
        while start < len(result) - 1 and result[start] == 0:
            start += 1

        return ''.join(map(str, result[start:]))",COT,"

```python
class BigNumCalculator:
    @staticmethod
    def add(num1, num2):
        # Convert input strings to integers
        num1_int = int(num1)
        num2_int = int(num2)
        
        # Calculate the sum
        sum_result = num1_int + num2_int
        
        # Convert the result back to string and return
        return str(sum_result)

    @staticmethod
    def subtract(num1, num2):
        # Convert input strings to integers
        num1_int = int(num1)
        num2_int = int(num2)
        
        # Calculate the difference
        diff_result = num1_int - num2_int
        
        # Convert the result back to string and return
        return str(diff_result)

    @staticmethod
    def multiply(num1, num2):
        # Convert input strings to integers
        num1_int = int(num1)
        num2_int = int(num2)
        
        # Calculate the product
        prod_result = num1_int * num2_int
        
        # Convert the result back to string and return
        return str(prod_result)
```",0.02298704371767357,0.03163578913930048,0.16304347826086957,0.375,0.22727272304866855,0.0481283422459893,0.16071428571428573,0.07407407052718945,0.13043478260869565,0.3,0.18181817759412314
Llama,0,"import logging
import datetime


class AccessGatewayFilter:

    def __init__(self):
        pass

    def filter(self, request):
        request_uri = request['path']
        method = request['method']

        if self.is_start_with(request_uri):
            return True

        try:
            token = self.get_jwt_user(request)
            user = token['user']
            if user['level'] > 2:
                self.set_current_user_info_and_log(user)
                return True
        except:
            return False

    def is_start_with(self, request_uri):
        start_with = [""/api"", '/login']
        for s in start_with:
            if request_uri.startswith(s):
                return True
        return False

    def get_jwt_user(self, request):
        token = request['headers']['Authorization']
        user = token['user']
        if token['jwt'].startswith(user['name']):
            jwt_str_date = token['jwt'].split(user['name'])[1]
            jwt_date = datetime.datetime.strptime(jwt_str_date, ""%Y-%m-%d"")
            if datetime.datetime.today() - jwt_date >= datetime.timedelta(days=3):
                return None
        return token

    def set_current_user_info_and_log(self, user):
        host = user['address']
        logging.log(msg=user['name'] + host + str(datetime.datetime.now()), level=1)",COTFewShot,"

```python
import logging
import jwt
from datetime import date

class AccessGatewayFilter:
    def __init__(self):
        pass

    def filter(self, request):
        # Filter incoming requests based on certain rules and conditions
        if request['path'] == '/login' and request['method'] == 'POST':
            return True
        else:
            # Add additional filtering logic as needed
            return False

    def is_start_with(self, request_uri):
        # Check if the request URI starts with certain prefixes
        prefixes = ['/api/data', '/api/auth']
        for prefix in prefixes:
            if request_uri.startswith(prefix):
                return True
        return False

    def get_jwt_user(self, request):
        # Get the user information from the JWT token in the request
        try:
            token = request['headers']['Authorization']['jwt']
            user_info = jwt.decode(token, options={""verify_signature"": False})
            return user_info
        except:
            return None

    def set_current_user_info_and_log(self, user):
        # Set the current user information and log the access
        logging.info(f""User {user['name']} accessed the system from {user.get('address', 'unknown')}"")
        # Add additional logging or user information setting logic as needed
        pass
```",0.1259259259259259,0.16221444962370393,0.46875,0.3409090909090909,0.3947368372299169,0.24,0.18604651162790697,0.2096069819797488,0.453125,0.32954545454545453,0.3815789424930748
Llama,10,"class BinaryDataProcessor:
    def __init__(self, binary_string):
        self.binary_string = binary_string
        self.clean_non_binary_chars()

    def clean_non_binary_chars(self):
        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))

    def calculate_binary_info(self):
        zeroes_count = self.binary_string.count('0')
        ones_count = self.binary_string.count('1')
        total_length = len(self.binary_string)

        zeroes_percentage = (zeroes_count / total_length)
        ones_percentage = (ones_count / total_length)

        return {
            'Zeroes': zeroes_percentage,
            'Ones': ones_percentage,
            'Bit length': total_length
        }

    def convert_to_ascii(self):
        byte_array = bytearray()
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            decimal = int(byte, 2)
            byte_array.append(decimal)

        return byte_array.decode('ascii')

    def convert_to_utf8(self):
        byte_array = bytearray()
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            decimal = int(byte, 2)
            byte_array.append(decimal)

        return byte_array.decode('utf-8')",COTFewShot,"

```python
class BinaryDataProcessor:
    def __init__(self, binary_string):
        self.binary_string = binary_string
        self.clean_non_binary_chars()

    def clean_non_binary_chars(self):
        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))

    def calculate_binary_info(self):
        total_length = len(self.binary_string)
        zeroes = self.binary_string.count('0')
        ones = self.binary_string.count('1')
        zero_percentage = zeroes / total_length if total_length > 0 else 0
        one_percentage = ones / total_length if total_length > 0 else 0
        return {'Zeroes': zero_percentage, 'Ones': one_percentage, 'Bit length': total_length}

    def convert_to_ascii(self):
        ascii_string = ''
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            ascii_string += chr(int(byte, 2))
        return ascii_string

    def convert_to_utf8(self):
        return self.convert_to_ascii()
```",0.2997677188586045,0.3654781568867308,0.6491228070175439,0.6607142857142857,0.6548672516375598,0.5061728395061729,0.4880952380952381,0.4969696919713499,0.6491228070175439,0.6607142857142857,0.6548672516375598
Llama,11,"class BitStatusUtil:
    @staticmethod
    def add(states, stat):
        BitStatusUtil.check([states, stat])
        return states | stat

    @staticmethod
    def has(states, stat):
        BitStatusUtil.check([states, stat])
        return (states & stat) == stat

    @staticmethod
    def remove(states, stat):
        BitStatusUtil.check([states, stat])
        if BitStatusUtil.has(states, stat):
            return states ^ stat
        return states

    @staticmethod
    def check(args):
        for arg in args:
            if arg < 0:
                raise ValueError(f""{arg} must be greater than or equal to 0"")
            if arg % 2 != 0:
                raise ValueError(f""{arg} not even"")",COTFewShot,"

```python
class BitStatusUtil:
    @staticmethod
    def add(states, stat):
        # Check if parameters are legal
        BitStatusUtil.check([states, stat])
        
        # Add the status to the current status using bitwise OR operation
        return states | stat

    @staticmethod
    def has(states, stat):
        # Check if parameters are legal
        BitStatusUtil.check([states, stat])
        
        # Check if the current status contains the specified status using bitwise AND operation
        return (states & stat) == stat

    @staticmethod
    def remove(states, stat):
        # Check if parameters are legal
        BitStatusUtil.check([states, stat])
        
        # Remove the specified status from the current status using bitwise AND and NOT operations
        return states & (~stat)

    @staticmethod
    def check(args):
        # Check if all parameters are non-negative and even
        for arg in args:
            if arg < 0 or arg % 2 != 0:
                raise ValueError(f""{arg} is not even or is negative"")
```",0.22834645669291337,0.2700241226651273,0.813953488372093,0.5384615384615384,0.6481481433556242,0.5892857142857143,0.3707865168539326,0.4551724090520809,0.7906976744186046,0.5230769230769231,0.6296296248371057
Llama,12,"import random


class BlackjackGame:
    def __init__(self):
        self.deck = self.create_deck()
        self.player_hand = []
        self.dealer_hand = []

    def create_deck(self):
        deck = []
        suits = ['S', 'C', 'D', 'H']
        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
        for suit in suits:
            for rank in ranks:
                deck.append(rank + suit)
        random.shuffle(deck)
        return deck

    def calculate_hand_value(self, hand):
        value = 0
        num_aces = 0
        for card in hand:
            rank = card[:-1]
            if rank.isdigit():
                value += int(rank)
            elif rank in ['J', 'Q', 'K']:
                value += 10
            elif rank == 'A':
                value += 11
                num_aces += 1
        while value > 21 and num_aces > 0:
            value -= 10
            num_aces -= 1
        return value

    def check_winner(self, player_hand, dealer_hand):
        player_value = self.calculate_hand_value(player_hand)
        dealer_value = self.calculate_hand_value(dealer_hand)
        if player_value > 21 and dealer_value > 21:
            if player_value <= dealer_value:
                return 'Player wins'
            else:
                return 'Dealer wins'
        elif player_value > 21:
            return 'Dealer wins'
        elif dealer_value > 21:
            return 'Player wins'
        else:
            if player_value <= dealer_value:
                return 'Dealer wins'
            else:
                return 'Player wins'",COTFewShot,"

```python
import random

class BlackjackGame:
    def __init__(self):
        # Initialize the Blackjack Game with the attribute deck, player_hand and dealer_hand
        self.deck = self.create_deck()
        self.player_hand = []
        self.dealer_hand = []

    def create_deck(self):
        # Create a deck of 52 cards, which stores 52 random order poker with the Jokers removed
        suits = ['S', 'H', 'D', 'C']
        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
        deck = [rank + suit for suit in suits for rank in ranks]
        random.shuffle(deck)
        return deck

    def calculate_hand_value(self, hand):
        # Calculate the value of the poker cards stored in the hand list according to the rules of the Blackjack Game
        values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 10, 'Q': 10, 'K': 10, 'A': 11}
        total_value = sum([values[card[0]] for card in hand])
        num_aces = sum([1 for card in hand if card[0] == 'A'])
        
        # If the total hand value exceeds 21 and there are Aces present, one Ace is treated as having a value of 1 instead of 11
        while total_value > 21 and num_aces:
            total_value -= 10
            num_aces -= 1
        return total_value

    def check_winner(self, player_hand, dealer_hand):
        # Determine the winner of a game by comparing the hand values of the player and dealer
        player_value = self.calculate_hand_value(player_hand)
        dealer_value = self.calculate_hand_value(dealer_hand)
        
        # If both players have hand values that are equal to or less than 21, the winner is the one whose hand value is closer to 21
        if player_value <= 21 and dealer_value <= 21:
            if player_value > dealer_value:
                return 'Player wins'
            elif player_value < dealer_value:
                return 'Dealer wins'
            else:
                return 'Dealer wins'  # In case of a tie, the dealer wins
        # Otherwise, the winner is the one with the lower hand value
        elif player_value <= 21:
            return 'Player wins'
        elif dealer_value <= 21:
            return 'Dealer wins'
        else:
            if player_value < dealer_value:
                return 'Player wins'
            else:
                return 'Dealer wins'
```",0.21250000000000002,0.24355130004999156,0.8214285714285714,0.40350877192982454,0.5411764661702423,0.5642857142857143,0.286231884057971,0.37980768784208585,0.7857142857142857,0.38596491228070173,0.5176470544055364
Llama,13,"class BookManagement:
    def __init__(self):
        self.inventory = {}

    def add_book(self, title, quantity=1):
        if title in self.inventory:
            self.inventory[title] += quantity
        else:
            self.inventory[title] = quantity

    def remove_book(self, title, quantity):
        if title not in self.inventory or self.inventory[title] < quantity:
            raise False
        self.inventory[title] -= quantity
        if self.inventory[title] == 0:
            del (self.inventory[title])

    def view_inventory(self):
        return self.inventory

    def view_book_quantity(self, title):
        if title not in self.inventory:
            return 0
        return self.inventory[title]",COTFewShot,"

```python
class BookManagement:
    def __init__(self):
        # Initialize the inventory of the Book Manager
        self.inventory = {}

    def add_book(self, title, quantity=1):
        # Add one or several books to inventory which is sorted by book title
        if title in self.inventory:
            self.inventory[title] += quantity
        else:
            self.inventory[title] = quantity
        # Sort the inventory by book title
        self.inventory = dict(sorted(self.inventory.items()))

    def remove_book(self, title, quantity):
        # Remove one or several books from inventory
        if title in self.inventory:
            if self.inventory[title] >= quantity:
                self.inventory[title] -= quantity
                if self.inventory[title] == 0:
                    del self.inventory[title]
                return True
            else:
                return False
        else:
            return False

    def view_inventory(self):
        # Get the inventory of the Book Management
        return self.inventory

    def view_book_quantity(self, title):
        # Get the quantity of a book
        if title in self.inventory:
            return self.inventory[title]
        else:
            return 0
```",0.2295081967213115,0.2777858015317106,0.868421052631579,0.5409836065573771,0.6666666619365371,0.6724137931034483,0.375,0.48148147688462123,0.868421052631579,0.5409836065573771,0.6666666619365371
Llama,14,"import sqlite3

class BookManagementDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS books (
                id INTEGER PRIMARY KEY,
                title TEXT,
                author TEXT,
                available INTEGER
            )
        ''')
        self.connection.commit()

    def add_book(self, title, author):
        self.cursor.execute('''
            INSERT INTO books (title, author, available)
            VALUES (?, ?, 1)
        ''', (title, author))
        self.connection.commit()

    def remove_book(self, book_id):
        self.cursor.execute('''
            DELETE FROM books WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def borrow_book(self, book_id):
        self.cursor.execute('''
            UPDATE books SET available = 0 WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def return_book(self, book_id):
        self.cursor.execute('''
            UPDATE books SET available = 1 WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def search_books(self):
        self.cursor.execute('''
            SELECT * FROM books
        ''')
        books = self.cursor.fetchall()
        return books",COTFewShot,"

```python
import sqlite3

class BookManagementDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS books
            (id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT, author TEXT, availability INTEGER)
        ''')
        self.connection.commit()

    def add_book(self, title, author):
        self.cursor.execute('INSERT INTO books (title, author, availability) VALUES (?, ?, 1)', (title, author))
        self.connection.commit()

    def remove_book(self, book_id):
        self.cursor.execute('DELETE FROM books WHERE id = ?', (book_id,))
        self.connection.commit()

    def borrow_book(self, book_id):
        self.cursor.execute('UPDATE books SET availability = 0 WHERE id = ?', (book_id,))
        self.connection.commit()

    def return_book(self, book_id):
        self.cursor.execute('UPDATE books SET availability = 1 WHERE id = ?', (book_id,))
        self.connection.commit()

    def search_books(self):
        self.cursor.execute('SELECT * FROM books')
        return self.cursor.fetchall()
```",0.44167141877774574,0.5000154963675544,0.8181818181818182,0.782608695652174,0.7999999950024692,0.6767676767676768,0.6979166666666666,0.6871794821806707,0.8181818181818182,0.782608695652174,0.7999999950024692
Llama,15,"class BoyerMooreSearch:
    def __init__(self, text, pattern):
        self.text, self.pattern = text, pattern
        self.textLen, self.patLen = len(text), len(pattern)

    def match_in_pattern(self, char):
        for i in range(self.patLen - 1, -1, -1):
            if char == self.pattern[i]:
                return i
        return -1

    def mismatch_in_text(self, currentPos):
        for i in range(self.patLen - 1, -1, -1):
            if self.pattern[i] != self.text[currentPos + i]:
                return currentPos + i
        return -1

    def bad_character_heuristic(self):
        positions = []
        for i in range(self.textLen - self.patLen + 1):
            mismatch_index = self.mismatch_in_text(i)
            if mismatch_index == -1:
                positions.append(i)
            else:
                match_index = self.match_in_pattern(self.text[mismatch_index])
                i = (mismatch_index - match_index)
        return positions",COTFewShot,"

```python
class BoyerMooreSearch:
    def __init__(self, text, pattern):
        self.text = text
        self.pattern = pattern
        self.textLen = len(text)
        self.patLen = len(pattern)

    def match_in_pattern(self, char):
        for i in range(self.patLen - 1, -1, -1):
            if self.pattern[i] == char:
                return i
        return -1

    def mismatch_in_text(self, currentPos):
        for i in range(self.patLen):
            if currentPos + i >= self.textLen or self.text[currentPos + i] != self.pattern[i]:
                return currentPos + i
        return -1

    def bad_character_heuristic(self):
        occurrences = []
        i = 0
        while i <= self.textLen - self.patLen:
            mismatchPos = self.mismatch_in_text(i)
            if mismatchPos == -1:
                occurrences.append(i)
                i += self.patLen
            else:
                char = self.text[mismatchPos]
                shift = self.patLen - self.match_in_pattern(char) - 1
                if shift < 1:
                    shift = 1
                i += shift
        return occurrences
```",0.2818181818181818,0.35459944896226075,0.7884615384615384,0.6507936507936508,0.7130434733066162,0.5747126436781609,0.45045045045045046,0.505050500123967,0.7884615384615384,0.6507936507936508,0.7130434733066162
Llama,16,"class Calculator:
    def __init__(self):
        self.operators = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '/': lambda x, y: x / y,
            '^': lambda x, y: x ** y
        }

    def calculate(self, expression):
        operand_stack = []
        operator_stack = []
        num_buffer = ''

        for char in expression:
            if char.isdigit() or char == '.':
                num_buffer += char
            else:
                if num_buffer:
                    operand_stack.append(float(num_buffer))
                    num_buffer = ''

                if char in '+-*/^':
                    while (
                            operator_stack and
                            operator_stack[-1] != '(' and
                            self.precedence(operator_stack[-1]) >= self.precedence(char)
                    ):
                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

                    operator_stack.append(char)
                elif char == '(':
                    operator_stack.append(char)
                elif char == ')':
                    while operator_stack and operator_stack[-1] != '(':
                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

                    operator_stack.pop()

        if num_buffer:
            operand_stack.append(float(num_buffer))

        while operator_stack:
            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

        return operand_stack[-1] if operand_stack else None

    def precedence(self, operator):
        precedences = {
            '+': 1,
            '-': 1,
            '*': 2,
            '/': 2,
            '^': 3
        }
        return precedences.get(operator, 0)

    def apply_operator(self, operand_stack, operator_stack):
        operator = operator_stack.pop()
        if operator == '^':
            operand2 = operand_stack.pop()
            operand1 = operand_stack.pop()
            result = self.operators[operator](operand1, operand2)
            operand_stack.append(result)
        else:
            operand2 = operand_stack.pop()
            operand1 = operand_stack.pop()
            result = self.operators[operator](operand1, operand2)
            operand_stack.append(result)
        return operand_stack, operator_stack",COTFewShot,"

```python
class Calculator:
    def __init__(self):
        self.operators = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '/': lambda x, y: x / y,
            '^': lambda x, y: x ** y
        }

    def calculate(self, expression):
        operand_stack = []
        operator_stack = []
        num = ''
        for char in expression:
            if char.isdigit():
                num += char
            else:
                operand_stack.append(int(num))
                num = ''
                while operator_stack and self.precedence(operator_stack[-1]) >= self.precedence(char):
                    operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)
                operator_stack.append(char)
        if num:
            operand_stack.append(int(num))
        while operator_stack:
            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)
        return operand_stack[0]

    def precedence(self, operator):
        if operator == '^':
            return 3
        elif operator in ['*', '/']:
            return 2
        elif operator in ['+', '-']:
            return 1
        else:
            return 0

    def apply_operator(self, operand_stack, operator_stack):
        operator = operator_stack.pop()
        operand2 = operand_stack.pop()
        operand1 = operand_stack.pop()
        result = self.operators[operator](operand1, operand2)
        operand_stack.append(result)
        return operand_stack, operator_stack
```",0.4451357306321387,0.47663847630280476,0.7241379310344828,0.8076923076923077,0.7636363586512397,0.5827814569536424,0.6929133858267716,0.6330935202171213,0.7126436781609196,0.7948717948717948,0.7515151465300275
Llama,17,"from datetime import datetime, timedelta

class CalendarUtil:
    def __init__(self):
        self.events = []

    def add_event(self, event):
        self.events.append(event)

    def remove_event(self, event):
        if event in self.events:
            self.events.remove(event)

    def get_events(self, date):
        events_on_date = []
        for event in self.events:
            if event['date'].date() == date.date():
                events_on_date.append(event)
        return events_on_date

    def is_available(self, start_time, end_time):
        for event in self.events:
            if start_time < event['end_time'] and end_time > event['start_time']:
                return False
        return True

    def get_available_slots(self, date):
        available_slots = []
        start_time = datetime(date.year, date.month, date.day, 0, 0)
        end_time = datetime(date.year, date.month, date.day, 23, 59)

        while start_time < end_time:
            slot_end_time = start_time + timedelta(minutes=60)
            if self.is_available(start_time, slot_end_time):
                available_slots.append((start_time, slot_end_time))
            start_time += timedelta(minutes=60)


        return available_slots

    def get_upcoming_events(self, num_events):
        now = datetime.now()
        upcoming_events = []
        for event in self.events:
            if event['start_time'] >= now:
                upcoming_events.append(event)
            if len(upcoming_events) == num_events:
                break
        return upcoming_events",COTFewShot,"

```python
from datetime import datetime, timedelta

class CalendarUtil:
    def __init__(self):
        self.events = []

    def add_event(self, event):
        self.events.append(event)

    def get_events(self, date):
        return [event for event in self.events if event['date'].date() == date.date()]

    def remove_event(self, event):
        self.events = [e for e in self.events if e != event]

    def is_available(self, start_time, end_time):
        for event in self.events:
            if (start_time >= event['start_time'] and start_time < event['end_time']) or (end_time > event['start_time'] and end_time <= event['end_time']) or (start_time <= event['start_time'] and end_time >= event['end_time']):
                return False
        return True

    def get_available_slots(self, date):
        available_slots = []
        start_time = datetime.combine(date, datetime.min.time())
        end_time = datetime.combine(date, datetime.max.time())
        for event in sorted(self.events, key=lambda x: x['start_time']):
            if event['date'].date() == date.date():
                if start_time < event['start_time']:
                    available_slots.append((start_time, event['start_time']))
                start_time = event['end_time']
        if start_time < end_time:
            available_slots.append((start_time, end_time))
        return available_slots

    def get_upcoming_events(self, num_events):
        upcoming_events = sorted(self.events, key=lambda x: x['start_time'])
        return upcoming_events[:num_events]
```",0.32575757575757575,0.3857471437225493,0.68,0.6538461538461539,0.6666666616685891,0.48333333333333334,0.4793388429752066,0.4813277958299616,0.64,0.6153846153846154,0.6274509753940792
Llama,18,"class CamelCaseMap:
    def __init__(self):
        self._data = {}

    def __getitem__(self, key):
        return self._data[self._convert_key(key)]

    def __setitem__(self, key, value):
        self._data[self._convert_key(key)] = value

    def __delitem__(self, key):
        del self._data[self._convert_key(key)]

    def __iter__(self):
        return iter(self._data)

    def __len__(self):
        return len(self._data)

    def _convert_key(self, key):
        if isinstance(key, str):
            return self._to_camel_case(key)
        return key

    @staticmethod
    def _to_camel_case(key):
        parts = key.split('_')
        return parts[0] + ''.join(part.title() for part in parts[1:])",COTFewShot,"

```python
class CamelCaseMap:
    def __init__(self):
        self._data = {}

    def __getitem__(self, key):
        return self._data[self._convert_key(key)]

    def __setitem__(self, key, value):
        self._data[self._convert_key(key)] = value

    def __delitem__(self, key):
        del self._data[self._convert_key(key)]

    def __iter__(self):
        return iter(self._data)

    def __len__(self):
        return len(self._data)

    def _convert_key(self, key):
        return self._to_camel_case(key)

    @staticmethod
    def _to_camel_case(key):
        words = key.split('_')
        return words[0] + ''.join(word.capitalize() for word in words[1:])
```",0.648507736914327,0.6909912698126032,0.7906976744186046,0.8095238095238095,0.7999999950006922,0.7213114754098361,0.7719298245614035,0.7457627068701522,0.7906976744186046,0.8095238095238095,0.7999999950006922
Llama,19,"class ChandrasekharSieve:
    def __init__(self, n):
        self.n = n
        self.primes = self.generate_primes()

    def generate_primes(self):
        if self.n < 2:
            return []

        sieve = [True] * (self.n + 1)
        sieve[0] = sieve[1] = False

        p = 2
        while p * p <= self.n:
            if sieve[p]:
                for i in range(p * p, self.n + 1, p):
                    sieve[i] = False
            p += 1

        primes = []
        for i in range(2, self.n + 1):
            if sieve[i]:
                primes.append(i)

        return primes

    def get_primes(self):
        return self.primes",COTFewShot,"

```python
class ChandrasekharSieve:
    def __init__(self, n):
        self.n = n
        self.primes = self.generate_primes()

    def generate_primes(self):
        sieve = [True] * (self.n + 1)
        sieve[0:2] = [False, False]  # 0 and 1 are not prime numbers
        for current_prime in range(2, int(self.n ** 0.5) + 1):
            if sieve[current_prime]:
                for multiple in range(current_prime * current_prime, self.n + 1, current_prime):
                    sieve[multiple] = False
        return [num for num, is_prime in enumerate(sieve) if is_prime]

    def get_primes(self):
        return self.primes
```",0.26636671993282407,0.31937729417167887,0.5869565217391305,0.5,0.5399999950320001,0.4,0.4,0.3999999950000001,0.5869565217391305,0.5,0.5399999950320001
Llama,1,"import math


class AreaCalculator:

    def __init__(self, radius):
        self.radius = radius

    def calculate_circle_area(self):
        return math.pi * self.radius ** 2

    def calculate_sphere_area(self):
        return 4 * math.pi * self.radius ** 2

    def calculate_cylinder_area(self, height):
        return 2 * math.pi * self.radius * (self.radius + height)

    def calculate_sector_area(self, angle):
        return self.radius ** 2 * angle / 2

    def calculate_annulus_area(self, inner_radius, outer_radius):
        return math.pi * (outer_radius ** 2 - inner_radius ** 2)",COTFewShot,"

```python
import math


class AreaCalculator:
    def __init__(self, radius):
        # This method will act as the constructor.
        # This method will Initialize the radius for shapes.
        self.radius = radius

    def calculate_circle_area(self):
        # This method will calculate the area of circle based on self.radius
        # This method will return area of circle as float
        return math.pi * (self.radius ** 2)

    def calculate_sphere_area(self):
        # This method will calculate the area of sphere based on self.radius
        # This method will return area of sphere as float
        return 4 * math.pi * (self.radius ** 2)

    def calculate_cylinder_area(self, height):
        # This method will calculate the area of cylinder based on self.radius and height
        # This method will accept ""height"" as a float which is the height of cylinder
        # This method will return area of cylinder as float
        return 2 * math.pi * self.radius * (self.radius + height)

    def calculate_sector_area(self, angle):
        # This method will calculate the area of sector based on self.radius and angle
        # This method will get ""angle"" as a float which is the angle of sector
        # This method will return area of sector as float
        return (angle / (2 * math.pi)) * math.pi * (self.radius ** 2)

    def calculate_annulus_area(self, inner_radius, outer_radius):
        # This method will calculate the area of annulus based on inner_radius and out_radius
        # This method will get ""inner_radius"" as a float which is the inner radius of sector, 
        # and ""outer_radius"" as a float which is the outer radius of sector 
        # This method will return area of annulus as float
        return math.pi * ((outer_radius ** 2) - (inner_radius ** 2))
```",0.10305343511450381,0.12444923072414114,0.9705882352941176,0.4230769230769231,0.589285710057398,0.6792452830188679,0.26666666666666666,0.38297871935547756,0.9117647058823529,0.3974358974358974,0.5535714243431122
Llama,20,"from datetime import datetime

class Chat:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username in self.users:
            return False
        else:
            self.users[username] = []
            return True

    def remove_user(self, username):
        if username in self.users:
            del self.users[username]
            return True
        else:
            return False

    def send_message(self, sender, receiver, message):
        if sender not in self.users or receiver not in self.users:
            return False

        timestamp = datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
        message_info = {
            'sender': sender,
            'receiver': receiver,
            'message': message,
            'timestamp': timestamp
        }
        self.users[sender].append(message_info)
        self.users[receiver].append(message_info)
        return True

    def get_messages(self, username):
        if username not in self.users:
            return []
        return self.users[username]",COTFewShot,"

```python
from datetime import datetime


class Chat:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username in self.users:
            return False
        else:
            self.users[username] = []
            return True

    def remove_user(self, username):
        if username in self.users:
            del self.users[username]
            return True
        else:
            return False

    def send_message(self, sender, receiver, message):
        if sender not in self.users or receiver not in self.users:
            return False
        else:
            timestamp = datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
            self.users[sender].append({
                'sender': sender,
                'receiver': receiver,
                'message': message,
                'timestamp': timestamp
            })
            self.users[receiver].append({
                'sender': sender,
                'receiver': receiver,
                'message': message,
                'timestamp': timestamp
            })
            return True

    def get_messages(self, username):
        if username in self.users:
            return self.users[username]
        else:
            return []
```",0.71875,0.7506127986629082,0.9183673469387755,0.9183673469387755,0.9183673419387756,0.8461538461538461,0.8571428571428571,0.8516128982260146,0.9183673469387755,0.9183673469387755,0.9183673419387756
Llama,21,"from datetime import datetime


class Classroom:
    def __init__(self, id):
        self.id = id
        self.courses = []

    def add_course(self, course):

        if course not in self.courses:
            self.courses.append(course)

    def remove_course(self, course):
        if course in self.courses:
            self.courses.remove(course)

    def is_free_at(self, check_time):
        check_time = datetime.strptime(check_time, '%H:%M')

        for course in self.courses:
            if datetime.strptime(course['start_time'], '%H:%M') <= check_time <= datetime.strptime(course['end_time'],
                                                                                                   '%H:%M'):
                return False
        return True

    def check_course_conflict(self, new_course):
        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M')
        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M')

        flag = True
        for course in self.courses:
            start_time = datetime.strptime(course['start_time'], '%H:%M')
            end_time = datetime.strptime(course['end_time'], '%H:%M')
            if start_time <= new_start_time and end_time >= new_start_time:
                flag = False
            if start_time <= new_end_time and end_time >= new_end_time:
                flag = False
        return flag",COTFewShot,"

```python
class ClassRegistrationSystem:
    def __init__(self):
        self.students = []
        self.students_registration_classes = {}

    def register_student(self, student):
        if student in self.students:
            return 0
        else:
            self.students.append(student)
            self.students_registration_classes[student['name']] = []
            return 1

    def register_class(self, student_name, class_name):
        if student_name in self.students_registration_classes:
            self.students_registration_classes[student_name].append(class_name)
        return self.students_registration_classes[student_name]

    def get_students_by_major(self, major):
        return [student['name'] for student in self.students if student['major'] == major]

    def get_all_major(self):
        return list(set([student['major'] for student in self.students]))

    def get_most_popular_class_in_major(self, major):
        students_in_major = [student for student in self.students if student['major'] == major]
        classes = []
        for student in students_in_major:
            classes.extend(self.students_registration_classes[student['name']])
        if classes:
            return max(set(classes), key=classes.count)
        else:
            return None
```",0.0009619110510120617,0.20204718046864986,0.1836734693877551,0.16981132075471697,0.17647058324298362,0.021739130434782608,0.023809523809523808,0.022727267737604397,0.1836734693877551,0.16981132075471697,0.17647058324298362
Llama,22,"class ClassRegistrationSystem:

    def __init__(self):
        self.students = []
        self.students_registration_classes = {}

    def register_student(self, student):
        if student in self.students:
            return 0
        else:
            self.students.append(student)
            return 1

    def register_class(self, student_name, class_name):
        if student_name in self.students_registration_classes:
            self.students_registration_classes[student_name].append(class_name)
        else:
            self.students_registration_classes[student_name] = [class_name]
        return self.students_registration_classes[student_name]

    def get_students_by_major(self, major):
        student_list = []
        for student in self.students:
            if student[""major""] == major:
                student_list.append(student[""name""])
        return student_list

    def get_all_major(self):
        major_list = []
        for student in self.students:
            if student[""major""] not in major_list:
                major_list.append(student[""major""])
        return major_list

    def get_most_popular_class_in_major(self, major):
        class_list = []
        for student in self.students:
            if student[""major""] == major:
                class_list += self.students_registration_classes[student[""name""]]
        most_popular_class = max(set(class_list), key=class_list.count)
        return most_popular_class",COTFewShot,"

```python
from datetime import datetime

class Classroom:
    def __init__(self, id):
        self.id = id
        self.courses = []

    def add_course(self, course):
        if course not in self.courses:
            self.courses.append(course)

    def remove_course(self, course):
        if course in self.courses:
            self.courses.remove(course)

    def is_free_at(self, check_time):
        check_time = datetime.strptime(check_time, '%H:%M')
        for course in self.courses:
            start_time = datetime.strptime(course['start_time'], '%H:%M')
            end_time = datetime.strptime(course['end_time'], '%H:%M')
            if start_time <= check_time < end_time:
                return False
        return True

    def check_course_conflict(self, new_course):
        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M')
        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M')
        for course in self.courses:
            start_time = datetime.strptime(course['start_time'], '%H:%M')
            end_time = datetime.strptime(course['end_time'], '%H:%M')
            if (new_start_time < end_time and new_end_time > start_time) or (new_start_time == start_time) or (new_end_time == end_time):
                return False
        return True
```",0.0009615384615384615,0.2731958710173677,0.22,0.2,0.20952380453514752,0.03571428571428571,0.03409090909090909,0.03488371593293744,0.22,0.2,0.20952380453514752
Llama,23,"import math
from typing import List

class CombinationCalculator:
    def __init__(self, datas: List[str]):
        self.datas = datas

    @staticmethod
    def count(n: int, m: int) -> int:
        if m == 0 or n == m:
            return 1
        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))

    @staticmethod
    def count_all(n: int) -> int:
        if n < 0 or n > 63:
            return False
        return (1 << n) - 1 if n != 63 else float(""inf"")

    def select(self, m: int) -> List[List[str]]:
        result = []
        self._select(0, [None] * m, 0, result)
        return result

    def select_all(self) -> List[List[str]]:
        result = []
        for i in range(1, len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):
        resultLen = len(resultList)
        resultCount = resultIndex + 1
        if resultCount > resultLen:
            result.append(resultList.copy())
            return

        for i in range(dataIndex, len(self.datas) + resultCount - resultLen):
            resultList[resultIndex] = self.datas[i]
            self._select(i + 1, resultList, resultIndex + 1, result)",COTFewShot,"

```python
import math
from typing import List

class CombinationCalculator:
    def __init__(self, datas: List[str]):
        self.datas = datas

    @staticmethod
    def count(n: int, m: int) -> int:
        if m > n:
            return 0
        return math.comb(n, m)

    @staticmethod
    def count_all(n: int) -> int:
        total = sum(math.comb(n, i) for i in range(n + 1))
        if total > 2**63 - 1:
            return float(""inf"")
        return total

    def select(self, m: int) -> List[List[str]]:
        result = []
        self._select(0, [None] * m, 0, result)
        return [x for x in result if None not in x]

    def select_all(self) -> List[List[str]]:
        result = []
        for i in range(1, len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):
        if resultIndex == len(resultList):
            result.append(resultList[:])
            return
        for i in range(dataIndex, len(self.datas)):
            resultList[resultIndex] = self.datas[i]
            self._select(i + 1, resultList, resultIndex + 1, result)
```",0.5365855927890407,0.5790453074451747,0.7333333333333333,0.7764705882352941,0.7542857092897959,0.5912408759124088,0.6183206106870229,0.6044776069428047,0.7222222222222222,0.7647058823529411,0.7428571378612244
Llama,24,"class ComplexCalculator:
    def __init__(self):
        pass

    @staticmethod
    def add(c1, c2):
        real = c1.real + c2.real
        imaginary = c1.imag + c2.imag
        answer = complex(real, imaginary)
        return answer
    
    @staticmethod
    def subtract(c1, c2):
        real = c1.real - c2.real
        imaginary = c1.imag - c2.imag
        return complex(real, imaginary)
    
    @staticmethod
    def multiply(c1, c2):
        real = c1.real * c2.real - c1.imag * c2.imag
        imaginary = c1.real * c2.imag + c1.imag * c2.real
        return complex(real, imaginary)
    
    @staticmethod
    def divide(c1, c2):
        denominator = c2.real**2 + c2.imag**2
        real = (c1.real * c2.real + c1.imag * c2.imag) / denominator
        imaginary = (c1.imag * c2.real - c1.real * c2.imag) / denominator
        return complex(real, imaginary)",COTFewShot,"

```python
class ComplexCalculator:
    def __init__(self):
        pass

    @staticmethod
    def add(c1, c2):
        return c1 + c2

    @staticmethod
    def subtract(c1, c2):
        return c1 - c2

    @staticmethod
    def multiply(c1, c2):
        return c1 * c2

    @staticmethod
    def divide(c1, c2):
        if c2 == 0:
            raise ZeroDivisionError(""Cannot divide by zero"")
        return c1 / c2
```",0.09368111048915667,0.11050892255546778,0.6,0.6428571428571429,0.6206896501783592,0.2786885245901639,0.4594594594594595,0.3469387708100792,0.6,0.6428571428571429,0.6206896501783592
Llama,25,"import json

class CookiesUtil:
    def __init__(self, cookies_file):
        self.cookies_file = cookies_file
        self.cookies = None

    def get_cookies(self, reponse):
        self.cookies = reponse['cookies']
        self._save_cookies()

    def load_cookies(self):
        try:
            with open(self.cookies_file, 'r') as file:
                cookies_data = json.load(file)
                return cookies_data
        except FileNotFoundError:
            return {}

    def _save_cookies(self):
        try:
            with open(self.cookies_file, 'w') as file:
                json.dump(self.cookies, file)
            return True
        except:
            return False

    def set_cookies(self, request):
        request['cookies'] = '; '.join([f'{key}={value}' for key, value in self.cookies.items()])",COTFewShot,"

```python
import json

class CookiesUtil:
    def __init__(self, cookies_file):
        self.cookies_file = cookies_file
        self.cookies = None

    def get_cookies(self, response):
        if 'cookies' in response:
            self.cookies = response['cookies']
            self._save_cookies()
            return self.cookies
        else:
            return None

    def load_cookies(self):
        try:
            with open(self.cookies_file, 'r') as file:
                self.cookies = json.load(file)
            return self.cookies
        except FileNotFoundError:
            return None
        except json.JSONDecodeError:
            return None

    def _save_cookies(self):
        if self.cookies is not None:
            try:
                with open(self.cookies_file, 'w') as file:
                    json.dump(self.cookies, file)
                return True
            except Exception as e:
                print(f""Error saving cookies: {e}"")
                return False
        else:
            return False
```",0.36250000000000004,0.4120721067357724,0.6938775510204082,0.6538461538461539,0.6732673217370846,0.5882352941176471,0.5194805194805194,0.5517241329502974,0.6938775510204082,0.6538461538461539,0.6732673217370846
Llama,26,"import csv


class CSVProcessor:

    def __init__(self):
        pass

    def read_csv(self, file_name):
        data = []
        with open(file_name, 'r') as file:
            reader = csv.reader(file)
            title = next(reader)
            for row in reader:
                data.append(row)
        return title, data

    def write_csv(self, data, file_name):
        try:
            with open(file_name, 'w', newline='') as file:
                writer = csv.writer(file)
                writer.writerows(data)
            return 1
        except:
            return 0

    def process_csv_data(self, N, save_file_name):
        title, data = self.read_csv(save_file_name)
        column_data = [row[N] for row in data]
        column_data = [row.upper() for row in column_data]
        new_data = [title, column_data]
        return self.write_csv(new_data, save_file_name.split('.')[0] + '_process.csv')",COTFewShot,"

```python
import csv

class CSVProcessor:
    def __init__(self):
        pass

    def read_csv(self, file_name):
        try:
            with open(file_name, 'r') as file:
                csv_reader = csv.reader(file)
                title = next(csv_reader)
                data = list(csv_reader)
            return title, data
        except:
            return None

    def write_csv(self, data, file_name):
        try:
            with open(file_name, 'w', newline='') as file:
                csv_writer = csv.writer(file)
                csv_writer.writerows(data)
            return 1
        except:
            return 0

    def process_csv_data(self, N, save_file_name):
        try:
            title, data = self.read_csv(save_file_name)
            new_data = [[row[N].upper()] for row in data]
            new_title = [title[N]]
            new_file_name = save_file_name.split('.')[0] + '_process.csv'
            self.write_csv([new_title] + new_data, new_file_name)
            return 1
        except:
            return 0
```",0.40476190476190477,0.46969538612586786,0.7627118644067796,0.7377049180327869,0.749999995001389,0.5853658536585366,0.5853658536585366,0.5853658486585366,0.7627118644067796,0.7377049180327869,0.749999995001389
Llama,27,"class CurrencyConverter:
    def __init__(self):
        self.rates = {
            'USD': 1.0,
            'EUR': 0.85,
            'GBP': 0.72,
            'JPY': 110.15,
            'CAD': 1.23,
            'AUD': 1.34,
            'CNY': 6.40,
        }

    def convert(self, amount, from_currency, to_currency):
        if from_currency == to_currency:
            return amount

        if from_currency not in self.rates or to_currency not in self.rates:
            return False

        from_rate = self.rates[from_currency]
        to_rate = self.rates[to_currency]

        converted_amount = (amount / from_rate) * to_rate
        return converted_amount

    def get_supported_currencies(self):
        return list(self.rates.keys())

    def add_currency_rate(self, currency, rate):
        if currency in self.rates:
            return False
        self.rates[currency] = rate

    def update_currency_rate(self, currency, new_rate):
        if currency not in self.rates:
            return False
        self.rates[currency] = new_rate",COTFewShot,"

```python
class CurrencyConverter:
    def __init__(self):
        self.rates = {
            'USD': 1.0,
            'EUR': 0.85,
            'GBP': 0.72,
            'JPY': 110.15,
            'CAD': 1.23,
            'AUD': 1.34,
            'CNY': 6.40,
        }

    def convert(self, amount, from_currency, to_currency):
        if from_currency in self.rates and to_currency in self.rates:
            return amount / self.rates[from_currency] * self.rates[to_currency]
        else:
            return None

    def get_supported_currencies(self):
        return list(self.rates.keys())

    def add_currency_rate(self, currency, rate):
        if currency not in self.rates:
            self.rates[currency] = rate
            return None
        else:
            return False

    def update_currency_rate(self, currency, new_rate):
        if currency in self.rates:
            self.rates[currency] = new_rate
            return None
        else:
            return False
```",0.526930248424647,0.5856168961331909,0.875,0.9180327868852459,0.89599999500288,0.7222222222222222,0.7738095238095238,0.7471264317875546,0.859375,0.9016393442622951,0.8799999950028801
Llama,28,"import sqlite3
import pandas as pd


class DatabaseProcessor:

    def __init__(self, database_name):
        self.database_name = database_name

    def create_table(self, table_name, key1, key2):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        create_table_query = f""CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)""
        cursor.execute(create_table_query)

        conn.commit()
        conn.close()

    def insert_into_database(self, table_name, data):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        for item in data:
            insert_query = f""INSERT INTO {table_name} (name, age) VALUES (?, ?)""
            cursor.execute(insert_query, (item['name'], item['age']))

        conn.commit()
        conn.close()

    def search_database(self, table_name, name):

        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        select_query = f""SELECT * FROM {table_name} WHERE name = ?""
        cursor.execute(select_query, (name,))
        result = cursor.fetchall()

        if result:
            return result
        else:
            return None

    def delete_from_database(self, table_name, name):

        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        delete_query = f""DELETE FROM {table_name} WHERE name = ?""
        cursor.execute(delete_query, (name,))

        conn.commit()
        conn.close()",COTFewShot,"

```python
import sqlite3
import pandas as pd

class DatabaseProcessor:
    def __init__(self, database_name):
        self.database_name = database_name

    def create_table(self, table_name, key1, key2):
        try:
            with sqlite3.connect(self.database_name) as conn:
                cursor = conn.cursor()
                cursor.execute(f""""""
                    CREATE TABLE IF NOT EXISTS {table_name} (
                        id INTEGER PRIMARY KEY,
                        {key1} TEXT,
                        {key2} INTEGER
                    )
                """""")
            return True
        except:
            return False

    def insert_into_database(self, table_name, data):
        try:
            with sqlite3.connect(self.database_name) as conn:
                cursor = conn.cursor()
                for row in data:
                    cursor.execute(f""""""
                        INSERT INTO {table_name} ({list(row.keys())[0]}, {list(row.keys())[1]})
                        VALUES (?, ?)
                    """""", (row[list(row.keys())[0]], row[list(row.keys())[1]]))
            return True
        except:
            return False

    def search_database(self, table_name, name):
        try:
            with sqlite3.connect(self.database_name) as conn:
                cursor = conn.cursor()
                cursor.execute(f""""""
                    SELECT * FROM {table_name}
                    WHERE {list(pd.read_sql_query(f""PRAGMA table_info({table_name})"", conn).iloc[1]['name'])} = ?
                """""", (name,))
                return cursor.fetchall()
        except:
            return []

    def delete_from_database(self, table_name, name):
        try:
            with sqlite3.connect(self.database_name) as conn:
                cursor = conn.cursor()
                cursor.execute(f""""""
                    DELETE FROM {table_name}
                    WHERE {list(pd.read_sql_query(f""PRAGMA table_info({table_name})"", conn).iloc[1]['name'])} = ?
                """""", (name,))
            return True
        except:
            return False
```",0.2676056338028169,0.31649254141274885,0.6329113924050633,0.5882352941176471,0.6097560925676682,0.4375,0.44545454545454544,0.4414414364418473,0.6329113924050633,0.5882352941176471,0.6097560925676682
Llama,29,"from collections import Counter


class DataStatistics:
    def mean(self, data):
        return round(sum(data) / len(data), 2)

    def median(self, data):
        sorted_data = sorted(data)
        n = len(sorted_data)
        if n % 2 == 0:
            middle = n // 2
            return round((sorted_data[middle - 1] + sorted_data[middle]) / 2, 2)
        else:
            middle = n // 2
            return sorted_data[middle]

    def mode(self, data):
        counter = Counter(data)
        mode_count = max(counter.values())
        mode = [x for x, count in counter.items() if count == mode_count]
        return mode",COTFewShot,"

```python
from collections import Counter
import statistics

class DataStatistics:
    def mean(self, data):
        return round(sum(data) / len(data), 2)

    def median(self, data):
        return round(statistics.median(data), 2)

    def mode(self, data):
        mode_data = Counter(data)
        max_count = max(mode_data.values())
        modes = [num for num, count in mode_data.items() if count == max_count]
        return modes
```",0.18766808650850567,0.22760707378688688,0.5102040816326531,0.6756756756756757,0.5813953439345592,0.3142857142857143,0.46808510638297873,0.3760683712615969,0.5102040816326531,0.6756756756756757,0.5813953439345592
Llama,2,"class ArgumentParser:
    def __init__(self):
        self.arguments = {}
        self.required = set()
        self.types = {}

    def parse_arguments(self, command_string):
        args = command_string.split()[1:]
        for i in range(len(args)):
            arg = args[i]
            if arg.startswith('--'):
                key_value = arg[2:].split('=')
                if len(key_value) == 2:
                    self.arguments[key_value[0]] = self._convert_type(key_value[0], key_value[1])
                else:
                    self.arguments[key_value[0]] = True
            elif arg.startswith('-'):
                key = arg[1:]
                if i + 1 < len(args) and not args[i + 1].startswith('-'):
                    self.arguments[key] = self._convert_type(key, args[i + 1])
                else:
                    self.arguments[key] = True
        missing_args = self.required - set(self.arguments.keys())
        if missing_args:
            return False, missing_args

        return True, None

    def get_argument(self, key):
        return self.arguments.get(key)

    def add_argument(self, arg, required=False, arg_type=str):
        if required:
            self.required.add(arg)
        self.types[arg] = arg_type

    def _convert_type(self, arg, value):
        try:
            return self.types[arg](value)
        except (ValueError, KeyError):
            return value",COTFewShot,"

```python
class ArgumentParser:
    def __init__(self):
        self.arguments = {}
        self.required = set()
        self.types = {}

    def parse_arguments(self, command_string):
        args = command_string.split()
        i = 0
        while i < len(args):
            if args[i].startswith('--'):
                arg_name = args[i][2:]
                if i + 1 < len(args) and not args[i + 1].startswith('-'):
                    arg_value = args[i + 1]
                    i += 2
                else:
                    arg_value = True
                    i += 1
            elif args[i].startswith('-'):
                arg_name = args[i][1:]
                if i + 1 < len(args) and not args[i + 1].startswith('-'):
                    arg_value = args[i + 1]
                    i += 2
                else:
                    arg_value = True
                    i += 1
            else:
                i += 1
                continue

            if arg_name in self.types:
                arg_value = self._convert_type(arg_name, arg_value)

            self.arguments[arg_name] = arg_value

        missing_args = self.required - set(self.arguments.keys())
        if missing_args:
            return False, missing_args
        else:
            return True, None

    def get_argument(self, key):
        return self.arguments.get(key)

    def add_argument(self, arg, required=False, arg_type=str):
        self.types[arg] = arg_type
        if required:
            self.required.add(arg)

    def _convert_type(self, arg, value):
        if self.types[arg] == int:
            try:
                return int(value)
            except ValueError:
                pass
        elif self.types[arg] == float:
            try:
                return float(value)
            except ValueError:
                pass
        elif self.types[arg] == bool:
            if value.lower() == 'true':
                return True
            elif value.lower() == 'false':
                return False
        return value
```",0.2727272727272727,0.32116436273724985,0.7435897435897436,0.6744186046511628,0.7073170681826295,0.576271186440678,0.4533333333333333,0.5074626816384495,0.717948717948718,0.6511627906976745,0.6829268242801905
Llama,30,"import numpy as np


class DataStatistics2:
    def __init__(self, data):
        self.data = np.array(data)

    def get_sum(self):
        return np.sum(self.data)

    def get_min(self):
        return np.min(self.data)

    def get_max(self):
        return np.max(self.data)

    def get_variance(self):
        return round(np.var(self.data), 2)

    def get_std_deviation(self):
        return round(np.std(self.data), 2)

    def get_correlation(self):
        return np.corrcoef(self.data, rowvar=False)",COTFewShot,"

```python
import numpy as np

class DataStatistics2:
    def __init__(self, data):
        self.data = np.array(data)

    def get_sum(self):
        return float(np.sum(self.data))

    def get_min(self):
        return float(np.min(self.data))

    def get_max(self):
        return float(np.max(self.data))

    def get_variance(self):
        return round(float(np.var(self.data)), 2)

    def get_std_deviation(self):
        return round(float(np.std(self.data)), 2)

    def get_correlation(self):
        return float(np.corrcoef(self.data, self.data)[0, 1])
```",0.5,0.542663864222526,0.875,0.7777777777777778,0.823529406782007,0.6363636363636364,0.5833333333333334,0.6086956471833649,0.875,0.7777777777777778,0.823529406782007
Llama,31,"import math

class DataStatistics4:

    @staticmethod
    def correlation_coefficient(data1, data2):
        n = len(data1)
        mean1 = sum(data1) / n
        mean2 = sum(data2) / n

        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))
        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n))) * math.sqrt(sum((data2[i] - mean2) ** 2 for i in range(n)))

        return numerator / denominator if denominator != 0 else 0
    
    @staticmethod
    def skewness(data):
        n = len(data)
        mean = sum(data) / n
        variance = sum((x - mean) ** 2 for x in data) / n
        std_deviation = math.sqrt(variance)

        skewness = sum((x - mean) ** 3 for x in data) * n / ((n - 1) * (n - 2) * std_deviation ** 3) if std_deviation != 0 else 0

        return skewness
    
    @staticmethod
    def kurtosis(data):

        n = len(data)
        mean = sum(data) / n
        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / n)

        if std_dev == 0:
            return math.nan

        centered_data = [(x - mean) for x in data]
        fourth_moment = sum(x ** 4 for x in centered_data) / n

        kurtosis_value = (fourth_moment / std_dev ** 4) - 3

        return kurtosis_value
    
    @staticmethod
    def pdf(data, mu, sigma):
        pdf_values = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]
        return pdf_values",COTFewShot,"

```python
import math
import numpy as np
from scipy.stats import norm

class DataStatistics4:
    @staticmethod
    def correlation_coefficient(data1, data2):
        mean1 = np.mean(data1)
        mean2 = np.mean(data2)
        numerator = sum((x - mean1) * (y - mean2) for x, y in zip(data1, data2))
        denominator = math.sqrt(sum((x - mean1) ** 2 for x in data1)) * math.sqrt(sum((y - mean2) ** 2 for y in data2))
        return numerator / denominator

    @staticmethod
    def skewness(data):
        mean = np.mean(data)
        variance = np.var(data)
        std_dev = math.sqrt(variance)
        numerator = sum((x - mean) ** 3 for x in data)
        denominator = len(data) * (std_dev ** 3)
        return numerator / denominator

    @staticmethod
    def kurtosis(data):
        mean = np.mean(data)
        variance = np.var(data)
        std_dev = math.sqrt(variance)
        numerator = sum((x - mean) ** 4 for x in data)
        denominator = len(data) * (std_dev ** 4)
        return numerator / denominator - 3

    @staticmethod
    def pdf(data, mu, sigma):
        return [norm.pdf(x, mu, sigma) for x in data]
```",0.16820701073056668,0.22234718620679753,0.5116279069767442,0.6567164179104478,0.5751633937699175,0.2994011976047904,0.47619047619047616,0.3676470540833153,0.5,0.6417910447761194,0.5620914983450811
Llama,32,"class DecryptionUtils:
    def __init__(self, key):
        self.key = key
    
    def caesar_decipher(self, ciphertext, shift):
        plaintext = """"
        for char in ciphertext:
            if char.isalpha():
                if char.isupper():
                    ascii_offset = 65
                else:
                    ascii_offset = 97
                shifted_char = chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)
                plaintext += shifted_char
            else:
                plaintext += char
        return plaintext
    
    def vigenere_decipher(self, ciphertext):
        decrypted_text = """"
        key_index = 0
        for char in ciphertext:
            if char.isalpha():
                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')
                decrypted_char = chr((ord(char.lower()) - ord('a') - shift) % 26 + ord('a'))
                decrypted_text += decrypted_char.upper() if char.isupper() else decrypted_char
                key_index += 1
            else:
                decrypted_text += char
        return decrypted_text
    
    def rail_fence_decipher(self, encrypted_text, rails):
        fence = [['\n' for _ in range(len(encrypted_text))] for _ in range(rails)]
        direction = -1
        row, col = 0, 0

        for _ in range(len(encrypted_text)):
            if row == 0 or row == rails - 1:
                direction = -direction

            fence[row][col] = ''
            col += 1
            row += direction

        index = 0
        for i in range(rails):
            for j in range(len(encrypted_text)):
                if fence[i][j] == '':
                    fence[i][j] = encrypted_text[index]
                    index += 1

        plain_text = ''
        direction = -1
        row, col = 0, 0
        for _ in range(len(encrypted_text)):
            if row == 0 or row == rails - 1:
                direction = -direction

            plain_text += fence[row][col]
            col += 1
            row += direction

        return plain_text",COTFewShot,"

```python
class DecryptionUtils:
    def __init__(self, key):
        self.key = key

    def caesar_decipher(self, ciphertext, shift):
        plaintext = ''
        for char in ciphertext:
            if char.isalpha():
                ascii_offset = 97 if char.islower() else 65
                plaintext += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)
            else:
                plaintext += char
        return plaintext

    def vigenere_decipher(self, ciphertext):
        key = self.key
        key_index = 0
        plaintext = ''
        for char in ciphertext:
            if char.isalpha():
                ascii_offset = 97 if char.islower() else 65
                shift = ord(key[key_index].lower()) - 97
                plaintext += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)
                key_index = (key_index + 1) % len(key)
            else:
                plaintext += char
        return plaintext

    def rail_fence_decipher(self, encrypted_text, rails):
        # Calculate the length of each rail
        rail_lengths = [0] * rails
        index = 0
        for i in range(len(encrypted_text)):
            rail_lengths[index] += 1
            if index == 0:
                direction = 1
            elif index == rails - 1:
                direction = -1
            index += direction

        # Initialize the rails
        rails_list = [''] * rails
        index = 0
        for i in range(len(encrypted_text)):
            rails_list[index] += encrypted_text[i]
            if index == 0:
                direction = 1
            elif index == rails - 1:
                direction = -1
            index += direction

        # Reconstruct the plaintext
        plaintext = [''] * len(encrypted_text)
        index = 0
        for i in range(rails):
            for j in range(rail_lengths[i]):
                plaintext[index] = rails_list[i][j]
                if i == 0:
                    direction = 1
                elif i == rails - 1:
                    direction = -1
                index += (rails - 1) * direction if i == 0 or i == rails - 1 else direction

        return ''.join(plaintext)
```",0.256198347107438,0.3217677292981897,0.6506024096385542,0.627906976744186,0.6390532494394455,0.43506493506493504,0.42948717948717946,0.4322580595163372,0.6506024096385542,0.627906976744186,0.6390532494394455
Llama,33,"class DiscountStrategy:
    def __init__(self, customer, cart, promotion=None):
        self.customer = customer
        self.cart = cart
        self.promotion = promotion
        self.__total = self.total()

    def total(self):
        self.__total = sum(item['quantity'] * item['price'] for item in self.cart)
        return self.__total

    def due(self):
        if self.promotion is None:
            discount = 0
        else:
            discount = self.promotion(self)
        return self.__total - discount

    @staticmethod
    def FidelityPromo(order):
        return order.total() * 0.05 if order.customer['fidelity'] >= 1000 else 0

    @staticmethod
    def BulkItemPromo(order):
        discount = 0
        for item in order.cart:
            if item['quantity'] >= 20:
                discount += item['quantity'] * item['price'] * 0.1
        return discount

    @staticmethod
    def LargeOrderPromo(order):
        return order.total() * 0.07 if len({item['product'] for item in order.cart}) >= 10 else 0",COTFewShot,"

```python
class DiscountStrategy:
    def __init__(self, customer, cart, promotion=None):
        self.customer = customer
        self.cart = cart
        self.promotion = promotion
        self.total()

    def total(self):
        total_cost = sum(item['quantity'] * item['price'] for item in self.cart)
        return total_cost

    def due(self):
        total_cost = self.total()
        if self.promotion:
            discount = self.promotion(self)
            return total_cost - discount
        else:
            return total_cost

    @staticmethod
    def FidelityPromo(order):
        if order.customer['fidelity'] > 1000:
            return order.total() * 0.05
        else:
            return 0.0

    @staticmethod
    def BulkItemPromo(order):
        discount = 0.0
        for item in order.cart:
            if item['quantity'] >= 20:
                discount += item['quantity'] * item['price'] * 0.10
        return discount

    @staticmethod
    def LargeOrderPromo(order):
        unique_products = len(set(item['product'] for item in order.cart))
        if unique_products >= 10:
            return order.total() * 0.07
        else:
            return 0.0
```",0.45714285714285713,0.521700521067724,0.8431372549019608,0.8113207547169812,0.8269230719249261,0.7052631578947368,0.6633663366336634,0.6836734643924407,0.8431372549019608,0.8113207547169812,0.8269230719249261
Llama,34,"from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT


class DocFileHandler:
    def __init__(self, file_path):
        self.file_path = file_path

    def read_text(self):
        doc = Document(self.file_path)
        text = []
        for paragraph in doc.paragraphs:
            text.append(paragraph.text)
        return ""\n"".join(text)

    def write_text(self, content, font_size=12, alignment='left'):
        try:
            doc = Document()
            paragraph = doc.add_paragraph()
            run = paragraph.add_run(content)
            font = run.font
            font.size = Pt(font_size)
            alignment_value = self._get_alignment_value(alignment)
            paragraph.alignment = alignment_value
            doc.save(self.file_path)
            return True
        except:
            return False

    def add_heading(self, heading, level=1):
        try:
            doc = Document(self.file_path)
            doc.add_heading(heading, level)
            doc.save(self.file_path)
            return True
        except:
            return False

    def add_table(self, data):
        try:
            doc = Document(self.file_path)
            table = doc.add_table(rows=len(data), cols=len(data[0]))
            for i, row in enumerate(data):
                for j, cell_value in enumerate(row):
                    table.cell(i, j).text = str(cell_value)
            doc.save(self.file_path)
            return True
        except:
            return False

    def _get_alignment_value(self, alignment):
        alignment_options = {
            'left': WD_PARAGRAPH_ALIGNMENT.LEFT,
            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,
            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT
        }
        return alignment_options.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)",COTFewShot,"

```python
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT


class DocFileHandler:
    def __init__(self, file_path):
        self.file_path = file_path

    def read_text(self):
        try:
            doc = Document(self.file_path)
            text = []
            for para in doc.paragraphs:
                text.append(para.text)
            return '\n'.join(text)
        except:
            return None

    def write_text(self, content, font_size=12, alignment='left'):
        try:
            doc = Document()
            para = doc.add_paragraph()
            run = para.add_run(content)
            font = run.font
            font.size = Pt(font_size)
            para.alignment = self._get_alignment_value(alignment)
            doc.save(self.file_path)
            return True
        except:
            return False

    def add_heading(self, heading, level=1):
        try:
            doc = Document()
            para = doc.add_heading(heading, level=level)
            doc.save(self.file_path)
            return True
        except:
            return False

    def add_table(self, data):
        try:
            doc = Document()
            table = doc.add_table(rows=len(data), cols=len(data[0]), style='Table Grid')
            for i, row in enumerate(data):
                for j, cell in enumerate(row):
                    table.cell(i, j).text = str(cell)
            doc.save(self.file_path)
            return True
        except:
            return False

    def _get_alignment_value(self, alignment):
        if alignment == 'left':
            return WD_PARAGRAPH_ALIGNMENT.LEFT
        elif alignment == 'center':
            return WD_PARAGRAPH_ALIGNMENT.CENTER
        elif alignment == 'right':
            return WD_PARAGRAPH_ALIGNMENT.RIGHT
        else:
            return WD_PARAGRAPH_ALIGNMENT.LEFT
```",0.5208333333333334,0.5722899253828302,0.8072289156626506,0.788235294117647,0.7976190426197562,0.6567164179104478,0.6518518518518519,0.6542750879368722,0.8072289156626506,0.788235294117647,0.7976190426197562
Llama,35,"class EightPuzzle:
    def __init__(self, initial_state):
        self.initial_state = initial_state
        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

    def find_blank(self, state):
        for i in range(3):
            for j in range(3):
                if state[i][j] == 0:
                    return i, j

    def move(self, state, direction):
        i, j = self.find_blank(state)
        new_state = [row[:] for row in state]

        if direction == 'up':
            new_state[i][j], new_state[i - 1][j] = new_state[i - 1][j], new_state[i][j]
        elif direction == 'down':
            new_state[i][j], new_state[i + 1][j] = new_state[i + 1][j], new_state[i][j]
        elif direction == 'left':
            new_state[i][j], new_state[i][j - 1] = new_state[i][j - 1], new_state[i][j]
        elif direction == 'right':
            new_state[i][j], new_state[i][j + 1] = new_state[i][j + 1], new_state[i][j]

        return new_state

    def get_possible_moves(self, state):
        moves = []
        i, j = self.find_blank(state)

        if i > 0:
            moves.append('up')
        if i < 2:
            moves.append('down')
        if j > 0:
            moves.append('left')
        if j < 2:
            moves.append('right')

        return moves

    def solve(self):
        open_list = [(self.initial_state, [])]
        closed_list = []

        while open_list:
            current_state, path = open_list.pop(0)
            closed_list.append(current_state)

            if current_state == self.goal_state:
                return path

            for move in self.get_possible_moves(current_state):
                new_state = self.move(current_state, move)
                if new_state not in closed_list:
                    open_list.append((new_state, path + [move]))

        return None",COTFewShot,"

```python
class EightPuzzle:
    def __init__(self, initial_state):
        self.initial_state = initial_state
        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

    def find_blank(self, state):
        for i in range(3):
            for j in range(3):
                if state[i][j] == 0:
                    return i, j

    def move(self, state, direction):
        i, j = self.find_blank(state)
        new_state = [row[:] for row in state]
        if direction == 'up' and i > 0:
            new_state[i][j], new_state[i-1][j] = new_state[i-1][j], new_state[i][j]
        elif direction == 'down' and i < 2:
            new_state[i][j], new_state[i+1][j] = new_state[i+1][j], new_state[i][j]
        elif direction == 'left' and j > 0:
            new_state[i][j], new_state[i][j-1] = new_state[i][j-1], new_state[i][j]
        elif direction == 'right' and j < 2:
            new_state[i][j], new_state[i][j+1] = new_state[i][j+1], new_state[i][j]
        return new_state

    def get_possible_moves(self, state):
        i, j = self.find_blank(state)
        moves = []
        if i > 0:
            moves.append('up')
        if i < 2:
            moves.append('down')
        if j > 0:
            moves.append('left')
        if j < 2:
            moves.append('right')
        return moves

    def solve(self):
        open_list = [(self.initial_state, [])]
        while open_list:
            state, path = open_list.pop(0)
            if state == self.goal_state:
                return path
            for direction in self.get_possible_moves(state):
                new_state = self.move(state, direction)
                open_list.append((new_state, path + [direction]))
        return None
```",0.5478328082794295,0.5954453553021365,0.75,0.7674418604651163,0.7586206846558331,0.6540880503144654,0.6842105263157895,0.6688102843916006,0.75,0.7674418604651163,0.7586206846558331
Llama,36,"from datetime import datetime

class EmailClient:
    def __init__(self, addr, capacity) -> None:
        self.addr = addr
        self.capacity = capacity
        self.inbox = []
    
    def send_to(self, recv, content, size):
        if not recv.is_full_with_one_more_email(size):
            timestamp = datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
            email = {
                ""sender"": self.addr,
                ""receiver"": recv.addr,
                ""content"": content,
                ""size"": size,
                ""time"": timestamp,
                ""state"": ""unread""
            }
            recv.inbox.append(email)
            return True
        else:
            self.clear_inbox(size)
            return False
    
    def fetch(self):
        if len(self.inbox) == 0:
            return None
        for i in range(len(self.inbox)):
            if self.inbox[i]['state'] == ""unread"":
                self.inbox[i]['state'] = ""read""
                return self.inbox[i]
        return None

    def is_full_with_one_more_email(self, size):
        occupied_size = self.get_occupied_size()
        return True if occupied_size + size > self.capacity else False
        
    def get_occupied_size(self):
        occupied_size = 0
        for email in self.inbox:
            occupied_size += email[""size""]
        return occupied_size

    def clear_inbox(self, size):
        if len(self.addr) == 0:
            return
        freed_space = 0
        while freed_space < size and self.inbox:
            email = self.inbox[0]
            freed_space += email['size']
            del self.inbox[0]",COTFewShot,"

```python
from datetime import datetime

class EmailClient:
    def __init__(self, addr, capacity):
        self.addr = addr
        self.capacity = capacity
        self.inbox = []

    def send_to(self, receiver, content, size):
        if receiver.is_full_with_one_more_email(size):
            return False
        email = {
            'sender': self.addr,
            'receiver': receiver.addr,
            'content': content,
            'size': size,
            'time': datetime.now().strftime(""%Y-%m-%d %H:%M:%S""),
            'state': 'unread'
        }
        receiver.inbox.append(email)
        return True

    def fetch(self):
        for email in self.inbox:
            if email['state'] == 'unread':
                email['state'] = 'read'
                return email
        return None

    def is_full_with_one_more_email(self, size):
        return self.get_occupied_size() + size > self.capacity

    def get_occupied_size(self):
        return sum(email['size'] for email in self.inbox)

    def clear_inbox(self, size):
        while self.get_occupied_size() + size > self.capacity:
            self.inbox.pop(0)
```",0.18466277522363916,0.23340486019657505,0.5301204819277109,0.6984126984126984,0.6027397211212235,0.3475177304964539,0.48514851485148514,0.40495867282255316,0.5301204819277109,0.6984126984126984,0.6027397211212235
Llama,37,"class EncryptionUtils:
    def __init__(self, key):
        self.key = key

    def caesar_cipher(self, plaintext, shift):
        ciphertext = """"
        for char in plaintext:
            if char.isalpha():
                if char.isupper():
                    ascii_offset = 65
                else:
                    ascii_offset = 97
                shifted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)
                ciphertext += shifted_char
            else:
                ciphertext += char
        return ciphertext
    
    def vigenere_cipher(self, plain_text):
        encrypted_text = """"
        key_index = 0
        for char in plain_text:
            if char.isalpha():
                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')
                encrypted_char = chr((ord(char.lower()) - ord('a') + shift) % 26 + ord('a'))
                encrypted_text += encrypted_char.upper() if char.isupper() else encrypted_char
                key_index += 1
            else:
                encrypted_text += char
        return encrypted_text

    def rail_fence_cipher(self, plain_text, rails):
        fence = [['\n' for _ in range(len(plain_text))] for _ in range(rails)]
        direction = -1
        row, col = 0, 0

        for char in plain_text:
            if row == 0 or row == rails-1:
                direction = -direction

            fence[row][col] = char
            col += 1
            row += direction

        encrypted_text = ''
        for i in range(rails):
            for j in range(len(plain_text)):
                if fence[i][j] != '\n':
                    encrypted_text += fence[i][j]

        return encrypted_text",COTFewShot,"

```python
class EncryptionUtils:
    def __init__(self, key):
        self.key = key

    def caesar_cipher(self, plaintext, shift):
        ciphertext = """"
        for char in plaintext:
            if char.isalpha():
                ascii_offset = 65 if char.isupper() else 97
                ciphertext += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)
            else:
                ciphertext += char
        return ciphertext

    def vigenere_cipher(self, plaintext):
        key_index = 0
        ciphertext = """"
        for char in plaintext:
            if char.isalpha():
                ascii_offset = 65 if char.isupper() else 97
                shift = ord(self.key[key_index % len(self.key)].lower()) - 97
                ciphertext += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)
                key_index += 1
            else:
                ciphertext += char
        return ciphertext

    def rail_fence_cipher(self, plaintext, rails):
        fence = [[] for _ in range(rails)]
        index = 0
        step = 1
        for char in plaintext:
            fence[index].append(char)
            if index == 0:
                step = 1
            elif index == rails - 1:
                step = -1
            index += step
        ciphertext = """"
        for rail in fence:
            ciphertext += """".join(rail)
        return ciphertext
```",0.3034605862254767,0.36738266011562065,0.6296296296296297,0.7727272727272727,0.69387754607247,0.4236111111111111,0.5596330275229358,0.4822134338308675,0.6172839506172839,0.7575757575757576,0.6802721038955992
Llama,38,"import openpyxl


class ExcelProcessor:
    def __init__(self):
        pass

    def read_excel(self, file_name):
        data = []
        try:
            workbook = openpyxl.load_workbook(file_name)
            sheet = workbook.active
            for row in sheet.iter_rows(values_only=True):
                data.append(row)
            workbook.close()
            return data
        except:
            return None

    def write_excel(self, data, file_name):
        try:
            workbook = openpyxl.Workbook()
            sheet = workbook.active
            for row in data:
                sheet.append(row)
            workbook.save(file_name)
            workbook.close()
            return 1
        except:
            return 0

    def process_excel_data(self, N, save_file_name):
        data = self.read_excel(save_file_name)
        if data is None or N >= len(data[0]):
            return 0
        new_data = []
        for row in data:
            new_row = list(row[:])
            if not str(row[N]).isdigit():
                new_row.append(str(row[N]).upper())
            else:
                new_row.append(row[N])
            new_data.append(new_row)
        new_file_name = save_file_name.split('.')[0] + '_process.xlsx'
        success = self.write_excel(new_data, new_file_name)
        return success, new_file_name",COTFewShot,"

```python
import openpyxl

class ExcelProcessor:
    def __init__(self):
        pass

    def read_excel(self, file_name):
        try:
            wb = openpyxl.load_workbook(file_name)
            sheet = wb.active
            data = []
            for row in sheet.rows:
                row_data = []
                for cell in row:
                    row_data.append(cell.value)
                data.append(tuple(row_data))
            return data
        except:
            return None

    def write_excel(self, data, file_name):
        try:
            wb = openpyxl.Workbook()
            sheet = wb.active
            for row in data:
                sheet.append(row)
            wb.save(file_name)
            return 1
        except:
            return 0

    def process_excel_data(self, N, save_file_name):
        try:
            data = self.read_excel(save_file_name)
            if data is None:
                return 0, None
            processed_data = []
            for row in data:
                processed_row = list(row)
                if N <= len(processed_row):
                    processed_row[N-1] = str(processed_row[N-1]).upper()
                processed_data.append(tuple(processed_row))
            write_result = self.write_excel(processed_data, 'processed_' + save_file_name)
            return write_result, 'processed_' + save_file_name
        except:
            return 0, None
```",0.37037037037037035,0.41725893335624004,0.6060606060606061,0.6060606060606061,0.6060606010606061,0.46464646464646464,0.46,0.462311552789071,0.5909090909090909,0.5909090909090909,0.5909090859090911
Llama,39,"import re
from collections import deque
from decimal import Decimal


class ExpressionCalculator:
    def __init__(self):
        self.postfix_stack = deque()
        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]

    def calculate(self, expression):
        self.prepare(self.transform(expression))

        result_stack = deque()
        self.postfix_stack.reverse()

        while self.postfix_stack:
            current_op = self.postfix_stack.pop()
            if not self.is_operator(current_op):
                current_op = current_op.replace(""~"", ""-"")
                result_stack.append(current_op)
            else:
                second_value = result_stack.pop()
                first_value = result_stack.pop()

                first_value = first_value.replace(""~"", ""-"")
                second_value = second_value.replace(""~"", ""-"")

                temp_result = self._calculate(first_value, second_value, current_op)
                result_stack.append(str(temp_result))

        return float(eval(""*"".join(result_stack)))

    def prepare(self, expression):
        op_stack = deque([','])
        arr = list(expression)
        current_index = 0
        count = 0

        for i, current_op in enumerate(arr):
            if self.is_operator(current_op):
                if count > 0:
                    self.postfix_stack.append("""".join(arr[current_index: current_index + count]))
                peek_op = op_stack[-1]
                if current_op == ')':
                    while op_stack[-1] != '(':
                        self.postfix_stack.append(str(op_stack.pop()))
                    op_stack.pop()
                else:
                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):
                        self.postfix_stack.append(str(op_stack.pop()))
                        peek_op = op_stack[-1]
                    op_stack.append(current_op)

                count = 0
                current_index = i + 1
            else:
                count += 1

        if count > 1 or (count == 1 and not self.is_operator(arr[current_index])):
            self.postfix_stack.append("""".join(arr[current_index: current_index + count]))

        while op_stack[-1] != ',':
            self.postfix_stack.append(str(op_stack.pop()))

    @staticmethod
    def is_operator(c):
        return c in {'+', '-', '*', '/', '(', ')', '%'}

    def compare(self, cur, peek):
        if cur == '%':
            cur = '/'
        if peek == '%':
            peek = '/'
        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]

    @staticmethod
    def _calculate(first_value, second_value, current_op):
        if current_op == '+':
            return Decimal(first_value) + Decimal(second_value)
        elif current_op == '-':
            return Decimal(first_value) - Decimal(second_value)
        elif current_op == '*':
            return Decimal(first_value) * Decimal(second_value)
        elif current_op == '/':
            return Decimal(first_value) / Decimal(second_value)
        elif current_op == '%':
            return Decimal(first_value) % Decimal(second_value)
        else:
            raise ValueError(""Unexpected operator: {}"".format(current_op))

    @staticmethod
    def transform(expression):
        expression = re.sub(r""\s+"", """", expression)
        expression = re.sub(r""=$"", """", expression)
        arr = list(expression)

        for i, c in enumerate(arr):
            if c == '-':
                if i == 0:
                    arr[i] = '~'
                else:
                    prev_c = arr[i - 1]
                    if prev_c in {'+', '-', '*', '/', '(', 'E', 'e'}:
                        arr[i] = '~'

        if arr[0] == '~' and (len(arr) > 1 and arr[1] == '('):
            arr[0] = '-'
            return ""0"" + """".join(arr)
        else:
            return """".join(arr)",COTFewShot,"

```python
import re
from collections import deque
from decimal import Decimal


class ExpressionCalculator:
    def __init__(self):
        self.postfix_stack = deque()
        self.operat_priority = {'+': 0, '-': 3, '*': 2, '/': 1, '%': -1, '(': 1, ')': 0, '^': 2}

    def calculate(self, expression):
        self.prepare(expression)
        stack = deque()
        for token in self.postfix_stack:
            if token not in self.operat_priority:
                stack.append(Decimal(token))
            else:
                second_value = stack.pop()
                first_value = stack.pop()
                result = self._calculate(first_value, second_value, token)
                stack.append(result)
        return float(stack.pop())

    def prepare(self, expression):
        self.postfix_stack.clear()
        expression = self.transform(expression)
        operator_stack = deque()
        for token in expression:
            if token not in self.operat_priority:
                self.postfix_stack.append(token)
            elif token == '(':
                operator_stack.append(token)
            elif token == ')':
                while operator_stack[-1] != '(':
                    self.postfix_stack.append(operator_stack.pop())
                operator_stack.pop()
            else:
                while (operator_stack and 
                       self.compare(token, operator_stack[-1]) and 
                       operator_stack[-1] != '('):
                    self.postfix_stack.append(operator_stack.pop())
                operator_stack.append(token)
        while operator_stack:
            self.postfix_stack.append(operator_stack.pop())

    @staticmethod
    def is_operator(c):
        return c in {'+', '-', '*', '/', '(', ')', '%', '^'}

    def compare(self, cur, peek):
        return self.operat_priority[cur] >= self.operat_priority[peek]

    @staticmethod
    def _calculate(first_value, second_value, current_op):
        if current_op == '+':
            return first_value + second_value
        elif current_op == '-':
            return first_value - second_value
        elif current_op == '*':
            return first_value * second_value
        elif current_op == '/':
            if second_value == 0:
                raise ZeroDivisionError(""Cannot divide by zero"")
            return first_value / second_value
        elif current_op == '%':
            if second_value == 0:
                raise ZeroDivisionError(""Cannot divide by zero"")
            return first_value % second_value
        elif current_op == '^':
            return first_value ** second_value

    @staticmethod
    def transform(expression):
        return re.sub(r'\s', '', expression)
```",0.1505253598760676,0.19275918130878322,0.5034013605442177,0.6666666666666666,0.5736434059500631,0.2534722222222222,0.38219895287958117,0.30480166535117964,0.4965986394557823,0.6576576576576577,0.565891467965567
Llama,3,"import itertools


class ArrangementCalculator:
    def __init__(self, datas):
        self.datas = datas

    @staticmethod
    def count(n, m=None):
        if m is None or n == m:
            return ArrangementCalculator.factorial(n)
        else:
            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)

    @staticmethod
    def count_all(n):
        total = 0
        for i in range(1, n + 1):
            total += ArrangementCalculator.count(n, i)
        return total

    def select(self, m=None):
        if m is None:
            m = len(self.datas)
        result = []
        for permutation in itertools.permutations(self.datas, m):
            result.append(list(permutation))
        return result

    def select_all(self):
        result = []
        for i in range(1, len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    @staticmethod
    def factorial(n):
        result = 1
        for i in range(2, n + 1):
            result *= i
        return result",COTFewShot,"

```python
class ArrangementCalculator:
    def __init__(self, datas):
        self.datas = datas

    @staticmethod
    def count(n, m=None):
        if m is None:
            m = n
        if m > n:
            return 0
        result = 1
        for i in range(n, n - m, -1):
            result *= i
        return result

    @staticmethod
    def count_all(n):
        result = 0
        for i in range(1, n + 1):
            result += ArrangementCalculator.count(n, i)
        return result

    def select(self, m=None):
        if m is None:
            m = len(self.datas)
        if m > len(self.datas):
            return []
        import itertools
        return [list(x) for x in itertools.permutations(self.datas, m)]

    def select_all(self):
        result = []
        for i in range(1, len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    @staticmethod
    def factorial(n):
        result = 1
        for i in range(2, n + 1):
            result *= i
        return result
```",0.5338983050847458,0.5822835325199103,0.7758620689655172,0.8181818181818182,0.7964601719946747,0.6739130434782609,0.6739130434782609,0.673913038478261,0.7758620689655172,0.8181818181818182,0.7964601719946747
Llama,40,"class FitnessTracker:
    def __init__(self, height, weight, age, sex) -> None:
        self.height = height
        self.weight = weight
        self.age = age
        self.sex = sex
        self.BMI_std = [
            {""male"": [20, 25]},
            {""female"": [19, 24]}
        ]

    def get_BMI(self):
        return self.weight / self.height ** 2

    def condition_judge(self):
        BMI = self.get_BMI()
        if self.sex == ""male"":
            BMI_range = self.BMI_std[0][""male""]
        else:
            BMI_range = self.BMI_std[1][""female""]
        if BMI > BMI_range[1]:
            # too fat
            return 1
        elif BMI < BMI_range[0]:
            # too thin
            return -1
        else:
            # normal
            return 0

    def calculate_calorie_intake(self):
        if self.sex == ""male"":
            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5
        else:
            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161
        if self.condition_judge() == 1:
            calorie_intake = BMR * 1.2  # Sedentary lifestyle
        elif self.condition_judge() == -1:
            calorie_intake = BMR * 1.6  # Active lifestyle
        else:
            calorie_intake = BMR * 1.4  # Moderate lifestyle
        return calorie_intake",COTFewShot,"

```python
class FitnessTracker:
    def __init__(self, height, weight, age, sex):
        self.height = height
        self.weight = weight
        self.age = age
        self.sex = sex
        self.BMI_std = {
            ""male"": [20, 25],
            ""female"": [19, 24]
        }
        self.BMI = self.get_BMI()

    def get_BMI(self):
        return self.weight / (self.height ** 2)

    def condition_judge(self):
        if self.sex == ""male"":
            if self.BMI < self.BMI_std[""male""][0]:
                return -1
            elif self.BMI > self.BMI_std[""male""][1]:
                return 1
            else:
                return 0
        elif self.sex == ""female"":
            if self.BMI < self.BMI_std[""female""][0]:
                return -1
            elif self.BMI > self.BMI_std[""female""][1]:
                return 1
            else:
                return 0

    def calculate_calorie_intake(self):
        if self.sex == ""male"":
            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5
        elif self.sex == ""female"":
            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161
        condition = self.condition_judge()
        if condition == 1:
            return BMR * 1.2
        elif condition == -1:
            return BMR * 1.6
        else:
            return BMR * 1.4
```",0.3959738192696686,0.4616938192239463,0.6666666666666666,0.7619047619047619,0.7111111061333335,0.5227272727272727,0.5798319327731093,0.5498007918261616,0.6666666666666666,0.7619047619047619,0.7111111061333335
Llama,41,"class GomokuGame:
    def __init__(self, board_size):
        self.board_size = board_size
        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        return False

    def check_winner(self):
        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]
        for row in range(self.board_size):
            for col in range(self.board_size):
                if self.board[row][col] != ' ':
                    for direction in directions:
                        if self._check_five_in_a_row(row, col, direction):
                            return self.board[row][col]
        return None

    def _check_five_in_a_row(self, row, col, direction):
        dx, dy = direction
        count = 1
        symbol = self.board[row][col]
        for i in range(1, 5):
            new_row = row + dx * i
            new_col = col + dy * i
            if not (0 <= new_row < self.board_size and 0 <= new_col < self.board_size):
                return False
            if self.board[new_row][new_col] != symbol:
                return False
            count += 1
        return count == 5",COTFewShot,"

```python
class GomokuGame:
    def __init__(self, board_size):
        self.board_size = board_size
        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if row < 0 or row >= self.board_size or col < 0 or col >= self.board_size or self.board[row][col] != ' ':
            return False
        self.board[row][col] = self.current_player
        self.current_player = 'O' if self.current_player == 'X' else 'X'
        return True

    def check_winner(self):
        for row in range(self.board_size):
            for col in range(self.board_size):
                if self.board[row][col] != ' ':
                    for direction in [(0, 1), (1, 0), (1, 1), (1, -1)]:
                        if self._check_five_in_a_row(row, col, direction):
                            return self.board[row][col]
        return None

    def _check_five_in_a_row(self, row, col, direction):
        symbol = self.board[row][col]
        count = 1
        for i in range(1, 5):
            new_row, new_col = row + i * direction[0], col + i * direction[1]
            if new_row < 0 or new_row >= self.board_size or new_col < 0 or new_col >= self.board_size or self.board[new_row][new_col] != symbol:
                break
            count += 1
        for i in range(1, 5):
            new_row, new_col = row - i * direction[0], col - i * direction[1]
            if new_row < 0 or new_row >= self.board_size or new_col < 0 or new_col >= self.board_size or self.board[new_row][new_col] != symbol:
                break
            count += 1
        return count >= 5
```",0.39593908629441626,0.45058582157578386,0.8571428571428571,0.8571428571428571,0.8571428521428571,0.6715328467153284,0.6764705882352942,0.6739926689927412,0.8428571428571429,0.8428571428571429,0.8428571378571429
Llama,42,"class Hotel:
    def __init__(self, name, rooms):
        self.name = name
        self.available_rooms = rooms
        # available_rooms = {room_type1: room_number1, room_type2: room_number2, ...}
        # available_rooms = {'single': 5, 'double': 3}
        self.booked_rooms = {}
        # booked_rooms = {room_type1: {name1: room_number1, name2: room_number2, ...}, room_type2: {...}, ...}
        # booked_rooms = {'single': {'name1': 2, 'name2':1}, 'double': {}}

    def book_room(self, room_type, room_number, name):
        # Check if there are any rooms of the specified type available
        if room_type not in self.available_rooms.keys():
            return False

        if room_number <= self.available_rooms[room_type]:
            # Book the room by adding it to the booked_rooms dictionary
            if room_type not in self.booked_rooms.keys():
                self.booked_rooms[room_type] = {}
            self.booked_rooms[room_type][name] = room_number
            self.available_rooms[room_type] -= room_number
            return ""Success!""
        elif self.available_rooms[room_type] != 0:
            return self.available_rooms[room_type]
        else:
            return False

    def check_in(self, room_type, room_number, name):
        # Check if the room of the specified type and number is booked
        if room_type not in self.booked_rooms.keys():
            return False
        if name in self.booked_rooms[room_type]:
            if room_number > self.booked_rooms[room_type][name]:
                return False
            elif room_number == self.booked_rooms[room_type][name]:
                # Check in the room by removing it from the booked_rooms dictionary
                self.booked_rooms[room_type].pop(name)
            else:
                self.booked_rooms[room_type][name] -= room_number


    def check_out(self, room_type, room_number):
        if room_type in self.available_rooms:
            self.available_rooms[room_type] += room_number
        else:
            self.available_rooms[room_type] = room_number

    def get_available_rooms(self, room_type):
        return self.available_rooms[room_type]",COTFewShot,"

```python
class Hotel:
    def __init__(self, name, rooms):
        self.name = name
        self.available_rooms = rooms
        self.booked_rooms = {}

    def book_room(self, room_type, room_number, name):
        if room_type not in self.available_rooms:
            return False
        if self.available_rooms[room_type] < room_number:
            return self.available_rooms[room_type]
        if self.available_rooms[room_type] == 0:
            return False
        if room_type not in self.booked_rooms:
            self.booked_rooms[room_type] = {}
        if name not in self.booked_rooms[room_type]:
            self.booked_rooms[room_type][name] = 0
        self.booked_rooms[room_type][name] += room_number
        self.available_rooms[room_type] -= room_number
        return 'Success!'

    def check_in(self, room_type, room_number, name):
        if room_type not in self.booked_rooms or name not in self.booked_rooms[room_type]:
            return False
        if self.booked_rooms[room_type][name] < room_number:
            return False
        if self.booked_rooms[room_type][name] == room_number:
            del self.booked_rooms[room_type][name]
            if len(self.booked_rooms[room_type]) == 0:
                del self.booked_rooms[room_type]
        else:
            self.booked_rooms[room_type][name] -= room_number
        return True

    def check_out(self, room_type, room_number):
        if room_type not in self.available_rooms:
            self.available_rooms[room_type] = 0
        self.available_rooms[room_type] += room_number

    def get_available_rooms(self, room_type):
        if room_type not in self.available_rooms:
            return 0
        return self.available_rooms[room_type]
```",0.19248714578332526,0.23507249602328012,0.4431818181818182,0.7647058823529411,0.5611510744909685,0.34810126582278483,0.5670103092783505,0.4313725443057286,0.4431818181818182,0.7647058823529411,0.5611510744909685
Llama,43,"class HRManagementSystem:
    def __init__(self):
        self.employees = {}

    def add_employee(self, employee_id, name, position, department, salary):
        if employee_id in self.employees:
            return False
        else:
            self.employees[employee_id] = {
                'name': name,
                'position': position,
                'department': department,
                'salary': salary
            }
            return True

    def remove_employee(self, employee_id):
        if employee_id in self.employees:
            del self.employees[employee_id]
            return True
        else:
            return False

    def update_employee(self, employee_id: int, employee_info: dict):
        employee = self.get_employee(employee_id)
        if employee == False:
            return False
        else:
            for key, value in employee_info.items():
                if key not in employee:
                    return False
            for key, value in employee_info.items():
                employee[key] = value
            return True

    def get_employee(self, employee_id):
        if employee_id in self.employees:
            return self.employees[employee_id]
        else:
            return False

    def list_employees(self):
        employee_data = {}
        if self.employees:
            for employee_id, employee_info in self.employees.items():
                employee_details = {}
                employee_details[""employee_ID""] = employee_id
                for key, value in employee_info.items():
                    employee_details[key] = value
                employee_data[employee_id] = employee_details
        return employee_data",COTFewShot,"

```python
class HRManagementSystem:
    def __init__(self):
        self.employees = {}

    def add_employee(self, employee_id, name, position, department, salary):
        if employee_id in self.employees:
            return False
        else:
            self.employees[employee_id] = {'name': name, 'position': position, 'department': department, 'salary': salary}
            return True

    def remove_employee(self, employee_id):
        if employee_id in self.employees:
            del self.employees[employee_id]
            return True
        else:
            return False

    def update_employee(self, employee_id, employee_info):
        if employee_id in self.employees:
            self.employees[employee_id] = employee_info
            return True
        else:
            return False

    def get_employee(self, employee_id):
        if employee_id in self.employees:
            return self.employees[employee_id]
        else:
            return False

    def list_employees(self):
        result = {}
        for employee_id, employee_info in self.employees.items():
            result[employee_id] = {'employee_ID': employee_id, 'name': employee_info['name'], 'position': employee_info['position'], 'department': employee_info['department'], 'salary': employee_info['salary']}
        return result
```",0.424477247817276,0.46785548176188224,0.6206896551724138,0.75,0.6792452780633679,0.4857142857142857,0.6375,0.5513513464426589,0.6206896551724138,0.75,0.6792452780633679
Llama,44,"import re
import string
import gensim
from bs4 import BeautifulSoup


class HtmlUtil:

    def __init__(self):
        self.SPACE_MARK = '-SPACE-'
        self.JSON_MARK = '-JSON-'
        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'
        self.URL_MARK = '-URL-'
        self.NUMBER_MARK = '-NUMBER-'
        self.TRACE_MARK = '-TRACE-'
        self.COMMAND_MARK = '-COMMAND-'
        self.COMMENT_MARK = '-COMMENT-'
        self.CODE_MARK = '-CODE-'

    @staticmethod
    def __format_line_feed(text):
        return re.sub(re.compile(r'\n+'), '\n', text)

    def format_line_html_text(self, html_text):
        if html_text is None or len(html_text) == 0:
            return ''
        soup = BeautifulSoup(html_text, 'lxml')

        code_tag = soup.find_all(name=['pre', 'blockquote'])
        for tag in code_tag:
            tag.string = self.CODE_MARK

        ul_ol_group = soup.find_all(name=['ul', 'ol'])
        for ul_ol_item in ul_ol_group:
            li_group = ul_ol_item.find_all('li')
            for li_item in li_group:
                li_item_text = li_item.get_text().strip()
                if len(li_item_text) == 0:
                    continue
                if li_item_text[-1] in string.punctuation:
                    li_item.string = '[{0}]{1}'.format('-', li_item_text)
                    continue
                li_item.string = '[{0}]{1}.'.format('-', li_item_text)

        p_group = soup.find_all(name=['p'])
        for p_item in p_group:
            p_item_text = p_item.get_text().strip()
            if p_item_text:
                if p_item_text[-1] in string.punctuation:
                    p_item.string = p_item_text
                    continue
                next_sibling = p_item.find_next_sibling()
                if next_sibling and self.CODE_MARK in next_sibling.get_text():
                    p_item.string = p_item_text + ':'
                    continue
                p_item.string = p_item_text + '.'

        clean_text = gensim.utils.decode_htmlentities(soup.get_text())
        return self.__format_line_feed(clean_text)

    def extract_code_from_html_text(self, html_text):
        text_with_code_tag = self.format_line_html_text(html_text)

        if self.CODE_MARK not in text_with_code_tag:
            return []

        code_index_start = 0
        soup = BeautifulSoup(html_text, 'lxml')
        code_tag = soup.find_all(name=['pre', 'blockquote'])
        code_count = text_with_code_tag.count(self.CODE_MARK)
        code_list = []
        for code_index in range(code_index_start, code_index_start + code_count):
            code = code_tag[code_index].get_text()
            if code:
                code_list.append(code)
        return code_list",COTFewShot,"

```python
import re
import string
import gensim
from bs4 import BeautifulSoup

class HtmlUtil:
    def __init__(self):
        self.SPACE_MARK = '-SPACE-'
        self.JSON_MARK = '-JSON-'
        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'
        self.URL_MARK = '-URL-'
        self.NUMBER_MARK = '-NUMBER-'
        self.TRACE_MARK = '-TRACE-'
        self.COMMAND_MARK = '-COMMAND-'
        self.COMMENT_MARK = '-COMMENT-'
        self.CODE_MARK = '-CODE-'

    @staticmethod
    def __format_line_feed(text):
        return re.sub(r'\n+', '\n', text)

    def format_line_html_text(self, html_text):
        soup = BeautifulSoup(html_text, 'html.parser')
        for pre in soup.find_all('pre'):
            pre.replace_with(self.CODE_MARK)
        return self.__format_line_feed(soup.get_text())

    def extract_code_from_html_text(self, html_text):
        soup = BeautifulSoup(html_text, 'html.parser')
        codes = []
        for pre in soup.find_all('pre'):
            code = pre.get_text()
            codes.append(code)
        return codes
```",0.1496496854488133,0.1613586496442686,0.4188034188034188,0.8305084745762712,0.5568181773611829,0.3116279069767442,0.7127659574468085,0.4336569536954997,0.4188034188034188,0.8305084745762712,0.5568181773611829
Llama,45,"from PIL import Image, ImageEnhance, ImageChops


class ImageProcessor:
    def __init__(self):
        self.image = None

    def load_image(self, image_path):
        self.image = Image.open(image_path)

    def save_image(self, save_path):
        if self.image:
            self.image.save(save_path)

    def resize_image(self, width, height):
        if self.image:
            self.image = self.image.resize((width, height))

    def rotate_image(self, degrees):
        if self.image:
            self.image = self.image.rotate(degrees)

    def adjust_brightness(self, factor):
        if self.image:
            enhancer = ImageEnhance.Brightness(self.image)
            self.image = enhancer.enhance(factor)",COTFewShot,"

```python
from PIL import Image, ImageEnhance, ImageChops

class ImageProcessor:
    def __init__(self):
        self.image = None

    def load_image(self, image_path):
        self.image = Image.open(image_path)

    def save_image(self, save_path):
        if self.image:
            self.image.save(save_path)

    def resize_image(self, width, height):
        if self.image:
            self.image = self.image.resize((width, height))

    def rotate_image(self, degrees):
        if self.image:
            self.image = self.image.rotate(degrees)

    def adjust_brightness(self, factor):
        if self.image:
            enhancer = ImageEnhance.Brightness(self.image)
            self.image = enhancer.enhance(factor)
```",0.9629629629629629,0.9632870032952194,1.0,0.95,0.9743589693622617,1.0,0.9629629629629629,0.9811320704734782,1.0,0.95,0.9743589693622617
Llama,46,"class Interpolation:
    def __init__(self):
        pass

    @staticmethod
    def interpolate_1d(x, y, x_interp):
        y_interp = []
        for xi in x_interp:
            for i in range(len(x) - 1):
                if x[i] <= xi <= x[i+1]:
                    yi = y[i] + (y[i+1] - y[i]) * (xi - x[i]) / (x[i+1] - x[i])
                    y_interp.append(yi)
                    break
        return y_interp
    
    @staticmethod
    def interpolate_2d(x, y, z, x_interp, y_interp):
        z_interp = []
        for xi, yi in zip(x_interp, y_interp):
            for i in range(len(x) - 1):
                if x[i] <= xi <= x[i+1]:
                    for j in range(len(y) - 1):
                        if y[j] <= yi <= y[j+1]:
                            z00 = z[i][j]
                            z01 = z[i][j+1]
                            z10 = z[i+1][j]
                            z11 = z[i+1][j+1]
                            zi = (z00 * (x[i+1] - xi) * (y[j+1] - yi) +
                                  z10 * (xi - x[i]) * (y[j+1] - yi) +
                                  z01 * (x[i+1] - xi) * (yi - y[j]) +
                                  z11 * (xi - x[i]) * (yi - y[j])) / ((x[i+1] - x[i]) * (y[j+1] - y[j]))
                            z_interp.append(zi)
                            break
                    break
        return z_interp",COTFewShot,"

```python
class Interpolation:
    def __init__(self):
        pass

    @staticmethod
    def interpolate_1d(x, y, x_interp):
        y_interp = []
        for x_val in x_interp:
            if x_val <= x[0]:
                y_interp.append(y[0])
            elif x_val >= x[-1]:
                y_interp.append(y[-1])
            else:
                for i in range(len(x) - 1):
                    if x_val >= x[i] and x_val <= x[i + 1]:
                        slope = (y[i + 1] - y[i]) / (x[i + 1] - x[i])
                        y_val = y[i] + slope * (x_val - x[i])
                        y_interp.append(y_val)
                        break
        return y_interp

    @staticmethod
    def interpolate_2d(x, y, z, x_interp, y_interp):
        z_interp = []
        for i in range(len(x_interp)):
            x_val = x_interp[i]
            y_val = y_interp[i]
            if x_val <= x[0] and y_val <= y[0]:
                z_interp.append(z[0][0])
            elif x_val >= x[-1] and y_val >= y[-1]:
                z_interp.append(z[-1][-1])
            elif x_val <= x[0] and y_val >= y[-1]:
                z_interp.append(z[0][-1])
            elif x_val >= x[-1] and y_val <= y[0]:
                z_interp.append(z[-1][0])
            else:
                for j in range(len(x) - 1):
                    if x_val >= x[j] and x_val <= x[j + 1]:
                        for k in range(len(y) - 1):
                            if y_val >= y[k] and y_val <= y[k + 1]:
                                q11 = z[j][k]
                                q12 = z[j][k + 1]
                                q21 = z[j + 1][k]
                                q22 = z[j + 1][k + 1]
                                r1 = q11 + (q12 - q11) * (y_val - y[k]) / (y[k + 1] - y[k])
                                r2 = q21 + (q22 - q21) * (y_val - y[k]) / (y[k + 1] - y[k])
                                z_val = r1 + (r2 - r1) * (x_val - x[j]) / (x[j + 1] - x[j])
                                z_interp.append(z_val)
                                break
                        break
        return z_interp
```",0.1702127659574468,0.21226054395318963,0.5606060606060606,0.38144329896907214,0.45398772524219955,0.35964912280701755,0.23699421965317918,0.28571428092559104,0.5303030303030303,0.36082474226804123,0.429447847941586
Llama,47,"class IPAddress:
    def __init__(self, ip_address):
        self.ip_address = ip_address

    def is_valid(self):
        octets = self.ip_address.split('.')
        if len(octets) != 4:
            return False
        for octet in octets:
            if not octet.isdigit() or int(octet) < 0 or int(octet) > 255:
                return False
        return True

    def get_octets(self):
        if self.is_valid():
            return self.ip_address.split('.')
        else:
            return []

    def get_binary(self):
        if self.is_valid():
            binary_octets = []
            for octet in self.get_octets():
                binary_octets.append(format(int(octet), '08b'))
            return '.'.join(binary_octets)
        else:
            return ''",COTFewShot,"

```python
class IPAddress:
    def __init__(self, ip_address):
        self.ip_address = ip_address

    def is_valid(self):
        parts = self.ip_address.split('.')
        if len(parts) != 4:
            return False
        for part in parts:
            if not part.isdigit():
                return False
            if not 0 <= int(part) <= 255:
                return False
        return True

    def get_octets(self):
        if self.is_valid():
            return self.ip_address.split('.')
        else:
            return []

    def get_binary(self):
        if self.is_valid():
            binary_parts = []
            for part in self.ip_address.split('.'):
                binary_part = bin(int(part))[2:].zfill(8)
                binary_parts.append(binary_part)
            return '.'.join(binary_parts)
        else:
            return ''
```",0.4411764705882353,0.49097700567034896,0.6744186046511628,0.6444444444444445,0.6590909040934918,0.6119402985074627,0.5694444444444444,0.5899280525604265,0.6744186046511628,0.6444444444444445,0.6590909040934918
Llama,48,"import socket


class IpUtil:

    @staticmethod
    def is_valid_ipv4(ip_address):
        try:
            socket.inet_pton(socket.AF_INET, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def is_valid_ipv6(ip_address):
        try:
            socket.inet_pton(socket.AF_INET6, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def get_hostname(ip_address):
        try:
            hostname = socket.gethostbyaddr(ip_address)[0]
            return hostname
        except socket.herror:
            return None",COTFewShot,"

```python
import socket
import ipaddress


class IpUtil:
    @staticmethod
    def is_valid_ipv4(ip_address):
        try:
            ipaddress.IPv4Address(ip_address)
            return True
        except ipaddress.AddressValueError:
            return False

    @staticmethod
    def is_valid_ipv6(ip_address):
        try:
            ipaddress.IPv6Address(ip_address)
            return True
        except ipaddress.AddressValueError:
            return False

    @staticmethod
    def get_hostname(ip_address):
        try:
            return socket.gethostbyaddr(ip_address)[0]
        except socket.herror:
            return None

    @staticmethod
    def get_binary(ip_address):
        try:
            if IpUtil.is_valid_ipv4(ip_address):
                return ipaddress.IPv4Address(ip_address).packed
            elif IpUtil.is_valid_ipv6(ip_address):
                return ipaddress.IPv6Address(ip_address).packed
            else:
                return None
        except ipaddress.AddressValueError:
            return None
```",0.2807017543859649,0.32222833502232834,0.7083333333333334,0.5862068965517241,0.6415094290067641,0.5428571428571428,0.36538461538461536,0.4367816043863126,0.7083333333333334,0.5862068965517241,0.6415094290067641
Llama,49,"class JobMarketplace:
    def __init__(self):
        self.job_listings = []
        self.resumes = []

    def post_job(self, job_title, company, requirements):
        # requirements = ['requirement1', 'requirement2']
        job = {""job_title"": job_title, ""company"": company, ""requirements"": requirements}
        self.job_listings.append(job)

    def remove_job(self, job):
        self.job_listings.remove(job)

    def submit_resume(self, name, skills, experience):
        resume = {""name"": name, ""skills"": skills, ""experience"": experience}
        self.resumes.append(resume)

    def withdraw_resume(self, resume):
        self.resumes.remove(resume)

    def search_jobs(self, criteria):
        matching_jobs = []
        for job_listing in self.job_listings:
            if criteria.lower() in job_listing[""job_title""].lower() or criteria.lower() in [r.lower() for r in job_listing[""requirements""]]:
                matching_jobs.append(job_listing)
        return matching_jobs

    def get_job_applicants(self, job):
        applicants = []
        for resume in self.resumes:
            if self.matches_requirements(resume, job[""requirements""]):
                applicants.append(resume)
        return applicants

    @staticmethod
    def matches_requirements(resume, requirements):
        for skill in resume[""skills""]:
            if skill not in requirements:
                return False
        return True",COTFewShot,"

```python
class JobMarketplace:
    def __init__(self):
        self.job_listings = []
        self.resumes = []

    def post_job(self, job_title, company, requirements):
        self.job_listings.append({
            'job_title': job_title,
            'company': company,
            'requirements': requirements
        })

    def remove_job(self, job):
        if job in self.job_listings:
            self.job_listings.remove(job)

    def submit_resume(self, name, skills, experience):
        self.resumes.append({
            'name': name,
            'skills': skills,
            'experience': experience
        })

    def withdraw_resume(self, resume):
        if resume in self.resumes:
            self.resumes.remove(resume)

    def search_jobs(self, criteria):
        return [job for job in self.job_listings if criteria in job['requirements']]

    def matches_requirements(self, resume, job):
        return any(skill in job['requirements'] for skill in resume['skills'])

    def get_job_applicants(self, job):
        return [resume for resume in self.resumes if self.matches_requirements(resume, job)]
```",0.23048655622124353,0.28097882894503906,0.5588235294117647,0.6551724137931034,0.6031745982060973,0.35344827586206895,0.45054945054945056,0.39613526077341366,0.5588235294117647,0.6551724137931034,0.6031745982060973
Llama,4,"class AssessmentSystem:
    def __init__(self):
        self.students = {}

    def add_student(self, name, grade, major):
        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}

    def add_course_score(self, name, course, score):
        if name in self.students:
            self.students[name]['courses'][course] = score

    def get_gpa(self, name):
        if name in self.students and self.students[name]['courses']:
            return sum(self.students[name]['courses'].values()) / len(self.students[name]['courses'])
        else:
            return None

    def get_all_students_with_fail_course(self):
        students = []
        for name, student in self.students.items():
            for course, score in student['courses'].items():
                if score < 60:
                    students.append(name)
                    break
        return students

    def get_course_average(self, course):
        total = 0
        count = 0
        for student in self.students.values():
            if course in student['courses']:
                score = student['courses'][course]
                if score is not None:
                    total += score
                    count += 1
        return total / count if count > 0 else None

    def get_top_student(self):
        top_student = None
        top_gpa = 0
        for name, student in self.students.items():
            gpa = self.get_gpa(name)
            if gpa is not None and gpa > top_gpa:
                top_gpa = gpa
                top_student = name
        return top_student",COTFewShot,"

```python
class AssessmentSystem:
    def __init__(self):
        # Initialize the students dictionary in the assessment system
        self.students = {}

    def add_student(self, name, grade, major):
        # Add a new student into self.students dictionary
        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}

    def add_course_score(self, name, course, score):
        # Add score of specific course for student in self.students
        if name in self.students:
            self.students[name]['courses'][course] = score

    def get_gpa(self, name):
        # Get average grade of one student
        if name in self.students and self.students[name]['courses']:
            total_score = sum(self.students[name]['courses'].values())
            return total_score / len(self.students[name]['courses'])
        else:
            return None

    def get_all_students_with_fail_course(self):
        # Get all students who have any score below 60
        fail_students = []
        for student, info in self.students.items():
            for score in info['courses'].values():
                if score < 60:
                    fail_students.append(student)
                    break
        return fail_students

    def get_course_average(self, course):
        # Get the average score of a specific course
        total_score = 0
        count = 0
        for student, info in self.students.items():
            if course in info['courses']:
                total_score += info['courses'][course]
                count += 1
        if count > 0:
            return total_score / count
        else:
            return None

    def get_top_student(self):
        # Calculate every student's gpa and find the student with highest gpa
        top_student = None
        top_gpa = 0
        for student, info in self.students.items():
            gpa = self.get_gpa(student)
            if gpa is not None and gpa > top_gpa:
                top_gpa = gpa
                top_student = student
        return top_student
```",0.3413461538461539,0.3915615721673638,0.8904109589041096,0.6190476190476191,0.7303370738132813,0.6785714285714286,0.5,0.57575757087236,0.8904109589041096,0.6190476190476191,0.7303370738132813
Llama,50,"import json
import os


class JSONProcessor:
    def read_json(self, file_path):
        if not os.path.exists(file_path):
            return 0
        try:
            with open(file_path, 'r') as file:
                data = json.load(file)
            return data
        except:
            return -1

    def write_json(self, data, file_path):
        try:
            with open(file_path, 'w') as file:
                json.dump(data, file)
            return 1
        except:
            return -1

    def process_json(self, file_path, remove_key):
        data = self.read_json(file_path)
        if data == 0 or data == -1:
            return 0
        if remove_key in data:
            del data[remove_key]
            self.write_json(data, file_path)
            return 1
        else:
            return 0",COTFewShot,"

```python
import json
import os


class JSONProcessor:
    def __init__(self):
        pass

    def read_json(self, file_path):
        try:
            if not os.path.exists(file_path):
                return 0
            with open(file_path, 'r') as file:
                data = json.load(file)
            return data
        except:
            return -1

    def write_json(self, data, file_path):
        try:
            with open(file_path, 'w') as file:
                json.dump(data, file)
            return 1
        except:
            return -1

    def process_json(self, file_path, remove_key):
        try:
            if not os.path.exists(file_path):
                return 0
            with open(file_path, 'r') as file:
                data = json.load(file)
            if remove_key in data:
                del data[remove_key]
                with open(file_path, 'w') as file:
                    json.dump(data, file)
                return 1
            else:
                return 0
        except:
            return 0
```",0.5517241379310345,0.5971494366348035,0.851063829787234,0.9090909090909091,0.8791208741263132,0.7391304347826086,0.8225806451612904,0.77862594921275,0.851063829787234,0.9090909090909091,0.8791208741263132
Llama,51,"import numpy as np


class KappaCalculator:

    @staticmethod
    def kappa(testData, k):
        dataMat = np.mat(testData)
        P0 = 0.0
        for i in range(k):
            P0 += dataMat[i, i] * 1.0
        xsum = np.sum(dataMat, axis=1)
        ysum = np.sum(dataMat, axis=0)
        sum = np.sum(dataMat)
        Pe = float(ysum * xsum) / sum / sum
        P0 = float(P0 / sum * 1.0)
        cohens_coefficient = float((P0 - Pe) / (1 - Pe))
        return cohens_coefficient

    @staticmethod
    def fleiss_kappa(testData, N, k, n):
        dataMat = np.mat(testData, float)
        oneMat = np.ones((k, 1))
        sum = 0.0
        P0 = 0.0
        for i in range(N):
            temp = 0.0
            for j in range(k):
                sum += dataMat[i, j]
                temp += 1.0 * dataMat[i, j] ** 2
            temp -= n
            temp /= (n - 1) * n
            P0 += temp
        P0 = 1.0 * P0 / N
        ysum = np.sum(dataMat, axis=0)
        for i in range(k):
            ysum[0, i] = (ysum[0, i] / sum) ** 2
        Pe = ysum * oneMat * 1.0
        ans = (P0 - Pe) / (1 - Pe)
        return ans[0, 0]",COTFewShot,"

```python
import numpy as np

class KappaCalculator:
    @staticmethod
    def kappa(testData, k):
        # Calculate the Cohen's kappa value of a k-dimensional matrix
        data = np.array(testData)
        po = np.trace(data) / np.sum(data)
        pe = np.sum(np.multiply(np.sum(data, axis=0), np.sum(data, axis=1))) / np.sum(data)**2
        kappa = (po - pe) / (1 - pe)
        return kappa

    @staticmethod
    def fleiss_kappa(testData, N, k, n):
        # Calculate the Fleiss kappa value of an N * k matrix
        data = np.array(testData)
        p_j = np.sum(data, axis=0) / (N * n)
        p_e = np.sum(np.square(p_j))
        p_i = np.sum(np.square(data), axis=1) / n**2
        p_o = np.sum(p_i) / N
        kappa = (p_o - p_e) / (1 - p_e)
        return kappa
```",0.07741401371152061,0.10291604724849629,0.3194444444444444,0.359375,0.3382352891349481,0.13076923076923078,0.18478260869565216,0.15315314829965113,0.3194444444444444,0.359375,0.3382352891349481
Llama,52,"import nltk
from nltk.stem import WordNetLemmatizer
from nltk import pos_tag, word_tokenize
import string

nltk.download('averaged_perceptron_tagger')
nltk.download('punkt')
nltk.download('wordnet')


class Lemmatization:
    def __init__(self):
        self.lemmatizer = WordNetLemmatizer()

    def lemmatize_sentence(self, sentence):
        lemmatized_words = []
        sentence = self.remove_punctuation(sentence)
        words = word_tokenize(sentence)
        tagged_words = pos_tag(words)
        for word, tag in tagged_words:
            if tag.startswith('V'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='v')
            elif tag.startswith('J'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='a')
            elif tag.startswith('R'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='r')
            else:
                lemmatized_word = self.lemmatizer.lemmatize(word)
            lemmatized_words.append(lemmatized_word)
        return lemmatized_words

    def get_pos_tag(self, sentence):
        pos_tags = []
        sentence = self.remove_punctuation(sentence)
        words = word_tokenize(sentence)
        tagged_words = pos_tag(words)
        for tagged_word in tagged_words:
            pos_tags.append(tagged_word[1])
        return pos_tags

    def remove_punctuation(self, sentence):
        return sentence.translate(str.maketrans('', '', string.punctuation))",COTFewShot,"

```python
import nltk
from nltk.stem import WordNetLemmatizer
from nltk import pos_tag, word_tokenize
import string

nltk.download('averaged_perceptron_tagger')
nltk.download('punkt')
nltk.download('wordnet')

class Lemmatization:
    def __init__(self):
        # Create a WordNetLemmatizer object and store it
        self.lemmatizer = WordNetLemmatizer()

    def lemmatize_sentence(self, sentence):
        # Remove punctuation from the sentence
        sentence_no_punct = self.remove_punctuation(sentence)
        
        # Tokenize the sentence
        tokens = word_tokenize(sentence_no_punct)
        
        # Get the part of speech tag for each word
        pos_tags = pos_tag(tokens)
        
        # Lemmatize the words based on their parts of speech
        lemmatized_words = []
        for word, pos in pos_tags:
            if pos.startswith('J'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='a')
            elif pos.startswith('V'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='v')
            elif pos.startswith('N'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='n')
            elif pos.startswith('R'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='r')
            else:
                lemmatized_word = word
            lemmatized_words.append(lemmatized_word)
        
        return lemmatized_words

    def get_pos_tag(self, sentence):
        # Remove punctuation from the sentence
        sentence_no_punct = self.remove_punctuation(sentence)
        
        # Tokenize the sentence
        tokens = word_tokenize(sentence_no_punct)
        
        # Get the part of speech tag for each word
        pos_tags = pos_tag(tokens)
        
        # Return the part of speech tags
        return [pos[1] for pos in pos_tags]

    def remove_punctuation(self, sentence):
        # Remove punctuation from the sentence
        translator = str.maketrans('', '', string.punctuation)
        sentence_no_punct = sentence.translate(translator)
        
        return sentence_no_punct
```",0.22159090909090912,0.2661766137643223,0.8421052631578947,0.5454545454545454,0.6620689607457789,0.6153846153846154,0.4057971014492754,0.48908296464293216,0.8245614035087719,0.5340909090909091,0.648275857297503
Llama,53,"import re
import string


class LongestWord:

    def __init__(self):
        self.word_list = []

    def add_word(self, word):
        self.word_list.append(word)

    def find_longest_word(self, sentence):
        longest_word = """"
        sentence = sentence.lower()
        sentence = re.sub('[%s]' % re.escape(string.punctuation), '', sentence)
        sentence = re.split(' ', sentence)
        for word in sentence:
            if word in self.word_list and len(word) > len(longest_word):
                longest_word = word
        return longest_word",COTFewShot,"

```python
import re
import string

class LongestWord:
    def __init__(self):
        self.word_list = []

    def add_word(self, word):
        self.word_list.append(word)

    def find_longest_word(self, sentence):
        # Remove punctuation marks and split the sentence into a list of words
        words = re.sub('['+string.punctuation+']', '', sentence).split()
        
        # Initialize the longest word and its length
        longest_word = ''
        max_length = 0
        
        # Iterate over each word in the sentence
        for word in words:
            # Check if the word is in the word list and its length is greater than the current max length
            if word in self.word_list and len(word) > max_length:
                longest_word = word
                max_length = len(word)
        
        return longest_word
```",0.23469387755102042,0.2725885263281359,0.7368421052631579,0.45161290322580644,0.559999995288,0.5740740740740741,0.3263157894736842,0.41610737792892216,0.7368421052631579,0.45161290322580644,0.559999995288
Llama,54,"import random


class MahjongConnect:
    def __init__(self, BOARD_SIZE, ICONS):
        self.BOARD_SIZE = BOARD_SIZE
        self.ICONS = ICONS
        self.board = self.create_board()

    def create_board(self):
        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]
        return board

    def is_valid_move(self, pos1, pos2):
        x1, y1 = pos1
        x2, y2 = pos2

        # Check if positions are within the game board range
        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and 0 <= x2 < self.BOARD_SIZE[
            0] and 0 <= y2 <
                self.BOARD_SIZE[1]):
            return False

        # Check if the two positions are the same
        if pos1 == pos2:
            return False

        # Check if the two positions have the same icon
        if self.board[x1][y1] != self.board[x2][y2]:
            return False

        # Check if there is a valid path between the two positions
        if not self.has_path(pos1, pos2):
            return False

        return True

    def has_path(self, pos1, pos2):
        visited = set()
        stack = [pos1]

        while stack:
            current_pos = stack.pop()
            if current_pos == pos2:
                return True

            if current_pos in visited:
                continue

            visited.add(current_pos)
            x, y = current_pos

            # Check adjacent positions (up, down, left, right)
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                new_x, new_y = x + dx, y + dy
                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:
                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:
                        stack.append((new_x, new_y))

        return False

    def remove_icons(self, pos1, pos2):
        x1, y1 = pos1
        x2, y2 = pos2
        self.board[x1][y1] = ' '
        self.board[x2][y2] = ' '

    def is_game_over(self):
        for row in self.board:
            if any(icon != ' ' for icon in row):
                return False
        return True",COTFewShot,"

```python
import random

class MahjongConnect:
    def __init__(self, BOARD_SIZE, ICONS):
        # Initialize the board size and the icon list
        self.BOARD_SIZE = BOARD_SIZE
        self.ICONS = ICONS
        # Create the game board
        self.board = self.create_board()

    def create_board(self):
        # Create the game board with the given board size and icons
        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]
        return board

    def is_valid_move(self, pos1, pos2):
        # Check if the move of two icons is valid
        # Check if positions are within the game board range
        if pos1[0] < 0 or pos1[0] >= self.BOARD_SIZE[0] or pos1[1] < 0 or pos1[1] >= self.BOARD_SIZE[1]:
            return False
        if pos2[0] < 0 or pos2[0] >= self.BOARD_SIZE[0] or pos2[1] < 0 or pos2[1] >= self.BOARD_SIZE[1]:
            return False
        # Check if the two positions are not the same
        if pos1 == pos2:
            return False
        # Check if the two positions have the same icon
        if self.board[pos1[0]][pos1[1]] != self.board[pos2[0]][pos2[1]]:
            return False
        # Check if there is a valid path between the two positions
        if not self.has_path(pos1, pos2):
            return False
        return True

    def has_path(self, pos1, pos2):
        # Check if there is a path between two icons
        # Define the possible movements (up, down, left, right)
        movements = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        # Create a queue for BFS and add the starting position
        queue = [(pos1, [pos1])]
        # Create a set to store the visited positions
        visited = set()
        while queue:
            (x, y), path = queue.pop(0)
            # If the current position is the target position, return True
            if (x, y) == pos2:
                return True
            # Mark the current position as visited
            visited.add((x, y))
            # Check all possible movements
            for dx, dy in movements:
                nx, ny = x + dx, y + dy
                # Check if the new position is within the game board range and not visited
                if 0 <= nx < self.BOARD_SIZE[0] and 0 <= ny < self.BOARD_SIZE[1] and (nx, ny) not in visited:
                    # If the new position has the same icon, add it to the queue
                    if self.board[nx][ny] == self.board[pos1[0]][pos1[1]]:
                        queue.append(((nx, ny), path + [(nx, ny)]))
        # If no path is found, return False
        return False

    def remove_icons(self, pos1, pos2):
        # Remove the connected icons on the game board
        self.board[pos1[0]][pos1[1]] = ' '
        self.board[pos2[0]][pos2[1]] = ' '

    def is_game_over(self):
        # Check if the game is over (i.e., if there are no more icons on the game board)
        for row in self.board:
            for icon in row:
                if icon != ' ':
                    return False
        return True
```",0.2965686274509804,0.3333731113435214,0.7154471544715447,0.5333333333333333,0.611111106217448,0.581081081081081,0.3944954128440367,0.46994535037415275,0.7154471544715447,0.5333333333333333,0.611111106217448
Llama,55,"class Manacher:
    def __init__(self, input_string) -> None:
        self.input_string = input_string

    def palindromic_length(self, center, diff, string):
        if (center - diff == -1 or center + diff == len(string)
                or string[center - diff] != string[center + diff]):
            return 0
        return 1 + self.palindromic_length(center, diff + 1, string)


    def palindromic_string(self):
        max_length = 0

        new_input_string = """"
        output_string = """"

        for i in self.input_string[:len(self.input_string) - 1]:
            new_input_string += i + ""|""
        new_input_string += self.input_string[-1]

        for i in range(len(new_input_string)):

            length =self.palindromic_length(i, 1, new_input_string)

            if max_length < length:
                max_length = length
                start = i

        for i in new_input_string[start - max_length:start + max_length + 1]:
            if i != ""|"":
                output_string += i

        return output_string",COTFewShot,"

```python
class Manacher:
    def __init__(self, input_string):
        self.input_string = input_string

    def palindromic_length(self, center, diff, string):
        # Preprocess the string to handle even-length palindromes
        processed_string = '#' + '#'.join(string) + '#'
        
        # Initialize the length of the palindrome
        length = 0
        
        # Check if the characters at the current positions are equal
        while center - diff >= 0 and center + diff < len(processed_string) and processed_string[center - diff] == processed_string[center + diff]:
            # If they are equal, increment the difference
            diff += 1
        
        # The length of the palindrome is twice the difference minus 1 (for the center character)
        length = 2 * (diff - 1)
        
        return length

    def palindromic_string(self):
        # Preprocess the string to handle even-length palindromes
        processed_string = '#' + '#'.join(self.input_string) + '#'
        
        # Initialize the maximum length and center of the palindrome
        max_length = 0
        center = 0
        
        # Iterate over the processed string
        for i in range(len(processed_string)):
            # Calculate the length of the palindrome centered at the current position
            length = self.palindromic_length(i, 1, processed_string)
            
            # If the length of the current palindrome is greater than the maximum length, update the maximum length and center
            if length > max_length:
                max_length = length
                center = i
        
        # Extract the longest palindromic substring from the processed string
        palindromic_substring = processed_string[center - max_length // 2: center + max_length // 2 + 1]
        
        # Remove the '#' characters from the palindromic substring
        palindromic_substring = palindromic_substring.replace('#', '')
        
        return palindromic_substring
```",0.05128205128205127,0.07441734626438293,0.5517241379310345,0.3047619047619048,0.392638032225526,0.23300970873786409,0.12972972972972974,0.1666666620720005,0.5,0.2761904761904762,0.3558282162746058
Llama,56,"class MetricsCalculator:
    def __init__(self):
        self.true_positives = 0
        self.false_positives = 0
        self.false_negatives = 0
        self.true_negatives = 0

    def update(self, predicted_labels, true_labels):
        for predicted, true in zip(predicted_labels, true_labels):
            if predicted == 1 and true == 1:
                self.true_positives += 1
            elif predicted == 1 and true == 0:
                self.false_positives += 1
            elif predicted == 0 and true == 1:
                self.false_negatives += 1
            elif predicted == 0 and true == 0:
                self.true_negatives += 1

    def precision(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        if self.true_positives + self.false_positives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_positives)

    def recall(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        if self.true_positives + self.false_negatives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_negatives)

    def f1_score(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        precision = self.precision(predicted_labels, true_labels)
        recall = self.recall(predicted_labels, true_labels)
        if precision + recall == 0.0:
            return 0.0
        return (2 * precision * recall) / (precision + recall)

    def accuracy(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives
        if total == 0:
            return 0.0
        return (self.true_positives + self.true_negatives) / total",COTFewShot,"

```python
class MetricsCalculator:
    def __init__(self):
        # Initialize the number of all four samples to 0
        self.true_positives = 0
        self.false_positives = 0
        self.false_negatives = 0
        self.true_negatives = 0

    def update(self, predicted_labels, true_labels):
        # Update the number of all four samples
        for predicted, true in zip(predicted_labels, true_labels):
            if predicted == 1 and true == 1:
                self.true_positives += 1
            elif predicted == 1 and true == 0:
                self.false_positives += 1
            elif predicted == 0 and true == 1:
                self.false_negatives += 1
            elif predicted == 0 and true == 0:
                self.true_negatives += 1

    def precision(self, predicted_labels, true_labels):
        # Calculate precision
        self.update(predicted_labels, true_labels)
        if self.true_positives + self.false_positives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_positives)

    def recall(self, predicted_labels, true_labels):
        # Calculate recall
        self.update(predicted_labels, true_labels)
        if self.true_positives + self.false_negatives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_negatives)

    def f1_score(self, predicted_labels, true_labels):
        # Calculate f1 score
        precision = self.precision(predicted_labels, true_labels)
        recall = self.recall(predicted_labels, true_labels)
        if precision + recall == 0:
            return 0.0
        return 2 * (precision * recall) / (precision + recall)

    def accuracy(self, predicted_labels, true_labels):
        # Calculate accuracy
        self.update(predicted_labels, true_labels)
        total = self.true_positives + self.false_positives + self.false_negatives + self.true_negatives
        if total == 0:
            return 0.0
        return (self.true_positives + self.true_negatives) / total
```",0.7070707070707071,0.7349498361409575,0.98,0.7424242424242424,0.8448275813020214,0.8990825688073395,0.7538461538461538,0.8200836770469706,0.98,0.7424242424242424,0.8448275813020214
Llama,57,"import numpy as np


class MetricsCalculator2:
    def __init__(self):
        pass

    @staticmethod
    def mrr(data):
        if type(data) != list and type(data) != tuple:
            raise Exception(""the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple"")

        if len(data) == 0:
            return 0.0, [0.0]
        if type(data) == tuple:
            (sub_list, total_num) = data
            sub_list = np.array(sub_list)
            if total_num == 0:
                return 0.0, [0.0]
            else:
                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                mr_np = sub_list * ranking_array

                mr = 0.0
                for team in mr_np:
                    if team > 0:
                        mr = team
                        break
                return mr, [mr]

        if type(data) == list:
            separate_result = []
            for (sub_list, total_num) in data:
                sub_list = np.array(sub_list)

                if total_num == 0:
                    mr = 0.0
                else:
                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                    mr_np = sub_list * ranking_array

                    mr = 0.0
                    for team in mr_np:
                        if team > 0:
                            mr = team
                            break

                separate_result.append(mr)
            return np.mean(separate_result), separate_result

    @staticmethod
    def map(data):
        if type(data) != list and type(data) != tuple:
            raise Exception(""the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple"")

        if len(data) == 0:
            return 0.0, [0.0]
        if type(data) == tuple:
            (sub_list, total_num) = data
            sub_list = np.array(sub_list)
            if total_num == 0:
                return 0.0, [0.0]
            else:
                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)

                right_ranking_list = []
                count = 1
                for t in sub_list:
                    if t == 0:
                        right_ranking_list.append(0)
                    else:
                        right_ranking_list.append(count)
                        count += 1

                ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num
                return ap, [ap]

        if type(data) == list:
            separate_result = []
            for (sub_list, total_num) in data:
                sub_list = np.array(sub_list)

                if total_num == 0:
                    ap = 0.0
                else:
                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)

                    right_ranking_list = []
                    count = 1
                    for t in sub_list:
                        if t == 0:
                            right_ranking_list.append(0)
                        else:
                            right_ranking_list.append(count)
                            count += 1

                    ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num

                separate_result.append(ap)
            return np.mean(separate_result), separate_result",COTFewShot,"

```python
import numpy as np

class MetricsCalculator2:
    def __init__(self):
        pass

    @staticmethod
    def mrr(data):
        if isinstance(data, tuple):
            actual_result, ground_truth_num = data
            reciprocal_ranks = []
            for i, result in enumerate(actual_result):
                if result == 1:
                    reciprocal_ranks.append(1 / (i + 1))
            if reciprocal_ranks:
                mrr_value = np.mean(reciprocal_ranks)
            else:
                mrr_value = 0
            return mrr_value, [mrr_value]
        elif isinstance(data, list):
            mrr_values = []
            precision_values = []
            for item in data:
                mrr_value, _ = MetricsCalculator2.mrr(item)
                mrr_values.append(mrr_value)
                precision_values.append(mrr_value)
            return np.mean(mrr_values), precision_values
        else:
            raise ValueError(""Invalid input data"")

    @staticmethod
    def map(data):
        if isinstance(data, tuple):
            actual_result, ground_truth_num = data
            precision_values = []
            correct_count = 0
            for i, result in enumerate(actual_result):
                if result == 1:
                    correct_count += 1
                    precision_values.append(correct_count / (i + 1))
            if precision_values:
                map_value = np.mean(precision_values)
            else:
                map_value = 0
            return map_value, [map_value]
        elif isinstance(data, list):
            map_values = []
            precision_values = []
            for item in data:
                map_value, _ = MetricsCalculator2.map(item)
                map_values.append(map_value)
                precision_values.append(map_value)
            return np.mean(map_values), precision_values
        else:
            raise ValueError(""Invalid input data"")
```",0.03881978115459871,0.060806087763411655,0.3411764705882353,0.4084507042253521,0.3717948668351414,0.15862068965517243,0.20535714285714285,0.17898832193068792,0.3411764705882353,0.4084507042253521,0.3717948668351414
Llama,58,"import random

class MinesweeperGame:
    def __init__(self, n, k) -> None:
        self.n = n
        self.k = k
        self.minesweeper_map = self.generate_mine_sweeper_map()
        self.player_map = self.generate_playerMap()
        self.score = 0

    def generate_mine_sweeper_map(self):
        arr = [[0 for row in range(self.n)] for column in range(self.n)]
        for num in range(self.k):
            x = random.randint(0, self.n-1)
            y = random.randint(0, self.n-1)
            arr[y][x] = 'X'
            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-1):
                if arr[y][x+1] != 'X':
                    arr[y][x+1] += 1
            if (x >=1 and x <= self.n-1) and (y >= 0 and y <= self.n-1):
                if arr[y][x-1] != 'X':
                    arr[y][x-1] += 1
            if (x >= 1 and x <= self.n-1) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x-1] != 'X':
                    arr[y-1][x-1] += 1
    
            if (x >= 0 and x <= self.n-2) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x+1] != 'X':
                    arr[y-1][x+1] += 1 
            if (x >= 0 and x <= self.n-1) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x] != 'X':
                    arr[y-1][x] += 1
    
            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x+1] != 'X':
                    arr[y+1][x+1] += 1
            if (x >= 1 and x <= self.n-1) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x-1] != 'X':
                    arr[y+1][x-1] += 1
            if (x >= 0 and x <= self.n-1) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x] != 'X':
                    arr[y+1][x] += 1
        return arr
    
    def generate_playerMap(self):
        arr = [['-' for row in range(self.n)] for column in range(self.n)]
        return arr

    def check_won(self, map):
        for i in range(self.n):
            for j in range(self.n):
                if map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':
                    return False
        return True
    
    def sweep(self, x, y):

        if (self.minesweeper_map[x][y] == 'X'):
            return False
        else:
            self.player_map[x][y] = self.minesweeper_map[x][y]
            self.score += 1
            if self.check_won(self.player_map) == True:
                return True
            return self.player_map",COTFewShot,"

```python
import random

class MinesweeperGame:
    def __init__(self, n, k):
        """"""
        Initialize the MinesweeperGame class with the size of the board and the number of mines.
        
        Args:
            n (int): The size of the board.
            k (int): The number of mines.
        """"""
        self.n = n
        self.k = k
        self.minesweeper_map = self.generate_mine_sweeper_map()
        self.player_map = self.generate_playerMap()
        self.score = 0

    def generate_mine_sweeper_map(self):
        """"""
        Generate a minesweeper map with the given size of the board and the number of mines.
        
        Returns:
            list: The minesweeper map.
        """"""
        # Initialize the map with zeros
        map = [[0 for _ in range(self.n)] for _ in range(self.n)]
        
        # Randomly place the mines
        mines = random.sample(range(self.n * self.n), self.k)
        for mine in mines:
            x, y = mine // self.n, mine % self.n
            map[x][y] = 'X'
        
        # Calculate the number of mines around each position
        for i in range(self.n):
            for j in range(self.n):
                if map[i][j] != 'X':
                    count = 0
                    for x in range(max(0, i-1), min(self.n, i+2)):
                        for y in range(max(0, j-1), min(self.n, j+2)):
                            if map[x][y] == 'X':
                                count += 1
                    map[i][j] = count
        
        return map

    def generate_playerMap(self):
        """"""
        Generate a player map with the given size of the board.
        
        Returns:
            list: The player map.
        """"""
        # Initialize the map with unknown positions
        return [['-' for _ in range(self.n)] for _ in range(self.n)]

    def check_won(self, map):
        """"""
        Check whether the player has won the game.
        
        Args:
            map (list): The player map.
        
        Returns:
            bool: True if the player has won, False otherwise.
        """"""
        # Check if all non-mine positions are revealed
        for i in range(self.n):
            for j in range(self.n):
                if self.minesweeper_map[i][j] != 'X' and map[i][j] == '-':
                    return False
        return True

    def sweep(self, x, y):
        """"""
        Sweep the given position.
        
        Args:
            x (int): The x coordinate of the position.
            y (int): The y coordinate of the position.
        
        Returns:
            bool or list: True if the player has won, False if the game continues, or the updated player map.
        """"""
        # Check if the position is within the board
        if x < 0 or x >= self.n or y < 0 or y >= self.n:
            return False
        
        # Check if the position is already revealed
        if self.player_map[x][y] != '-':
            return False
        
        # Reveal the position
        self.player_map[x][y] = self.minesweeper_map[x][y]
        
        # Check if the player has won
        if self.check_won(self.player_map):
            return True
        
        # If the revealed position is a mine, end the game
        if self.minesweeper_map[x][y] == 'X':
            return False
        
        # If the revealed position is a zero, recursively reveal all adjacent positions
        if self.minesweeper_map[x][y] == 0:
            for i in range(max(0, x-1), min(self.n, x+2)):
                for j in range(max(0, y-1), min(self.n, y+2)):
                    self.sweep(i, j)
        
        return self.player_map
```",0.09411764705882353,0.12978445327028473,0.6352941176470588,0.375,0.47161571585591433,0.39766081871345027,0.21725239616613418,0.280991730967574,0.6235294117647059,0.3680555555555556,0.46288209140176584
Llama,59,"from datetime import datetime
import numpy as np

class MovieBookingSystem:
    def __init__(self):
        self.movies = []

    def add_movie(self, name, price, start_time, end_time, n):
        movie = {
            'name': name,
            'price': price,
            'start_time': datetime.strptime(start_time, '%H:%M'),
            'end_time': datetime.strptime(end_time, '%H:%M'),
            'seats': np.zeros((n, n))
        }
        self.movies.append(movie)

    def book_ticket(self, name, seats_to_book):
        for movie in self.movies:
            if movie['name'] == name:
                for seat in seats_to_book:
                    if movie['seats'][seat[0]][seat[1]] == 0:
                        movie['seats'][seat[0]][seat[1]] = 1
                    else:
                        return ""Booking failed.""
                return ""Booking success.""
        return ""Movie not found.""


    def available_movies(self, start_time, end_time):
        start_time = datetime.strptime(start_time, '%H:%M')
        end_time = datetime.strptime(end_time, '%H:%M')

        available_movies = []
        for movie in self.movies:
            if start_time <= movie['start_time'] and movie['end_time'] <= end_time:
                available_movies.append(movie['name'])

        return available_movies",COTFewShot,"

```python
from datetime import datetime
import numpy as np

class MovieBookingSystem:
    def __init__(self):
        self.movies = []

    def add_movie(self, name, price, start_time, end_time, n):
        # Convert time strings to datetime objects
        start_time = datetime.strptime(start_time, '%H:%M')
        start_time = start_time.replace(year=1900, month=1, day=1)
        end_time = datetime.strptime(end_time, '%H:%M')
        end_time = end_time.replace(year=1900, month=1, day=1)

        # Create a new movie dictionary
        movie = {
            'name': name,
            'price': price,
            'start_time': start_time,
            'end_time': end_time,
            'seats': np.zeros((n, n))
        }

        # Add the movie to the list
        self.movies.append(movie)

    def book_ticket(self, name, seats_to_book):
        # Find the movie with the given name
        for movie in self.movies:
            if movie['name'] == name:
                # Check if the seats are available
                for seat in seats_to_book:
                    if movie['seats'][seat[0], seat[1]] == 1:
                        return 'Booking failed.'
                # Book the seats
                for seat in seats_to_book:
                    movie['seats'][seat[0], seat[1]] = 1
                return 'Booking success.'
        return 'Movie not found.'

    def available_movies(self, start_time, end_time):
        # Convert time strings to datetime objects
        start_time = datetime.strptime(start_time, '%H:%M')
        start_time = start_time.replace(year=1900, month=1, day=1)
        end_time = datetime.strptime(end_time, '%H:%M')
        end_time = end_time.replace(year=1900, month=1, day=1)

        # Find available movies
        available_movies = [movie['name'] for movie in self.movies 
                            if start_time < movie['end_time'] and end_time > movie['start_time']]
        return available_movies
```",0.2608695652173913,0.29979542277099824,0.8405797101449275,0.6105263157894737,0.7073170682964011,0.625,0.42207792207792205,0.5038759641800373,0.8260869565217391,0.6,0.6951219463451814
Llama,5,"class AutomaticGuitarSimulator:
    def __init__(self, text) -> None:
        self.play_text = text

    def interpret(self, display=False):
        if len(self.play_text) == 0:
            return
        else:
            play_list = []
            play_segs = self.play_text.split("" "")
            for play_seg in play_segs:
                pos = 0
                for ele in play_seg:
                    if ele.isalpha():
                        pos += 1
                        continue
                    break
                play_chord = play_seg[0:pos]
                play_value = play_seg[pos:]
                play_list.append({'Chord': play_chord, 'Tune': play_value})
                if display:
                    self.display(play_chord, play_value)
            return play_list

    def display(self, key, value):
        return ""Normal Guitar Playing -- Chord: %s, Play Tune: %s"" % (key, value)",COTFewShot,"

```python
class AutomaticGuitarSimulator:
    def __init__(self, text):
        """"""
        Initialize the score to be played.
        
        Args:
            text (str): The score to be played.
        """"""
        self.play_text = text

    def interpret(self, display=False):
        """"""
        Interpret the music score to be played.
        
        Args:
            display (bool): Whether to print the interpreted score.
        
        Returns:
            list: A list of dictionaries containing the chord and tune.
        """"""
        # Split the input text into individual notes
        notes = self.play_text.split()
        
        # Initialize an empty list to store the interpreted notes
        interpreted_notes = []
        
        # Iterate over each note
        for note in notes:
            # Extract the chord and tune from the note
            chord = ''
            tune = ''
            for char in note:
                if char.isalpha():
                    chord += char
                else:
                    tune += char
            
            # Add the interpreted note to the list
            interpreted_notes.append({'Chord': chord, 'Tune': tune})
        
        # If display is True, print the interpreted notes
        if display:
            for note in interpreted_notes:
                print(f""Normal Guitar Playing -- Chord: {note['Chord']}, Play Tune: {note['Tune']}"")
        
        # Return the list of interpreted notes
        return interpreted_notes

    def display(self, key, value):
        """"""
        Print out chord and play tune.
        
        Args:
            key (str): The chord.
            value (str): The tune.
        
        Returns:
            str: A string representing the chord and tune.
        """"""
        # Return a string representing the chord and tune
        return f""Normal Guitar Playing -- Chord: {key}, Play Tune: {value}""
```",0.047393364928909956,0.06590163210360171,0.46875,0.28846153846153844,0.3571428524263039,0.23170731707317074,0.10795454545454546,0.14728681736914864,0.421875,0.25961538461538464,0.3214285667120182
Llama,60,"import sqlite3


class MovieTicketDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS tickets (
                id INTEGER PRIMARY KEY,
                movie_name TEXT,
                theater_name TEXT,
                seat_number TEXT,
                customer_name TEXT
            )
        ''')
        self.connection.commit()

    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):
        self.cursor.execute('''
            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)
            VALUES (?, ?, ?, ?)
        ''', (movie_name, theater_name, seat_number, customer_name))
        self.connection.commit()

    def search_tickets_by_customer(self, customer_name):
        self.cursor.execute('''
            SELECT * FROM tickets WHERE customer_name = ?
        ''', (customer_name,))
        tickets = self.cursor.fetchall()
        return tickets

    def delete_ticket(self, ticket_id):
        self.cursor.execute('''
            DELETE FROM tickets WHERE id = ?
        ''', (ticket_id,))
        self.connection.commit()",COTFewShot,"

```python
import sqlite3

class MovieTicketDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        # Create a ""tickets"" table in the database if it does not exist already
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS tickets
            (id INTEGER PRIMARY KEY AUTOINCREMENT, 
            movie_name TEXT, 
            theater_name TEXT, 
            seat_number TEXT, 
            customer_name TEXT)
        ''')
        self.connection.commit()

    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):
        # Insert a new ticket into the ""tickets"" table
        self.cursor.execute('''
            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)
            VALUES (?, ?, ?, ?)
        ''', (movie_name, theater_name, seat_number, customer_name))
        self.connection.commit()

    def search_tickets_by_customer(self, customer_name):
        # Search for tickets in the ""tickets"" table by customer name
        self.cursor.execute('''
            SELECT * FROM tickets
            WHERE customer_name = ?
        ''', (customer_name,))
        return self.cursor.fetchall()

    def delete_ticket(self, ticket_id):
        # Delete a ticket from the ""tickets"" table by ticket ID
        self.cursor.execute('''
            DELETE FROM tickets
            WHERE id = ?
        ''', (ticket_id,))
        self.connection.commit()
```",0.5,0.532345254646754,0.9375,0.6521739130434783,0.7692307643918476,0.8297872340425532,0.5954198473282443,0.6933333284685432,0.921875,0.6413043478260869,0.7564102515713347
Llama,61,"class MusicPlayer:
    def __init__(self):
        self.playlist = []
        self.current_song = None
        self.volume = 50

    def add_song(self, song):
        self.playlist.append(song)

    def remove_song(self, song):
        if song in self.playlist:
            self.playlist.remove(song)
            if self.current_song == song:
                self.stop()

    def play(self):
        if self.playlist and self.current_song:
            return self.playlist[0]
        elif len(self.playlist): 
            return False

    def stop(self):
        if self.current_song:
            self.current_song = None
            return True
        else:
            return False

    def switch_song(self):
        if self.current_song:
            current_index = self.playlist.index(self.current_song)
            if current_index < len(self.playlist) - 1:
                self.current_song = self.playlist[current_index + 1]
                return True
            else:
                return False
        else:
            return False

    def previous_song(self):
        if self.current_song:
            current_index = self.playlist.index(self.current_song)
            if current_index > 0:
                self.current_song = self.playlist[current_index - 1]
                return True
            else:
                return False
        else:
            return False

    def set_volume(self, volume):
        if 0 <= volume <= 100:
            self.volume = volume
        else:
            return False

    def shuffle(self):
        if self.playlist:
            import random
            random.shuffle(self.playlist)
            return True
        else:
            return False",COTFewShot,"

```python
class MusicPlayer:
    def __init__(self):
        # Initialize the music player with an empty playlist, no current song, and a default volume of 50.
        self.playlist = []
        self.current_song = None
        self.volume = 50

    def add_song(self, song):
        # Add a song to the playlist.
        self.playlist.append(song)

    def remove_song(self, song):
        # Remove a song from the playlist if it exists.
        if song in self.playlist:
            self.playlist.remove(song)

    def play(self):
        # Play the current song in the playlist.
        if self.current_song is not None:
            return self.current_song
        else:
            return False

    def stop(self):
        # Stop the current song in the playlist.
        if self.current_song is not None:
            self.current_song = None
            return True
        else:
            return False

    def switch_song(self):
        # Switch to the next song in the playlist.
        if self.current_song is not None:
            current_index = self.playlist.index(self.current_song)
            if current_index < len(self.playlist) - 1:
                self.current_song = self.playlist[current_index + 1]
                return True
            else:
                return False
        else:
            if len(self.playlist) > 0:
                self.current_song = self.playlist[0]
                return True
            else:
                return False

    def previous_song(self):
        # Switch to the previous song in the playlist.
        if self.current_song is not None:
            current_index = self.playlist.index(self.current_song)
            if current_index > 0:
                self.current_song = self.playlist[current_index - 1]
                return True
            else:
                return False
        else:
            return False

    def set_volume(self, volume):
        # Set the volume of the music player if it's between 0 and 100.
        if 0 <= volume <= 100:
            self.volume = volume
            return True
        else:
            return False

    def shuffle(self):
        # Shuffle the playlist.
        if len(self.playlist) > 0:
            import random
            random.shuffle(self.playlist)
            return True
        else:
            return False
```",0.3601694915254237,0.3917989470845355,0.8983050847457628,0.5955056179775281,0.7162162114216583,0.7403846153846154,0.48125,0.5833333285583104,0.8983050847457628,0.5955056179775281,0.7162162114216583
Llama,62,"class NLPDataProcessor:

    def construct_stop_word_list(self):
        stop_word_list = ['a', 'an', 'the']
        return stop_word_list

    def remove_stop_words(self, string_list, stop_word_list):
        answer = []
        for string in string_list:
            string_split = string.split()
            for word in string_split:
                if word in stop_word_list:
                    string_split.remove(word)
            answer.append(string_split)
        return answer

    def process(self, string_list):
        stop_word_list = self.construct_stop_word_list()
        words_list = self.remove_stop_words(string_list, stop_word_list)
        return words_list",COTFewShot,"

```python
class NLPDataProcessor:
    def __init__(self):
        pass

    def construct_stop_word_list(self):
        # This method constructs a stop word list including 'a', 'an', 'the'.
        stop_word_list = ['a', 'an', 'the']
        return stop_word_list

    def remove_stop_words(self, string_list, stop_word_list):
        # This method removes all the stop words from the list of strings.
        result = []
        for string in string_list:
            words = string.split()
            words_without_stop_words = [word for word in words if word.lower() not in stop_word_list]
            result.append(words_without_stop_words)
        return result

    def process(self, string_list):
        # This method constructs a stop word list including 'a', 'an', 'the', and removes all the stop words from the list of strings.
        stop_word_list = self.construct_stop_word_list()
        return self.remove_stop_words(string_list, stop_word_list)
```",0.17,0.20896788704721808,0.7941176470588235,0.47368421052631576,0.5934065887259993,0.58,0.34523809523809523,0.43283581621742034,0.7941176470588235,0.47368421052631576,0.5934065887259993
Llama,63,"from collections import Counter
import re

class NLPDataProcessor2:

    def process_data(self, string_list):
        words_list = []
        for string in string_list:
            # Remove non-English letters and convert to lowercase
            processed_string = re.sub(r'[^a-zA-Z\s]', '', string.lower())
            # Split the string into words
            words = processed_string.split()
            words_list.append(words)
        return words_list

    def calculate_word_frequency(self, words_list):
        word_frequency = Counter()
        for words in words_list:
            word_frequency.update(words)
        sorted_word_frequency = dict(sorted(word_frequency.items(), key=lambda x: x[1], reverse=True))
        top_5_word_frequency = dict(list(sorted_word_frequency.items())[:5])
        return top_5_word_frequency

    def process(self, string_list):
        words_list = self.process_data(string_list)
        word_frequency_dict = self.calculate_word_frequency(words_list)
        return word_frequency_dict",COTFewShot,"

```python
from collections import Counter
import re

class NLPDataProcessor2:
    def process_data(self, string_list):
        # Keep only English letters and spaces in the string, then convert the string to lower case, and then split the string into a list of words.
        words_list = []
        for string in string_list:
            # Remove non-English letters and spaces, convert to lower case, and split into words
            words = re.sub('[^a-zA-Z\s]', '', string).lower().split()
            words_list.append(words)
        return words_list

    def calculate_word_frequency(self, words_list):
        # Calculate the word frequency of each word in the list of words list, and sort the word frequency dictionary by value in descending order.
        word_frequency = Counter(word for words in words_list for word in words)
        # Sort the word frequency dictionary by value in descending order and return the top 5
        return dict(sorted(word_frequency.items(), key=lambda item: item[1], reverse=True)[:5])

    def process(self, string_list):
        # Keep only English letters and spaces in the string, then convert the string to lower case, and then split the string into a list of words. 
        # Calculate the word frequency of each word in the list of words list, and sort the word frequency dictionary by value in descending order.
        words_list = self.process_data(string_list)
        return self.calculate_word_frequency(words_list)
```",0.1542553191489362,0.18049130213967482,0.7192982456140351,0.5256410256410257,0.6074074025283952,0.5487804878048781,0.36,0.4347826039114099,0.7192982456140351,0.5256410256410257,0.6074074025283952
Llama,64,"class NumberConverter:
    @staticmethod
    def decimal_to_binary(decimal_num):
        binary_num = bin(decimal_num)[2:]
        return binary_num

    @staticmethod
    def binary_to_decimal(binary_num):
        decimal_num = int(binary_num, 2)
        return decimal_num

    @staticmethod
    def decimal_to_octal(decimal_num):
        octal_num = oct(decimal_num)[2:]
        return octal_num

    @staticmethod
    def octal_to_decimal(octal_num):
        decimal_num = int(octal_num, 8)
        return decimal_num

    @staticmethod
    def decimal_to_hex(decimal_num):
        hex_num = hex(decimal_num)[2:]
        return hex_num

    @staticmethod
    def hex_to_decimal(hex_num):
        decimal_num = int(hex_num, 16)
        return decimal_num",COTFewShot,"

```python
class NumberConverter:
    @staticmethod
    def decimal_to_binary(decimal_num):
        # Convert a number from decimal format to binary format
        return bin(decimal_num)[2:]

    @staticmethod
    def binary_to_decimal(binary_num):
        # Convert a number from binary format to decimal format
        return int(binary_num, 2)

    @staticmethod
    def decimal_to_octal(decimal_num):
        # Convert a number from decimal format to octal format
        return oct(decimal_num)[2:]

    @staticmethod
    def octal_to_decimal(octal_num):
        # Convert a number from octal format to decimal format
        return int(octal_num, 8)

    @staticmethod
    def decimal_to_hex(decimal_num):
        # Convert a number from decimal format to hex format
        return hex(decimal_num)[2:]

    @staticmethod
    def hex_to_decimal(hex_num):
        # Convert a number from hex format to decimal format
        return int(hex_num, 16)
```",0.08421052631578946,0.10343931373005653,0.8,0.6060606060606061,0.689655167508918,0.2857142857142857,0.24489795918367346,0.2637362587658496,0.68,0.5151515151515151,0.586206891646849
Llama,65,"class NumberWordFormatter:
    def __init__(self):
        self.NUMBER = ["""", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""]
        self.NUMBER_TEEN = [""TEN"", ""ELEVEN"", ""TWELVE"", ""THIRTEEN"", ""FOURTEEN"", ""FIFTEEN"", ""SIXTEEN"", ""SEVENTEEN"",
                            ""EIGHTEEN"",
                            ""NINETEEN""]
        self.NUMBER_TEN = [""TEN"", ""TWENTY"", ""THIRTY"", ""FORTY"", ""FIFTY"", ""SIXTY"", ""SEVENTY"", ""EIGHTY"", ""NINETY""]
        self.NUMBER_MORE = ["""", ""THOUSAND"", ""MILLION"", ""BILLION""]
        self.NUMBER_SUFFIX = [""k"", ""w"", """", ""m"", """", """", ""b"", """", """", ""t"", """", """", ""p"", """", """", ""e""]

    def format(self, x):
        if x is not None:
            return self.format_string(str(x))
        else:
            return """"

    def format_string(self, x):
        lstr, rstr = (x.split('.') + [''])[:2]
        lstrrev = lstr[::-1]
        a = [''] * 5

        if len(lstrrev) % 3 == 1:
            lstrrev += ""00""
        elif len(lstrrev) % 3 == 2:
            lstrrev += ""0""

        lm = """"
        for i in range(len(lstrrev) // 3):
            a[i] = lstrrev[3 * i:3 * i + 3][::-1]
            if a[i] != ""000"":
                lm = self.trans_three(a[i]) + "" "" + self.parse_more(i) + "" "" + lm
            else:
                lm += self.trans_three(a[i])

        xs = f""AND CENTS {self.trans_two(rstr)} "" if rstr else """"
        if not lm.strip():
            return ""ZERO ONLY""
        else:
            return f""{lm.strip()} {xs}ONLY""

    def trans_two(self, s):
        s = s.zfill(2)
        if s[0] == ""0"":
            return self.NUMBER[int(s[-1])]
        elif s[0] == ""1"":
            return self.NUMBER_TEEN[int(s) - 10]
        elif s[1] == ""0"":
            return self.NUMBER_TEN[int(s[0]) - 1]
        else:
            return self.NUMBER_TEN[int(s[0]) - 1] + "" "" + self.NUMBER[int(s[-1])]

    def trans_three(self, s):
        if s[0] == ""0"":
            return self.trans_two(s[1:])
        elif s[1:] == ""00"":
            return f""{self.NUMBER[int(s[0])]} HUNDRED""
        else:
            return f""{self.NUMBER[int(s[0])]} HUNDRED AND {self.trans_two(s[1:])}""

    def parse_more(self, i):
        return self.NUMBER_MORE[i]",COTFewShot,"

```python
class NumberWordFormatter:
    def __init__(self):
        self.NUMBER = ["""", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""]
        self.NUMBER_TEEN = [""TEN"", ""ELEVEN"", ""TWELVE"", ""THIRTEEN"", ""FOURTEEN"", ""FIFTEEN"", ""SIXTEEN"", ""SEVENTEEN"",
                            ""EIGHTEEN"", ""NINETEEN""]
        self.NUMBER_TEN = ["""", ""TEN"", ""TWENTY"", ""THIRTY"", ""FORTY"", ""FIFTY"", ""SIXTY"", ""SEVENTY"", ""EIGHTY"", ""NINETY""]
        self.NUMBER_MORE = ["""", ""THOUSAND"", ""MILLION"", ""BILLION""]
        self.NUMBER_SUFFIX = [""k"", ""w"", """", ""m"", """", """", ""b"", """", """", ""t"", """", """", ""p"", """", """", ""e""]

    def format(self, x):
        if isinstance(x, int):
            return self.format_int(x) + "" ONLY""
        elif isinstance(x, float):
            integer_part = int(x)
            decimal_part = str(x).split('.')[1]
            return self.format_int(integer_part) + "" POINT "" + self.format_decimal(decimal_part) + "" ONLY""

    def format_string(self, x):
        if '.' in x:
            integer_part, decimal_part = x.split('.')
            return self.format_int(int(integer_part)) + "" POINT "" + self.format_decimal(decimal_part) + "" ONLY""
        else:
            return self.format_int(int(x)) + "" ONLY""

    def trans_two(self, s):
        if int(s) < 10:
            return self.NUMBER[int(s)]
        elif int(s) < 20:
            return self.NUMBER_TEEN[int(s) - 10]
        else:
            tens, ones = s
            if ones == '0':
                return self.NUMBER_TEN[int(tens)]
            else:
                return self.NUMBER_TEN[int(tens)] + "" "" + self.NUMBER[int(ones)]

    def trans_three(self, s):
        hundreds, tens, ones = s
        if hundreds == '0':
            return self.trans_two(tens + ones)
        elif tens == '0' and ones == '0':
            return self.NUMBER[int(hundreds)] + "" HUNDRED""
        else:
            return self.NUMBER[int(hundreds)] + "" HUNDRED AND "" + self.trans_two(tens + ones)

    def parse_more(self, i):
        return self.NUMBER_MORE[i]

    def format_int(self, x):
        if x == 0:
            return ""ZERO""
        result = """"
        i = 0
        while x > 0:
            if x % 1000 != 0:
                result = self.trans_three(str(x % 1000).zfill(3)) + "" "" + self.parse_more(i) + "" "" + result
            x //= 1000
            i += 1
        return result.strip()

    def format_decimal(self, x):
        result = """"
        for digit in x:
            result += self.NUMBER[int(digit)] + "" ""
        return result.strip()
```",0.3062730627306273,0.35584204234863615,0.6071428571428571,0.6071428571428571,0.6071428521428572,0.4429223744292237,0.42358078602620086,0.43303570928820556,0.6071428571428571,0.6071428571428571,0.6071428521428572
Llama,66,"class NumericEntityUnescaper:
    def __init__(self):
        pass

    def replace(self, string):
        out = []
        pos = 0
        length = len(string)

        while pos < length - 2:
            if string[pos] == '&' and string[pos + 1] == '#':
                start = pos + 2
                is_hex = False
                first_char = string[start]

                if first_char == 'x' or first_char == 'X':
                    start += 1
                    is_hex = True

                if start == length:
                    return ''.join(out)

                end = start
                while end < length and self.is_hex_char(string[end]):
                    end += 1

                if end < length and string[end] == ';':
                    try:
                        entity_value = int(string[start:end], 16 if is_hex else 10)
                    except:
                        return ''.join(out)

                    out.append(chr(entity_value))
                    pos = end + 1
                    continue

            out.append(string[pos])
            pos += 1

        return ''.join(out)

    @staticmethod
    def is_hex_char(char):
        return char.isdigit() or ('a' <= char.lower() <= 'f')",COTFewShot,"

```python
class NumericEntityUnescaper:
    def __init__(self):
        pass

    def replace(self, string):
        # Initialize an empty string to store the result
        result = """"
        
        # Initialize an empty string to store the numeric entity
        entity = """"
        
        # Initialize a flag to indicate whether we are currently processing a numeric entity
        in_entity = False
        
        # Iterate over each character in the input string
        i = 0
        while i < len(string):
            # If the character is an ampersand and we are not currently processing a numeric entity,
            # it could be the start of a numeric entity
            if string[i] == '&' and not in_entity:
                # Check if the next characters are '#x' or '#'
                if i + 2 < len(string) and string[i+1:i+3] == '#x':
                    in_entity = True
                    entity = ''
                    i += 3
                elif i + 1 < len(string) and string[i+1] == '#':
                    in_entity = True
                    entity = ''
                    i += 2
                else:
                    result += string[i]
                    i += 1
            # If we are currently processing a numeric entity and the character is a semicolon,
            # it could be the end of the numeric entity
            elif string[i] == ';' and in_entity:
                # Try to convert the numeric entity to a Unicode character
                try:
                    if entity.startswith('x'):
                        result += chr(int(entity[1:], 16))
                    else:
                        result += chr(int(entity))
                except ValueError:
                    # If the conversion fails, just append the entity to the result as is
                    result += '&' + entity + ';'
                in_entity = False
                entity = ''
                i += 1
            # If we are currently processing a numeric entity and the character is a digit or a letter,
            # add it to the entity
            elif in_entity:
                entity += string[i]
                i += 1
            # If we are not currently processing a numeric entity, just append the character to the result
            else:
                result += string[i]
                i += 1
        return result

    @staticmethod
    def is_hex_char(char):
        # Check if the character is a digit or a letter between 'a' and 'f' (inclusive) or between 'A' and 'F' (inclusive)
        return char.isdigit() or ('a' <= char <= 'f') or ('A' <= char <= 'F')
```",0.03571428571428572,0.05790505400585817,0.5454545454545454,0.3076923076923077,0.3934426183391562,0.22807017543859648,0.11711711711711711,0.15476190027848652,0.45454545454545453,0.2564102564102564,0.3278688478473528
Llama,67,"class Order:

    def __init__(self):
        self.menu = []
        # menu = [{""dish"": dish name, ""price"": price, ""count"": count}, ...]
        self.selected_dishes = []
        # selected_dish = {""dish"": dish name, ""count"": count, price: price}
        self.sales = {}
        # 


    def add_dish(self, dish):
        for menu_dish in self.menu:
            if dish[""dish""] == menu_dish[""dish""]:
                if menu_dish[""count""] < dish[""count""]:
                    return False
                else:
                    menu_dish[""count""] -= dish[""count""]
                    break
        self.selected_dishes.append(dish)
        return True

    def calculate_total(self):
        total = 0
        for dish in self.selected_dishes:
            total += dish[""price""] * dish[""count""] * self.sales[dish[""dish""]]
        return total

    def checkout(self):
        if len(self.selected_dishes) == 0:
            return False
        total = self.calculate_total()
        self.selected_dishes = []
        return total",COTFewShot,"

```python
class Order:
    def __init__(self):
        self.menu = []
        self.selected_dishes = []
        self.sales = {}

    def add_dish(self, dish):
        # Check if the dish exists in the menu and if the count is valid
        for menu_dish in self.menu:
            if menu_dish[""dish""] == dish[""dish""] and menu_dish[""count""] >= dish[""count""]:
                # Update the count in the menu
                menu_dish[""count""] -= dish[""count""]
                # Add the dish to the selected dishes
                self.selected_dishes.append(dish)
                return True
        return False

    def calculate_total(self):
        total = 0
        # Calculate the total price of dishes
        for dish in self.selected_dishes:
            if dish[""dish""] in self.sales:
                total += dish[""count""] * dish[""price""] * self.sales[dish[""dish""]]
            else:
                total += dish[""count""] * dish[""price""]
        return total

    def checkout(self):
        if not self.selected_dishes:
            return False
        return self.calculate_total()
```",0.19090909090909094,0.25155680847994893,0.6949152542372882,0.6612903225806451,0.6776859454162968,0.4673913043478261,0.4056603773584906,0.43434342936843184,0.6779661016949152,0.6451612903225806,0.661157019796462
Llama,68,"class PageUtil:
    def __init__(self, data, page_size):
        self.data = data
        self.page_size = page_size
        self.total_items = len(data)
        self.total_pages = (self.total_items + page_size - 1) // page_size

    def get_page(self, page_number):
        if page_number < 1 or page_number > self.total_pages:
            return []

        start_index = (page_number - 1) * self.page_size
        end_index = start_index + self.page_size
        return self.data[start_index:end_index]

    def get_page_info(self, page_number):
        if page_number < 1 or page_number > self.total_pages:
            return {}

        start_index = (page_number - 1) * self.page_size
        end_index = min(start_index + self.page_size, self.total_items)
        page_data = self.data[start_index:end_index]

        page_info = {
            ""current_page"": page_number,
            ""per_page"": self.page_size,
            ""total_pages"": self.total_pages,
            ""total_items"": self.total_items,
            ""has_previous"": page_number > 1,
            ""has_next"": page_number < self.total_pages,
            ""data"": page_data
        }
        return page_info

    def search(self, keyword):
        results = [item for item in self.data if keyword in str(item)]
        num_results = len(results)
        num_pages = (num_results + self.page_size - 1) // self.page_size

        search_info = {
            ""keyword"": keyword,
            ""total_results"": num_results,
            ""total_pages"": num_pages,
            ""results"": results
        }
        return search_info",COTFewShot,"

```python
class PageUtil:
    def __init__(self, data, page_size):
        """"""
        Initialize the PageUtil object with the given data and page size.
        
        Args:
            data (list): The data to be paginated.
            page_size (int): The number of items per page.
        """"""
        self.data = data
        self.page_size = page_size
        self.total_items = len(data)
        self.total_pages = (self.total_items + page_size - 1) // page_size

    def get_page(self, page_number):
        """"""
        Retrieve a specific page of data.
        
        Args:
            page_number (int): The page number to fetch.
        
        Returns:
            list: The data on the specified page.
        """"""
        start_index = (page_number - 1) * self.page_size
        end_index = start_index + self.page_size
        return self.data[start_index:end_index]

    def get_page_info(self, page_number):
        """"""
        Retrieve information about a specific page.
        
        Args:
            page_number (int): The page number to fetch information about.
        
        Returns:
            dict: The page information such as current page number, total pages, etc.
        """"""
        has_previous = page_number > 1
        has_next = page_number < self.total_pages
        page_info = {
            ""current_page"": page_number,
            ""per_page"": self.page_size,
            ""total_pages"": self.total_pages,
            ""total_items"": self.total_items,
            ""has_previous"": has_previous,
            ""has_next"": has_next,
            ""data"": self.get_page(page_number)
        }
        return page_info

    def search(self, keyword):
        """"""
        Search for items in the data that contain the given keyword.
        
        Args:
            keyword (str): The keyword to search for.
        
        Returns:
            dict: The search information such as total results and matching items.
        """"""
        matching_items = [item for item in self.data if str(keyword) in str(item)]
        total_results = len(matching_items)
        total_pages = (total_results + self.page_size - 1) // self.page_size
        search_info = {
            ""keyword"": keyword,
            ""total_results"": total_results,
            ""total_pages"": total_pages,
            ""results"": matching_items
        }
        return search_info
```",0.2943722943722944,0.3278952982710188,0.8108108108108109,0.5084745762711864,0.6249999952625868,0.6456692913385826,0.3867924528301887,0.483775806523786,0.8108108108108109,0.5084745762711864,0.6249999952625868
Llama,69,"import PyPDF2


class PDFHandler:
    def __init__(self, filepaths):
        self.filepaths = filepaths
        # PdfFileReader is deprecated and was removed in PyPDF2 3.0.0. Use PdfReader instead.
        self.readers = [PyPDF2.PdfReader(fp) for fp in filepaths]

    def merge_pdfs(self, output_filepath):
        pdf_writer = PyPDF2.PdfWriter()

        for reader in self.readers:
            # reader.getNumPages is deprecated and was removed in PyPDF2 3.0.0. Use len(reader.pages) instead.
            for page_num in range(len(reader.pages)):
                # reader.getPage(pageNumber) is deprecated and was removed in PyPDF2 3.0.0. Use reader.pages[page_number] instead.
                page = reader.pages[page_num]
                # addPage is deprecated and was removed in PyPDF2 3.0.0. Use add_page instead.
                pdf_writer.add_page(page)

        with open(output_filepath, 'wb') as out:
            pdf_writer.write(out)
        return f""Merged PDFs saved at {output_filepath}""

    def extract_text_from_pdfs(self):
        pdf_texts = []
        for reader in self.readers:
            for page_num in range(len(reader.pages)):
                page = reader.pages[page_num]
                pdf_texts.append(page.extract_text())
        return pdf_texts",COTFewShot,"

```python
import PyPDF2

class PDFHandler:
    def __init__(self, filepaths):
        self.filepaths = filepaths
        self.readers = [PyPDF2.PdfFileReader(fp) for fp in filepaths]

    def merge_pdfs(self, output_filepath):
        try:
            pdf_writer = PyPDF2.PdfFileWriter()
            for reader in self.readers:
                for page_num in range(reader.numPages):
                    pdf_writer.addPage(reader.getPage(page_num))
            with open(output_filepath, 'wb') as output_pdf:
                pdf_writer.write(output_pdf)
            return f""Merged PDFs saved at {output_filepath}""
        except Exception as e:
            return f""Failed to merge PDFs: {str(e)}""

    def extract_text_from_pdfs(self):
        pdf_texts = []
        for reader in self.readers:
            text = ''
            for page_num in range(reader.numPages):
                text += reader.getPage(page_num).extractText()
            pdf_texts.append(text)
        return pdf_texts
```",0.2536650951199468,0.28773900811848024,0.5384615384615384,0.5833333333333334,0.559999995008,0.4158415841584158,0.5,0.4540540490962747,0.5384615384615384,0.5833333333333334,0.559999995008
Llama,6,"class AvgPartition:
    def __init__(self, lst, limit):
        self.lst = lst
        self.limit = limit

    def setNum(self):
        size = len(self.lst) // self.limit
        remainder = len(self.lst) % self.limit
        return size, remainder

        
    def get(self, index):
        size, remainder = self.setNum()
        start = index * size + min(index, remainder)
        end = start + size
        if index + 1 <= remainder:
            end += 1
        return self.lst[start:end]",COTFewShot,"

```python
class AvgPartition:
    def __init__(self, lst, limit):
        # Check if the number of partitions is greater than 0
        if limit <= 0:
            raise ValueError(""Number of partitions must be greater than 0"")
        self.lst = lst
        self.limit = limit

    def setNum(self):
        # Calculate the size of each block and the remainder of the division
        block_size = len(self.lst) // self.limit
        remainder = len(self.lst) % self.limit
        return (block_size, remainder)

    def get(self, index):
        # Calculate the size of each block and the remainder of the division
        block_size, remainder = self.setNum()
        
        # Calculate the start and end positions based on the index of the partition
        start = index * block_size + min(index, remainder)
        end = (index + 1) * block_size + min(index + 1, remainder)
        
        # Return the corresponding block as list
        return self.lst[start:end]
```",0.1968503937007874,0.2313825861943754,0.8857142857142857,0.4492753623188406,0.5961538416882397,0.6101694915254238,0.32142857142857145,0.4210526270592661,0.8857142857142857,0.4492753623188406,0.5961538416882397
Llama,70,"class PersonRequest:
    def __init__(self, name: str, sex: str, phoneNumber: str):
        self.name = self._validate_name(name)
        self.sex = self._validate_sex(sex)
        self.phoneNumber = self._validate_phoneNumber(phoneNumber)

    def _validate_name(self, name: str) -> str:
        if not name:
            return None
        if len(name) > 33:
            return None
        return name

    def _validate_sex(self, sex: str) -> str:
        if sex not in [""Man"", ""Woman"", ""UGM""]:
            return None
        return sex

    def _validate_phoneNumber(self, phoneNumber: str) -> str:
        if not phoneNumber:
            return None
        if len(phoneNumber) != 11 or not phoneNumber.isdigit():
            return None
        return phoneNumber",COTFewShot,"

```python
class PersonRequest:
    def __init__(self, name: str, sex: str, phoneNumber: str):
        self.name = self._validate_name(name)
        self.sex = self._validate_sex(sex)
        self.phoneNumber = self._validate_phoneNumber(phoneNumber)

    def _validate_name(self, name: str) -> str:
        if not name or len(name) > 33:
            return None
        return name

    def _validate_sex(self, sex: str) -> str:
        if sex not in ['Man', 'Woman', 'UGM']:
            return None
        return sex

    def _validate_phoneNumber(self, phoneNumber: str) -> str:
        if not phoneNumber or not phoneNumber.isdigit() or len(phoneNumber) != 11:
            return None
        return phoneNumber
```",0.6935843694022402,0.7309621108311255,0.8717948717948718,0.8292682926829268,0.8499999950031252,0.7761194029850746,0.7761194029850746,0.7761193979850747,0.8205128205128205,0.7804878048780488,0.799999995003125
Llama,71,"class PushBoxGame:
    def __init__(self, map):
        self.map = map
        self.player_row = 0
        self.player_col = 0
        self.targets = []
        self.boxes = []
        self.target_count = 0
        self.is_game_over = False

        self.init_game()

    def init_game(self):
        for row in range(len(self.map)):
            for col in range(len(self.map[row])):
                if self.map[row][col] == ""O"":
                    self.player_row = row
                    self.player_col = col
                elif self.map[row][col] == ""G"":
                    self.targets.append((row, col))
                    self.target_count += 1
                elif self.map[row][col] == ""X"":
                    self.boxes.append((row, col))

    def check_win(self):
        box_on_target_count = 0
        for box in self.boxes:
            if box in self.targets:
                box_on_target_count += 1
        if box_on_target_count == self.target_count:
            self.is_game_over = True
        return self.is_game_over

    def move(self, direction):
        new_player_row = self.player_row
        new_player_col = self.player_col

        if direction == ""w"":
            new_player_row -= 1
        elif direction == ""s"":
            new_player_row += 1
        elif direction == ""a"":
            new_player_col -= 1
        elif direction == ""d"":
            new_player_col += 1

        if self.map[new_player_row][new_player_col] != ""#"":
            if (new_player_row, new_player_col) in self.boxes:
                new_box_row = new_player_row + (new_player_row - self.player_row)
                new_box_col = new_player_col + (new_player_col - self.player_col)

                if self.map[new_box_row][new_box_col] != ""#"":
                    self.boxes.remove((new_player_row, new_player_col))
                    self.boxes.append((new_box_row, new_box_col))
                    self.player_row = new_player_row
                    self.player_col = new_player_col
            else:
                self.player_row = new_player_row
                self.player_col = new_player_col

        return self.check_win()",COTFewShot,"

```python
class PushBoxGame:
    def __init__(self, map):
        self.map = map
        self.player_row = 0
        self.player_col = 0
        self.targets = []
        self.boxes = []
        self.target_count = 0
        self.is_game_over = False
        self.init_game()

    def init_game(self):
        for i in range(len(self.map)):
            for j in range(len(self.map[i])):
                if self.map[i][j] == 'O':
                    self.player_row = i
                    self.player_col = j
                elif self.map[i][j] == 'G':
                    self.targets.append((i, j))
                    self.target_count += 1
                elif self.map[i][j] == 'X':
                    self.boxes.append((i, j))

    def check_win(self):
        for box in self.boxes:
            if box not in self.targets:
                self.is_game_over = False
                return False
        self.is_game_over = True
        return True

    def move(self, direction):
        new_row = self.player_row
        new_col = self.player_col
        if direction == 'w':
            new_row -= 1
        elif direction == 's':
            new_row += 1
        elif direction == 'a':
            new_col -= 1
        elif direction == 'd':
            new_col += 1

        if self.map[new_row][new_col] == '#':
            return self.check_win()

        if (new_row, new_col) in self.boxes:
            box_row = new_row
            box_col = new_col
            new_box_row = box_row
            new_box_col = box_col
            if direction == 'w':
                new_box_row -= 1
            elif direction == 's':
                new_box_row += 1
            elif direction == 'a':
                new_box_col -= 1
            elif direction == 'd':
                new_box_col += 1

            if self.map[new_box_row][new_box_col] == '#':
                return self.check_win()

            if (new_box_row, new_box_col) in self.boxes:
                return self.check_win()

            self.boxes.remove((box_row, box_col))
            self.boxes.append((new_box_row, new_box_col))

        self.player_row = new_row
        self.player_col = new_col

        return self.check_win()
```",0.2755102040816326,0.33899144862374764,0.5866666666666667,0.6111111111111112,0.5986394507843955,0.4520547945205479,0.43137254901960786,0.441471566909095,0.5866666666666667,0.6111111111111112,0.5986394507843955
Llama,72,"import re


class RegexUtils:

    def match(self, pattern, text):
        ans = re.match(pattern, text)
        if ans:
            return True
        else:
            return False

    def findall(self, pattern, text):
        return re.findall(pattern, text)

    def split(self, pattern, text):
        return re.split(pattern, text)

    def sub(self, pattern, replacement, text):
        return re.sub(pattern, replacement, text)

    def generate_email_pattern(self):
        pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        return pattern

    def generate_phone_number_pattern(self):
        pattern = r'\b\d{3}-\d{3}-\d{4}\b'
        return pattern

    def generate_split_sentences_pattern(self):
        pattern = r'[.!?][\s]{1,2}(?=[A-Z])'
        return pattern

    def split_sentences(self, text):
        pattern = self.generate_split_sentences_pattern()
        return self.split(pattern, text)

    def validate_phone_number(self, phone_number):
        pattern = self.generate_phone_number_pattern()
        return self.match(pattern, phone_number)

    def extract_email(self, text):
        pattern = self.generate_email_pattern()
        return self.findall(pattern, text)",COTFewShot,"

```python
import re

class RegexUtils:
    def match(self, pattern, text):
        return bool(re.fullmatch(pattern, text))

    def findall(self, pattern, text):
        return re.findall(pattern, text)

    def split(self, pattern, text):
        return re.split(pattern, text)

    def sub(self, pattern, replacement, text):
        return re.sub(pattern, replacement, text)

    def generate_email_pattern(self):
        return r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'

    def generate_phone_number_pattern(self):
        return r'\b\d{3}-\d{3}-\d{4}\b'

    def generate_split_sentences_pattern(self):
        return r'[.!?][\s]{1,2}(?=[A-Z])'

    def split_sentences(self, text):
        pattern = self.generate_split_sentences_pattern()
        sentences = re.split(pattern, text)
        return [sentence.strip() for sentence in sentences if sentence]

    def validate_phone_number(self, phone_number):
        pattern = self.generate_phone_number_pattern()
        return bool(re.fullmatch(pattern, phone_number))

    def extract_email(self, text):
        pattern = self.generate_email_pattern()
        return re.findall(pattern, text)
```",0.4882402381374754,0.5499620092614781,0.8444444444444444,0.7450980392156863,0.791666661686198,0.6153846153846154,0.6233766233766234,0.6193548337098856,0.8222222222222222,0.7254901960784313,0.7708333283528647
Llama,73,"class RPGCharacter:
    def __init__(self, name, hp, attack_power, defense, level=1):
        self.name = name
        self.hp = hp
        self.attack_power = attack_power
        self.defense = defense
        self.level = level
        self.exp = 0

    def attack(self, other_character):
        damage = max(self.attack_power - other_character.defense, 1)
        other_character.hp -= damage

    def heal(self):
        self.hp += 10
        if self.hp > 100:
            self.hp = 100
        return self.hp

    def gain_exp(self, amount):
        while amount != 0:
            if self.exp + amount >= self.level * 100:
                amount -= (self.level * 100 - self.exp)
                self.level_up()
            else:
                self.exp += amount
                amount = 0

    def level_up(self):
        if self.level < 100:
            self.level += 1
            self.exp = 0
            self.hp += 20
            self.attack_power += 5
            self.defense += 5
        return self.level, self.hp, self.attack_power, self.defense

    def is_alive(self):
        return self.hp > 0",COTFewShot,"

```python
class RPGCharacter:
    def __init__(self, name, hp, attack_power, defense, level=1):
        self.name = name
        self.hp = hp
        self.attack_power = attack_power
        self.defense = defense
        self.level = level
        self.exp = 0

    def attack(self, other_character):
        damage = max(self.attack_power - other_character.defense, 0)
        other_character.hp -= damage

    def heal(self):
        self.hp = min(self.hp + 10, 100)
        return self.hp

    def gain_exp(self, amount):
        self.exp += amount
        while self.exp >= 100 * self.level:
            self.level_up()

    def level_up(self):
        if self.level < 100:
            self.level += 1
            self.hp += 20
            self.attack_power += 5
            self.defense += 5
            self.exp = 0
            return self.level, self.hp, self.attack_power, self.defense
        else:
            self.exp = 0
            return self.level, self.hp, self.attack_power, self.defense

    def is_alive(self):
        return self.hp > 0
```",0.5737395027862753,0.6267163430303482,0.8888888888888888,0.8727272727272727,0.8807339399545493,0.7217391304347827,0.7904761904761904,0.7545454495557852,0.8703703703703703,0.8545454545454545,0.8623853161013384
Llama,74,"class Server:

    def __init__(self):
        self.white_list = []
        self.send_struct = {}
        self.receive_struct = {}

    def add_white_list(self, addr):
        if addr in self.white_list:
            return False
        else:
            self.white_list.append(addr)
            return self.white_list

    def del_white_list(self, addr):
        if addr not in self.white_list:
            return False
        else:
            self.white_list.remove(addr)
            return self.white_list

    def recv(self, info):
        if not isinstance(info, dict) or ""addr"" not in info or ""content"" not in info:
            return -1
        addr = info[""addr""]
        content = info[""content""]
        if addr not in self.white_list:
            return False
        else:
            self.receive_struct = {""addr"": addr, ""content"": content}
            return self.receive_struct[""content""]

    def send(self, info):
        if not isinstance(info, dict) or ""addr"" not in info or ""content"" not in info:
            return ""info structure is not correct""
        self.send_struct = {""addr"": info[""addr""], ""content"": info[""content""]}

    def show(self, type):
        if type == ""send"":
            return self.send_struct
        elif type == ""receive"":
            return self.receive_struct
        else:
            return False",COTFewShot,"

```python
class Server:
    def __init__(self):
        self.white_list = []
        self.send_struct = {}
        self.receive_struct = {}

    def add_white_list(self, addr):
        if addr not in self.white_list:
            self.white_list.append(addr)
            return self.white_list
        else:
            return False

    def del_white_list(self, addr):
        if addr in self.white_list:
            self.white_list.remove(addr)
            return self.white_list
        else:
            return False

    def recv(self, info):
        if info[""addr""] in self.white_list:
            self.receive_struct = info
            return info[""content""]
        else:
            return False

    def send(self, info):
        self.send_struct = info
        return None

    def show(self, type):
        if type == 'send':
            return self.send_struct
        elif type == 'receive':
            return self.receive_struct
        else:
            return False
```",0.2799746590667526,0.33619477127955316,0.625,0.875,0.7291666618055557,0.5054945054945055,0.71875,0.5935483822484912,0.625,0.875,0.7291666618055557
Llama,75,"class ShoppingCart:
    def __init__(self):
        self.items = {}

    def add_item(self, item, price, quantity=1):
        if item in self.items:
            self.items[item] = {'price': price, 'quantity': quantity}
        else:
            self.items[item] = {'price': price, 'quantity': quantity}

    def remove_item(self, item, quantity=1):
        if item in self.items:
            self.items[item]['quantity'] -= quantity
        else:
            pass

    def view_items(self) -> dict:
        return self.items

    def total_price(self) -> float:
        return sum([item['quantity'] * item['price'] for item in self.items.values()])",COTFewShot,"

```python
class ShoppingCart:
    def __init__(self):
        self.items = {}

    def add_item(self, item, price, quantity=1):
        if item in self.items:
            self.items[item][""quantity""] += quantity
        else:
            self.items[item] = {""price"": price, ""quantity"": quantity}

    def remove_item(self, item, quantity=1):
        if item in self.items:
            if self.items[item][""quantity""] <= quantity:
                del self.items[item]
            else:
                self.items[item][""quantity""] -= quantity

    def view_items(self):
        return self.items

    def total_price(self):
        total = 0
        for item in self.items:
            total += self.items[item][""price""] * self.items[item][""quantity""]
        return total
```",0.375,0.432966499213362,0.6756756756756757,0.6410256410256411,0.6578947318455679,0.5769230769230769,0.47619047619047616,0.5217391254805294,0.6756756756756757,0.6410256410256411,0.6578947318455679
Llama,76,"class SignInSystem:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username in self.users:
            return False
        else:
            self.users[username] = False
            return True

    def sign_in(self, username):
        if username not in self.users:
            return False
        else:
            self.users[username] = True
            return True

    def check_sign_in(self, username):
        if username not in self.users:
            return False
        else:
            if self.users[username]:
                return True
            else:
                return False

    def all_signed_in(self):
        if all(self.users.values()):
            return True
        else:
            return False

    def all_not_signed_in(self):
        not_signed_in_users = []
        for username, signed_in in self.users.items():
            if not signed_in:
                not_signed_in_users.append(username)
        return not_signed_in_users",COTFewShot,"

```python
class SignInSystem:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username not in self.users:
            self.users[username] = False
            return True
        return False

    def sign_in(self, username):
        if username in self.users:
            self.users[username] = True
            return True
        return False

    def check_sign_in(self, username):
        if username in self.users and self.users[username]:
            return True
        return False

    def all_signed_in(self):
        for user in self.users.values():
            if not user:
                return False
        return True

    def all_not_signed_in(self):
        return [username for username, signed_in in self.users.items() if not signed_in]
```",0.43020474077690063,0.505278326578485,0.7714285714285715,0.75,0.7605633752826821,0.6290322580645161,0.6842105263157895,0.6554621798827767,0.7714285714285715,0.75,0.7605633752826821
Llama,77,"import random


class Snake:
    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):
        self.length = 1
        self.SCREEN_WIDTH = SCREEN_WIDTH
        self.SCREEN_HEIGHT = SCREEN_HEIGHT
        self.BLOCK_SIZE = BLOCK_SIZE
        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]
        self.score = 0
        self.food_position = food_position

    def move(self, direction):
        cur = self.positions[0]
        x, y = direction

        new = (
            ((cur[0] + (x * self.BLOCK_SIZE)) % self.SCREEN_WIDTH),
            (cur[1] + (y * self.BLOCK_SIZE)) % self.SCREEN_HEIGHT,
        )

        if new == self.food_position:
            self.eat_food()

        if len(self.positions) > 2 and new in self.positions[2:]:
            self.reset()
        else:
            self.positions.insert(0, new)
            if len(self.positions) > self.length:
                self.positions.pop()

    def random_food_position(self):
        while self.food_position in self.positions:
            self.food_position = (random.randint(0, self.SCREEN_WIDTH // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE,
                                  random.randint(0, self.SCREEN_HEIGHT // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE)

    def reset(self):
        self.length = 1
        self.positions = [((self.SCREEN_WIDTH / 2), (self.SCREEN_HEIGHT / 2))]
        self.score = 0
        self.random_food_position()

    def eat_food(self):
        self.length += 1
        self.score += 100
        self.random_food_position()",COTFewShot,"

```python
import random

class Snake:
    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):
        self.length = 1
        self.SCREEN_WIDTH = SCREEN_WIDTH
        self.SCREEN_HEIGHT = SCREEN_HEIGHT
        self.BLOCK_SIZE = BLOCK_SIZE
        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]
        self.score = 0
        self.food_position = food_position

    def move(self, direction):
        new_head_position = (self.positions[-1][0] + direction[0] * self.BLOCK_SIZE, 
                             self.positions[-1][1] + direction[1] * self.BLOCK_SIZE)
        if new_head_position in self.positions:
            self.reset()
        elif (new_head_position[0] < 0 or new_head_position[0] >= self.SCREEN_WIDTH or 
              new_head_position[1] < 0 or new_head_position[1] >= self.SCREEN_HEIGHT):
            self.reset()
        else:
            self.positions.append(new_head_position)
            if new_head_position == self.food_position:
                self.eat_food()
            else:
                self.positions.pop(0)

    def random_food_position(self):
        while True:
            x = random.randint(0, self.SCREEN_WIDTH - self.BLOCK_SIZE) // self.BLOCK_SIZE * self.BLOCK_SIZE
            y = random.randint(0, self.SCREEN_HEIGHT - self.BLOCK_SIZE) // self.BLOCK_SIZE * self.BLOCK_SIZE
            new_food_position = (x, y)
            if new_food_position not in self.positions:
                self.food_position = new_food_position
                break

    def reset(self):
        self.length = 1
        self.positions = [((self.SCREEN_WIDTH / 2), (self.SCREEN_HEIGHT / 2))]
        self.score = 0
        self.random_food_position()

    def eat_food(self):
        self.length += 1
        self.score += 10
        self.random_food_position()
```",0.43448275862068964,0.4985257824826376,0.6538461538461539,0.6710526315789473,0.6623376573385057,0.5766423357664233,0.5683453237410072,0.5724637631162047,0.6538461538461539,0.6710526315789473,0.6623376573385057
Llama,78,"import re


class SplitSentence:

    def split_sentences(self, sentences_string):
        sentences = re.split(r'(?<!\w\.\w.)(?<![A-Z][a-z]\.)(?<=\.|\?)\s', sentences_string)
        return sentences

    def count_words(self, sentence):
        sentence = re.sub(r'[^a-zA-Z\s]', '', sentence)
        words = sentence.split()
        return len(words)

    def process_text_file(self, sentences_string):
        sentences = self.split_sentences(sentences_string)
        max_count = 0
        for sentence in sentences:
            count = self.count_words(sentence)
            if count > max_count:
                max_count = count

        return max_count",COTFewShot,"

```python
import re

class SplitSentence:
    def __init__(self):
        pass

    def split_sentences(self, sentences_string):
        sentences = re.split(r'(?<=[.?\s])\s*(?=[A-Z][a-z]|Mr\.|Mrs\.|Ms\.|Dr\.|Prof\.)', sentences_string)
        return [sentence for sentence in sentences if sentence]

    def count_words(self, sentence):
        words = re.findall(r'\b[a-zA-Z]+\b', sentence)
        return len(words)

    def process_text_file(self, sentences_string):
        sentences = self.split_sentences(sentences_string)
        max_word_count = 0
        for sentence in sentences:
            word_count = self.count_words(sentence)
            if word_count > max_word_count:
                max_word_count = word_count
        return max_word_count
```",0.32142857142857145,0.3829653971965425,0.7105263157894737,0.6136363636363636,0.6585365803926235,0.48148148148148145,0.43333333333333335,0.45614034589104346,0.7105263157894737,0.6136363636363636,0.6585365803926235
Llama,79,"class SQLGenerator:
    def __init__(self, table_name):
        self.table_name = table_name

    def select(self, fields=None, condition=None):
        if fields is None:
            fields = ""*""
        else:
            fields = "", "".join(fields)
        sql = f""SELECT {fields} FROM {self.table_name}""
        if condition is not None:
            sql += f"" WHERE {condition}""
        return sql + "";""

    def insert(self, data):
        fields = "", "".join(data.keys())
        values = "", "".join([f""'{value}'"" for value in data.values()])
        sql = f""INSERT INTO {self.table_name} ({fields}) VALUES ({values})""
        return sql + "";""

    def update(self, data, condition):
        set_clause = "", "".join([f""{field} = '{value}'"" for field, value in data.items()])
        sql = f""UPDATE {self.table_name} SET {set_clause} WHERE {condition}""
        return sql + "";""

    def delete(self, condition):
        sql = f""DELETE FROM {self.table_name} WHERE {condition}""
        return sql + "";""

    def select_female_under_age(self, age):
        condition = f""age < {age} AND gender = 'female'""
        return self.select(condition=condition)

    def select_by_age_range(self, min_age, max_age):
        condition = f""age BETWEEN {min_age} AND {max_age}""
        return self.select(condition=condition)",COTFewShot,"

```python
class SQLGenerator:
    def __init__(self, table_name):
        self.table_name = table_name

    def select(self, fields=None, condition=None):
        sql = 'SELECT '
        if fields is None:
            sql += '*'
        else:
            sql += ', '.join(fields)
        sql += f' FROM {self.table_name}'
        if condition is not None:
            sql += f' WHERE {condition}'
        sql += ';'
        return sql

    def insert(self, data):
        fields = ', '.join(data.keys())
        values = ', '.join(f""'{value}'"" for value in data.values())
        sql = f'INSERT INTO {self.table_name} ({fields}) VALUES ({values});'
        return sql

    def update(self, data, condition):
        sets = ', '.join(f'{key} = \'{value}\'' for key, value in data.items())
        sql = f'UPDATE {self.table_name} SET {sets} WHERE {condition};'
        return sql

    def delete(self, condition):
        sql = f'DELETE FROM {self.table_name} WHERE {condition};'
        return sql

    def select_female_under_age(self, age):
        sql = f'SELECT * FROM {self.table_name} WHERE age < {age} AND gender = \'female\';'
        return sql

    def select_by_age_range(self, min_age, max_age):
        sql = f'SELECT * FROM {self.table_name} WHERE age BETWEEN {min_age} AND {max_age};'
        return sql
```",0.24489795918367346,0.3130125716639287,0.675,0.6585365853658537,0.6666666616674289,0.5,0.48333333333333334,0.4915254187302499,0.675,0.6585365853658537,0.6666666616674289
Llama,7,"class BalancedBrackets:
    def __init__(self, expr):
        self.stack = []
        self.left_brackets = [""("", ""{"", ""[""]
        self.right_brackets = ["")"", ""}"", ""]""]
        self.expr = expr

    def clear_expr(self):
        self.expr = ''.join(c for c in self.expr if (c in self.left_brackets or c in self.right_brackets))

    def check_balanced_brackets(self):
        self.clear_expr()
        for Brkt in self.expr:
            if Brkt in self.left_brackets:
                self.stack.append(Brkt)
            else:
                Current_Brkt = self.stack.pop()
                if Current_Brkt == ""("":
                    if Brkt != "")"":
                        return False
                if Current_Brkt == ""{"":
                    if Brkt != ""}"":
                        return False
                if Current_Brkt == ""["":
                    if Brkt != ""]"":
                        return False
        if self.stack:
            return False
        return True",COTFewShot,"

```python
class BalancedBrackets:
    def __init__(self, expr):
        # Initialize the class with an expression
        self.stack = []
        self.left_brackets = [""("", ""{"", ""[""]
        self.right_brackets = ["")"", ""}"", ""]""]
        self.expr = expr

    def clear_expr(self):
        # Clear the expression of all characters that are not brackets
        self.expr = ''.join([char for char in self.expr if char in self.left_brackets or char in self.right_brackets])
        return self.expr

    def check_balanced_brackets(self):
        # Check if the expression has balanced brackets
        self.clear_expr()
        for char in self.expr:
            if char in self.left_brackets:
                self.stack.append(char)
            elif char in self.right_brackets:
                if not self.stack:
                    return False
                left_bracket = self.stack.pop()
                if (char == ')' and left_bracket != '(') or (char == '}' and left_bracket != '{') or (char == ']' and left_bracket != '['):
                    return False
        return not self.stack
```",0.21008403361344538,0.2608174111688406,0.6938775510204082,0.5,0.581196576328439,0.5375,0.39814814814814814,0.45744680362154827,0.6938775510204082,0.5,0.581196576328439
Llama,80,"class SQLQueryBuilder:

    @staticmethod
    def select(table, columns='*', where=None):
        if columns != '*':
            columns = ', '.join(columns)
        query = f""SELECT {columns} FROM {table}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query

    @staticmethod
    def insert(table, data):
        keys = ', '.join(data.keys())
        values = ', '.join(f""'{v}'"" for v in data.values())
        return f""INSERT INTO {table} ({keys}) VALUES ({values})""

    @staticmethod
    def delete(table, where=None):
        query = f""DELETE FROM {table}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query

    @staticmethod
    def update(table, data, where=None):
        update_str = ', '.join(f""{k}='{v}'"" for k, v in data.items())
        query = f""UPDATE {table} SET {update_str}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query",COTFewShot,"

```python
class SQLQueryBuilder:
    @staticmethod
    def select(table, columns='*', where=None):
        query = f""SELECT {', '.join(columns)} FROM {table}""
        if where:
            conditions = [f""{key}='{value}'"" for key, value in where.items()]
            query += f"" WHERE {' AND '.join(conditions)}""
        return query

    @staticmethod
    def insert(table, data):
        columns = ', '.join(data.keys())
        values = ', '.join(f""'{value}'"" for value in data.values())
        return f""INSERT INTO {table} ({columns}) VALUES ({values})""

    @staticmethod
    def delete(table, where=None):
        query = f""DELETE FROM {table}""
        if where:
            conditions = [f""{key}='{value}'"" for key, value in where.items()]
            query += f"" WHERE {' AND '.join(conditions)}""
        return query

    @staticmethod
    def update(table, data, where=None):
        sets = ', '.join(f""{key}='{value}'"" for key, value in data.items())
        query = f""UPDATE {table} SET {sets}""
        if where:
            conditions = [f""{key}='{value}'"" for key, value in where.items()]
            query += f"" WHERE {' AND '.join(conditions)}""
        return query
```",0.3360434751408291,0.40490251325604104,0.7543859649122807,0.7166666666666667,0.7350427300460224,0.575,0.5822784810126582,0.5786163472014556,0.7543859649122807,0.7166666666666667,0.7350427300460224
Llama,81,"import math
class Statistics3:
    @staticmethod
    def median(data):
        sorted_data = sorted(data)
        n = len(sorted_data)
        if n % 2 == 1:
            return sorted_data[n // 2]
        else:
            return (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2

    @staticmethod
    def mode(data):
        counts = {}
        for value in data:
            counts[value] = counts.get(value, 0) + 1
        max_count = max(counts.values())
        mode_values = [value for value, count in counts.items() if count == max_count]
        return mode_values

    @staticmethod
    def correlation(x, y):
        n = len(x)
        mean_x = sum(x) / n
        mean_y = sum(y) / n
        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))
        denominator = math.sqrt(sum((xi - mean_x) ** 2 for xi in x) * sum((yi - mean_y) ** 2 for yi in y))
        if denominator == 0:
            return None
        return numerator / denominator

    @staticmethod
    def mean(data):
        if len(data) == 0:
            return None
        return sum(data) / len(data)

    @staticmethod
    def correlation_matrix(data):
        matrix = []
        for i in range(len(data[0])):
            row = []
            for j in range(len(data[0])):
                column1 = [row[i] for row in data]
                column2 = [row[j] for row in data]
                correlation = Statistics3.correlation(column1, column2)
                row.append(correlation)
            matrix.append(row)
        return matrix

    @staticmethod
    def standard_deviation(data):
        n = len(data)
        if n < 2:
            return None
        mean_value = Statistics3.mean(data)
        variance = sum((x - mean_value) ** 2 for x in data) / (n - 1)
        return math.sqrt(variance)

    @staticmethod
    def z_score(data):
        mean = Statistics3.mean(data)
        std_deviation = Statistics3.standard_deviation(data)
        if std_deviation is None or std_deviation == 0:
            return None
        return [(x - mean) / std_deviation for x in data]",COTFewShot,"

```python
import math
import numpy as np
from scipy import stats


class Statistics3:
    @staticmethod
    def median(data):
        return np.median(data)

    @staticmethod
    def mode(data):
        return stats.mode(data)[0].tolist()

    @staticmethod
    def correlation(x, y):
        return np.corrcoef(x, y)[0, 1]

    @staticmethod
    def mean(data):
        return np.mean(data)

    @staticmethod
    def correlation_matrix(data):
        return np.corrcoef(data).tolist()

    @staticmethod
    def standard_deviation(data):
        return np.std(data)

    @staticmethod
    def z_score(data):
        mean = np.mean(data)
        std_dev = np.std(data)
        return [(x - mean) / std_dev for x in data]
```",0.017636389055540796,0.020757500927159386,0.23478260869565218,0.627906976744186,0.34177214793702937,0.09767441860465116,0.3442622950819672,0.1521739096001366,0.23478260869565218,0.627906976744186,0.34177214793702937
Llama,82,"class StockPortfolioTracker:
    def __init__(self, cash_balance):
        self.portfolio = []
        self.cash_balance = cash_balance

    def add_stock(self, stock):
        for pf in self.portfolio:
            if pf['name'] == stock['name']:
                pf['quantity'] += stock['quantity']
                return

        self.portfolio.append(stock)

    def remove_stock(self, stock):
        for pf in self.portfolio:
            if pf['name'] == stock['name'] and pf['quantity'] >= stock['quantity']:
                pf['quantity'] -= stock['quantity']
                if pf['quantity'] == 0:
                    self.portfolio.remove(pf)
                return True
        return False

    def buy_stock(self, stock):
        if stock['price'] * stock['quantity'] > self.cash_balance:
            return False
        else:
            self.add_stock(stock)
            self.cash_balance -= stock['price'] * stock['quantity']
            return True

    def sell_stock(self, stock):
        if self.remove_stock(stock) == False:
            return False
        self.cash_balance += stock['price'] * stock['quantity']
        return True

    def calculate_portfolio_value(self):
        total_value = self.cash_balance
        for stock in self.portfolio:
            total_value += stock['price'] * stock['quantity']
        return total_value

    def get_portfolio_summary(self):
        summary = []
        for stock in self.portfolio:
            value = self.get_stock_value(stock)
            summary.append({""name"": stock[""name""], ""value"": value})
        portfolio_value = self.calculate_portfolio_value()
        return portfolio_value, summary

    def get_stock_value(self, stock):
        return stock['price'] * stock['quantity']",COTFewShot,"

```python
class StockPortfolioTracker:
    def __init__(self, cash_balance):
        self.portfolio = []
        self.cash_balance = cash_balance

    def add_stock(self, stock):
        self.portfolio.append(stock)

    def remove_stock(self, stock):
        for s in self.portfolio:
            if s['name'] == stock['name'] and s['price'] == stock['price'] and s['quantity'] == stock['quantity']:
                self.portfolio.remove(s)
                return True
        return False

    def buy_stock(self, stock):
        total_cost = stock['price'] * stock['quantity']
        if self.cash_balance >= total_cost:
            self.cash_balance -= total_cost
            self.add_stock(stock)
            return True
        return False

    def sell_stock(self, stock):
        for s in self.portfolio:
            if s['name'] == stock['name'] and s['price'] == stock['price'] and s['quantity'] == stock['quantity']:
                self.cash_balance += stock['price'] * stock['quantity']
                self.portfolio.remove(s)
                return True
        return False

    def calculate_portfolio_value(self):
        total_value = self.cash_balance
        for stock in self.portfolio:
            total_value += stock['price'] * stock['quantity']
        return total_value

    def get_portfolio_summary(self):
        total_value = self.calculate_portfolio_value()
        stock_values = [{'name': stock['name'], 'value': stock['price'] * stock['quantity']} for stock in self.portfolio]
        return (total_value, stock_values)

    def get_stock_value(self, stock):
        return stock['price'] * stock['quantity']
```",0.3759827885556272,0.4528673250784336,0.6666666666666666,0.7017543859649122,0.6837606787639712,0.5221238938053098,0.59,0.5539906053472636,0.65,0.6842105263157895,0.6666666616699541
Llama,83,"import sqlite3


class StudentDatabaseProcessor:

    def __init__(self, database_name):
        self.database_name = database_name

    def create_student_table(self):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        create_table_query = """"""
        CREATE TABLE IF NOT EXISTS students (
            id INTEGER PRIMARY KEY,
            name TEXT,
            age INTEGER,
            gender TEXT,
            grade INTEGER
        )
        """"""
        cursor.execute(create_table_query)

        conn.commit()
        conn.close()

    def insert_student(self, student_data):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        insert_query = """"""
        INSERT INTO students (name, age, gender, grade)
        VALUES (?, ?, ?, ?)
        """"""
        cursor.execute(insert_query,
                       (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))

        conn.commit()
        conn.close()

    def search_student_by_name(self, name):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        select_query = ""SELECT * FROM students WHERE name = ?""
        cursor.execute(select_query, (name,))
        result = cursor.fetchall()

        conn.close()

        return result

    def delete_student_by_name(self, name):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        delete_query = ""DELETE FROM students WHERE name = ?""
        cursor.execute(delete_query, (name,))

        conn.commit()
        conn.close()",COTFewShot,"

```python
import sqlite3

class StudentDatabaseProcessor:
    def __init__(self, database_name):
        self.database_name = database_name

    def create_student_table(self):
        try:
            with sqlite3.connect(self.database_name) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS students (
                        ID INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT NOT NULL,
                        age INTEGER NOT NULL,
                        gender TEXT NOT NULL,
                        grade INTEGER NOT NULL
                    )
                ''')
        except sqlite3.Error as e:
            print(f""Error creating table: {e}"")

    def insert_student(self, student_data):
        try:
            with sqlite3.connect(self.database_name) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO students (name, age, gender, grade)
                    VALUES (?, ?, ?, ?)
                ''', (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))
                conn.commit()
        except sqlite3.Error as e:
            print(f""Error inserting student: {e}"")

    def search_student_by_name(self, name):
        try:
            with sqlite3.connect(self.database_name) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT * FROM students
                    WHERE name = ?
                ''', (name,))
                return cursor.fetchall()
        except sqlite3.Error as e:
            print(f""Error searching student: {e}"")
            return []

    def delete_student_by_name(self, name):
        try:
            with sqlite3.connect(self.database_name) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    DELETE FROM students
                    WHERE name = ?
                ''', (name,))
                conn.commit()
        except sqlite3.Error as e:
            print(f""Error deleting student: {e}"")
```",0.2608695652173913,0.30652184606585203,0.7567567567567568,0.6511627906976745,0.699999995028125,0.4954128440366973,0.4576271186440678,0.4757709201179919,0.7567567567567568,0.6511627906976745,0.699999995028125
Llama,84,"import json


class TextFileProcessor:
    def __init__(self, file_path):
        self.file_path = file_path

    def read_file_as_json(self):
        with open(self.file_path, 'r') as file:
            data = json.load(file)

        return data

    def read_file(self):
        with open(self.file_path, 'r') as file:
            return file.read()

    def write_file(self, content):
        with open(self.file_path, 'w') as file:
            file.write(content)

    def process_file(self):
        content = self.read_file()
        content = ''.join([char for char in content if char.isalpha()])
        self.write_file(content)
        return content",COTFewShot,"

```python
import json

class TextFileProcessor:
    def __init__(self, file_path):
        self.file_path = file_path

    def read_file_as_json(self):
        try:
            with open(self.file_path, 'r') as file:
                data = json.load(file)
            return data
        except json.JSONDecodeError:
            raise ValueError(""The file content is not compliant with JSON rules"")

    def read_file(self):
        try:
            with open(self.file_path, 'r') as file:
                content = file.read()
            return content
        except FileNotFoundError:
            return None

    def write_file(self, content):
        with open(self.file_path, 'w') as file:
            file.write(str(content))

    def process_file(self):
        try:
            with open(self.file_path, 'r') as file:
                content = file.read()
            processed_content = ''.join(filter(str.isalpha, content))
            self.write_file(processed_content)
            return processed_content
        except FileNotFoundError:
            return None
```",0.3253012048192771,0.3854883835968598,0.7631578947368421,0.5918367346938775,0.666666661746598,0.603448275862069,0.4666666666666667,0.5263157845553734,0.7631578947368421,0.5918367346938775,0.666666661746598
Llama,85,"import time

class Thermostat:
    def __init__(self, current_temperature, target_temperature, mode):
        self.current_temperature = current_temperature
        self.target_temperature = target_temperature
        self.mode = mode

    def get_target_temperature(self):
        return self.target_temperature

    def set_target_temperature(self, temperature):
        self.target_temperature = temperature

    def get_mode(self):
        return self.mode

    def set_mode(self, mode):
        if mode in ['heat', 'cool']:
            self.mode = mode
        else:
            return False

    def auto_set_mode(self):
        if self.current_temperature < self.target_temperature:
            self.mode = 'heat'
        else:
            self.mode = 'cool'

    def auto_check_conflict(self):
        if self.current_temperature > self.target_temperature:
            if self.mode == 'cool':
                return True
            else:
                self.auto_set_mode()
                return False
        else:
            if self.mode == 'heat':
                return True
            else:
                self.auto_set_mode()
                return False

    def simulate_operation(self):
        self.auto_set_mode()
        use_time = 0
        if self.mode == 'heat':
            while(self.current_temperature < self.target_temperature):
                self.current_temperature += 1
                use_time += 1
        else:
            while(self.current_temperature > self.target_temperature):
                self.current_temperature -= 1
                use_time += 1
        return use_time",COTFewShot,"

```python
import time

class Thermostat:
    def __init__(self, current_temperature, target_temperature, mode):
        self.current_temperature = current_temperature
        self.target_temperature = target_temperature
        self.mode = mode

    def get_target_temperature(self):
        return int(self.target_temperature)

    def set_target_temperature(self, temperature):
        self.target_temperature = temperature

    def get_mode(self):
        return self.mode

    def set_mode(self, mode):
        if mode in ['heat', 'cool']:
            self.mode = mode
        else:
            raise ValueError(""Invalid mode. Mode should be 'heat' or 'cool'."")

    def auto_set_mode(self):
        if self.current_temperature < self.target_temperature:
            self.mode = 'heat'
        else:
            self.mode = 'cool'

    def auto_check_conflict(self):
        if self.mode == 'heat' and self.current_temperature >= self.target_temperature:
            self.mode = 'cool'
            return False
        elif self.mode == 'cool' and self.current_temperature <= self.target_temperature:
            self.mode = 'heat'
            return False
        return True

    def simulate_operation(self):
        start_time = time.time()
        self.auto_set_mode()
        while self.current_temperature != self.target_temperature:
            if self.mode == 'heat':
                self.current_temperature += 0.1
            else:
                self.current_temperature -= 0.1
            time.sleep(0.1)
            self.auto_check_conflict()
        end_time = time.time()
        return int(end_time - start_time)
```",0.4523809523809524,0.510461499335291,0.8936170212765957,0.6176470588235294,0.7304347777754253,0.6956521739130435,0.5378151260504201,0.606635066171919,0.8936170212765957,0.6176470588235294,0.7304347777754253
Llama,86,"class TicTacToe:
    def __init__(self, N=3):
        self.board = [[' ' for _ in range(N)] for _ in range(3)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        else:
            return False

    def check_winner(self):
        for row in self.board:
            if row[0] == row[1] == row[2] != ' ':
                return row[0]
        for col in range(3):
            if self.board[0][col] == self.board[1][col] == self.board[2][col] != ' ':
                return self.board[0][col]
        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':
            return self.board[0][0]
        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':
            return self.board[0][2]
        return None

    def is_board_full(self):
        for row in self.board:
            if ' ' in row:
                return False
        return True",COTFewShot,"

```python
class TicTacToe:
    def __init__(self, N=3):
        self.board = [[' ' for _ in range(N)] for _ in range(3)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        return False

    def check_winner(self):
        # Check rows
        for row in self.board:
            if row[0] == row[1] == row[2] != ' ':
                return row[0]

        # Check columns
        for col in range(3):
            if self.board[0][col] == self.board[1][col] == self.board[2][col] != ' ':
                return self.board[0][col]

        # Check diagonals
        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':
            return self.board[0][0]
        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':
            return self.board[0][2]

        return None

    def is_board_full(self):
        for row in self.board:
            if ' ' in row:
                return False
        return True
```",0.848,0.8634268716920761,0.98,0.875,0.9245282969028124,0.9484536082474226,0.8761904761904762,0.9108910841167532,0.98,0.875,0.9245282969028124
Llama,87,"import datetime
import time

class TimeUtils:

    def __init__(self):
        self.datetime = datetime.datetime.now()

    def get_current_time(self):
        format = ""%H:%M:%S""
        return self.datetime.strftime(format)

    def get_current_date(self):
        format = ""%Y-%m-%d""
        return self.datetime.strftime(format)

    def add_seconds(self, seconds):
        new_datetime = self.datetime + datetime.timedelta(seconds=seconds)
        format = ""%H:%M:%S""
        return new_datetime.strftime(format)

    def string_to_datetime(self, string):
        return datetime.datetime.strptime(string, ""%Y-%m-%d %H:%M:%S"")

    def datetime_to_string(self, datetime):
        return datetime.strftime(""%Y-%m-%d %H:%M:%S"")

    def get_minutes(self, string_time1, string_time2):
        time1 = self.string_to_datetime(string_time1)
        time2 = self.string_to_datetime(string_time2)
        return round((time2 - time1).seconds / 60)

    def get_format_time(self, year, month, day, hour, minute, second):
        format = ""%Y-%m-%d %H:%M:%S""
        time_item = datetime.datetime(year, month, day, hour, minute, second)
        return time_item.strftime(format)",COTFewShot,"

```python
import datetime
import time

class TimeUtils:
    def __init__(self):
        self.datetime = datetime.datetime.now()

    def get_current_time(self):
        return self.datetime.strftime('%H:%M:%S')

    def get_current_date(self):
        return self.datetime.strftime('%Y-%m-%d')

    def add_seconds(self, seconds):
        new_datetime = self.datetime + datetime.timedelta(seconds=seconds)
        return new_datetime.strftime('%H:%M:%S')

    def string_to_datetime(self, string):
        return datetime.datetime.strptime(string, '%Y-%m-%d %H:%M:%S')

    def datetime_to_string(self, datetime):
        return datetime.strftime('%Y-%m-%d %H:%M:%S')

    def get_minutes(self, string_time1, string_time2):
        datetime1 = datetime.datetime.strptime(string_time1, '%Y-%m-%d %H:%M:%S')
        datetime2 = datetime.datetime.strptime(string_time2, '%Y-%m-%d %H:%M:%S')
        time_diff = abs((datetime2 - datetime1).total_seconds() / 60)
        return round(time_diff)

    def get_format_time(self, year, month, day, hour, minute, second):
        return f'{year:04}-{month:02}-{day:02} {hour:02}:{minute:02}:{second:02}'
```",0.34281593803675847,0.3976564142273964,0.6666666666666666,0.6666666666666666,0.6666666616666668,0.5294117647058824,0.5555555555555556,0.5421686697016984,0.6666666666666666,0.6666666666666666,0.6666666616666668
Llama,88,"from math import pi, fabs


class TriCalculator:

    def __init__(self):
        pass

    def cos(self, x):
        return round(self.taylor(x, 50), 10)

    def factorial(self, a):
        b = 1
        while a != 1:
            b *= a
            a -= 1
        return b

    def taylor(self, x, n):
        a = 1
        x = x / 180 * pi
        count = 1
        for k in range(1, n):
            if count % 2 != 0:
                a -= (x ** (2 * k)) / self.factorial(2 * k)
            else:
                a += (x ** (2 * k)) / self.factorial(2 * k)
            count += 1
        return a

    def sin(self, x):
        x = x / 180 * pi
        g = 0
        t = x
        n = 1

        while fabs(t) >= 1e-15:
            g += t
            n += 1
            t = -t * x * x / (2 * n - 1) / (2 * n - 2)
        return round(g, 10)

    def tan(self, x):
        if self.cos(x) != 0:
            result = self.sin(x) / self.cos(x)
            return round(result, 10)
        else:
            return False",COTFewShot,"

```python
from math import pi, fabs

class TriCalculator:
    def __init__(self):
        pass

    def cos(self, x):
        return self.taylor(x, 50)

    def factorial(self, a):
        if a == 0:
            return 1
        else:
            return a * self.factorial(a-1)

    def taylor(self, x, n):
        sum = 0
        for i in range(n):
            sign = (-1)**i
            sum += ((x/180*pi)**(2.0*i)) / self.factorial(2*i)
        return sum

    def sin(self, x):
        sum = 0
        for i in range(50):
            sign = (-1)**i
            sum += ((x/180*pi)**(2.0*i+1)) / self.factorial(2*i+1)
        return sum

    def tan(self, x):
        return self.sin(x) / self.cos(x)
```",0.08489525565494824,0.11051042847799977,0.4931506849315068,0.6923076923076923,0.5759999951411201,0.2230769230769231,0.4084507042253521,0.2885572093611545,0.4794520547945205,0.6730769230769231,0.5599999951411201
Llama,89,"import random


class TwentyFourPointGame:
    def __init__(self) -> None:
        self.nums = []

    def _generate_cards(self):
        for i in range(4):
            self.nums.append(random.randint(1, 9))
        assert len(self.nums) == 4

    def get_my_cards(self):
        self.nums = []
        self._generate_cards()
        return self.nums

    def answer(self, expression):
        if expression == 'pass':
            return self.get_my_cards()
        statistic = {}
        for c in expression:
            if c.isdigit() and int(c) in self.nums:
                statistic[c] = statistic.get(c, 0) + 1

        nums_used = statistic.copy()

        for num in self.nums:
            if nums_used.get(str(num), -100) != -100 and nums_used[str(num)] > 0:
                nums_used[str(num)] -= 1
            else:
                return False

        if all(count == 0 for count in nums_used.values()) == True:
            return self.evaluate_expression(expression)
        else:
            return False

    def evaluate_expression(self, expression):
        try:
            if eval(expression) == 24:
                return True
            else:
                return False
        except Exception as e:
            return False",COTFewShot,"

```python
import random

class TwentyFourPointGame:
    def __init__(self):
        self.nums = []

    def _generate_cards(self):
        self.nums = random.sample(range(1, 10), 4)

    def get_my_cards(self):
        self._generate_cards()
        return self.nums

    def evaluate_expression(self, expression):
        try:
            result = eval(expression)
            return result == 24
        except:
            return False

    def answer(self, expression):
        try:
            # Replace the numbers in the expression with the actual numbers
            for i, num in enumerate(self.nums):
                expression = expression.replace(str(i+1), str(num))
            return self.evaluate_expression(expression)
        except:
            return False
```",0.08924225185898052,0.11840086502816773,0.3333333333333333,0.5555555555555556,0.4166666619791667,0.20689655172413793,0.36363636363636365,0.2637362591136337,0.32,0.5333333333333333,0.3999999953125
Llama,8,"class BankAccount:
    def __init__(self, balance=0):
        self.balance = balance

    def deposit(self, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        self.balance += amount
        return self.balance

    def withdraw(self, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient balance."")
        self.balance -= amount
        return self.balance

    def view_balance(self):
        return self.balance

    def transfer(self, other_account, amount):
        self.withdraw(amount)
        other_account.deposit(amount)",COTFewShot,"

```python
class BankAccount:
    def __init__(self, balance=0):
        # Initialize a bank account object with an attribute balance, default value is 0.
        self.balance = balance

    def deposit(self, amount):
        # Deposit a certain amount into the account, increasing the account balance, return the current account balance.
        if amount < 0:
            raise ValueError(""Invalid amount"")
        self.balance += amount
        return self.balance

    def withdraw(self, amount):
        # Withdraw a certain amount from the account, decreasing the account balance, return the current account balance.
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient balance"")
        self.balance -= amount
        return self.balance

    def view_balance(self):
        # Return the account balance.
        return self.balance

    def transfer(self, other_account, amount):
        # Transfer a certain amount from the current account to another account.
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient balance"")
        self.balance -= amount
        other_account.balance += amount
        return self.balance
```",0.2857142857142857,0.30228211184122983,0.9032258064516129,0.4745762711864407,0.6222222177061729,0.7777777777777778,0.3888888888888889,0.5185185140740741,0.9032258064516129,0.4745762711864407,0.6222222177061729
Llama,90,"class URLHandler:
    def __init__(self, url):
        self.url = url

    def get_scheme(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            return self.url[:scheme_end]
        return None

    def get_host(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            url_without_scheme = self.url[scheme_end + 3:]
            host_end = url_without_scheme.find(""/"")
            if host_end != -1:
                return url_without_scheme[:host_end]
            return url_without_scheme
        return None

    def get_path(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            url_without_scheme = self.url[scheme_end + 3:]
            host_end = url_without_scheme.find(""/"")
            if host_end != -1:
                return url_without_scheme[host_end:]
        return None

    def get_query_params(self):
        query_start = self.url.find(""?"")
        fragment_start = self.url.find(""#"")
        if query_start != -1:
            query_string = self.url[query_start + 1:fragment_start]
            params = {}
            if len(query_string) > 0:
                param_pairs = query_string.split(""&"")
                for pair in param_pairs:
                    key_value = pair.split(""="")
                    if len(key_value) == 2:
                        key, value = key_value
                        params[key] = value
            return params
        return None

    def get_fragment(self):
        fragment_start = self.url.find(""#"")
        if fragment_start != -1:
            return self.url[fragment_start + 1:]
        return None",COTFewShot,"

```python
class URLHandler:
    def __init__(self, url):
        self.url = url

    def _get_scheme(self):
        return self.url.split('://')[0]

    def get_host(self):
        url_parts = self.url.split('://')
        if len(url_parts) > 1:
            host_path = url_parts[1].split('/')
            return host_path[0]
        else:
            return None

    def get_path(self):
        url_parts = self.url.split('://')
        if len(url_parts) > 1:
            host_path = url_parts[1].split('/', 1)
            if len(host_path) > 1:
                return '/' + host_path[1]
            else:
                return '/'
        else:
            return self.url

    def get_query_params(self):
        url_parts = self.url.split('?')
        if len(url_parts) > 1:
            query_params = url_parts[1].split('#')[0]
            params_dict = {}
            for param in query_params.split('&'):
                key_value = param.split('=')
                if len(key_value) == 2:
                    params_dict[key_value[0]] = key_value[1]
            return params_dict
        else:
            return {}

    def get_fragment(self):
        url_parts = self.url.split('#')
        if len(url_parts) > 1:
            return url_parts[1]
        else:
            return None

    def get_scheme(self):
        return self._get_scheme()
```",0.08692764936637946,0.13372550649759293,0.43859649122807015,0.46296296296296297,0.4504504454541028,0.22549019607843138,0.26136363636363635,0.2421052581850417,0.43859649122807015,0.46296296296296297,0.4504504454541028
Llama,91,"import urllib.parse


class UrlPath:
    def __init__(self):
        self.segments = []
        self.with_end_tag = False

    def add(self, segment):
        self.segments.append(self.fix_path(segment))

    def parse(self, path, charset):
        if path:
            if path.endswith('/'):
                self.with_end_tag = True

            path = self.fix_path(path)
            if path:
                split = path.split('/')
                for seg in split:
                    decoded_seg = urllib.parse.unquote(seg, encoding=charset)
                    self.segments.append(decoded_seg)

    @staticmethod
    def fix_path(path):
        if not path:
            return ''

        segment_str = path.strip('/')
        return segment_str",COTFewShot,"

```python
import urllib.parse


class UrlPath:
    def __init__(self, url=None):
        self.segments = []
        self.with_end_tag = False

    def add(self, segment):
        self.segments.append(segment)

    def parse(self, path, charset):
        path = self.fix_path(path)
        self.segments = path.split('/')

    @staticmethod
    def fix_path(path):
        return path.strip('/')
```",0.22242859251117317,0.2551091684402268,0.5581395348837209,0.8275862068965517,0.6666666618557099,0.421875,0.6923076923076923,0.5242718399547555,0.5581395348837209,0.8275862068965517,0.6666666618557099
Llama,92,"import sqlite3


class UserLoginDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()

    def insert_user(self, username, password):
        self.cursor.execute('''
            INSERT INTO users (username, password)
            VALUES (?, ?)
        ''', (username, password))
        self.connection.commit()

    def search_user_by_username(self, username):
        self.cursor.execute('''
            SELECT * FROM users WHERE username = ?
        ''', (username,))
        user = self.cursor.fetchone()
        return user

    def delete_user_by_username(self, username):
        self.cursor.execute('''
            DELETE FROM users WHERE username = ?
        ''', (username,))
        self.connection.commit()

    def validate_user_login(self, username, password):
        user = self.search_user_by_username(username)
        if user is not None and user[1] == password:
            return True
        return False",COTFewShot,"

```python
import sqlite3

class UserLoginDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS users
            (username TEXT PRIMARY KEY, password TEXT)
        ''')
        self.connection.commit()

    def insert_user(self, username, password):
        self.cursor.execute('INSERT INTO users VALUES (?, ?)', (username, password))
        self.connection.commit()

    def search_user_by_username(self, username):
        self.cursor.execute('SELECT * FROM users WHERE username = ?', (username,))
        return self.cursor.fetchall()

    def delete_user_by_username(self, username):
        self.cursor.execute('DELETE FROM users WHERE username = ?', (username,))
        self.connection.commit()

    def validate_user_login(self, username, password):
        self.cursor.execute('SELECT * FROM users WHERE username = ? AND password = ?', (username, password))
        return len(self.cursor.fetchall()) > 0
```",0.34065934065934067,0.3909401134663573,0.6481481481481481,0.5737704918032787,0.6086956471924386,0.5454545454545454,0.49411764705882355,0.5185185135307119,0.6481481481481481,0.5737704918032787,0.6086956471924386
Llama,93,"import numpy as np
from gensim import matutils
from numpy import dot, array


class VectorUtil:
    @staticmethod
    def similarity(vector_1, vector_2):
        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))

    @staticmethod
    def cosine_similarities(vector_1, vectors_all):
        norm = np.linalg.norm(vector_1)
        all_norms = np.linalg.norm(vectors_all, axis=1)
        dot_products = dot(vectors_all, vector_1)
        similarities = dot_products / (norm * all_norms)
        return similarities

    @staticmethod
    def n_similarity(vector_list_1, vector_list_2):
        if not (len(vector_list_1) and len(vector_list_2)):
            raise ZeroDivisionError('At least one of the passed list is empty.')

        return dot(matutils.unitvec(array(vector_list_1).mean(axis=0)),
                   matutils.unitvec(array(vector_list_2).mean(axis=0)))

    @staticmethod
    def compute_idf_weight_dict(total_num, number_dict):
        index_2_key_map = {}

        index = 0

        count_list = []
        for key, count in number_dict.items():
            index_2_key_map[index] = key
            count_list.append(count)
            index = index + 1

        a = np.array(count_list)
        ## smooth, in case the divide by zero error
        a = np.log((total_num + 1) / (a + 1))
        result = {}

        for index, w in enumerate(a):
            key = index_2_key_map[index]
            result[key] = w

        return result",COTFewShot,"

```python
import numpy as np
from gensim import matutils
from numpy import dot, array

class VectorUtil:
    @staticmethod
    def similarity(vector_1, vector_2):
        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))

    @staticmethod
    def cosine_similarities(vector_1, vectors_all):
        similarities = []
        for vector_2 in vectors_all:
            similarity = dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))
            similarities.append(similarity)
        return np.array(similarities)

    @staticmethod
    def n_similarity(vector_list_1, vector_list_2):
        return np.mean([VectorUtil.similarity(vector_1, vector_2) for vector_1, vector_2 in zip(vector_list_1, vector_list_2)])

    @staticmethod
    def compute_idf_weight_dict(total_num, number_dict):
        idf_weight_dict = {}
        for key, count in number_dict.items():
            idf_weight = np.log(total_num + 1) - np.log(count + 1)
            idf_weight_dict[key] = idf_weight
        return idf_weight_dict
```",0.22255746954654151,0.2534799122956879,0.3894736842105263,0.6727272727272727,0.49333332868888896,0.3111111111111111,0.5121951219512195,0.38709676949181343,0.3894736842105263,0.6727272727272727,0.49333332868888896
Llama,94,"class VendingMachine:
    def __init__(self):
        self.inventory = {}
        self.balance = 0

    def add_item(self, item_name, price, quantity):
        if not self.restock_item(item_name, quantity):
            self.inventory[item_name] = {'price': price, 'quantity': quantity}

    def insert_coin(self, amount):
        self.balance += amount
        return self.balance

    def purchase_item(self, item_name):
        if item_name in self.inventory:
            item = self.inventory[item_name]
            if item['quantity'] > 0 and self.balance >= item['price']:
                self.balance -= item['price']
                item['quantity'] -= 1
                return self.balance
            else:
                return False
        else:
            return False

    def restock_item(self, item_name, quantity):
        if item_name in self.inventory:
            self.inventory[item_name]['quantity'] += quantity
            return True
        else:
            return False

    def display_items(self):
        if not self.inventory:
            return False
        else:
            items = []
            for item_name, item_info in self.inventory.items():
                items.append(f""{item_name} - ${item_info['price']} [{item_info['quantity']}]"")
            return ""\n"".join(items)",COTFewShot,"

```python
class VendingMachine:
    def __init__(self):
        self.inventory = {}
        self.balance = 0

    def add_item(self, item_name, price, quantity):
        self.inventory[item_name] = {'price': price, 'quantity': quantity}

    def insert_coin(self, amount):
        self.balance += amount
        return self.balance

    def purchase_item(self, item_name):
        if item_name in self.inventory:
            if self.inventory[item_name]['quantity'] > 0:
                if self.balance >= self.inventory[item_name]['price']:
                    self.balance -= self.inventory[item_name]['price']
                    self.inventory[item_name]['quantity'] -= 1
                    return self.balance
                else:
                    return False
            else:
                return False
        else:
            return False

    def restock_item(self, item_name, quantity):
        if item_name in self.inventory:
            self.inventory[item_name]['quantity'] += quantity
            return True
        else:
            return False

    def display_items(self):
        if self.inventory:
            items = []
            for item in self.inventory:
                items.append(f'{item} - ${self.inventory[item][""price""]} [{self.inventory[item][""quantity""]}]')
            return items
        else:
            return False
```",0.6237658056513252,0.6706766031968607,0.7758620689655172,0.8181818181818182,0.7964601719946747,0.6666666666666666,0.7111111111111111,0.6881720380159557,0.7586206896551724,0.8,0.7787610569504269
Llama,95,"class Warehouse:
    def __init__(self):
        self.inventory = {}  # Product ID: Product
        self.orders = {}  # Order ID: Order

    def add_product(self, product_id, name, quantity):
        if product_id not in self.inventory:
            self.inventory[product_id] = {'name': name, 'quantity': quantity}
        else:
            self.inventory[product_id]['quantity'] += quantity

    def update_product_quantity(self, product_id, quantity):
        if product_id in self.inventory:
            self.inventory[product_id]['quantity'] += quantity

    def get_product_quantity(self, product_id):
        if product_id in self.inventory:
            return self.inventory[product_id]['quantity']
        else:
            return False

    def create_order(self, order_id, product_id, quantity):
        if self.get_product_quantity(product_id) >= quantity:
            self.update_product_quantity(product_id, -quantity)
            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}
        else:
            return False

    def change_order_status(self, order_id, status):
        if order_id in self.orders:
            self.orders[order_id]['status'] = status
        else:
            return False

    def track_order(self, order_id):
        if order_id in self.orders:
            return self.orders[order_id]['status']
        else:
            return False",COTFewShot,"

```python
class Warehouse:
    def __init__(self):
        self.inventory = {}
        self.orders = {}

    def add_product(self, product_id, name, quantity):
        if product_id in self.inventory:
            self.inventory[product_id]['quantity'] += quantity
        else:
            self.inventory[product_id] = {'name': name, 'quantity': quantity}

    def update_product_quantity(self, product_id, quantity):
        if product_id in self.inventory:
            self.inventory[product_id]['quantity'] += quantity
        else:
            raise ValueError(""Product not found in inventory"")

    def get_product_quantity(self, product_id):
        if product_id in self.inventory:
            return self.inventory[product_id]['quantity']
        else:
            return False

    def create_order(self, order_id, product_id, quantity):
        if product_id in self.inventory and self.inventory[product_id]['quantity'] >= quantity:
            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}
            self.update_product_quantity(product_id, -quantity)
            return True
        else:
            return False

    def change_order_status(self, order_id, status):
        if order_id in self.orders:
            self.orders[order_id]['status'] = status
            return True
        else:
            return False

    def track_order(self, order_id):
        if order_id in self.orders:
            return self.orders[order_id]['status']
        else:
            return False
```",0.6260869565217392,0.6795542645635215,0.9090909090909091,0.8620689655172413,0.8849557472159135,0.7912087912087912,0.7741935483870968,0.7826086906527646,0.8909090909090909,0.8448275862068966,0.8672566321716658
Llama,96,"class WeatherSystem:
    def __init__(self, city) -> None:
        self.temperature = None
        self.weather = None
        self.city = city
        self.weather_list = {}
    
    def query(self, weather_list, tmp_units = 'celsius'):
        self.weather_list = weather_list
        if self.city not in weather_list:
            return False
        else:
            self.temperature = self.weather_list[self.city]['temperature']
            self.weather = self.weather_list[self.city]['weather']
        if self.weather_list[self.city]['temperature units'] != tmp_units:
            if tmp_units == 'celsius':
                return self.fahrenheit_to_celsius(), self.weather
            elif tmp_units == 'fahrenheit':
                return self.celsius_to_fahrenheit(), self.weather
        else:
            return self.temperature, self.weather
    
    def set_city(self, city):
        self.city = city

    def celsius_to_fahrenheit(self):
        return (self.temperature * 9/5) + 32

    def fahrenheit_to_celsius(self):
        return (self.temperature - 32) * 5/9",COTFewShot,"

```python
class WeatherSystem:
    def __init__(self, city):
        self.temperature = None
        self.weather = None
        self.city = city
        self.weather_list = {}

    def query(self, weather_list, tmp_units='celsius'):
        if self.city in weather_list:
            self.weather_list = weather_list[self.city]
            self.temperature = self.weather_list['temperature']
            self.weather = self.weather_list['weather']
            if tmp_units == 'fahrenheit' and self.weather_list['temperature units'] == 'celsius':
                self.temperature = self.celsius_to_fahrenheit()
            elif tmp_units == 'celsius' and self.weather_list['temperature units'] == 'fahrenheit':
                self.temperature = self.fahrenheit_to_celsius()
            return (self.temperature, self.weather)
        else:
            return None

    def set_city(self, city):
        self.city = city

    def celsius_to_fahrenheit(self):
        if self.temperature is not None:
            return (self.temperature * 9/5) + 32
        else:
            return None

    def fahrenheit_to_celsius(self):
        if self.temperature is not None:
            return (self.temperature - 32) * 5/9
        else:
            return None
```",0.30392156862745096,0.385917240742594,0.7884615384615384,0.7454545454545455,0.7663551351908464,0.5294117647058824,0.5232558139534884,0.5263157844738554,0.7884615384615384,0.7454545454545455,0.7663551351908464
Llama,97,"class Words2Numbers:

    def __init__(self):
        self.numwords = {}
        self.units = [
            ""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"",
            ""nine"", ""ten"", ""eleven"", ""twelve"", ""thirteen"", ""fourteen"", ""fifteen"",
            ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen"",
        ]
        self.tens = ["""", """", ""twenty"", ""thirty"", ""forty"", ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""]
        self.scales = [""hundred"", ""thousand"", ""million"", ""billion"", ""trillion""]

        self.numwords[""and""] = (1, 0)
        for idx, word in enumerate(self.units):
            self.numwords[word] = (1, idx)
        for idx, word in enumerate(self.tens):
            self.numwords[word] = (1, idx * 10)
        for idx, word in enumerate(self.scales):
            self.numwords[word] = (10 ** (idx * 3 or 2), 0)

        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}
        self.ordinal_endings = [('ieth', 'y'), ('th', '')]

    def text2int(self, textnum):
        textnum = textnum.replace('-', ' ')

        current = result = 0
        curstring = """"
        onnumber = False
        for word in textnum.split():
            if word in self.ordinal_words:
                scale, increment = (1, self.ordinal_words[word])
                current = current * scale + increment
                onnumber = True
            else:
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = ""%s%s"" % (word[:-len(ending)], replacement)

                if word not in self.numwords:
                    if onnumber:
                        curstring += repr(result + current) + "" ""
                    curstring += word + "" ""
                    result = current = 0
                    onnumber = False
                else:
                    scale, increment = self.numwords[word]
                    current = current * scale + increment
                    if scale > 100:
                        result += current
                        current = 0
                    onnumber = True

        if onnumber:
            curstring += repr(result + current)

        return curstring

    def is_valid_input(self, textnum):

        textnum = textnum.replace('-', ' ')

        for word in textnum.split():
            if word in self.ordinal_words:
                continue
            else:
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = ""%s%s"" % (word[:-len(ending)], replacement)

                if word not in self.numwords:
                    return False

        return True",COTFewShot,"

```python
class Words2Numbers:
    def __init__(self, city=None):
        self.numwords = {}
        self.units = [
            ""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"",
            ""nine"", ""ten"", ""eleven"", ""twelve"", ""thirteen"", ""fourteen"", ""fifteen"",
            ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen"",
        ]
        self.tens = ["""", """", ""twenty"", ""thirty"", ""forty"", ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""]
        self.scales = [""hundred"", ""thousand"", ""million"", ""billion"", ""trillion""]

        self.numwords[""and""] = (1, 0)
        for idx, word in enumerate(self.units):
            self.numwords[word] = (1, idx)
        for idx, word in enumerate(self.tens):
            self.numwords[word] = (1, idx * 10)
        for idx, word in enumerate(self.scales):
            self.numwords[word] = (10 ** (idx * 3 or 2), 0)

        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}
        self.ordinal_endings = [('ieth', 'y'), ('th', '')]

    def text2int(self, textnum):
        current = result = 0
        for word in textnum.replace('-', ' ').split():
            if word in self.numwords:
                scale, increment = self.numwords[word]
                current = current * scale + increment
                if scale > 100:
                    result += current
                    current = 0
            elif word in self.ordinal_words:
                scale = self.ordinal_words[word]
                current = current * scale + scale
            elif word in ['hundred', 'thousand', 'million', 'billion', 'trillion']:
                current *= self.numwords[word][0]
            else:
                raise ValueError(""Invalid word: "" + word)
        return str(result + current)

    def is_valid_input(self, textnum):
        try:
            self.text2int(textnum)
            return True
        except ValueError:
            return False
```",0.49470527510556134,0.5266236267272029,0.8721804511278195,0.8405797101449275,0.8560885558873109,0.7019230769230769,0.7684210526315789,0.7336683367187697,0.8721804511278195,0.8405797101449275,0.8560885558873109
Llama,98,"import xml.etree.ElementTree as ET


class XMLProcessor:
    def __init__(self, file_name):
        self.file_name = file_name
        self.root = None

    def read_xml(self):
        try:
            tree = ET.parse(self.file_name)
            self.root = tree.getroot()
            return self.root
        except:
            return None

    def write_xml(self, file_name):
        try:
            tree = ET.ElementTree(self.root)
            tree.write(file_name)
            return True
        except:
            return False

    def process_xml_data(self, file_name):
        for element in self.root.iter('item'):
            text = element.text
            element.text = text.upper()
        return self.write_xml(file_name)

    def find_element(self, element_name):
        elements = self.root.findall(element_name)
        return elements",COTFewShot,"

```python
import xml.etree.ElementTree as ET

class XMLProcessor:
    def __init__(self, file_name):
        self.file_name = file_name
        self.root = None

    def read_xml(self):
        try:
            tree = ET.parse(self.file_name)
            self.root = tree.getroot()
            return self.root
        except:
            return None

    def write_xml(self, file_name):
        try:
            tree = ET.ElementTree(self.root)
            tree.write(file_name)
            return True
        except:
            return False

    def process_xml_data(self, file_name):
        try:
            # Modify the data in XML elements
            # For demonstration purposes, this example will simply write the current XML data to a new file
            tree = ET.ElementTree(self.root)
            tree.write(file_name)
            return True
        except:
            return False

    def find_element(self, element_name):
        try:
            elements = self.root.findall('.//' + element_name)
            return elements
        except:
            return []
```",0.4731182795698925,0.5026849867623862,0.8333333333333334,0.5833333333333334,0.686274504959631,0.7464788732394366,0.5955056179775281,0.6624999950632814,0.8333333333333334,0.5833333333333334,0.686274504959631
Llama,99,"import zipfile


class ZipFileProcessor:
    def __init__(self, file_name):
        self.file_name = file_name

    def read_zip_file(self):
        try:
            zip_file = zipfile.ZipFile(self.file_name, 'r')
            return zip_file
        except:
            return None

    def extract_all(self, output_path):
        try:
            with zipfile.ZipFile(self.file_name, 'r') as zip_file:
                zip_file.extractall(output_path)
            return True
        except:
            return False

    def extract_file(self, file_name, output_path):
        try:
            with zipfile.ZipFile(self.file_name, 'r') as zip_file:
                zip_file.extract(file_name, output_path)
            return True
        except:
            return False

    def create_zip_file(self, files, output_file_name):
        try:
            with zipfile.ZipFile(output_file_name, 'w') as zip_file:
                for file in files:
                    zip_file.write(file)
            return True
        except:
            return False",COTFewShot,"

```python
import zipfile


class ZipFileProcessor:
    def __init__(self, file_name):
        self.file_name = file_name

    def read_zip_file(self):
        try:
            zip_file = zipfile.ZipFile(self.file_name, 'r')
            return zip_file
        except:
            return None

    def extract_all(self, output_path):
        try:
            with zipfile.ZipFile(self.file_name, 'r') as zip_file:
                zip_file.extractall(output_path)
            return True
        except:
            return False

    def extract_file(self, file_name, output_path):
        try:
            with zipfile.ZipFile(self.file_name, 'r') as zip_file:
                zip_file.extract(file_name, output_path)
            return True
        except:
            return False

    def create_zip_file(self, files, output_file_name):
        try:
            with zipfile.ZipFile(output_file_name, 'w') as zip_file:
                for file in files:
                    zip_file.write(file)
            return True
        except:
            return False
```",0.972972972972973,0.9731482306711113,1.0,0.9523809523809523,0.9756097511005354,1.0,0.9672131147540983,0.9833333283347223,1.0,0.9523809523809523,0.9756097511005354
Llama,9,"class BigNumCalculator:
    @staticmethod
    def add(num1, num2):
        max_length = max(len(num1), len(num2))
        num1 = num1.zfill(max_length)
        num2 = num2.zfill(max_length)

        carry = 0
        result = []
        for i in range(max_length - 1, -1, -1):
            digit_sum = int(num1[i]) + int(num2[i]) + carry
            carry = digit_sum // 10
            digit = digit_sum % 10
            result.insert(0, str(digit))

        if carry > 0:
            result.insert(0, str(carry))

        return ''.join(result)

    @staticmethod
    def subtract(num1, num2):

        if len(num1) < len(num2):
            num1, num2 = num2, num1
            negative = True
        elif len(num1) > len(num2):
            negative = False
        else:
            if num1 < num2:
                num1, num2 = num2, num1
                negative = True
            else:
                negative = False

        max_length = max(len(num1), len(num2))
        num1 = num1.zfill(max_length)
        num2 = num2.zfill(max_length)

        borrow = 0
        result = []
        for i in range(max_length - 1, -1, -1):
            digit_diff = int(num1[i]) - int(num2[i]) - borrow

            if digit_diff < 0:
                digit_diff += 10
                borrow = 1
            else:
                borrow = 0

            result.insert(0, str(digit_diff))

        while len(result) > 1 and result[0] == '0':
            result.pop(0)

        if negative:
            result.insert(0, '-')

        return ''.join(result)

    @staticmethod
    def multiply(num1, num2):
        len1, len2 = len(num1), len(num2)
        result = [0] * (len1 + len2)

        for i in range(len1 - 1, -1, -1):
            for j in range(len2 - 1, -1, -1):
                mul = int(num1[i]) * int(num2[j])
                p1, p2 = i + j, i + j + 1
                total = mul + result[p2]

                result[p1] += total // 10
                result[p2] = total % 10

        start = 0
        while start < len(result) - 1 and result[start] == 0:
            start += 1

        return ''.join(map(str, result[start:]))",COTFewShot,"

```python
class BigNumCalculator:
    @staticmethod
    def add(num1, num2):
        # Convert input strings to integers
        num1_int = int(num1)
        num2_int = int(num2)
        
        # Calculate the sum
        sum_result = num1_int + num2_int
        
        # Convert the result back to string and return
        return str(sum_result)

    @staticmethod
    def subtract(num1, num2):
        # Convert input strings to integers
        num1_int = int(num1)
        num2_int = int(num2)
        
        # Calculate the difference
        diff_result = num1_int - num2_int
        
        # Convert the result back to string and return
        return str(diff_result)

    @staticmethod
    def multiply(num1, num2):
        # Convert input strings to integers
        num1_int = int(num1)
        num2_int = int(num2)
        
        # Calculate the product
        product_result = num1_int * num2_int
        
        # Convert the result back to string and return
        return str(product_result)
```",0.02298704371767357,0.03163578913930048,0.16304347826086957,0.375,0.22727272304866855,0.0481283422459893,0.16071428571428573,0.07407407052718945,0.13043478260869565,0.3,0.18181817759412314
Llama,0,"import logging
import datetime


class AccessGatewayFilter:

    def __init__(self):
        pass

    def filter(self, request):
        request_uri = request['path']
        method = request['method']

        if self.is_start_with(request_uri):
            return True

        try:
            token = self.get_jwt_user(request)
            user = token['user']
            if user['level'] > 2:
                self.set_current_user_info_and_log(user)
                return True
        except:
            return False

    def is_start_with(self, request_uri):
        start_with = [""/api"", '/login']
        for s in start_with:
            if request_uri.startswith(s):
                return True
        return False

    def get_jwt_user(self, request):
        token = request['headers']['Authorization']
        user = token['user']
        if token['jwt'].startswith(user['name']):
            jwt_str_date = token['jwt'].split(user['name'])[1]
            jwt_date = datetime.datetime.strptime(jwt_str_date, ""%Y-%m-%d"")
            if datetime.datetime.today() - jwt_date >= datetime.timedelta(days=3):
                return None
        return token

    def set_current_user_info_and_log(self, user):
        host = user['address']
        logging.log(msg=user['name'] + host + str(datetime.datetime.now()), level=1)",ZeroShot,"

```python
# This class is a filter used for accessing gateway filtering, primarily for authentication and access log recording.
import logging
import datetime
import jwt  # Import the PyJWT library for handling JWT tokens

class AccessGatewayFilter:
    def __init__(self):
        # Initialize the logger
        self.logger = logging.getLogger(__name__)
        # Set the secret key for JWT token verification
        self.secret_key = ""your_secret_key_here""

    def filter(self, request):
        """"""
        Filter the incoming request based on certain rules and conditions.
        :return: bool, True if the request is allowed, False otherwise
        """"""
        # Check if the request URI starts with certain prefixes
        if not self.is_start_with(request.uri):
            return False
        
        # Get the user information from the JWT token in the request
        user = self.get_jwt_user(request)
        if user is None:
            return False
        
        # Set the current user information and log the access
        self.set_current_user_info_and_log(user)
        return True

    def is_start_with(self, request_uri):
        """"""
        Check if the request URI starts with certain prefixes.
        :return: bool, True if the URI starts with certain prefixes, False otherwise
        """"""
        # Define the allowed prefixes
        allowed_prefixes = [""/api"", ""/admin""]
        for prefix in allowed_prefixes:
            if request_uri.startswith(prefix):
                return True
        return False

    def get_jwt_user(self, request):
        """"""
        Get the user information from the JWT token in the request.
        :return: dict or None, the user information if the token is valid, None otherwise
        """"""
        # Get the JWT token from the request headers
        token = request.headers.get(""Authorization"")
        if token is None:
            return None
        
        # Verify the JWT token
        try:
            user = jwt.decode(token, self.secret_key, algorithms=[""HS256""])
            return user
        except jwt.ExpiredSignatureError:
            self.logger.warning(""Expired JWT token"")
        except jwt.InvalidTokenError:
            self.logger.warning(""Invalid JWT token"")
        return None

    def set_current_user_info_and_log(self, user):
        """"""
        Set the current user information and log the access.
        :return: None
        """"""
        # Set the current user information
        self.current_user = user
        # Log the access
        self.logger.info(f""Access logged for user {user['username']} at {datetime.datetime.now()}"")
```",0.04577464788732395,0.06513773924271474,0.46875,0.2459016393442623,0.3225806406474737,0.27,0.11842105263157894,0.16463414210291502,0.453125,0.23770491803278687,0.3118279524754307
Llama,1,"import math


class AreaCalculator:

    def __init__(self, radius):
        self.radius = radius

    def calculate_circle_area(self):
        return math.pi * self.radius ** 2

    def calculate_sphere_area(self):
        return 4 * math.pi * self.radius ** 2

    def calculate_cylinder_area(self, height):
        return 2 * math.pi * self.radius * (self.radius + height)

    def calculate_sector_area(self, angle):
        return self.radius ** 2 * angle / 2

    def calculate_annulus_area(self, inner_radius, outer_radius):
        return math.pi * (outer_radius ** 2 - inner_radius ** 2)",ZeroShot,"

```python
# This is a class for calculating the area of different shapes, including circle, sphere, cylinder, sector and annulus.
import math

class AreaCalculator:
    # Initialize the radius for shapes.
    def __init__(self, radius):
        self.radius = radius  # store the radius as an instance variable

    # Calculate the area of circle based on self.radius
    def calculate_circle_area(self):
        # formula for area of circle: π * r^2
        return math.pi * (self.radius ** 2)

    # Calculate the area of sphere based on self.radius
    def calculate_sphere_area(self):
        # formula for area of sphere: 4 * π * r^2
        return 4 * math.pi * (self.radius ** 2)

    # Calculate the area of cylinder based on self.radius and height
    def calculate_cylinder_area(self, height):
        # formula for area of cylinder: 2 * π * r * (r + h)
        return 2 * math.pi * self.radius * (self.radius + height)

    # Calculate the area of sector based on self.radius and angle
    def calculate_sector_area(self, angle):
        # formula for area of sector: (angle/360) * π * r^2
        return (angle / 360) * math.pi * (self.radius ** 2)

    # Calculate the area of annulus based on inner_radius and outer_radius
    def calculate_annulus_area(self, inner_radius, outer_radius):
        # formula for area of annulus: π * (outer_radius^2 - inner_radius^2)
        return math.pi * ((outer_radius ** 2) - (inner_radius ** 2))
```",0.11004784688995216,0.13841852246393824,0.9705882352941176,0.3793103448275862,0.5454545414138379,0.660377358490566,0.2517985611510791,0.36458332933648,0.9117647058823529,0.3563218390804598,0.5123966901741684
Llama,2,"class ArgumentParser:
    def __init__(self):
        self.arguments = {}
        self.required = set()
        self.types = {}

    def parse_arguments(self, command_string):
        args = command_string.split()[1:]
        for i in range(len(args)):
            arg = args[i]
            if arg.startswith('--'):
                key_value = arg[2:].split('=')
                if len(key_value) == 2:
                    self.arguments[key_value[0]] = self._convert_type(key_value[0], key_value[1])
                else:
                    self.arguments[key_value[0]] = True
            elif arg.startswith('-'):
                key = arg[1:]
                if i + 1 < len(args) and not args[i + 1].startswith('-'):
                    self.arguments[key] = self._convert_type(key, args[i + 1])
                else:
                    self.arguments[key] = True
        missing_args = self.required - set(self.arguments.keys())
        if missing_args:
            return False, missing_args

        return True, None

    def get_argument(self, key):
        return self.arguments.get(key)

    def add_argument(self, arg, required=False, arg_type=str):
        if required:
            self.required.add(arg)
        self.types[arg] = arg_type

    def _convert_type(self, arg, value):
        try:
            return self.types[arg](value)
        except (ValueError, KeyError):
            return value",ZeroShot,"

```python
class ArgumentParser:
    def __init__(self):
        # Initialize the fields: arguments dictionary, types dictionary, and required set
        self.arguments = {}
        self.types = {}
        self.required = set()

    def parse_arguments(self, command_string):
        # Split the command string into a list of arguments
        args = command_string.split()
        
        # Iterate over the arguments in steps of 2 (assuming key-value pairs)
        for i in range(0, len(args), 2):
            # Check if the argument has a corresponding value
            if i + 1 < len(args):
                key = args[i].lstrip('-')  # Remove leading dashes from the key
                value = args[i + 1]
                
                # Check if the key exists in the types dictionary
                if key in self.types:
                    # Convert the value to the specified type
                    self.arguments[key] = self._convert_type(key, value)
                else:
                    # If the key does not exist, add it to the arguments dictionary as a string
                    self.arguments[key] = value
            else:
                # If an argument is missing a value, return False with the missing argument name
                return False, {args[i].lstrip('-')}
        
        # Check for missing required arguments
        missing_args = self.required - set(self.arguments.keys())
        if missing_args:
            return False, missing_args
        else:
            return True, None

    def get_argument(self, key):
        # Retrieve the value of the specified argument from the arguments dictionary
        return self.arguments.get(key)

    def add_argument(self, arg, required=False, arg_type=str):
        # Add the argument to the types dictionary with its corresponding type
        self.types[arg] = arg_type
        
        # If the argument is required, add it to the required set
        if required:
            self.required.add(arg)

    def _convert_type(self, arg, value):
        # Try to convert the value to the specified type
        try:
            return self.types[arg](value)
        except (ValueError, TypeError):
            # If the conversion fails, return the original value
            return value
```",0.14453125,0.1714246720554583,0.7435897435897436,0.4566929133858268,0.5658536538222487,0.559322033898305,0.2857142857142857,0.37822349122618043,0.7435897435897436,0.4566929133858268,0.5658536538222487
Llama,3,"import itertools


class ArrangementCalculator:
    def __init__(self, datas):
        self.datas = datas

    @staticmethod
    def count(n, m=None):
        if m is None or n == m:
            return ArrangementCalculator.factorial(n)
        else:
            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)

    @staticmethod
    def count_all(n):
        total = 0
        for i in range(1, n + 1):
            total += ArrangementCalculator.count(n, i)
        return total

    def select(self, m=None):
        if m is None:
            m = len(self.datas)
        result = []
        for permutation in itertools.permutations(self.datas, m):
            result.append(list(permutation))
        return result

    def select_all(self):
        result = []
        for i in range(1, len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    @staticmethod
    def factorial(n):
        result = 1
        for i in range(2, n + 1):
            result *= i
        return result",ZeroShot,"

```python
import itertools
import math

class ArrangementCalculator:
    def __init__(self, datas):
        # Initialize the ArrangementCalculator object with a list of datas
        self.datas = datas

    @staticmethod
    def count(n, m=None):
        # If m is not provided or n equals m, return factorial(n)
        if m is None or n == m:
            return ArrangementCalculator.factorial(n)
        # Calculate the number of arrangements by choosing m items from n items (permutations)
        else:
            return math.factorial(n) // math.factorial(n - m)

    @staticmethod
    def count_all(n):
        # Calculate the total number of all possible arrangements by choosing at least 1 item and at most n items from n items
        total_count = 0
        for i in range(1, n + 1):
            total_count += ArrangementCalculator.count(n, i)
        return total_count

    def select(self, m=None):
        # If m is not provided, set m to the length of the internal datas
        if m is None:
            m = len(self.datas)
        # Generate a list of arrangements by selecting m items from the internal datas
        return list(itertools.permutations(self.datas, m))

    def select_all(self):
        # Generate a list of all arrangements by selecting at least 1 item and at most the number of internal datas
        all_arrangements = []
        for i in range(1, len(self.datas) + 1):
            all_arrangements.extend(self.select(i))
        return all_arrangements

    @staticmethod
    def factorial(n):
        # Calculate the factorial of a given number
        return math.factorial(n)
```",0.2079207920792079,0.23962790858415925,0.896551724137931,0.5416666666666666,0.6753246706291113,0.6086956521739131,0.345679012345679,0.44094487726951453,0.896551724137931,0.5416666666666666,0.6753246706291113
Llama,4,"class AssessmentSystem:
    def __init__(self):
        self.students = {}

    def add_student(self, name, grade, major):
        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}

    def add_course_score(self, name, course, score):
        if name in self.students:
            self.students[name]['courses'][course] = score

    def get_gpa(self, name):
        if name in self.students and self.students[name]['courses']:
            return sum(self.students[name]['courses'].values()) / len(self.students[name]['courses'])
        else:
            return None

    def get_all_students_with_fail_course(self):
        students = []
        for name, student in self.students.items():
            for course, score in student['courses'].items():
                if score < 60:
                    students.append(name)
                    break
        return students

    def get_course_average(self, course):
        total = 0
        count = 0
        for student in self.students.values():
            if course in student['courses']:
                score = student['courses'][course]
                if score is not None:
                    total += score
                    count += 1
        return total / count if count > 0 else None

    def get_top_student(self):
        top_student = None
        top_gpa = 0
        for name, student in self.students.items():
            gpa = self.get_gpa(name)
            if gpa is not None and gpa > top_gpa:
                top_gpa = gpa
                top_student = name
        return top_student",ZeroShot,"

```python
class AssessmentSystem:
    def __init__(self):
        # Initialize an empty dictionary to store students' information
        self.students = {}

    def add_student(self, name, grade, major):
        # Add a new student into the dictionary with an empty dictionary for courses
        self.students[name] = {'grade': grade, 'major': major, 'courses': {}}

    def add_course_score(self, name, course, score):
        # Check if the student exists in the system
        if name in self.students:
            # Add the course score to the student's courses dictionary
            self.students[name]['courses'][course] = score
        else:
            # Raise an error if the student does not exist
            raise ValueError(""Student does not exist in the system"")

    def get_gpa(self, name):
        # Check if the student exists in the system
        if name in self.students:
            # Get the student's courses dictionary
            courses = self.students[name]['courses']
            # Check if the student has any courses
            if courses:
                # Calculate the average grade
                gpa = sum(courses.values()) / len(courses)
                return gpa
            else:
                # Return None if the student has no courses
                return None
        else:
            # Return None if the student does not exist
            return None

    def get_all_students_with_fail_course(self):
        # Initialize an empty list to store students with failing courses
        failing_students = []
        # Iterate over each student in the system
        for name, student in self.students.items():
            # Iterate over each course the student is taking
            for course, score in student['courses'].items():
                # Check if the student has a failing grade in the course
                if score < 60:
                    # Add the student to the list of failing students
                    failing_students.append(name)
                    # Break out of the loop to avoid adding the same student multiple times
                    break
        # Return the list of failing students
        return failing_students

    def get_course_average(self, course):
        # Initialize variables to store the sum of scores and the count of students
        total_score = 0
        student_count = 0
        # Iterate over each student in the system
        for student in self.students.values():
            # Check if the student is taking the course
            if course in student['courses']:
                # Add the student's score to the total score
                total_score += student['courses'][course]
                # Increment the student count
                student_count += 1
        # Check if any students are taking the course
        if student_count > 0:
            # Calculate and return the average score
            return total_score / student_count
        else:
            # Return None if no students are taking the course
            return None

    def get_top_student(self):
        # Initialize variables to store the top student and their GPA
        top_student = None
        top_gpa = 0
        # Iterate over each student in the system
        for name, student in self.students.items():
            # Calculate the student's GPA
            gpa = self.get_gpa(name)
            # Check if the student's GPA is higher than the current top GPA
            if gpa is not None and gpa > top_gpa:
                # Update the top student and GPA
                top_student = name
                top_gpa = gpa
        # Return the top student
        return top_student
```",0.1213483146067416,0.1483014241840316,0.8904109589041096,0.4744525547445255,0.6190476145120182,0.5428571428571428,0.25165562913907286,0.3438913983866014,0.8767123287671232,0.46715328467153283,0.6095238049882087
Llama,5,"class AutomaticGuitarSimulator:
    def __init__(self, text) -> None:
        self.play_text = text

    def interpret(self, display=False):
        if len(self.play_text) == 0:
            return
        else:
            play_list = []
            play_segs = self.play_text.split("" "")
            for play_seg in play_segs:
                pos = 0
                for ele in play_seg:
                    if ele.isalpha():
                        pos += 1
                        continue
                    break
                play_chord = play_seg[0:pos]
                play_value = play_seg[pos:]
                play_list.append({'Chord': play_chord, 'Tune': play_value})
                if display:
                    self.display(play_chord, play_value)
            return play_list

    def display(self, key, value):
        return ""Normal Guitar Playing -- Chord: %s, Play Tune: %s"" % (key, value)",ZeroShot,"

```python
# This class is an automatic guitar simulator that can interpret and play based on the input guitar sheet music.

class AutomaticGuitarSimulator:
    def __init__(self, text) -> None:
        """"""
        Initialize the score to be played
        """"""
        self.play_text = text

    def interpret(self, display=False):
        """"""
        Interpret the music score to be played
        :return:list of dict, The dict includes two fields, Chore and Tune, which are letters and numbers, respectively
        """"""
        # Assuming the input text is a string of space-separated chord and tune pairs
        score = self.play_text.split(',')
        interpreted_score = []
        
        # Iterate over each pair in the score
        for pair in score:
            # Split the pair into chord and tune
            chord_tune = pair.split(':')
            
            # Check if the pair is in the correct format
            if len(chord_tune) != 2:
                raise ValueError(""Invalid score format"")
            
            # Extract chord and tune
            chord = chord_tune[0].strip()
            tune = chord_tune[1].strip()
            
            # Check if the tune is a number
            if not tune.isdigit():
                raise ValueError(""Tune must be a number"")
            
            # Create a dictionary for the chord and tune
            chord_tune_dict = {
                ""Chore"": chord,
                ""Tune"": int(tune)
            }
            
            # Add the dictionary to the interpreted score
            interpreted_score.append(chord_tune_dict)
        
        # If display is True, print out the interpreted score
        if display:
            for key, value in interpreted_score:
                self.display(key, value)
        
        return interpreted_score


    def display(self, key, value):
        """"""
        Print out chord and play tune with following format: Normal Guitar Playing -- Chord: %s, Play Tune: %s
        :return: str
        """"""
        # Print out the chord and tune
        print(""Normal Guitar Playing -- Chord: %s, Play Tune: %d"" % (key, value))
        return ""Normal Guitar Playing -- Chord: %s, Play Tune: %d"" % (key, value)


# Example usage:
simulator = AutomaticGuitarSimulator(""A:1, B:2, C:3"")
interpreted_score = simulator.interpret(display=True)
```",0.06985294117647058,0.0861914256216268,0.515625,0.2214765100671141,0.30985915072582604,0.34146341463414637,0.11764705882352941,0.17499999618828135,0.515625,0.2214765100671141,0.30985915072582604
Llama,6,"class AvgPartition:
    def __init__(self, lst, limit):
        self.lst = lst
        self.limit = limit

    def setNum(self):
        size = len(self.lst) // self.limit
        remainder = len(self.lst) % self.limit
        return size, remainder

        
    def get(self, index):
        size, remainder = self.setNum()
        start = index * size + min(index, remainder)
        end = start + size
        if index + 1 <= remainder:
            end += 1
        return self.lst[start:end]",ZeroShot,"

```python
class AvgPartition:
    def __init__(self, lst, limit):
        # Check if the number of partitions is greater than 0
        if limit <= 0:
            raise ValueError(""Number of partitions must be greater than 0"")
        # Initialize the list and the number of partitions
        self.lst = lst
        self.limit = limit

    def setNum(self):
        # Calculate the size of each block
        block_size = len(self.lst) // self.limit
        # Calculate the remainder of the division
        remainder = len(self.lst) % self.limit
        # Return the size of each block and the remainder of the division
        return block_size, remainder


    def get(self, index):
        # Check if the index is within the valid range
        if index < 0 or index >= self.limit:
            raise IndexError(""Index out of range"")
        
        # Calculate the size of each block and the remainder of the division
        block_size, remainder = self.setNum()
        
        # Calculate the start position of the block
        start = index * block_size + min(index, remainder)
        
        # Calculate the end position of the block
        end = (index + 1) * block_size + min(index + 1, remainder)
        
        # Return the corresponding block
        return self.lst[start:end]

# Example usage:
avg_partition = AvgPartition([1, 2, 3, 4, 5, 6, 7, 8, 9], 3)
print(avg_partition.get(0))  # Output: [1, 2, 3]
print(avg_partition.get(1))  # Output: [4, 5, 6]
print(avg_partition.get(2))  # Output: [7, 8, 9]
```",0.10194174757281552,0.12572316390563876,0.8857142857142857,0.31313131313131315,0.462686563304745,0.5932203389830508,0.21084337349397592,0.3111111072418766,0.8857142857142857,0.31313131313131315,0.462686563304745
Llama,7,"class BalancedBrackets:
    def __init__(self, expr):
        self.stack = []
        self.left_brackets = [""("", ""{"", ""[""]
        self.right_brackets = ["")"", ""}"", ""]""]
        self.expr = expr

    def clear_expr(self):
        self.expr = ''.join(c for c in self.expr if (c in self.left_brackets or c in self.right_brackets))

    def check_balanced_brackets(self):
        self.clear_expr()
        for Brkt in self.expr:
            if Brkt in self.left_brackets:
                self.stack.append(Brkt)
            else:
                Current_Brkt = self.stack.pop()
                if Current_Brkt == ""("":
                    if Brkt != "")"":
                        return False
                if Current_Brkt == ""{"":
                    if Brkt != ""}"":
                        return False
                if Current_Brkt == ""["":
                    if Brkt != ""]"":
                        return False
        if self.stack:
            return False
        return True",ZeroShot,"

```python
# This is a class that checks for bracket matching

class BalancedBrackets:
    def __init__(self, expr):
        # Initializes the class with an expression.
        self.expr = expr

    def clear_expr(self):
        # Clears the expression of all characters that are not brackets.
        self.expr = ''.join([char for char in self.expr if char in '()[]{}'])

    def check_balanced_brackets(self):
        # Checks if the expression has balanced brackets.
        # :return: True if the expression has balanced brackets, False otherwise.
        stack = []
        bracket_map = {')': '(', '}': '{', ']': '['}
        
        # Iterate over each character in the expression
        for char in self.expr:
            # If the character is an opening bracket, push it onto the stack
            if char in bracket_map.values():
                stack.append(char)
            # If the character is a closing bracket, check if the stack is empty or the top of the stack does not match
            elif char in bracket_map.keys():
                if not stack or stack.pop() != bracket_map[char]:
                    return False
        
        # If the stack is empty after iterating over the entire expression, the brackets are balanced
        return not stack


# Example usage:
if __name__ == ""__main__"":
    # Create an instance of the BalancedBrackets class
    bb = BalancedBrackets(""({[]})"")
    
    # Clear the expression of non-bracket characters
    bb.clear_expr()
    
    # Check if the expression has balanced brackets
    print(bb.check_balanced_brackets())  # Output: True

    # Create an instance of the BalancedBrackets class with unbalanced brackets
    bb_unbalanced = BalancedBrackets(""({[})"")
    
    # Clear the expression of non-bracket characters
    bb_unbalanced.clear_expr()
    
    # Check if the expression has balanced brackets
    print(bb_unbalanced.check_balanced_brackets())  # Output: False
```",0.02941176470588235,0.049433136733796464,0.5102040816326531,0.2336448598130841,0.32051281620397765,0.225,0.09523809523809523,0.13382899210348131,0.5102040816326531,0.2336448598130841,0.32051281620397765
Llama,8,"class BankAccount:
    def __init__(self, balance=0):
        self.balance = balance

    def deposit(self, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        self.balance += amount
        return self.balance

    def withdraw(self, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient balance."")
        self.balance -= amount
        return self.balance

    def view_balance(self):
        return self.balance

    def transfer(self, other_account, amount):
        self.withdraw(amount)
        other_account.deposit(amount)",ZeroShot,"

```python
# This is a class as a bank account system, which supports deposit money, withdraw money, view balance, and transfer money.

class BankAccount:
    def __init__(self, balance=0):
        # Initializes a bank account object with an attribute balance, default value is 0.
        self.balance = balance  # Set the initial balance

    def deposit(self, amount):
        # Deposits a certain amount into the account, increasing the account balance, return the current account balance.
        # If amount is negative, raise a ValueError(""Invalid amount"").
        if amount < 0:  # Check if amount is negative
            raise ValueError(""Invalid amount"")
        self.balance += amount  # Increase the account balance
        return self.balance  # Return the current account balance

    def withdraw(self, amount):
        # Withdraws a certain amount from the account, decreasing the account balance, return the current account balance.
        # If amount is negative, raise a ValueError(""Invalid amount"").
        # If the withdrawal amount is greater than the account balance, raise a ValueError(""Insufficient balance."").
        if amount < 0:  # Check if amount is negative
            raise ValueError(""Invalid amount"")
        if amount > self.balance:  # Check if withdrawal amount is greater than the account balance
            raise ValueError(""Insufficient balance."")
        self.balance -= amount  # Decrease the account balance
        return self.balance  # Return the current account balance

    def view_balance(self):
        # Return the account balance.
        return self.balance  # Return the current account balance

    def transfer(self, other_account, amount):
        # Transfers a certain amount from the current account to another account.
        if amount < 0:  # Check if amount is negative
            raise ValueError(""Invalid amount"")
        if amount > self.balance:  # Check if transfer amount is greater than the account balance
            raise ValueError(""Insufficient balance."")
        self.balance -= amount  # Decrease the account balance
        other_account.balance += amount  # Increase the other account balance
        return self.balance  # Return the current account balance

# Example usage:
if __name__ == ""__main__"":
    account1 = BankAccount(1000)  # Create a bank account with initial balance 1000
    account2 = BankAccount(500)  # Create another bank account with initial balance 500
    
    print(""Account 1 initial balance:"", account1.view_balance())  # View account 1 balance
    print(""Account 2 initial balance:"", account2.view_balance())  # View account 2 balance
    
    account1.deposit(500)  # Deposit 500 into account 1
    print(""Account 1 balance after deposit:"", account1.view_balance())  # View account 1 balance
    
    account1.withdraw(200)  # Withdraw 200 from account 1
    print(""Account 1 balance after withdrawal:"", account1.view_balance())  # View account 1 balance
    
    account1.transfer(account2, 300)  # Transfer 300 from account 1 to account 2
    print(""Account 1 balance after transfer:"", account1.view_balance())  # View account 1 balance
    print(""Account 2 balance after transfer:"", account2.view_balance())  # View account 2 balance
```",0.06435643564356436,0.0757600810959807,0.9354838709677419,0.2543859649122807,0.39999999663828784,0.7777777777777778,0.16203703703703703,0.26819923086272957,0.9354838709677419,0.2543859649122807,0.39999999663828784
Llama,9,"class BigNumCalculator:
    @staticmethod
    def add(num1, num2):
        max_length = max(len(num1), len(num2))
        num1 = num1.zfill(max_length)
        num2 = num2.zfill(max_length)

        carry = 0
        result = []
        for i in range(max_length - 1, -1, -1):
            digit_sum = int(num1[i]) + int(num2[i]) + carry
            carry = digit_sum // 10
            digit = digit_sum % 10
            result.insert(0, str(digit))

        if carry > 0:
            result.insert(0, str(carry))

        return ''.join(result)

    @staticmethod
    def subtract(num1, num2):

        if len(num1) < len(num2):
            num1, num2 = num2, num1
            negative = True
        elif len(num1) > len(num2):
            negative = False
        else:
            if num1 < num2:
                num1, num2 = num2, num1
                negative = True
            else:
                negative = False

        max_length = max(len(num1), len(num2))
        num1 = num1.zfill(max_length)
        num2 = num2.zfill(max_length)

        borrow = 0
        result = []
        for i in range(max_length - 1, -1, -1):
            digit_diff = int(num1[i]) - int(num2[i]) - borrow

            if digit_diff < 0:
                digit_diff += 10
                borrow = 1
            else:
                borrow = 0

            result.insert(0, str(digit_diff))

        while len(result) > 1 and result[0] == '0':
            result.pop(0)

        if negative:
            result.insert(0, '-')

        return ''.join(result)

    @staticmethod
    def multiply(num1, num2):
        len1, len2 = len(num1), len(num2)
        result = [0] * (len1 + len2)

        for i in range(len1 - 1, -1, -1):
            for j in range(len2 - 1, -1, -1):
                mul = int(num1[i]) * int(num2[j])
                p1, p2 = i + j, i + j + 1
                total = mul + result[p2]

                result[p1] += total // 10
                result[p2] = total % 10

        start = 0
        while start < len(result) - 1 and result[start] == 0:
            start += 1

        return ''.join(map(str, result[start:]))",ZeroShot,"

```python
# This is a class that implements big number calculations, including adding, subtracting and multiplying.

class BigNumCalculator:
    @staticmethod
    def add(num1, num2):
        """"""
        Adds two big numbers.
        :return: The sum of the two numbers,str.
        """"""
        # Convert input numbers to integers, add them, and convert back to string
        return str(int(num1) + int(num2))

    @staticmethod
    def subtract(num1, num2):
        """"""
        Subtracts two big numbers.
        :return: The difference of the two numbers,str.
        """"""
        # Convert input numbers to integers, subtract them, and convert back to string
        # Check if num1 is greater than num2 to avoid negative result
        if int(num1) >= int(num2):
            return str(int(num1) - int(num2))
        else:
            return '-' + str(int(num2) - int(num1))

    @staticmethod
    def multiply(num1, num2):
        """"""
        Multiplies two big numbers.
        :return: The product of the two numbers,str.
        """"""
        # Convert input numbers to integers, multiply them, and convert back to string
        return str(int(num1) * int(num2))


# Example usage:
print(BigNumCalculator.add('12345678901234567890', '98765432109876543210'))
print(BigNumCalculator.subtract('12345678901234567890', '98765432109876543210'))
print(BigNumCalculator.multiply('12345678901234567890', '98765432109876543210'))
```",0.029807307606803255,0.0410165980019394,0.20652173913043478,0.24358974358974358,0.22352940679861602,0.053475935828877004,0.09174311926605505,0.06756756291476475,0.18478260869565216,0.21794871794871795,0.19999999503391014
Llama,10,"class BinaryDataProcessor:
    def __init__(self, binary_string):
        self.binary_string = binary_string
        self.clean_non_binary_chars()

    def clean_non_binary_chars(self):
        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))

    def calculate_binary_info(self):
        zeroes_count = self.binary_string.count('0')
        ones_count = self.binary_string.count('1')
        total_length = len(self.binary_string)

        zeroes_percentage = (zeroes_count / total_length)
        ones_percentage = (ones_count / total_length)

        return {
            'Zeroes': zeroes_percentage,
            'Ones': ones_percentage,
            'Bit length': total_length
        }

    def convert_to_ascii(self):
        byte_array = bytearray()
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            decimal = int(byte, 2)
            byte_array.append(decimal)

        return byte_array.decode('ascii')

    def convert_to_utf8(self):
        byte_array = bytearray()
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            decimal = int(byte, 2)
            byte_array.append(decimal)

        return byte_array.decode('utf-8')",ZeroShot,"

```python
class BinaryDataProcessor:
    def __init__(self, binary_string):
        # Clean the binary string by removing all non 0 or 1 characters
        self.binary_string = self.clean_non_binary_chars(binary_string)

    def clean_non_binary_chars(self, binary_string):
        # Use a list comprehension to filter out non 0 or 1 characters
        return ''.join([char for char in binary_string if char in '01'])

    def calculate_binary_info(self):
        # Calculate the total length of the binary string
        total_length = len(self.binary_string)
        
        # Calculate the percentage of 0 and 1 in the binary string
        zero_percentage = (self.binary_string.count('0') / total_length) * 100 if total_length > 0 else 0
        one_percentage = (self.binary_string.count('1') / total_length) * 100 if total_length > 0 else 0
        
        # Return the binary string information as a dictionary
        return {
            'total_length': total_length,
            'zero_percentage': zero_percentage,
            'one_percentage': one_percentage
        }

    def convert_to_ascii(self):
        # Split the binary string into 8-bit chunks
        binary_chunks = [self.binary_string[i:i+8] for i in range(0, len(self.binary_string), 8)]
        
        # Convert each binary chunk to an ASCII character
        ascii_string = ''
        for chunk in binary_chunks:
            if len(chunk) < 8:
                break  # Ignore incomplete chunks
            ascii_char = chr(int(chunk, 2))
            ascii_string += ascii_char
        
        # Return the ASCII string
        return ascii_string

    def convert_to_utf8(self):
        # Split the binary string into 8-bit chunks
        binary_chunks = [self.binary_string[i:i+8] for i in range(0, len(self.binary_string), 8)]
        
        # Convert each binary chunk to a UTF-8 character
        utf8_string = ''
        for chunk in binary_chunks:
            if len(chunk) < 8:
                break  # Ignore incomplete chunks
            utf8_char = chr(int(chunk, 2))
            utf8_string += utf8_char
        
        # Return the UTF-8 string
        return utf8_string

# Example usage:
binary_data = BinaryDataProcessor('10101010')
print(binary_data.calculate_binary_info())
print(binary_data.convert_to_ascii())
print(binary_data.convert_to_utf8())
```",0.04545454545454546,0.06700309072058727,0.49122807017543857,0.24561403508771928,0.3274853756725146,0.2962962962962963,0.12903225806451613,0.17977527667213747,0.47368421052631576,0.23684210526315788,0.3157894692397661
Llama,11,"class BitStatusUtil:
    @staticmethod
    def add(states, stat):
        BitStatusUtil.check([states, stat])
        return states | stat

    @staticmethod
    def has(states, stat):
        BitStatusUtil.check([states, stat])
        return (states & stat) == stat

    @staticmethod
    def remove(states, stat):
        BitStatusUtil.check([states, stat])
        if BitStatusUtil.has(states, stat):
            return states ^ stat
        return states

    @staticmethod
    def check(args):
        for arg in args:
            if arg < 0:
                raise ValueError(f""{arg} must be greater than or equal to 0"")
            if arg % 2 != 0:
                raise ValueError(f""{arg} not even"")",ZeroShot,"

```python
# This is a utility class that provides methods for manipulating and checking status using bitwise operations.

class BitStatusUtil:
    @staticmethod
    def add(states, stat):
        # Check if the parameters are legal
        BitStatusUtil.check(states)
        BitStatusUtil.check(stat)
        
        # Add a status to the current status using bitwise OR operation
        return states | stat

    @staticmethod
    def has(states, stat):
        # Check if the parameters are legal
        BitStatusUtil.check(states)
        BitStatusUtil.check(stat)
        
        # Check if the current status contains the specified status using bitwise AND operation
        return (states & stat) == stat

    @staticmethod
    def remove(states, stat):
        # Check if the parameters are legal
        BitStatusUtil.check(states)
        BitStatusUtil.check(stat)
        
        # Remove the specified status from the current status using bitwise AND and NOT operations
        return states & (~stat)

    @staticmethod
    def check(args):
        # Check if the parameter is greater than or equal to 0
        if args < 0:
            raise ValueError(""Parameter must be greater than or equal to 0"")
        
        # Check if the parameter is even
        if args % 2 != 0:
            raise ValueError(""Parameter must be even"")
```",0.18125,0.20536839187020914,0.813953488372093,0.4666666666666667,0.5932203343507614,0.5535714285714286,0.2980769230769231,0.38749999544999997,0.813953488372093,0.4666666666666667,0.5932203343507614
Llama,12,"import random


class BlackjackGame:
    def __init__(self):
        self.deck = self.create_deck()
        self.player_hand = []
        self.dealer_hand = []

    def create_deck(self):
        deck = []
        suits = ['S', 'C', 'D', 'H']
        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
        for suit in suits:
            for rank in ranks:
                deck.append(rank + suit)
        random.shuffle(deck)
        return deck

    def calculate_hand_value(self, hand):
        value = 0
        num_aces = 0
        for card in hand:
            rank = card[:-1]
            if rank.isdigit():
                value += int(rank)
            elif rank in ['J', 'Q', 'K']:
                value += 10
            elif rank == 'A':
                value += 11
                num_aces += 1
        while value > 21 and num_aces > 0:
            value -= 10
            num_aces -= 1
        return value

    def check_winner(self, player_hand, dealer_hand):
        player_value = self.calculate_hand_value(player_hand)
        dealer_value = self.calculate_hand_value(dealer_hand)
        if player_value > 21 and dealer_value > 21:
            if player_value <= dealer_value:
                return 'Player wins'
            else:
                return 'Dealer wins'
        elif player_value > 21:
            return 'Dealer wins'
        elif dealer_value > 21:
            return 'Player wins'
        else:
            if player_value <= dealer_value:
                return 'Dealer wins'
            else:
                return 'Player wins'",ZeroShot,"

```python
import random

class BlackjackGame:
    def __init__(self):
        # Initialize the deck, player's hand, and dealer's hand
        self.deck = self.create_deck()
        self.player_hand = []
        self.dealer_hand = []

    def create_deck(self):
        # Create a list of suits and ranks
        suits = ['S', 'H', 'D', 'C']
        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
        
        # Use list comprehension to generate the deck
        deck = [rank + suit for suit in suits for rank in ranks]
        
        # Shuffle the deck to randomize the order
        random.shuffle(deck)
        
        return deck

    def calculate_hand_value(self, hand):
        # Initialize the total value and the number of Aces
        total_value = 0
        num_aces = 0
        
        # Iterate over each card in the hand
        for card in hand:
            # Get the rank of the card
            rank = card[0]
            
            # Check if the card is an Ace
            if rank == 'A':
                # Increment the number of Aces
                num_aces += 1
                # Add 11 to the total value (Ace is worth 11 initially)
                total_value += 11
            # Check if the card is a face card (J, Q, K)
            elif rank in ['J', 'Q', 'K']:
                # Add 10 to the total value (face cards are worth 10)
                total_value += 10
            # If the card is a number card, add its value to the total
            else:
                # Convert the rank to an integer and add it to the total value
                total_value += int(rank)
        
        # If the total value exceeds 21 and there are Aces, reduce the value of Aces
        while total_value > 21 and num_aces:
            # Subtract 10 from the total value (treating an Ace as 1 instead of 11)
            total_value -= 10
            # Decrement the number of Aces
            num_aces -= 1
        
        return total_value

    def check_winner(self, player_hand, dealer_hand):
        # Calculate the hand values of the player and dealer
        player_value = self.calculate_hand_value(player_hand)
        dealer_value = self.calculate_hand_value(dealer_hand)
        
        # Check if both players have hand values that are equal to or less than 21
        if player_value <= 21 and dealer_value <= 21:
            # The winner is the one whose hand value is closer to 21
            if player_value > dealer_value:
                return ""Player wins""
            elif player_value < dealer_value:
                return ""Dealer wins""
            else:
                return ""It's a tie""
        # If one or both players have hand values that exceed 21, the winner is the one with the lower hand value
        else:
            if player_value > 21 and dealer_value > 21:
                if player_value < dealer_value:
                    return ""Player wins""
                elif player_value > dealer_value:
                    return ""Dealer wins""
                else:
                    return ""It's a tie""
            elif player_value > 21:
                return ""Dealer wins""
            else:
                return ""Player wins""

# Example usage:
game = BlackjackGame()
game.player_hand = ['AS', '8S']
game.dealer_hand = ['10D', '5C']
print(game.calculate_hand_value(game.player_hand))  # Output: 19
print(game.calculate_hand_value(game.dealer_hand))  # Output: 15
print(game.check_winner(game.player_hand, game.dealer_hand))  # Output: Player wins
```",0.14831460674157307,0.1798846111687857,0.8571428571428571,0.3850267379679144,0.531365309375417,0.6357142857142857,0.2507042253521127,0.35959595553923074,0.7857142857142857,0.35294117647058826,0.48708486657098904
Llama,13,"class BookManagement:
    def __init__(self):
        self.inventory = {}

    def add_book(self, title, quantity=1):
        if title in self.inventory:
            self.inventory[title] += quantity
        else:
            self.inventory[title] = quantity

    def remove_book(self, title, quantity):
        if title not in self.inventory or self.inventory[title] < quantity:
            raise False
        self.inventory[title] -= quantity
        if self.inventory[title] == 0:
            del (self.inventory[title])

    def view_inventory(self):
        return self.inventory

    def view_book_quantity(self, title):
        if title not in self.inventory:
            return 0
        return self.inventory[title]",ZeroShot,"

```python
class BookManagement:
    def __init__(self):
        # Initialize an empty dictionary to store the inventory
        self.inventory = {}

    def add_book(self, title, quantity=1):
        # Check if the quantity is a positive integer
        if not isinstance(quantity, int) or quantity <= 0:
            raise ValueError(""Invalid quantity. Quantity must be a positive integer."")
        
        # If the book is already in the inventory, increment its quantity
        if title in self.inventory:
            self.inventory[title] += quantity
        # If the book is not in the inventory, add it with the given quantity
        else:
            self.inventory[title] = quantity

        # Sort the inventory by book title
        self.inventory = dict(sorted(self.inventory.items()))

    def remove_book(self, title, quantity):
        # Check if the quantity is a positive integer
        if not isinstance(quantity, int) or quantity <= 0:
            raise ValueError(""Invalid quantity. Quantity must be a positive integer."")
        
        # Check if the book is in the inventory
        if title not in self.inventory:
            raise ValueError(""Book not found in inventory."")
        
        # Check if the quantity to remove is not more than the available quantity
        if quantity > self.inventory[title]:
            raise ValueError(""Not enough quantity to remove."")
        
        # Decrement the quantity of the book
        self.inventory[title] -= quantity
        
        # If the quantity of the book becomes zero, remove it from the inventory
        if self.inventory[title] == 0:
            del self.inventory[title]

    def view_inventory(self):
        # Return the current inventory
        return self.inventory

    def view_book_quantity(self, title):
        # Return the quantity of the book if it exists in the inventory, otherwise return 0
        return self.inventory.get(title, 0)
```",0.12227074235807861,0.14354721660385464,0.868421052631579,0.3626373626373626,0.511627902820744,0.7068965517241379,0.25153374233128833,0.3710407201105629,0.868421052631579,0.3626373626373626,0.511627902820744
Llama,14,"import sqlite3

class BookManagementDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS books (
                id INTEGER PRIMARY KEY,
                title TEXT,
                author TEXT,
                available INTEGER
            )
        ''')
        self.connection.commit()

    def add_book(self, title, author):
        self.cursor.execute('''
            INSERT INTO books (title, author, available)
            VALUES (?, ?, 1)
        ''', (title, author))
        self.connection.commit()

    def remove_book(self, book_id):
        self.cursor.execute('''
            DELETE FROM books WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def borrow_book(self, book_id):
        self.cursor.execute('''
            UPDATE books SET available = 0 WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def return_book(self, book_id):
        self.cursor.execute('''
            UPDATE books SET available = 1 WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def search_books(self):
        self.cursor.execute('''
            SELECT * FROM books
        ''')
        books = self.cursor.fetchall()
        return books",ZeroShot,"

```python
import sqlite3

class BookManagementDB:

    def __init__(self, db_name):
        # Create a database connection
        self.conn = sqlite3.connect(db_name)
        # Create a cursor object
        self.cursor = self.conn.cursor()
        # Create the book table if it does not already exist
        self.create_table()

    def create_table(self):
        # SQL query to create the book table
        query = """"""
            CREATE TABLE IF NOT EXISTS books (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                author TEXT NOT NULL,
                available INTEGER DEFAULT 1
            )
        """"""
        # Execute the query
        self.cursor.execute(query)
        # Commit the changes
        self.conn.commit()

    def add_book(self, title, author):
        # SQL query to insert a new book into the table
        query = """"""
            INSERT INTO books (title, author)
            VALUES (?, ?)
        """"""
        # Execute the query with the provided title and author
        self.cursor.execute(query, (title, author))
        # Commit the changes
        self.conn.commit()

    def remove_book(self, book_id):
        # SQL query to delete a book from the table based on the book ID
        query = """"""
            DELETE FROM books
            WHERE id = ?
        """"""
        # Execute the query with the provided book ID
        self.cursor.execute(query, (book_id,))
        # Commit the changes
        self.conn.commit()

    def borrow_book(self, book_id):
        # SQL query to update the availability of a book to 0 (borrowed)
        query = """"""
            UPDATE books
            SET available = 0
            WHERE id = ? AND available = 1
        """"""
        # Execute the query with the provided book ID
        self.cursor.execute(query, (book_id,))
        # Commit the changes
        self.conn.commit()

    def return_book(self, book_id):
        # SQL query to update the availability of a book to 1 (available)
        query = """"""
            UPDATE books
            SET available = 1
            WHERE id = ? AND available = 0
        """"""
        # Execute the query with the provided book ID
        self.cursor.execute(query, (book_id,))
        # Commit the changes
        self.conn.commit()

    def search_books(self):
        # SQL query to select all books from the table
        query = """"""
            SELECT *
            FROM books
        """"""
        # Execute the query
        self.cursor.execute(query)
        # Fetch all the rows from the query
        books = self.cursor.fetchall()
        # Return the list of books
        return books

# Example usage:
if __name__ == ""__main__"":
    db = BookManagementDB(""book_management.db"")
    db.add_book(""To Kill a Mockingbird"", ""Harper Lee"")
    db.add_book(""1984"", ""George Orwell"")
    print(db.search_books())
    db.borrow_book(1)
    print(db.search_books())
    db.return_book(1)
    print(db.search_books())
    db.remove_book(2)
    print(db.search_books())
```",0.1308139534883721,0.15681672191099263,0.8636363636363636,0.4222222222222222,0.5671641746936958,0.5959595959595959,0.25877192982456143,0.36085626489128303,0.8636363636363636,0.4222222222222222,0.5671641746936958
Llama,15,"class BoyerMooreSearch:
    def __init__(self, text, pattern):
        self.text, self.pattern = text, pattern
        self.textLen, self.patLen = len(text), len(pattern)

    def match_in_pattern(self, char):
        for i in range(self.patLen - 1, -1, -1):
            if char == self.pattern[i]:
                return i
        return -1

    def mismatch_in_text(self, currentPos):
        for i in range(self.patLen - 1, -1, -1):
            if self.pattern[i] != self.text[currentPos + i]:
                return currentPos + i
        return -1

    def bad_character_heuristic(self):
        positions = []
        for i in range(self.textLen - self.patLen + 1):
            mismatch_index = self.mismatch_in_text(i)
            if mismatch_index == -1:
                positions.append(i)
            else:
                match_index = self.match_in_pattern(self.text[mismatch_index])
                i = (mismatch_index - match_index)
        return positions",ZeroShot,"

```python
class BoyerMooreSearch:
    def __init__(self, text, pattern):
        # Initialize the text and pattern
        self.text = text
        self.pattern = pattern
        # Create a dictionary to store the last occurrence of each character in the pattern
        self.last_occurrence = {}
        for i in range(len(self.pattern)):
            self.last_occurrence[self.pattern[i]] = i

    def match_in_pattern(self, char):
        # Find the rightmost occurrence of a character in the pattern
        # Return -1 if the character is not found in the pattern
        return self.last_occurrence.get(char, -1)

    def mismatch_in_text(self, currentPos):
        # Compare the pattern with the text starting from the current position
        for i in range(len(self.pattern)):
            # If the characters do not match, return the position of the mismatch
            if currentPos + i >= len(self.text) or self.text[currentPos + i] != self.pattern[i]:
                return currentPos + i
        # If the entire pattern matches, return -1
        return -1

    def bad_character_heuristic(self):
        # Initialize a list to store the positions of the pattern in the text
        positions = []
        # Initialize the current position in the text
        currentPos = 0
        while currentPos <= len(self.text) - len(self.pattern):
            # Find the position of the first mismatch between the pattern and the text
            mismatchPos = self.mismatch_in_text(currentPos)
            # If the pattern matches the text at the current position, add the position to the list
            if mismatchPos == -1:
                positions.append(currentPos)
                # Move the current position to the right of the match
                currentPos += len(self.pattern)
            else:
                # Move the current position based on the bad character heuristic
                char = self.text[mismatchPos]
                shift = max(1, mismatchPos - self.match_in_pattern(char))
                currentPos += shift
        return positions
```",0.053061224489795916,0.0727577542859246,0.6153846153846154,0.29906542056074764,0.4025157188687156,0.367816091954023,0.1553398058252427,0.21843002995445499,0.6153846153846154,0.29906542056074764,0.4025157188687156
Llama,16,"class Calculator:
    def __init__(self):
        self.operators = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '/': lambda x, y: x / y,
            '^': lambda x, y: x ** y
        }

    def calculate(self, expression):
        operand_stack = []
        operator_stack = []
        num_buffer = ''

        for char in expression:
            if char.isdigit() or char == '.':
                num_buffer += char
            else:
                if num_buffer:
                    operand_stack.append(float(num_buffer))
                    num_buffer = ''

                if char in '+-*/^':
                    while (
                            operator_stack and
                            operator_stack[-1] != '(' and
                            self.precedence(operator_stack[-1]) >= self.precedence(char)
                    ):
                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

                    operator_stack.append(char)
                elif char == '(':
                    operator_stack.append(char)
                elif char == ')':
                    while operator_stack and operator_stack[-1] != '(':
                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

                    operator_stack.pop()

        if num_buffer:
            operand_stack.append(float(num_buffer))

        while operator_stack:
            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

        return operand_stack[-1] if operand_stack else None

    def precedence(self, operator):
        precedences = {
            '+': 1,
            '-': 1,
            '*': 2,
            '/': 2,
            '^': 3
        }
        return precedences.get(operator, 0)

    def apply_operator(self, operand_stack, operator_stack):
        operator = operator_stack.pop()
        if operator == '^':
            operand2 = operand_stack.pop()
            operand1 = operand_stack.pop()
            result = self.operators[operator](operand1, operand2)
            operand_stack.append(result)
        else:
            operand2 = operand_stack.pop()
            operand1 = operand_stack.pop()
            result = self.operators[operator](operand1, operand2)
            operand_stack.append(result)
        return operand_stack, operator_stack",ZeroShot,"

```python
# This is a class for a calculator, capable of performing basic arithmetic calculations on numerical expressions using the operators +, -, *, /, and ^ (exponentiation).
class Calculator:
    def __init__(self):
        # Initialize the operations performed by the five operators'+','-','*','/','^'
        self.operators = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '/': lambda x, y: x / y if y != 0 else float('inf'),
            '^': lambda x, y: x ** y
        }

    def calculate(self, expression):
        # Split the expression into tokens (numbers and operators)
        tokens = self.tokenize(expression)
        
        # Initialize the operand stack and operator stack
        operand_stack = []
        operator_stack = []
        
        # Iterate over each token in the expression
        for token in tokens:
            # If the token is a number, push it onto the operand stack
            if token.replace('.', '', 1).isdigit():
                operand_stack.append(float(token))
            # If the token is an operator, apply the operators with higher or equal precedence
            elif token in self.operators:
                while (operator_stack and 
                       self.precedence(operator_stack[-1]) >= self.precedence(token)):
                    operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)
                operator_stack.append(token)
        
        # Apply any remaining operators
        while operator_stack:
            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)
        
        # Return the final result
        return operand_stack[0] if operand_stack else None

    def precedence(self, operator):
        # Returns the priority of the specified operator
        precedence_map = {
            '+': 1,
            '-': 1,
            '*': 2,
            '/': 2,
            '^': 3
        }
        return precedence_map.get(operator, 0)

    def apply_operator(self, operand_stack, operator_stack):
        # Use the operator at the top of the operator stack to perform the operation on the two numbers at the top of the operator stack
        operator = operator_stack.pop()
        operand2 = operand_stack.pop()
        operand1 = operand_stack.pop()
        result = self.operators[operator](operand1, operand2)
        operand_stack.append(result)
        return operand_stack, operator_stack

    def tokenize(self, expression):
        # Split the expression into tokens (numbers and operators)
        tokens = []
        current_token = ''
        for char in expression:
            if char.isspace():
                continue
            if char in self.operators:
                if current_token:
                    tokens.append(current_token)
                    current_token = ''
                tokens.append(char)
            else:
                current_token += char
        if current_token:
            tokens.append(current_token)
        return tokens
```",0.2861635220125786,0.31665910831748795,0.8045977011494253,0.43209876543209874,0.5622489914375575,0.609271523178808,0.336996336996337,0.43396225956490303,0.8045977011494253,0.43209876543209874,0.5622489914375575
Llama,17,"from datetime import datetime, timedelta

class CalendarUtil:
    def __init__(self):
        self.events = []

    def add_event(self, event):
        self.events.append(event)

    def remove_event(self, event):
        if event in self.events:
            self.events.remove(event)

    def get_events(self, date):
        events_on_date = []
        for event in self.events:
            if event['date'].date() == date.date():
                events_on_date.append(event)
        return events_on_date

    def is_available(self, start_time, end_time):
        for event in self.events:
            if start_time < event['end_time'] and end_time > event['start_time']:
                return False
        return True

    def get_available_slots(self, date):
        available_slots = []
        start_time = datetime(date.year, date.month, date.day, 0, 0)
        end_time = datetime(date.year, date.month, date.day, 23, 59)

        while start_time < end_time:
            slot_end_time = start_time + timedelta(minutes=60)
            if self.is_available(start_time, slot_end_time):
                available_slots.append((start_time, slot_end_time))
            start_time += timedelta(minutes=60)


        return available_slots

    def get_upcoming_events(self, num_events):
        now = datetime.now()
        upcoming_events = []
        for event in self.events:
            if event['start_time'] >= now:
                upcoming_events.append(event)
            if len(upcoming_events) == num_events:
                break
        return upcoming_events",ZeroShot,"

```python
from datetime import datetime, timedelta

class CalendarUtil:
    def __init__(self):
        # Initialize the calendar with an empty list of events
        self.events = []

    def add_event(self, event):
        # Add an event to the calendar
        # Event should be a dictionary with 'start_time', 'end_time', and 'date' keys
        self.events.append(event)

    def remove_event(self, event):
        # Remove an event from the calendar
        # Event should be a dictionary with 'start_time', 'end_time', and 'date' keys
        self.events = [e for e in self.events if e != event]

    def get_events(self, date):
        # Get all events on a given date
        # Date should be a datetime object
        return [event for event in self.events if event['date'] == date.date()]

    def is_available(self, start_time, end_time):
        # Check if the calendar is available for a given time slot
        # Start_time and end_time should be datetime objects
        for event in self.events:
            if (start_time >= event['start_time'] and start_time < event['end_time']) or \
               (end_time > event['start_time'] and end_time <= event['end_time']) or \
               (start_time <= event['start_time'] and end_time >= event['end_time']):
                return False
        return True

    def get_available_slots(self, date):
        # Get all available time slots on a given date
        # Date should be a datetime object
        available_slots = []
        start_time = datetime.combine(date, datetime.min.time())
        end_time = datetime.combine(date, datetime.min.time()) + timedelta(minutes=30)
        while end_time <= datetime.combine(date, datetime.max.time()):
            if self.is_available(start_time, end_time):
                available_slots.append((start_time, end_time))
            start_time += timedelta(minutes=30)
            end_time += timedelta(minutes=30)
        return available_slots

    def get_upcoming_events(self, num_events):
        # Get the next n upcoming events from a given date
        # Date should be a datetime object
        upcoming_events = sorted(self.events, key=lambda x: x['start_time'])
        return upcoming_events[:num_events]

# Example usage:
calendar = CalendarUtil()
event1 = {'start_time': datetime(2024, 9, 16, 10), 'end_time': datetime(2024, 9, 16, 11), 'date': datetime(2024, 9, 16).date()}
event2 = {'start_time': datetime(2024, 9, 16, 12), 'end_time': datetime(2024, 9, 16, 13), 'date': datetime(2024, 9, 16).date()}
calendar.add_event(event1)
calendar.add_event(event2)
print(calendar.get_events(datetime(2024, 9, 16).date()))
print(calendar.is_available(datetime(2024, 9, 16, 11), datetime(2024, 9, 16, 12)))
print(calendar.get_available_slots(datetime(2024, 9, 16).date()))
print(calendar.get_upcoming_events(2))
```",0.10367892976588629,0.13288604440319204,0.6666666666666666,0.352112676056338,0.4608294885642083,0.43333333333333335,0.21940928270042195,0.29131652214768267,0.64,0.3380281690140845,0.44239630884070597
Llama,18,"class CamelCaseMap:
    def __init__(self):
        self._data = {}

    def __getitem__(self, key):
        return self._data[self._convert_key(key)]

    def __setitem__(self, key, value):
        self._data[self._convert_key(key)] = value

    def __delitem__(self, key):
        del self._data[self._convert_key(key)]

    def __iter__(self):
        return iter(self._data)

    def __len__(self):
        return len(self._data)

    def _convert_key(self, key):
        if isinstance(key, str):
            return self._to_camel_case(key)
        return key

    @staticmethod
    def _to_camel_case(key):
        parts = key.split('_')
        return parts[0] + ''.join(part.title() for part in parts[1:])",ZeroShot,"

```python
# This is a custom class that allows keys to be in camel case style by converting them from underscore style, 
# which provides dictionary-like functionality.

class CamelCaseMap:
    def __init__(self):
        # Initialize data to an empty dictionary
        self.data = {}

    def __getitem__(self, key):
        # Convert key to camel case and return the value corresponding to the key
        return self.data[self._convert_key(key)]

    def __setitem__(self, key, value):
        # Convert key to camel case and set the value corresponding to the key to the specified value
        self.data[self._convert_key(key)] = value

    def __delitem__(self, key):
        # Convert key to camel case and delete the value corresponding to the key
        del self.data[self._convert_key(key)]

    def __iter__(self):
        # Returning Iterateable Objects with Own Data
        return iter(self.data)

    def __len__(self):
        # Returns the length of the own data
        return len(self.data)

    def _convert_key(self, key):
        # Convert key string into camel case
        return self._to_camel_case(key)

    @staticmethod
    def _to_camel_case(key):
        # Split key by underscore and capitalize the first letter of each word except the first word
        words = key.split('_')
        # Capitalize the first letter of each word except the first word
        camel_case_key = words[0] + ''.join(word.capitalize() for word in words[1:])
        return camel_case_key

# Example usage
if __name__ == ""__main__"":
    camel_case_map = CamelCaseMap()
    camel_case_map['hello_world'] = 'Hello World'
    print(camel_case_map['hello_world'])  # Outputs: Hello World
    print(len(camel_case_map))  # Outputs: 1
    for key in camel_case_map:
        print(key)  # Outputs: helloWorld
    del camel_case_map['hello_world']
    print(len(camel_case_map))  # Outputs: 0
```",0.054298642533936646,0.07293528934541156,0.7441860465116279,0.27350427350427353,0.3999999960695314,0.4918032786885246,0.16304347826086957,0.24489795544389842,0.7209302325581395,0.26495726495726496,0.3874999960695313
Llama,19,"class ChandrasekharSieve:
    def __init__(self, n):
        self.n = n
        self.primes = self.generate_primes()

    def generate_primes(self):
        if self.n < 2:
            return []

        sieve = [True] * (self.n + 1)
        sieve[0] = sieve[1] = False

        p = 2
        while p * p <= self.n:
            if sieve[p]:
                for i in range(p * p, self.n + 1, p):
                    sieve[i] = False
            p += 1

        primes = []
        for i in range(2, self.n + 1):
            if sieve[i]:
                primes.append(i)

        return primes

    def get_primes(self):
        return self.primes",ZeroShot,"

```python
class ChandrasekharSieve:
    def __init__(self, n):
        # Initialize the limit and a boolean array, prime, of size n+1
        self.n = n
        self.prime = [True] * (n + 1)
        # 0 and 1 are not prime numbers
        self.prime[0] = self.prime[1] = False

    def generate_primes(self):
        # Iterate from 2 to sqrt(n)
        for p in range(2, int(self.n ** 0.5) + 1):
            # If p is a prime, mark as composite all the multiples of p
            if self.prime[p]:
                # Start from p*p because all the multiples of p less than p*p have already been marked
                for i in range(p * p, self.n + 1, p):
                    self.prime[i] = False

    def get_primes(self):
        # Return a list of all prime numbers in the range [2, n]
        return [p for p in range(2, self.n + 1) if self.prime[p]]

# Example usage
if __name__ == ""__main__"":
    sieve = ChandrasekharSieve(30)
    sieve.generate_primes()
    print(sieve.get_primes())
```",0.10638297872340424,0.1499213120549155,0.6739130434782609,0.3333333333333333,0.4460431610392837,0.38666666666666666,0.20714285714285716,0.26976743731746894,0.6739130434782609,0.3333333333333333,0.4460431610392837
Llama,20,"from datetime import datetime

class Chat:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username in self.users:
            return False
        else:
            self.users[username] = []
            return True

    def remove_user(self, username):
        if username in self.users:
            del self.users[username]
            return True
        else:
            return False

    def send_message(self, sender, receiver, message):
        if sender not in self.users or receiver not in self.users:
            return False

        timestamp = datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
        message_info = {
            'sender': sender,
            'receiver': receiver,
            'message': message,
            'timestamp': timestamp
        }
        self.users[sender].append(message_info)
        self.users[receiver].append(message_info)
        return True

    def get_messages(self, username):
        if username not in self.users:
            return []
        return self.users[username]",ZeroShot,"

```python
# This is a chat class with the functions of adding users, removing users, sending messages, and obtaining messages.

from datetime import datetime

class Chat:
    def __init__(self):
        # Initialize the Chat with an attribute users, which is an empty dictionary.
        self.users = {}
        # Initialize the messages attribute, which is an empty dictionary.
        self.messages = {}

    def add_user(self, username):
        # Add a new user to the Chat.
        # If the user is already in the Chat, returns False, otherwise, returns True.
        if username in self.users:
            return False
        else:
            self.users[username] = []
            self.messages[username] = []
            return True

    def remove_user(self, username):
        # Remove a user from the Chat.
        # If the user is already in the Chat, returns True, otherwise, returns False.
        if username in self.users:
            del self.users[username]
            del self.messages[username]
            # Remove messages sent to or from the removed user
            for user in self.messages:
                self.messages[user] = [message for message in self.messages[user] if message['sender'] != username and message['receiver'] != username]
            return True
        else:
            return False

    def send_message(self, sender, receiver, message):
        # Send a message from a user to another user.
        # If the sender or the receiver is not in the Chat, returns False, otherwise, returns True.
        if sender in self.users and receiver in self.users:
            # Create a new message dictionary with the sender, receiver, message, and timestamp.
            new_message = {
                'sender': sender,
                'receiver': receiver,
                'message': message,
                'timestamp': datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
            }
            # Add the new message to the messages list of the receiver.
            self.messages[receiver].append(new_message)
            return True
        else:
            return False

    def get_messages(self, username):
        # Get all the messages of a user from the Chat.
        # Returns a list of messages, each message is a dictionary with keys 'sender', 'receiver', 'message', 'timestamp'.
        if username in self.messages:
            return self.messages[username]
        else:
            return []
```",0.15034965034965034,0.17889616199996128,0.9183673469387755,0.4017857142857143,0.5590062069457198,0.7051282051282052,0.24553571428571427,0.36423840676461555,0.9183673469387755,0.4017857142857143,0.5590062069457198
Llama,21,"from datetime import datetime


class Classroom:
    def __init__(self, id):
        self.id = id
        self.courses = []

    def add_course(self, course):

        if course not in self.courses:
            self.courses.append(course)

    def remove_course(self, course):
        if course in self.courses:
            self.courses.remove(course)

    def is_free_at(self, check_time):
        check_time = datetime.strptime(check_time, '%H:%M')

        for course in self.courses:
            if datetime.strptime(course['start_time'], '%H:%M') <= check_time <= datetime.strptime(course['end_time'],
                                                                                                   '%H:%M'):
                return False
        return True

    def check_course_conflict(self, new_course):
        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M')
        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M')

        flag = True
        for course in self.courses:
            start_time = datetime.strptime(course['start_time'], '%H:%M')
            end_time = datetime.strptime(course['end_time'], '%H:%M')
            if start_time <= new_start_time and end_time >= new_start_time:
                flag = False
            if start_time <= new_end_time and end_time >= new_end_time:
                flag = False
        return flag",ZeroShot,"

```python
class ClassRegistrationSystem:
    def __init__(self):
        # Initialize the registration system with the attribute students and students_registration_class.
        self.students = []  # list of student dictionaries
        self.students_registration_class = {}  # dictionary, key is the student name, value is a list of class names

    def register_student(self, student):
        # register a student to the system, add the student to the students list, if the student is already registered, return 0, else return 1
        if student in self.students:
            return 0  # student already registered
        else:
            self.students.append(student)
            self.students_registration_class[student['name']] = []  # initialize empty class list for the student
            return 1  # student registered successfully

    def register_class(self, student_name, class_name):
        # register a class to the student.
        if student_name in self.students_registration_class:
            self.students_registration_class[student_name].append(class_name)  # add class to the student's class list
        return self.students_registration_class[student_name]  # return a list of class names that the student has registered

    def get_students_by_major(self, major):
        # get all students in the major
        students_in_major = [student['name'] for student in self.students if student['major'] == major]
        return students_in_major  # return a list of student name

    def get_all_major(self):
        # get all majors in the system
        all_majors = list(set([student['major'] for student in self.students]))
        return all_majors  # return a list of majors

    def get_most_popular_class_in_major(self, major):
        # get the class with the highest enrollment in the major.
        students_in_major = self.get_students_by_major(major)
        class_enrollments = {}
        for student in students_in_major:
            classes = self.students_registration_class[student]
            for class_name in classes:
                if class_name in class_enrollments:
                    class_enrollments[class_name] += 1
                else:
                    class_enrollments[class_name] = 1
        if class_enrollments:
            most_popular_class = max(class_enrollments, key=class_enrollments.get)
            return most_popular_class  # return a string of the most popular class in this major
        else:
            return None  # return None if no classes are registered in the major


class Classroom:
    def __init__(self, class_name, capacity):
        # Initialize the classroom with the attribute class_name and capacity.
        self.class_name = class_name
        self.capacity = capacity
        self.enrolled_students = []  # list to keep track of enrolled students

    def enroll_student(self, student_name):
        # enroll a student in the class.
        if len(self.enrolled_students) < self.capacity:
            self.enrolled_students.append(student_name)
            return True  # student enrolled successfully
        else:
            return False  # class is full

    def get_enrolled_students(self):
        # get all students enrolled in the class.
        return self.enrolled_students  # return a list of student names

    def get_class_name(self):
        # get the name of the class.
        return self.class_name  # return a string of the class name

    def get_capacity(self):
        # get the capacity of the class.
        return self.capacity  # return an integer of the class capacity


# Example usage:
if __name__ == ""__main__"":
    registration_system = ClassRegistrationSystem()
    student1 = {'name': 'John', 'major': 'CS'}
    student2 = {'name': 'Alice', 'major': 'CS'}
    student3 = {'name': 'Bob', 'major': 'Math'}

    registration_system.register_student(student1)
    registration_system.register_student(student2)
    registration_system.register_student(student3)

    registration_system.register_class('John', 'Data Structures')
    registration_system.register_class('John', 'Algorithms')
    registration_system.register_class('Alice', 'Data Structures')
    registration_system.register_class('Bob', 'Linear Algebra')

    print(registration_system.get_students_by_major('CS'))  # Output: ['John', 'Alice']
    print(registration_system.get_all_major())  # Output: ['CS', 'Math']
    print(registration_system.get_most_popular_class_in_major('CS'))  # Output: 'Data Structures'

    classroom = Classroom('Data Structures', 10)
    print(classroom.enroll_student('John'))  # Output: True
    print(classroom.enroll_student('Alice'))  # Output: True
    print(classroom.get_enrolled_students())  # Output: ['John', 'Alice']
    print(classroom.get_class_name())  # Output: 'Data Structures'
    print(classroom.get_capacity())  # Output: 10
```",0.004282655246252676,0.009884639556951723,0.2857142857142857,0.0782122905027933,0.12280701416935988,0.07608695652173914,0.01871657754010695,0.030042915285969873,0.2653061224489796,0.07262569832402235,0.1140350843447985
Llama,22,"class ClassRegistrationSystem:

    def __init__(self):
        self.students = []
        self.students_registration_classes = {}

    def register_student(self, student):
        if student in self.students:
            return 0
        else:
            self.students.append(student)
            return 1

    def register_class(self, student_name, class_name):
        if student_name in self.students_registration_classes:
            self.students_registration_classes[student_name].append(class_name)
        else:
            self.students_registration_classes[student_name] = [class_name]
        return self.students_registration_classes[student_name]

    def get_students_by_major(self, major):
        student_list = []
        for student in self.students:
            if student[""major""] == major:
                student_list.append(student[""name""])
        return student_list

    def get_all_major(self):
        major_list = []
        for student in self.students:
            if student[""major""] not in major_list:
                major_list.append(student[""major""])
        return major_list

    def get_most_popular_class_in_major(self, major):
        class_list = []
        for student in self.students:
            if student[""major""] == major:
                class_list += self.students_registration_classes[student[""name""]]
        most_popular_class = max(set(class_list), key=class_list.count)
        return most_popular_class",ZeroShot,"

```python
from datetime import datetime

class Course:
    def __init__(self, name, start_time, end_time):
        """"""
        Initialize a course with name, start_time, and end_time.
        """"""
        self.name = name
        self.start_time = start_time
        self.end_time = end_time

class Classroom:
    def __init__(self, id):
        """"""
        Initialize the classroom management system.
        """"""
        # Initialize an empty list to store courses
        self.courses = []
        # Initialize the classroom id
        self.id = id

    def add_course(self, course):
        """"""
        Add course to self.courses list if the course wasn't in it.
        """"""
        # Check if the course is not already in the list
        if course not in self.courses:
            # Check for conflicts before adding the course
            if self.check_course_conflict(course):
                # Add the course to the list if no conflicts
                self.courses.append(course)
            else:
                # Print a message if the course conflicts with existing courses
                print(f""Cannot add {course.name} due to time conflict."")

    def remove_course(self, course):
        """"""
        Remove course from self.courses list if the course was in it.
        """"""
        # Check if the course is in the list
        if course in self.courses:
            # Remove the course from the list
            self.courses.remove(course)

    def is_free_at(self, check_time):
        """"""
        Change the time format as '%H:%M' and check the time is free or not in the classroom.
        :return: True if the check_time does not conflict with every course time, or False otherwise.
        """"""
        # Convert check_time to datetime object if it's a string
        if isinstance(check_time, str):
            check_time = datetime.strptime(check_time, '%H:%M')
        # Iterate over each course in the classroom
        for course in self.courses:
            # Convert course start and end times to datetime objects if they're strings
            if isinstance(course.start_time, str):
                course_start_time = datetime.strptime(course.start_time, '%H:%M')
            else:
                course_start_time = course.start_time
            if isinstance(course.end_time, str):
                course_end_time = datetime.strptime(course.end_time, '%H:%M')
            else:
                course_end_time = course.end_time
            # Check if check_time is within a course time
            if course_start_time <= check_time < course_end_time:
                # Return False if check_time conflicts with a course
                return False
        # Return True if check_time does not conflict with any courses
        return True

    def check_course_conflict(self, new_course):
        """"""
        Before adding a new course, check if the new course time conflicts with any other course.
        :return: False if the new course time conflicts(including two courses have the same boundary time) with other courses, or True otherwise.
        """"""
        # Iterate over each course in the classroom
        for course in self.courses:
            # Convert new course start and end times to datetime objects if they're strings
            if isinstance(new_course.start_time, str):
                new_start_time = datetime.strptime(new_course.start_time, '%H:%M')
            else:
                new_start_time = new_course.start_time
            if isinstance(new_course.end_time, str):
                new_end_time = datetime.strptime(new_course.end_time, '%H:%M')
            else:
                new_end_time = new_course.end_time
            # Convert course start and end times to datetime objects if they're strings
            if isinstance(course.start_time, str):
                course_start_time = datetime.strptime(course.start_time, '%H:%M')
            else:
                course_start_time = course.start_time
            if isinstance(course.end_time, str):
                course_end_time = datetime.strptime(course.end_time, '%H:%M')
            else:
                course_end_time = course.end_time
            # Check for conflicts between new course and existing course
            if (new_start_time < course_end_time and new_end_time > course_start_time) or \
               (new_start_time == course_start_time or new_end_time == course_end_time):
                # Return False if a conflict is found
                return False
        # Return True if no conflicts are found
        return True


# Example usage:
classroom = Classroom(1)
course1 = Course(""Math"", ""09:00"", ""10:00"")
course2 = Course(""Science"", ""10:00"", ""11:00"")
course3 = Course(""English"", ""10:00"", ""11:00"")

classroom.add_course(course1)
classroom.add_course(course2)
classroom.add_course(course3)

print(classroom.is_free_at(""11:00""))  # Should print: True
print(classroom.is_free_at(""10:00""))  # Should print: False
```",0.00019379844961240307,0.12979211886008096,0.24,0.0718562874251497,0.11059907479453812,0.03571428571428571,0.008130081300813009,0.013245030091663335,0.24,0.0718562874251497,0.11059907479453812
Llama,23,"import math
from typing import List

class CombinationCalculator:
    def __init__(self, datas: List[str]):
        self.datas = datas

    @staticmethod
    def count(n: int, m: int) -> int:
        if m == 0 or n == m:
            return 1
        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))

    @staticmethod
    def count_all(n: int) -> int:
        if n < 0 or n > 63:
            return False
        return (1 << n) - 1 if n != 63 else float(""inf"")

    def select(self, m: int) -> List[List[str]]:
        result = []
        self._select(0, [None] * m, 0, result)
        return result

    def select_all(self) -> List[List[str]]:
        result = []
        for i in range(1, len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):
        resultLen = len(resultList)
        resultCount = resultIndex + 1
        if resultCount > resultLen:
            result.append(resultList.copy())
            return

        for i in range(dataIndex, len(self.datas) + resultCount - resultLen):
            resultList[resultIndex] = self.datas[i]
            self._select(i + 1, resultList, resultIndex + 1, result)",ZeroShot,"

```python
import math
from typing import List

class CombinationCalculator:
    def __init__(self, datas: List[str]):
        # Initialize the calculator with a list of data
        self.datas = datas

    @staticmethod
    def count(n: int, m: int) -> int:
        # Calculate the number of combinations for a specific count using the formula n! / (m! * (n-m)!)
        if m > n:
            return 0
        result = math.comb(n, m)
        return result

    @staticmethod
    def count_all(n: int) -> int:
        # Calculate the number of all possible combinations, which is 2^n
        result = 2 ** n
        # If the number of combinations is greater than 2^63-1, return float(""inf"")
        if result > 2 ** 63 - 1:
            return float(""inf"")
        return result

    def select(self, m: int) -> List[List[str]]:
        # Generate combinations with a specified number of elements
        result = []
        self._select(0, [], 0, result, m)
        return result

    def select_all(self) -> List[List[str]]:
        # Generate all possible combinations of selecting elements from the given data list
        result = []
        for i in range(len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]], m: int):
        # Generate combinations with a specified number of elements by recursion
        if resultIndex == m:
            # If the current combination has the specified number of elements, add it to the result
            result.append(resultList[:])
            return
        for i in range(dataIndex, len(self.datas)):
            # Add the current element to the current combination
            resultList.append(self.datas[i])
            # Recursively generate combinations with the remaining elements
            self._select(i + 1, resultList, resultIndex + 1, result, m)
            # Remove the current element from the current combination for backtracking
            resultList.pop()
```",0.22709163346613548,0.26071844250953974,0.6777777777777778,0.46923076923076923,0.5545454497107439,0.45985401459854014,0.30434782608695654,0.3662790649744795,0.6666666666666666,0.46153846153846156,0.5454545406198348
Llama,24,"class ComplexCalculator:
    def __init__(self):
        pass

    @staticmethod
    def add(c1, c2):
        real = c1.real + c2.real
        imaginary = c1.imag + c2.imag
        answer = complex(real, imaginary)
        return answer
    
    @staticmethod
    def subtract(c1, c2):
        real = c1.real - c2.real
        imaginary = c1.imag - c2.imag
        return complex(real, imaginary)
    
    @staticmethod
    def multiply(c1, c2):
        real = c1.real * c2.real - c1.imag * c2.imag
        imaginary = c1.real * c2.imag + c1.imag * c2.real
        return complex(real, imaginary)
    
    @staticmethod
    def divide(c1, c2):
        denominator = c2.real**2 + c2.imag**2
        real = (c1.real * c2.real + c1.imag * c2.imag) / denominator
        imaginary = (c1.imag * c2.real - c1.real * c2.imag) / denominator
        return complex(real, imaginary)",ZeroShot,"

```python
# This is a class that implements addition, subtraction, multiplication, and division operations for complex numbers.

class ComplexCalculator:

    def __init__(self):
        # Initialize an empty constructor as no instance variables are required
        pass

    @staticmethod
    def add(c1, c2):
        """"""
        Adds two complex numbers.
        :return: The sum of the two complex numbers, complex.
        """"""
        # Extract real and imaginary parts of the complex numbers
        real1, imag1 = c1.real, c1.imag
        real2, imag2 = c2.real, c2.imag
        
        # Calculate the sum of real and imaginary parts separately
        real_sum = real1 + real2
        imag_sum = imag1 + imag2
        
        # Return the sum as a complex number
        return complex(real_sum, imag_sum)

    @staticmethod
    def subtract(c1, c2):
        """"""
        Subtracts two complex numbers.
        :return: The difference of the two complex numbers, complex.
        """"""
        # Extract real and imaginary parts of the complex numbers
        real1, imag1 = c1.real, c1.imag
        real2, imag2 = c2.real, c2.imag
        
        # Calculate the difference of real and imaginary parts separately
        real_diff = real1 - real2
        imag_diff = imag1 - imag2
        
        # Return the difference as a complex number
        return complex(real_diff, imag_diff)

    @staticmethod
    def multiply(c1, c2):
        """"""
        Multiplies two complex numbers.
        :return: The product of the two complex numbers, complex.
        """"""
        # Extract real and imaginary parts of the complex numbers
        real1, imag1 = c1.real, c1.imag
        real2, imag2 = c2.real, c2.imag
        
        # Calculate the product using the formula (a+bi)*(c+di) = (ac-bd) + (ad+bc)i
        real_product = real1 * real2 - imag1 * imag2
        imag_product = real1 * imag2 + real2 * imag1
        
        # Return the product as a complex number
        return complex(real_product, imag_product)

    @staticmethod
    def divide(c1, c2):
        """"""
        Divides two complex numbers.
        :return: The quotient of the two complex numbers, complex.
        """"""
        # Check for division by zero
        if c2 == 0:
            raise ZeroDivisionError(""Cannot divide by zero"")
        
        # Extract real and imaginary parts of the complex numbers
        real1, imag1 = c1.real, c1.imag
        real2, imag2 = c2.real, c2.imag
        
        # Calculate the magnitude of the denominator
        magnitude = real2 ** 2 + imag2 ** 2
        
        # Calculate the quotient using the formula (a+bi)/(c+di) = ((ac+bd)/magnitude) + ((bc-ad)/magnitude)i
        real_quotient = (real1 * real2 + imag1 * imag2) / magnitude
        imag_quotient = (imag1 * real2 - real1 * imag2) / magnitude
        
        # Return the quotient as a complex number
        return complex(real_quotient, imag_quotient)


# Example usage:
if __name__ == ""__main__"":
    c1 = complex(3, 4)
    c2 = complex(1, 2)
    
    print(""Addition:"", ComplexCalculator.add(c1, c2))
    print(""Subtraction:"", ComplexCalculator.subtract(c1, c2))
    print(""Multiplication:"", ComplexCalculator.multiply(c1, c2))
    print(""Division:"", ComplexCalculator.divide(c1, c2))
```",0.027918781725888325,0.041945493011007466,0.7666666666666667,0.17424242424242425,0.28395061426611806,0.2786885245901639,0.07112970711297072,0.11333333009355565,0.7333333333333333,0.16666666666666666,0.2716049352537723
Llama,25,"import json

class CookiesUtil:
    def __init__(self, cookies_file):
        self.cookies_file = cookies_file
        self.cookies = None

    def get_cookies(self, reponse):
        self.cookies = reponse['cookies']
        self._save_cookies()

    def load_cookies(self):
        try:
            with open(self.cookies_file, 'r') as file:
                cookies_data = json.load(file)
                return cookies_data
        except FileNotFoundError:
            return {}

    def _save_cookies(self):
        try:
            with open(self.cookies_file, 'w') as file:
                json.dump(self.cookies, file)
            return True
        except:
            return False

    def set_cookies(self, request):
        request['cookies'] = '; '.join([f'{key}={value}' for key, value in self.cookies.items()])",ZeroShot,"

```python
import json

class CookiesUtil:
    def __init__(self, cookies_file):
        # Initialize the cookies file path
        self.cookies_file = cookies_file
        # Initialize the cookies data as an empty dictionary
        self.cookies_data = {}

    def get_cookies(self, response):
        # Get the cookies from the response
        self.cookies_data = response.cookies.get_dict()
        # Save the cookies to the cookies file
        self._save_cookies()

    def load_cookies(self):
        # Try to load the cookies from the cookies file
        try:
            with open(self.cookies_file, 'r') as file:
                # Load the cookies data from the file
                self.cookies_data = json.load(file)
        except FileNotFoundError:
            # If the file does not exist, return an empty dictionary
            self.cookies_data = {}
        # Return the cookies data
        return self.cookies_data

    def _save_cookies(self):
        # Try to save the cookies to the cookies file
        try:
            with open(self.cookies_file, 'w') as file:
                # Save the cookies data to the file
                json.dump(self.cookies_data, file)
            # Return True if successful
            return True
        except Exception as e:
            # Print the error message
            print(f""Error saving cookies: {e}"")
            # Return False if failed
            return False
```",0.09554140127388534,0.1304539727773379,0.673469387755102,0.4520547945205479,0.5409836017508735,0.4411764705882353,0.24793388429752067,0.31746031285350357,0.673469387755102,0.4520547945205479,0.5409836017508735
Llama,26,"import csv


class CSVProcessor:

    def __init__(self):
        pass

    def read_csv(self, file_name):
        data = []
        with open(file_name, 'r') as file:
            reader = csv.reader(file)
            title = next(reader)
            for row in reader:
                data.append(row)
        return title, data

    def write_csv(self, data, file_name):
        try:
            with open(file_name, 'w', newline='') as file:
                writer = csv.writer(file)
                writer.writerows(data)
            return 1
        except:
            return 0

    def process_csv_data(self, N, save_file_name):
        title, data = self.read_csv(save_file_name)
        column_data = [row[N] for row in data]
        column_data = [row.upper() for row in column_data]
        new_data = [title, column_data]
        return self.write_csv(new_data, save_file_name.split('.')[0] + '_process.csv')",ZeroShot,"

```python
import csv

class CSVProcessor:

    def __init__(self, file_name=None):
        # Initialize the class with a file name if provided
        self.file_name = file_name

    def read_csv(self, file_name):
        """"""
        Read the csv file by file_name, get the title and data from it
        :return title, data: (list, list), first row is title, the rest is data
        """"""
        try:
            with open(file_name, 'r') as file:
                # Use csv.reader to read the csv file
                csv_reader = csv.reader(file)
                # Get the title (first row) and data
                title = next(csv_reader)
                data = list(csv_reader)
                return title, data
        except FileNotFoundError:
            # Handle the case when the file does not exist
            print(f""File {file_name} not found."")
            return None, None

    def write_csv(self, data, file_name):
        """"""
        Write data into a csv file.
        :return:int, if success return 1, or 0 otherwise
        """"""
        try:
            with open(file_name, 'w', newline='') as file:
                # Use csv.writer to write the csv file
                csv_writer = csv.writer(file)
                # Write the data to the csv file
                csv_writer.writerows(data)
                return 1
        except Exception as e:
            # Handle any exceptions during writing
            print(f""Error writing to file {file_name}: {str(e)}"")
            return 0

    def process_csv_data(self, N, save_file_name=None):
        """"""
        Read a csv file into variable title and data.
        Only remain the N th (from 0) column data and Capitalize them, store the title and new data into a new csv file.
        Add '_process' suffix after old file name, as a new file name.
        :return:int, if success return 1, or 0 otherwise
        """"""
        if self.file_name is None:
            # If no file name is provided, return an error
            print(""No file name provided."")
            return 0
        
        # Read the csv file
        title, data = self.read_csv(self.file_name)
        
        if title is None or data is None:
            # If reading the csv file fails, return an error
            return 0
        
        # Process the data
        new_title = [title[N].upper()]
        new_data = [[row[N].upper()] for row in data]
        
        # If save_file_name is not provided, generate a new file name
        if save_file_name is None:
            save_file_name = self.file_name.split('.')[0] + '_process.csv'
        
        # Write the new data to a csv file
        new_data.insert(0, new_title)
        return self.write_csv(new_data, save_file_name)


# Example usage
if __name__ == ""__main__"":
    processor = CSVProcessor('example.csv')
    processor.process_csv_data(1)
```",0.06231454005934719,0.08000145505411595,0.7457627118644068,0.2732919254658385,0.3999999960747934,0.4878048780487805,0.14084507042253522,0.21857923149571504,0.7457627118644068,0.2732919254658385,0.3999999960747934
Llama,27,"class CurrencyConverter:
    def __init__(self):
        self.rates = {
            'USD': 1.0,
            'EUR': 0.85,
            'GBP': 0.72,
            'JPY': 110.15,
            'CAD': 1.23,
            'AUD': 1.34,
            'CNY': 6.40,
        }

    def convert(self, amount, from_currency, to_currency):
        if from_currency == to_currency:
            return amount

        if from_currency not in self.rates or to_currency not in self.rates:
            return False

        from_rate = self.rates[from_currency]
        to_rate = self.rates[to_currency]

        converted_amount = (amount / from_rate) * to_rate
        return converted_amount

    def get_supported_currencies(self):
        return list(self.rates.keys())

    def add_currency_rate(self, currency, rate):
        if currency in self.rates:
            return False
        self.rates[currency] = rate

    def update_currency_rate(self, currency, new_rate):
        if currency not in self.rates:
            return False
        self.rates[currency] = new_rate",ZeroShot,"

```python
class CurrencyConverter:
    def __init__(self):
        # Initialize the exchange rate of the US dollar against various currencies
        self.exchange_rates = {
            'USD': 1.0,  # Base currency
            'EUR': 0.88,  # 1 USD = 0.88 EUR
            'GBP': 0.76,  # 1 USD = 0.76 GBP
            'JPY': 114.74,  # 1 USD = 114.74 JPY
            'CNY': 6.47,  # 1 USD = 6.47 CNY
        }

    def convert(self, amount, from_currency, to_currency):
        # Check if both currencies are supported
        if from_currency not in self.exchange_rates or to_currency not in self.exchange_rates:
            raise ValueError(""One or both currencies are not supported"")
        
        # Convert the amount to USD first
        usd_amount = amount / self.exchange_rates[from_currency]
        
        # Then convert the USD amount to the target currency
        converted_amount = usd_amount * self.exchange_rates[to_currency]
        
        return converted_amount

    def get_supported_currencies(self):
        # Returns a list of supported currency types
        return list(self.exchange_rates.keys())

    def add_currency_rate(self, currency, rate):
        # Check if the currency is already supported
        if currency in self.exchange_rates:
            return False  # Return False if the currency is already supported
        
        # Add the new currency rate
        self.exchange_rates[currency] = rate
        return None

    def update_currency_rate(self, currency, new_rate):
        # Check if the currency is supported
        if currency not in self.exchange_rates:
            return False  # Return False if the currency is not supported
        
        # Update the exchange rate for the currency
        self.exchange_rates[currency] = new_rate
        return None
```",0.10194174757281552,0.1313086296042469,0.6875,0.43137254901960786,0.5301204771897228,0.43333333333333335,0.22285714285714286,0.2943396181559274,0.6875,0.43137254901960786,0.5301204771897228
Llama,28,"import sqlite3
import pandas as pd


class DatabaseProcessor:

    def __init__(self, database_name):
        self.database_name = database_name

    def create_table(self, table_name, key1, key2):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        create_table_query = f""CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)""
        cursor.execute(create_table_query)

        conn.commit()
        conn.close()

    def insert_into_database(self, table_name, data):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        for item in data:
            insert_query = f""INSERT INTO {table_name} (name, age) VALUES (?, ?)""
            cursor.execute(insert_query, (item['name'], item['age']))

        conn.commit()
        conn.close()

    def search_database(self, table_name, name):

        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        select_query = f""SELECT * FROM {table_name} WHERE name = ?""
        cursor.execute(select_query, (name,))
        result = cursor.fetchall()

        if result:
            return result
        else:
            return None

    def delete_from_database(self, table_name, name):

        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        delete_query = f""DELETE FROM {table_name} WHERE name = ?""
        cursor.execute(delete_query, (name,))

        conn.commit()
        conn.close()",ZeroShot,"

```python
import sqlite3
import pandas as pd

class DatabaseProcessor:

    # Initialize database name of database processor
    def __init__(self, database_name):
        # Connect to SQLite database. It will be created if it doesn't exist.
        self.conn = sqlite3.connect(database_name)
        # Create a cursor object
        self.cursor = self.conn.cursor()


    # Create a new table in the database if it doesn't exist.
    def create_table(self, table_name, key1, key2):
        # SQL query string to create a new table
        query = f""""""
            CREATE TABLE IF NOT EXISTS {table_name} (
                id INTEGER PRIMARY KEY,
                {key1} TEXT,
                {key2} INTEGER
            )
        """"""
        # Execute the query
        self.cursor.execute(query)
        # Commit the changes
        self.conn.commit()


    # Insert data into the specified table in the database.
    def insert_into_database(self, table_name, data):
        # Check if data is a list of tuples
        if not isinstance(data, list) or not all(isinstance(item, tuple) for item in data):
            raise ValueError(""Data must be a list of tuples"")
        
        # Check if each tuple has exactly 2 elements
        if not all(len(item) == 2 for item in data):
            raise ValueError(""Each tuple must have exactly 2 elements"")
        
        # SQL query string to insert data into the table
        query = f""""""
            INSERT INTO {table_name} ({data[0][0].lower()}, {data[0][1].lower()}) 
            VALUES (?, ?)
        """"""
        # Execute the query for each tuple in the data
        self.cursor.executemany(query, [(item[1], item[2]) for item in data])
        # Commit the changes
        self.conn.commit()


    # Search the specified table in the database for rows with a matching name.
    def search_database(self, table_name, name):
        # SQL query string to select rows from the table with a matching name
        query = f""""""
            SELECT * FROM {table_name} 
            WHERE {table_name[:-1]}1 = ?
        """"""
        # Execute the query
        self.cursor.execute(query, (name,))
        # Fetch all rows
        rows = self.cursor.fetchall()
        # Return the rows if any, otherwise return None
        return rows if rows else None


    # Delete rows from the specified table in the database with a matching name.
    def delete_from_database(self, table_name, name):
        # SQL query string to delete rows from the table with a matching name
        query = f""""""
            DELETE FROM {table_name} 
            WHERE {table_name[:-1]}1 = ?
        """"""
        # Execute the query
        self.cursor.execute(query, (name,))
        # Commit the changes
        self.conn.commit()


# Example usage
if __name__ == ""__main__"":
    db = DatabaseProcessor(""example.db"")
    db.create_table(""users"", ""name"", ""age"")
    data = [(""name"", ""John"", 25), (""name"", ""Alice"", 30)]
    db.insert_into_database(""users"", data)
    print(db.search_database(""users"", ""John""))
    db.delete_from_database(""users"", ""John"")
    print(db.search_database(""users"", ""John""))
```",0.07377049180327869,0.0920080142533486,0.6455696202531646,0.2982456140350877,0.40799999567712003,0.39285714285714285,0.16117216117216118,0.2285714244458088,0.6455696202531646,0.2982456140350877,0.40799999567712003
Llama,29,"from collections import Counter


class DataStatistics:
    def mean(self, data):
        return round(sum(data) / len(data), 2)

    def median(self, data):
        sorted_data = sorted(data)
        n = len(sorted_data)
        if n % 2 == 0:
            middle = n // 2
            return round((sorted_data[middle - 1] + sorted_data[middle]) / 2, 2)
        else:
            middle = n // 2
            return sorted_data[middle]

    def mode(self, data):
        counter = Counter(data)
        mode_count = max(counter.values())
        mode = [x for x, count in counter.items() if count == mode_count]
        return mode",ZeroShot,"

```python
# This is a class for performing data statistics, supporting to calculate the mean, median, and mode of a given data set.

from collections import Counter
import statistics

class DataStatistics:
    # Calculate the average value of a group of data, accurate to two digits after the Decimal separator
    def mean(self, data):
        # Check if data is empty
        if not data:
            return None
        # Calculate the mean using the statistics library and round to two decimal places
        return round(statistics.mean(data), 2)

    # Calculate the median of a group of data, accurate to two digits after the Decimal separator
    def median(self, data):
        # Check if data is empty
        if not data:
            return None
        # Calculate the median using the statistics library and round to two decimal places
        return round(statistics.median(data), 2)

    # Calculate the mode of a set of data
    def mode(self, data):
        # Check if data is empty
        if not data:
            return None
        # Use Counter to count the frequency of each data point
        counter = Counter(data)
        # Find the data point with the highest frequency
        mode = [k for k, v in counter.items() if v == max(counter.values())]
        # If there are multiple modes, return the smallest one
        return min(mode)

# Example usage:
data_stats = DataStatistics()
data = [1, 2, 3, 4, 4, 5, 5, 5]
print(data_stats.mean(data))  # Output: 3.75
print(data_stats.median(data))  # Output: 4.0
print(data_stats.mode(data))  # Output: 5
```",0.031111111111111117,0.03501116382220886,0.5102040816326531,0.22935779816513763,0.31645569192357,0.22857142857142856,0.09411764705882353,0.13333332920138904,0.4489795918367347,0.2018348623853211,0.27848100837926626
Llama,30,"import numpy as np


class DataStatistics2:
    def __init__(self, data):
        self.data = np.array(data)

    def get_sum(self):
        return np.sum(self.data)

    def get_min(self):
        return np.min(self.data)

    def get_max(self):
        return np.max(self.data)

    def get_variance(self):
        return round(np.var(self.data), 2)

    def get_std_deviation(self):
        return round(np.std(self.data), 2)

    def get_correlation(self):
        return np.corrcoef(self.data, rowvar=False)",ZeroShot,"

```python
# This is a class for performing data statistics, supporting to get the sum, minimum, maximum, variance, standard deviation, and correlation of a given dataset.

import numpy as np

class DataStatistics2:
    # Initialize Data List
    def __init__(self, data):
        # Check if input data is a list
        if not isinstance(data, list):
            raise TypeError(""Input data must be a list"")
        # Check if list is not empty
        if len(data) == 0:
            raise ValueError(""Input list cannot be empty"")
        # Check if all elements in the list are numbers
        if not all(isinstance(x, (int, float)) for x in data):
            raise ValueError(""All elements in the list must be numbers"")
        self.data = np.array(data)  # Convert list to numpy array for efficient calculations

    # Calculate the sum of data
    def get_sum(self):
        # Use numpy's sum function to calculate the sum of the data
        return np.sum(self.data)

    # Calculate the minimum value in the data
    def get_min(self):
        # Use numpy's min function to find the minimum value in the data
        return np.min(self.data)

    # Calculate the maximum value in the data
    def get_max(self):
        # Use numpy's max function to find the maximum value in the data
        return np.max(self.data)

    # Calculate variance, accurate to two digits after the Decimal separator
    def get_variance(self):
        # Use numpy's var function to calculate the variance of the data
        return round(np.var(self.data), 2)

    # Calculate standard deviation, accurate to two digits after the Decimal separator
    def get_std_deviation(self):
        # Use numpy's std function to calculate the standard deviation of the data
        return round(np.std(self.data), 2)

    # Calculate correlation
    def get_correlation(self):
        # Since correlation is typically calculated between two datasets, 
        # we'll calculate the correlation of the data with itself
        # This will give us a correlation coefficient of 1.0
        # For a more meaningful correlation calculation, you would need two separate datasets
        return np.corrcoef(self.data, self.data)[0, 1]
```",0.027118644067796606,0.04072642526935845,0.96875,0.22302158273381295,0.3625730963729011,0.7272727272727273,0.14035087719298245,0.23529411493512112,0.96875,0.22302158273381295,0.3625730963729011
Llama,31,"import math

class DataStatistics4:

    @staticmethod
    def correlation_coefficient(data1, data2):
        n = len(data1)
        mean1 = sum(data1) / n
        mean2 = sum(data2) / n

        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))
        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n))) * math.sqrt(sum((data2[i] - mean2) ** 2 for i in range(n)))

        return numerator / denominator if denominator != 0 else 0
    
    @staticmethod
    def skewness(data):
        n = len(data)
        mean = sum(data) / n
        variance = sum((x - mean) ** 2 for x in data) / n
        std_deviation = math.sqrt(variance)

        skewness = sum((x - mean) ** 3 for x in data) * n / ((n - 1) * (n - 2) * std_deviation ** 3) if std_deviation != 0 else 0

        return skewness
    
    @staticmethod
    def kurtosis(data):

        n = len(data)
        mean = sum(data) / n
        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / n)

        if std_dev == 0:
            return math.nan

        centered_data = [(x - mean) for x in data]
        fourth_moment = sum(x ** 4 for x in centered_data) / n

        kurtosis_value = (fourth_moment / std_dev ** 4) - 3

        return kurtosis_value
    
    @staticmethod
    def pdf(data, mu, sigma):
        pdf_values = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]
        return pdf_values",ZeroShot,"

```python
import math

class DataStatistics4:

    # Calculate the correlation coefficient of two sets of data
    @staticmethod
    def correlation_coefficient(data1, data2):
        # Calculate the means of the two datasets
        mean1 = sum(data1) / len(data1)
        mean2 = sum(data2) / len(data2)

        # Calculate the deviations from the mean for each dataset
        deviations1 = [x - mean1 for x in data1]
        deviations2 = [x - mean2 for x in data2]

        # Calculate the covariance and the variances
        covariance = sum(x * y for x, y in zip(deviations1, deviations2)) / len(data1)
        variance1 = sum(x ** 2 for x in deviations1) / len(data1)
        variance2 = sum(x ** 2 for x in deviations2) / len(data2)

        # Calculate the correlation coefficient
        correlation_coefficient = covariance / math.sqrt(variance1 * variance2)
        return correlation_coefficient

    # Calculate the skewness of a set of data
    @staticmethod
    def skewness(data):
        # Calculate the mean of the dataset
        mean = sum(data) / len(data)

        # Calculate the deviations from the mean
        deviations = [x - mean for x in data]

        # Calculate the variance
        variance = sum(x ** 2 for x in deviations) / len(data)

        # Calculate the skewness
        skewness = sum(x ** 3 for x in deviations) / len(data) / (variance ** 1.5)
        return skewness

    # Calculate the kurtosis of a set of data
    @staticmethod
    def kurtosis(data):
        # Calculate the mean of the dataset
        mean = sum(data) / len(data)

        # Calculate the deviations from the mean
        deviations = [x - mean for x in data]

        # Calculate the variance
        variance = sum(x ** 2 for x in deviations) / len(data)

        # Calculate the kurtosis
        kurtosis = sum(x ** 4 for x in deviations) / len(data) / (variance ** 2) - 3
        return kurtosis

    # Calculate the probability density function (PDF) of a set of data under a normal distribution
    @staticmethod
    def pdf(data, mu, sigma):
        # Calculate the PDF for each data point
        pdf = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-((x - mu) ** 2) / (2 * sigma ** 2)) for x in data]
        return pdf

# Example usage
if __name__ == ""__main__"":
    data1 = [1, 2, 3, 4, 5]
    data2 = [2, 3, 5, 7, 11]
    print(""Correlation Coefficient:"", DataStatistics4.correlation_coefficient(data1, data2))
    print(""Skewness:"", DataStatistics4.skewness(data1))
    print(""Kurtosis:"", DataStatistics4.kurtosis(data1))
    print(""PDF:"", DataStatistics4.pdf(data1, 3, 1))
```",0.12672176308539945,0.1595101730237664,0.5232558139534884,0.3488372093023256,0.41860464636279077,0.2874251497005988,0.21238938053097345,0.24427480427299636,0.47674418604651164,0.3178294573643411,0.3813953440372093
Llama,32,"class DecryptionUtils:
    def __init__(self, key):
        self.key = key
    
    def caesar_decipher(self, ciphertext, shift):
        plaintext = """"
        for char in ciphertext:
            if char.isalpha():
                if char.isupper():
                    ascii_offset = 65
                else:
                    ascii_offset = 97
                shifted_char = chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)
                plaintext += shifted_char
            else:
                plaintext += char
        return plaintext
    
    def vigenere_decipher(self, ciphertext):
        decrypted_text = """"
        key_index = 0
        for char in ciphertext:
            if char.isalpha():
                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')
                decrypted_char = chr((ord(char.lower()) - ord('a') - shift) % 26 + ord('a'))
                decrypted_text += decrypted_char.upper() if char.isupper() else decrypted_char
                key_index += 1
            else:
                decrypted_text += char
        return decrypted_text
    
    def rail_fence_decipher(self, encrypted_text, rails):
        fence = [['\n' for _ in range(len(encrypted_text))] for _ in range(rails)]
        direction = -1
        row, col = 0, 0

        for _ in range(len(encrypted_text)):
            if row == 0 or row == rails - 1:
                direction = -direction

            fence[row][col] = ''
            col += 1
            row += direction

        index = 0
        for i in range(rails):
            for j in range(len(encrypted_text)):
                if fence[i][j] == '':
                    fence[i][j] = encrypted_text[index]
                    index += 1

        plain_text = ''
        direction = -1
        row, col = 0, 0
        for _ in range(len(encrypted_text)):
            if row == 0 or row == rails - 1:
                direction = -direction

            plain_text += fence[row][col]
            col += 1
            row += direction

        return plain_text",ZeroShot,"

```python
class DecryptionUtils:
    def __init__(self, key):
        # Initialize the decryption utility with a key
        self.key = key

    def caesar_decipher(self, ciphertext, shift):
        # Decipher the given ciphertext using the Caesar cipher
        # Create a string of lowercase and uppercase alphabets
        lowercase_alphabets = 'abcdefghijklmnopqrstuvwxyz'
        uppercase_alphabets = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        
        # Initialize an empty string to store the deciphered text
        plaintext = ''
        
        # Iterate over each character in the ciphertext
        for char in ciphertext:
            # Check if the character is an alphabet
            if char.isalpha():
                # Find the index of the character in the alphabet string
                if char.islower():
                    index = lowercase_alphabets.index(char)
                    # Shift the character back by the given shift value
                    new_index = (index - shift) % 26
                    # Append the deciphered character to the plaintext
                    plaintext += lowercase_alphabets[new_index]
                else:
                    index = uppercase_alphabets.index(char)
                    # Shift the character back by the given shift value
                    new_index = (index - shift) % 26
                    # Append the deciphered character to the plaintext
                    plaintext += uppercase_alphabets[new_index]
            else:
                # If the character is not an alphabet, append it as is
                plaintext += char
        
        # Return the deciphered plaintext
        return plaintext

    def vigenere_decipher(self, ciphertext):
        # Decipher the given ciphertext using the Vigenere cipher
        # Create a string of lowercase and uppercase alphabets
        lowercase_alphabets = 'abcdefghijklmnopqrstuvwxyz'
        uppercase_alphabets = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        
        # Initialize an empty string to store the deciphered text
        plaintext = ''
        
        # Convert the key to lowercase
        key = self.key.lower()
        
        # Initialize a key index to keep track of the current key character
        key_index = 0
        
        # Iterate over each character in the ciphertext
        for char in ciphertext:
            # Check if the character is an alphabet
            if char.isalpha():
                # Find the index of the character in the alphabet string
                if char.islower():
                    index = lowercase_alphabets.index(char)
                    # Find the index of the current key character in the alphabet string
                    key_char_index = lowercase_alphabets.index(key[key_index % len(key)])
                    # Shift the character back by the given key character value
                    new_index = (index - key_char_index) % 26
                    # Append the deciphered character to the plaintext
                    plaintext += lowercase_alphabets[new_index]
                else:
                    index = uppercase_alphabets.index(char)
                    # Find the index of the current key character in the alphabet string
                    key_char_index = lowercase_alphabets.index(key[key_index % len(key)])
                    # Shift the character back by the given key character value
                    new_index = (index - key_char_index) % 26
                    # Append the deciphered character to the plaintext
                    plaintext += uppercase_alphabets[new_index]
                # Increment the key index
                key_index += 1
            else:
                # If the character is not an alphabet, append it as is
                plaintext += char
        
        # Return the deciphered plaintext
        return plaintext

    def rail_fence_decipher(self, encrypted_text, rails):
        # Decipher the given ciphertext using the Rail Fence cipher
        # Calculate the length of the ciphertext
        length = len(encrypted_text)
        
        # Initialize a 2D list to represent the rail fence
        fence = [['' for _ in range(length)] for _ in range(rails)]
        
        # Initialize variables to keep track of the current rail and direction
        curr_rail = 0
        dir = 1
        
        # Iterate over each character in the ciphertext
        for i in range(length):
            # Place the character in the current rail
            fence[curr_rail][i] = encrypted_text[i]
            
            # Update the current rail and direction
            if curr_rail == 0:
                dir = 1
            elif curr_rail == rails - 1:
                dir = -1
            curr_rail += dir
        
        # Initialize an empty string to store the deciphered text
        plaintext = ''
        
        # Read the characters from the fence in a zig-zag manner
        for col in range(length):
            for row in range(rails):
                # Check if the current cell is not empty
                if fence[row][col] != '':
                    # Append the character to the plaintext
                    plaintext += fence[row][col]
        
        # Return the deciphered plaintext
        return plaintext
```",0.053082191780821915,0.07541315816293491,0.6024096385542169,0.3401360544217687,0.43478260408279773,0.3116883116883117,0.16666666666666666,0.21719456559529912,0.5542168674698795,0.3129251700680272,0.3999999953871456
Llama,33,"class DiscountStrategy:
    def __init__(self, customer, cart, promotion=None):
        self.customer = customer
        self.cart = cart
        self.promotion = promotion
        self.__total = self.total()

    def total(self):
        self.__total = sum(item['quantity'] * item['price'] for item in self.cart)
        return self.__total

    def due(self):
        if self.promotion is None:
            discount = 0
        else:
            discount = self.promotion(self)
        return self.__total - discount

    @staticmethod
    def FidelityPromo(order):
        return order.total() * 0.05 if order.customer['fidelity'] >= 1000 else 0

    @staticmethod
    def BulkItemPromo(order):
        discount = 0
        for item in order.cart:
            if item['quantity'] >= 20:
                discount += item['quantity'] * item['price'] * 0.1
        return discount

    @staticmethod
    def LargeOrderPromo(order):
        return order.total() * 0.07 if len({item['product'] for item in order.cart}) >= 10 else 0",ZeroShot,"

```python
class DiscountStrategy:
    def __init__(self, customer, cart, promotion=None):
        # Initialize the DiscountStrategy with customer information, a cart of items, and an optional promotion.
        self.customer = customer
        self.cart = cart
        self.promotion = promotion

    def total(self):
        # Calculate the total cost of items in the cart.
        total_cost = sum(item['price'] * item['quantity'] for item in self.cart)
        return total_cost

    def due(self):
        # Calculate the final amount to be paid after applying the discount.
        total_cost = self.total()
        discount = 0
        if self.promotion == 'FidelityPromo':
            discount = self.FidelityPromo(self.cart)
        elif self.promotion == 'BulkItemPromo':
            discount = self.BulkItemPromo(self.cart)
        elif self.promotion == 'LargeOrderPromo':
            discount = self.LargeOrderPromo(self.cart)
        final_amount = total_cost - discount
        return final_amount

    @staticmethod
    def FidelityPromo(order):
        # Calculate the discount based on the fidelity points of the customer.
        # Customers with over 1000 points can enjoy a 5% discount on the entire order.
        total_cost = sum(item['price'] * item['quantity'] for item in order)
        if order[0]['customer_points'] > 1000:
            discount = total_cost * 0.05
        else:
            discount = 0
        return discount

    @staticmethod
    def BulkItemPromo(order):
        # Calculate the discount based on bulk item quantity in the order.
        # In the same order, if the quantity of a single item reaches 20 or more, each item will enjoy a 10% discount.
        discount = 0
        for item in order:
            if item['quantity'] >= 20:
                discount += item['price'] * item['quantity'] * 0.1
        return discount

    @staticmethod
    def LargeOrderPromo(order):
        # Calculate the discount based on the number of different products in the order.
        # If the quantity of different products in the order reaches 10 or more, the entire order will enjoy a 7% discount.
        unique_items = len(set(item['product_id'] for item in order))
        total_cost = sum(item['price'] * item['quantity'] for item in order)
        if unique_items >= 10:
            discount = total_cost * 0.07
        else:
            discount = 0
        return discount

# Example usage:
class Customer:
    def __init__(self, customer_points):
        self.customer_points = customer_points

class Item:
    def __init__(self, product_id, price, quantity):
        self.product_id = product_id
        self.price = price
        self.quantity = quantity

customer = Customer(1200)
cart = [
    {'product_id': 1, 'price': 10, 'quantity': 5, 'customer_points': customer.customer_points},
    {'product_id': 2, 'price': 20, 'quantity': 25, 'customer_points': customer.customer_points},
    {'product_id': 3, 'price': 30, 'quantity': 1, 'customer_points': customer.customer_points},
]

discount_strategy = DiscountStrategy(customer, cart, 'FidelityPromo')
print(discount_strategy.due())

discount_strategy = DiscountStrategy(customer, cart, 'BulkItemPromo')
print(discount_strategy.due())

discount_strategy = DiscountStrategy(customer, cart, 'LargeOrderPromo')
print(discount_strategy.due())
```",0.09444444444444444,0.1190530375245593,0.803921568627451,0.27702702702702703,0.4120602976955128,0.5368421052631579,0.18149466192170818,0.2712765919682266,0.7843137254901961,0.2702702702702703,0.4020100464392314
Llama,34,"from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT


class DocFileHandler:
    def __init__(self, file_path):
        self.file_path = file_path

    def read_text(self):
        doc = Document(self.file_path)
        text = []
        for paragraph in doc.paragraphs:
            text.append(paragraph.text)
        return ""\n"".join(text)

    def write_text(self, content, font_size=12, alignment='left'):
        try:
            doc = Document()
            paragraph = doc.add_paragraph()
            run = paragraph.add_run(content)
            font = run.font
            font.size = Pt(font_size)
            alignment_value = self._get_alignment_value(alignment)
            paragraph.alignment = alignment_value
            doc.save(self.file_path)
            return True
        except:
            return False

    def add_heading(self, heading, level=1):
        try:
            doc = Document(self.file_path)
            doc.add_heading(heading, level)
            doc.save(self.file_path)
            return True
        except:
            return False

    def add_table(self, data):
        try:
            doc = Document(self.file_path)
            table = doc.add_table(rows=len(data), cols=len(data[0]))
            for i, row in enumerate(data):
                for j, cell_value in enumerate(row):
                    table.cell(i, j).text = str(cell_value)
            doc.save(self.file_path)
            return True
        except:
            return False

    def _get_alignment_value(self, alignment):
        alignment_options = {
            'left': WD_PARAGRAPH_ALIGNMENT.LEFT,
            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,
            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT
        }
        return alignment_options.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)",ZeroShot,"

```python
# This is a class that handles Word documents and provides functionalities for reading, writing, and modifying the content of Word documents.

from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT


class DocFileHandler:
    def __init__(self, file_path):
        # Initializes the DocFileHandler object with the specified file path.
        self.file_path = file_path
        self.document = Document(self.file_path)

    def read_text(self):
        # Reads the content of a Word document and returns it as a string.
        text = ''
        for paragraph in self.document.paragraphs:
            text += paragraph.text + '\n'
        return text

    def write_text(self, content, font_size=12, alignment='left'):
        # Writes the specified content to a Word document.
        paragraph = self.document.add_paragraph()
        run = paragraph.add_run(content)
        font = run.font
        font.size = Pt(font_size)
        paragraph.alignment = self._get_alignment_value(alignment)
        self.document.save(self.file_path)
        return True

    def add_heading(self, heading, level=1):
        # Adds a heading to the Word document.
        self.document.add_heading(heading, level=level)
        self.document.save(self.file_path)
        return True

    def add_table(self, data):
        # Adds a table to the Word document with the specified data.
        table = self.document.add_table(rows=len(data), cols=len(data[0]), style='Table Grid')
        for i, row in enumerate(data):
            for j, cell in enumerate(row):
                table.cell(i, j).text = str(cell)
        self.document.save(self.file_path)
        return True

    def _get_alignment_value(self, alignment):
        # Returns the alignment value corresponding to the given alignment string.
        alignment_values = {
            'left': WD_PARAGRAPH_ALIGNMENT.LEFT,
            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,
            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT,
            'justify': WD_PARAGRAPH_ALIGNMENT.JUSTIFY
        }
        return alignment_values.get(alignment, WD_PARAGRAPH_ALIGNMENT.LEFT)


# Example usage:
if __name__ == ""__main__"":
    file_path = ""example.docx""
    handler = DocFileHandler(file_path)
    print(handler.read_text())
    handler.write_text(""Hello, World!"", font_size=14, alignment='center')
    handler.add_heading(""Example Heading"", level=2)
    data = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    handler.add_table(data)
```",0.18803418803418803,0.23237354522836923,0.7710843373493976,0.42953020134228187,0.5517241333356867,0.6044776119402985,0.3389121338912134,0.43431634928361446,0.7710843373493976,0.42953020134228187,0.5517241333356867
Llama,35,"class EightPuzzle:
    def __init__(self, initial_state):
        self.initial_state = initial_state
        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

    def find_blank(self, state):
        for i in range(3):
            for j in range(3):
                if state[i][j] == 0:
                    return i, j

    def move(self, state, direction):
        i, j = self.find_blank(state)
        new_state = [row[:] for row in state]

        if direction == 'up':
            new_state[i][j], new_state[i - 1][j] = new_state[i - 1][j], new_state[i][j]
        elif direction == 'down':
            new_state[i][j], new_state[i + 1][j] = new_state[i + 1][j], new_state[i][j]
        elif direction == 'left':
            new_state[i][j], new_state[i][j - 1] = new_state[i][j - 1], new_state[i][j]
        elif direction == 'right':
            new_state[i][j], new_state[i][j + 1] = new_state[i][j + 1], new_state[i][j]

        return new_state

    def get_possible_moves(self, state):
        moves = []
        i, j = self.find_blank(state)

        if i > 0:
            moves.append('up')
        if i < 2:
            moves.append('down')
        if j > 0:
            moves.append('left')
        if j < 2:
            moves.append('right')

        return moves

    def solve(self):
        open_list = [(self.initial_state, [])]
        closed_list = []

        while open_list:
            current_state, path = open_list.pop(0)
            closed_list.append(current_state)

            if current_state == self.goal_state:
                return path

            for move in self.get_possible_moves(current_state):
                new_state = self.move(current_state, move)
                if new_state not in closed_list:
                    open_list.append((new_state, path + [move]))

        return None",ZeroShot,"

```python
class EightPuzzle:
    def __init__(self, initial_state):
        # Initialize the initial state of the 8-puzzle game
        self.initial_state = initial_state
        # Set the goal state of the game (solved state)
        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

    def find_blank(self, state):
        # Iterate over the 2D list to find the blank position (0)
        for i in range(len(state)):
            for j in range(len(state[0])):
                if state[i][j] == 0:
                    # Return the coordinates of the blank position
                    return i, j

    def move(self, state, direction):
        # Find the blank position
        i, j = self.find_blank(state)
        # Create a copy of the current state
        new_state = [row[:] for row in state]
        
        # Move the blank position according to the given direction
        if direction == 'up' and i > 0:
            new_state[i][j], new_state[i-1][j] = new_state[i-1][j], new_state[i][j]
        elif direction == 'down' and i < 2:
            new_state[i][j], new_state[i+1][j] = new_state[i+1][j], new_state[i][j]
        elif direction == 'left' and j > 0:
            new_state[i][j], new_state[i][j-1] = new_state[i][j-1], new_state[i][j]
        elif direction == 'right' and j < 2:
            new_state[i][j], new_state[i][j+1] = new_state[i][j+1], new_state[i][j]
        
        # Return the new state
        return new_state

    def get_possible_moves(self, state):
        # Find the blank position
        i, j = self.find_blank(state)
        # Initialize a list to store possible moves
        moves = []
        
        # Check all possible directions
        if i > 0:
            moves.append('up')
        if i < 2:
            moves.append('down')
        if j > 0:
            moves.append('left')
        if j < 2:
            moves.append('right')
        
        # Return the list of possible moves
        return moves

    def solve(self):
        # Initialize a queue with the initial state
        open_list = [(self.initial_state, [])]
        # Initialize a set to store visited states
        visited = set()
        
        while open_list:
            # Dequeue the next state
            state, path = open_list.pop(0)
            # Convert the state to a tuple for hashing
            state_tuple = tuple(map(tuple, state))
            
            # Check if the state is the goal state
            if state == self.goal_state:
                # Return the path to the goal state
                return path
            
            # Check if the state has been visited
            if state_tuple in visited:
                continue
            
            # Mark the state as visited
            visited.add(state_tuple)
            
            # Get all possible moves from the current state
            for move in self.get_possible_moves(state):
                # Get the new state after making the move
                new_state = self.move(state, move)
                # Append the new state and the updated path to the queue
                open_list.append((new_state, path + [move]))
        
        # If no solution is found, return None
        return None

# Example usage:
if __name__ == ""__main__"":
    # Initialize the 8-puzzle game with a given initial state
    game = EightPuzzle([[4, 1, 3], [7, 2, 5], [0, 8, 6]])
    # Solve the puzzle
    solution = game.solve()
    print(""Solution:"", solution)
```",0.17274939172749393,0.20163020403840573,0.7727272727272727,0.4,0.5271317784508143,0.5786163522012578,0.27627627627627627,0.3739837354627702,0.7727272727272727,0.4,0.5271317784508143
Llama,36,"from datetime import datetime

class EmailClient:
    def __init__(self, addr, capacity) -> None:
        self.addr = addr
        self.capacity = capacity
        self.inbox = []
    
    def send_to(self, recv, content, size):
        if not recv.is_full_with_one_more_email(size):
            timestamp = datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
            email = {
                ""sender"": self.addr,
                ""receiver"": recv.addr,
                ""content"": content,
                ""size"": size,
                ""time"": timestamp,
                ""state"": ""unread""
            }
            recv.inbox.append(email)
            return True
        else:
            self.clear_inbox(size)
            return False
    
    def fetch(self):
        if len(self.inbox) == 0:
            return None
        for i in range(len(self.inbox)):
            if self.inbox[i]['state'] == ""unread"":
                self.inbox[i]['state'] = ""read""
                return self.inbox[i]
        return None

    def is_full_with_one_more_email(self, size):
        occupied_size = self.get_occupied_size()
        return True if occupied_size + size > self.capacity else False
        
    def get_occupied_size(self):
        occupied_size = 0
        for email in self.inbox:
            occupied_size += email[""size""]
        return occupied_size

    def clear_inbox(self, size):
        if len(self.addr) == 0:
            return
        freed_space = 0
        while freed_space < size and self.inbox:
            email = self.inbox[0]
            freed_space += email['size']
            del self.inbox[0]",ZeroShot,"

```python
from datetime import datetime

class EmailClient:
    def __init__(self, addr, capacity) -> None:
        # Initialize the email address and capacity of the email box
        self.addr = addr
        self.capacity = capacity
        # Initialize an empty list to store emails
        self.emails = []
        # Initialize the total occupied size to 0
        self.occupied_size = 0.0

    def send_to(self, recv, content, size):
        # Check if the receiver's email box has enough space
        if self.is_full_with_one_more_email(size):
            return False
        # Create a new email with the given content and size
        email = {
            ""sender"": self.addr,
            ""receiver"": recv,
            ""content"": content,
            ""size"": size,
            ""timestamp"": datetime.now(),
            ""read"": False
        }
        # Add the email to the email box
        self.emails.append(email)
        # Update the occupied size
        self.occupied_size += size
        return True

    def fetch(self):
        # Find the first unread email in the email box
        for email in self.emails:
            if not email[""read""]:
                # Mark the email as read
                email[""read""] = True
                return email
        # If no unread emails are found, return None
        return None

    def is_full_with_one_more_email(self, size):
        # Check if the email box is full after adding an email of the given size
        return self.occupied_size + size > self.capacity

    def get_occupied_size(self):
        # Return the total occupied size of the email box
        return self.occupied_size

    def clear_inbox(self, size):
        # Sort the emails by timestamp
        self.emails.sort(key=lambda x: x[""timestamp""])
        # Delete the oldest emails until the email box has enough space
        while self.occupied_size + size > self.capacity and self.emails:
            email = self.emails.pop(0)
            self.occupied_size -= email[""size""]
```",0.1282051282051282,0.16884617007803915,0.6265060240963856,0.4642857142857143,0.5333333284439186,0.41134751773049644,0.28292682926829266,0.335260110778008,0.6144578313253012,0.45535714285714285,0.5230769181875082
Llama,37,"class EncryptionUtils:
    def __init__(self, key):
        self.key = key

    def caesar_cipher(self, plaintext, shift):
        ciphertext = """"
        for char in plaintext:
            if char.isalpha():
                if char.isupper():
                    ascii_offset = 65
                else:
                    ascii_offset = 97
                shifted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)
                ciphertext += shifted_char
            else:
                ciphertext += char
        return ciphertext
    
    def vigenere_cipher(self, plain_text):
        encrypted_text = """"
        key_index = 0
        for char in plain_text:
            if char.isalpha():
                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')
                encrypted_char = chr((ord(char.lower()) - ord('a') + shift) % 26 + ord('a'))
                encrypted_text += encrypted_char.upper() if char.isupper() else encrypted_char
                key_index += 1
            else:
                encrypted_text += char
        return encrypted_text

    def rail_fence_cipher(self, plain_text, rails):
        fence = [['\n' for _ in range(len(plain_text))] for _ in range(rails)]
        direction = -1
        row, col = 0, 0

        for char in plain_text:
            if row == 0 or row == rails-1:
                direction = -direction

            fence[row][col] = char
            col += 1
            row += direction

        encrypted_text = ''
        for i in range(rails):
            for j in range(len(plain_text)):
                if fence[i][j] != '\n':
                    encrypted_text += fence[i][j]

        return encrypted_text",ZeroShot,"

```python
# This is a class that provides methods for encryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.

class EncryptionUtils:
    def __init__(self, key):
        # Initializes the class with a key.
        self.key = key

    def caesar_cipher(self, plaintext, shift):
        # Encrypts the plaintext using the Caesar cipher.
        # Convert the plaintext to lowercase and remove non-alphabetic characters.
        plaintext = ''.join(filter(str.isalpha, plaintext)).lower()
        
        # Initialize an empty string to store the ciphertext.
        ciphertext = """"
        
        # Iterate over each character in the plaintext.
        for char in plaintext:
            # Calculate the ASCII value of the character after shifting.
            shifted_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))
            
            # Append the shifted character to the ciphertext.
            ciphertext += shifted_char
        
        # Return the ciphertext.
        return ciphertext

    def vigenere_cipher(self, plaintext):
        # Encrypts the plaintext using the Vigenere cipher.
        # Convert the plaintext and key to lowercase and remove non-alphabetic characters.
        plaintext = ''.join(filter(str.isalpha, plaintext)).lower()
        key = ''.join(filter(str.isalpha, self.key)).lower()
        
        # Initialize an empty string to store the ciphertext.
        ciphertext = """"
        
        # Initialize a counter to keep track of the current position in the key.
        key_index = 0
        
        # Iterate over each character in the plaintext.
        for char in plaintext:
            # Calculate the shift value based on the current character in the key.
            shift = ord(key[key_index]) - ord('a')
            
            # Calculate the ASCII value of the character after shifting.
            shifted_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))
            
            # Append the shifted character to the ciphertext.
            ciphertext += shifted_char
            
            # Move to the next character in the key.
            key_index = (key_index + 1) % len(key)
        
        # Return the ciphertext.
        return ciphertext

    def rail_fence_cipher(self, plain_text, rails):
        # Encrypts the plaintext using the Rail Fence cipher.
        # Initialize a list of lists to represent the rails.
        rail = [''] * rails
        
        # Initialize variables to keep track of the current rail and direction.
        dir_down = False
        row, col = 0, 0
        
        # Iterate over each character in the plaintext.
        for char in plain_text:
            # Append the character to the current rail.
            rail[row] += char
            
            # If we are at the top or bottom rail, change direction.
            if row == 0:
                dir_down = True
            elif row == rails - 1:
                dir_down = False
            
            # Move to the next rail based on the current direction.
            row += 1 if dir_down else -1
        
        # Initialize an empty string to store the ciphertext.
        ciphertext = """"
        
        # Iterate over each rail and append its characters to the ciphertext.
        for i in range(rails):
            ciphertext += rail[i]
        
        # Return the ciphertext.
        return ciphertext

# Example usage:
utils = EncryptionUtils(""key"")
print(utils.caesar_cipher(""Hello, World!"", 3))
print(utils.vigenere_cipher(""Attack at dawn""))
print(utils.rail_fence_cipher(""WEAREDISCOVEREDSAVEYOURSELF"", 3))
```",0.0850574712643678,0.10845468318635096,0.6172839506172839,0.3246753246753247,0.4255319103760978,0.3541666666666667,0.1881918819188192,0.2457831279983743,0.5925925925925926,0.3116883116883117,0.40851063378035307
Llama,38,"import openpyxl


class ExcelProcessor:
    def __init__(self):
        pass

    def read_excel(self, file_name):
        data = []
        try:
            workbook = openpyxl.load_workbook(file_name)
            sheet = workbook.active
            for row in sheet.iter_rows(values_only=True):
                data.append(row)
            workbook.close()
            return data
        except:
            return None

    def write_excel(self, data, file_name):
        try:
            workbook = openpyxl.Workbook()
            sheet = workbook.active
            for row in data:
                sheet.append(row)
            workbook.save(file_name)
            workbook.close()
            return 1
        except:
            return 0

    def process_excel_data(self, N, save_file_name):
        data = self.read_excel(save_file_name)
        if data is None or N >= len(data[0]):
            return 0
        new_data = []
        for row in data:
            new_row = list(row[:])
            if not str(row[N]).isdigit():
                new_row.append(str(row[N]).upper())
            else:
                new_row.append(row[N])
            new_data.append(new_row)
        new_file_name = save_file_name.split('.')[0] + '_process.xlsx'
        success = self.write_excel(new_data, new_file_name)
        return success, new_file_name",ZeroShot,"

```python
# This is a class for processing excel files, including reading and writing excel data, 
# as well as processing specific operations and saving as a new excel file.

import openpyxl

class ExcelProcessor:
    def __init__(self):
        # Initialize an empty workbook
        self.workbook = None
        self.data = None

    def read_excel(self, file_name):
        """"""
        Reading data from Excel files
        :return: list of data, Data in Excel
        """"""
        try:
            # Load the workbook from the specified file
            self.workbook = openpyxl.load_workbook(file_name)
            # Select the first sheet
            sheet = self.workbook.active
            # Read data from the sheet
            self.data = [[cell.value for cell in row] for row in sheet.rows]
            return self.data
        except Exception as e:
            # Handle exceptions
            print(f""Error reading Excel file: {e}"")
            return None

    def write_excel(self, data, file_name):
        """"""
        Write data to the specified Excel file
        :return: 0 or 1, 1 represents successful writing, 0 represents failed writing
        """"""
        try:
            # Create a new workbook
            self.workbook = openpyxl.Workbook()
            # Select the first sheet
            sheet = self.workbook.active
            # Write data to the sheet
            for i, row in enumerate(data):
                for j, cell in enumerate(row):
                    sheet.cell(row=i+1, column=j+1).value = cell
            # Save the workbook to the specified file
            self.workbook.save(file_name)
            return 1
        except Exception as e:
            # Handle exceptions
            print(f""Error writing Excel file: {e}"")
            return 0

    def process_excel_data(self, N, save_file_name):
        """"""
        Change the specified column in the Excel file to uppercase
        :return: (int, str), The former is the return value of write_excel, 
                 while the latter is the saved file name of the processed data
        """"""
        if self.data is None:
            # Check if data has been read
            print(""No data to process. Please read an Excel file first."")
            return None
        try:
            # Process the data by converting the specified column to uppercase
            for row in self.data:
                if len(row) > N:
                    row[N] = str(row[N]).upper()
            # Write the processed data to a new Excel file
            result = self.write_excel(self.data, save_file_name)
            return result, save_file_name
        except Exception as e:
            # Handle exceptions
            print(f""Error processing Excel data: {e}"")
            return None
```",0.04702194357366772,0.06941442652107921,0.5454545454545454,0.26666666666666666,0.3582089508130987,0.32323232323232326,0.12121212121212122,0.17630853597796153,0.5454545454545454,0.26666666666666666,0.3582089508130987
Llama,39,"import re
from collections import deque
from decimal import Decimal


class ExpressionCalculator:
    def __init__(self):
        self.postfix_stack = deque()
        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]

    def calculate(self, expression):
        self.prepare(self.transform(expression))

        result_stack = deque()
        self.postfix_stack.reverse()

        while self.postfix_stack:
            current_op = self.postfix_stack.pop()
            if not self.is_operator(current_op):
                current_op = current_op.replace(""~"", ""-"")
                result_stack.append(current_op)
            else:
                second_value = result_stack.pop()
                first_value = result_stack.pop()

                first_value = first_value.replace(""~"", ""-"")
                second_value = second_value.replace(""~"", ""-"")

                temp_result = self._calculate(first_value, second_value, current_op)
                result_stack.append(str(temp_result))

        return float(eval(""*"".join(result_stack)))

    def prepare(self, expression):
        op_stack = deque([','])
        arr = list(expression)
        current_index = 0
        count = 0

        for i, current_op in enumerate(arr):
            if self.is_operator(current_op):
                if count > 0:
                    self.postfix_stack.append("""".join(arr[current_index: current_index + count]))
                peek_op = op_stack[-1]
                if current_op == ')':
                    while op_stack[-1] != '(':
                        self.postfix_stack.append(str(op_stack.pop()))
                    op_stack.pop()
                else:
                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):
                        self.postfix_stack.append(str(op_stack.pop()))
                        peek_op = op_stack[-1]
                    op_stack.append(current_op)

                count = 0
                current_index = i + 1
            else:
                count += 1

        if count > 1 or (count == 1 and not self.is_operator(arr[current_index])):
            self.postfix_stack.append("""".join(arr[current_index: current_index + count]))

        while op_stack[-1] != ',':
            self.postfix_stack.append(str(op_stack.pop()))

    @staticmethod
    def is_operator(c):
        return c in {'+', '-', '*', '/', '(', ')', '%'}

    def compare(self, cur, peek):
        if cur == '%':
            cur = '/'
        if peek == '%':
            peek = '/'
        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]

    @staticmethod
    def _calculate(first_value, second_value, current_op):
        if current_op == '+':
            return Decimal(first_value) + Decimal(second_value)
        elif current_op == '-':
            return Decimal(first_value) - Decimal(second_value)
        elif current_op == '*':
            return Decimal(first_value) * Decimal(second_value)
        elif current_op == '/':
            return Decimal(first_value) / Decimal(second_value)
        elif current_op == '%':
            return Decimal(first_value) % Decimal(second_value)
        else:
            raise ValueError(""Unexpected operator: {}"".format(current_op))

    @staticmethod
    def transform(expression):
        expression = re.sub(r""\s+"", """", expression)
        expression = re.sub(r""=$"", """", expression)
        arr = list(expression)

        for i, c in enumerate(arr):
            if c == '-':
                if i == 0:
                    arr[i] = '~'
                else:
                    prev_c = arr[i - 1]
                    if prev_c in {'+', '-', '*', '/', '(', 'E', 'e'}:
                        arr[i] = '~'

        if arr[0] == '~' and (len(arr) > 1 and arr[1] == '('):
            arr[0] = '-'
            return ""0"" + """".join(arr)
        else:
            return """".join(arr)",ZeroShot,"

```python
from collections import deque
from decimal import Decimal

class ExpressionCalculator:
    def __init__(self):
        # Initialize the expression calculator
        self.postfix_stack = deque()
        # Define operator precedence
        self.operat_priority = {'+': 1, '-': 1, '*': 2, '/': 2, '%': 2, '(': 0}

    def calculate(self, expression):
        # Convert infix expression to postfix notation
        postfix_expression = self.prepare(expression)
        
        # Evaluate the postfix expression
        stack = deque()
        for char in postfix_expression:
            if char not in self.operat_priority and char not in ['(', ')']:
                # If the character is a number, push it to the stack
                stack.append(Decimal(char))
            else:
                # If the character is an operator, pop two numbers from the stack, perform the operation, and push the result
                second_value = stack.pop()
                first_value = stack.pop()
                result = self._calculate(first_value, second_value, char)
                stack.append(result)
        
        # The final result is the only element left in the stack
        return stack[0]

    def prepare(self, expression):
        # Transform the infix expression to a format suitable for conversion
        expression = self.transform(expression)
        
        # Initialize an empty stack to store operators
        operator_stack = deque()
        
        # Initialize an empty string to store the postfix expression
        postfix_expression = ''
        
        # Iterate over each character in the expression
        for char in expression:
            if char not in self.operat_priority and char not in ['(', ')']:
                # If the character is a number, add it to the postfix expression
                postfix_expression += char + ' '
            elif char == '(':
                # If the character is an open parenthesis, push it to the operator stack
                operator_stack.append(char)
            elif char == ')':
                # If the character is a close parenthesis, pop operators from the stack and add them to the postfix expression until an open parenthesis is found
                while operator_stack[-1] != '(':
                    postfix_expression += operator_stack.pop() + ' '
                # Remove the open parenthesis from the stack
                operator_stack.pop()
            else:
                # If the character is an operator, pop operators from the stack and add them to the postfix expression until an operator with lower precedence is found
                while operator_stack and operator_stack[-1] != '(' and self.compare(char, operator_stack[-1]):
                    postfix_expression += operator_stack.pop() + ' '
                # Push the current operator to the stack
                operator_stack.append(char)
        
        # Pop any remaining operators from the stack and add them to the postfix expression
        while operator_stack:
            postfix_expression += operator_stack.pop() + ' '
        
        return postfix_expression.strip()

    @staticmethod
    def is_operator(c):
        # Check if a character is an operator in {'+', '-', '*', '/', '(', ')', '%'}
        return c in {'+', '-', '*', '/', '(', ')', '%'}

    def compare(self, cur, peek):
        # Compare the precedence of two operators
        return self.operat_priority[cur] >= self.operat_priority[peek]

    @staticmethod
    def _calculate(first_value, second_value, current_op):
        # Perform the mathematical calculation based on the given operands and operator
        if current_op == '+':
            return first_value + second_value
        elif current_op == '-':
            return first_value - second_value
        elif current_op == '*':
            return first_value * second_value
        elif current_op == '/':
            if second_value == 0:
                raise ZeroDivisionError(""Cannot divide by zero"")
            return first_value / second_value
        elif current_op == '%':
            if second_value == 0:
                raise ZeroDivisionError(""Cannot divide by zero"")
            return first_value % second_value

    @staticmethod
    def transform(expression):
        # Transform the infix expression to a format suitable for conversion
        return expression.replace(' ', '')
```",0.09819639278557116,0.1296493615523854,0.47619047619047616,0.3977272727272727,0.4334365275480451,0.22569444444444445,0.18950437317784258,0.20602218204274161,0.4557823129251701,0.3806818181818182,0.4148606761548563
Llama,40,"class FitnessTracker:
    def __init__(self, height, weight, age, sex) -> None:
        self.height = height
        self.weight = weight
        self.age = age
        self.sex = sex
        self.BMI_std = [
            {""male"": [20, 25]},
            {""female"": [19, 24]}
        ]

    def get_BMI(self):
        return self.weight / self.height ** 2

    def condition_judge(self):
        BMI = self.get_BMI()
        if self.sex == ""male"":
            BMI_range = self.BMI_std[0][""male""]
        else:
            BMI_range = self.BMI_std[1][""female""]
        if BMI > BMI_range[1]:
            # too fat
            return 1
        elif BMI < BMI_range[0]:
            # too thin
            return -1
        else:
            # normal
            return 0

    def calculate_calorie_intake(self):
        if self.sex == ""male"":
            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5
        else:
            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161
        if self.condition_judge() == 1:
            calorie_intake = BMR * 1.2  # Sedentary lifestyle
        elif self.condition_judge() == -1:
            calorie_intake = BMR * 1.6  # Active lifestyle
        else:
            calorie_intake = BMR * 1.4  # Moderate lifestyle
        return calorie_intake",ZeroShot,"

```python
class FitnessTracker:
    def __init__(self, height, weight, age, sex) -> None:
        """"""
        Initialize the class with height, weight, age, and sex, and calculate the BMI standard based on sex, and male is 20-25, female is 19-24.
        """"""
        # Initialize the attributes
        self.height = height  # height in cm
        self.weight = weight  # weight in kg
        self.age = age
        self.sex = sex.lower()  # convert sex to lowercase
        
        # Define the BMI standard based on sex
        if self.sex == 'male':
            self.bmi_standard = (20, 25)
        elif self.sex == 'female':
            self.bmi_standard = (19, 24)
        else:
            raise ValueError(""Invalid sex. Please enter 'male' or 'female'."")

    def get_BMI(self):
        """"""
        Calculate the BMI based on the height and weight.
        :return: BMI, which is the weight divide by the square of height, float.
        """"""
        # Calculate the BMI
        bmi = self.weight / ((self.height / 100) ** 2)
        return bmi

    def condition_judge(self):
        """"""
        Judge the condition of the user based on the BMI standard.
        :return: 1 if the user is too fat, -1 if the user is too thin, 0 if the user is normal, int.
        """"""
        # Get the BMI
        bmi = self.get_BMI()
        
        # Judge the condition based on the BMI standard
        if bmi > self.bmi_standard[1]:
            return 1  # too fat
        elif bmi < self.bmi_standard[0]:
            return -1  # too thin
        else:
            return 0  # normal

    def calculate_calorie_intake(self):
        """"""
        Calculate the calorie intake based on the user's condition and BMR (Basal Metabolic Rate), 
        BMR is calculated based on the user's height, weight, age, and sex, 
        male is 10 * self.weight + 6.25 * self.height - 5 * self.age + 5, 
        female is 10 * self.weight + 6.25 * self.height - 5 * self.age - 161, 
        and the calorie intake is calculated based on the BMR and the user's condition, 
        if the user is too fat, the calorie intake is BMR * 1.2, 
        if the user is too thin, the calorie intake is BMR * 1.6, 
        if the user is normal, the calorie intake is BMR * 1.4.
        :return: calorie intake, float.
        """"""
        # Calculate the BMR based on sex
        if self.sex == 'male':
            bmr = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5
        elif self.sex == 'female':
            bmr = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161
        
        # Judge the condition
        condition = self.condition_judge()
        
        # Calculate the calorie intake based on the condition
        if condition == 1:  # too fat
            calorie_intake = bmr * 1.2
        elif condition == -1:  # too thin
            calorie_intake = bmr * 1.6
        else:  # normal
            calorie_intake = bmr * 1.4
        
        return calorie_intake

# Example usage
tracker = FitnessTracker(170, 60, 25, 'male')
print(""BMI:"", tracker.get_BMI())
print(""Condition:"", tracker.condition_judge())
print(""Calorie intake:"", tracker.calculate_calorie_intake())
```",0.09502262443438914,0.13267804865079535,0.7361111111111112,0.36551724137931035,0.4884792582386545,0.4772727272727273,0.21212121212121213,0.29370628944593874,0.7222222222222222,0.3586206896551724,0.4792626683769034
Llama,41,"class GomokuGame:
    def __init__(self, board_size):
        self.board_size = board_size
        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        return False

    def check_winner(self):
        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]
        for row in range(self.board_size):
            for col in range(self.board_size):
                if self.board[row][col] != ' ':
                    for direction in directions:
                        if self._check_five_in_a_row(row, col, direction):
                            return self.board[row][col]
        return None

    def _check_five_in_a_row(self, row, col, direction):
        dx, dy = direction
        count = 1
        symbol = self.board[row][col]
        for i in range(1, 5):
            new_row = row + dx * i
            new_col = col + dy * i
            if not (0 <= new_row < self.board_size and 0 <= new_col < self.board_size):
                return False
            if self.board[new_row][new_col] != symbol:
                return False
            count += 1
        return count == 5",ZeroShot,"

```python
class GomokuGame:
    def __init__(self, board_size):
        # Initialize the board with empty spaces
        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]
        # Set the current player symbol as 'X'
        self.current_player = 'X'
        # Store the board size for later use
        self.board_size = board_size

    def make_move(self, row, col):
        # Check if the move is within the board boundaries
        if row < 0 or row >= self.board_size or col < 0 or col >= self.board_size:
            return False
        # Check if the cell is already occupied
        if self.board[row][col] != ' ':
            return False
        # Place the current player's symbol on the board
        self.board[row][col] = self.current_player
        # Change the current player to the other player
        self.current_player = 'O' if self.current_player == 'X' else 'X'
        return True

    def check_winner(self):
        # Check all cells on the board for a winner
        for row in range(self.board_size):
            for col in range(self.board_size):
                # Check if the cell is occupied by a player
                if self.board[row][col] != ' ':
                    # Check all directions for five consecutive symbols
                    for direction in [(0, 1), (1, 0), (1, 1), (1, -1)]:
                        if self._check_five_in_a_row(row, col, direction):
                            return self.board[row][col]
        # If no winner is found, return None
        return None

    def _check_five_in_a_row(self, row, col, direction):
        # Get the symbol of the player at the given cell
        symbol = self.board[row][col]
        # Initialize a counter for consecutive symbols
        count = 1
        # Check in the positive direction
        r, c = row + direction[0], col + direction[1]
        while 0 <= r < self.board_size and 0 <= c < self.board_size and self.board[r][c] == symbol:
            count += 1
            r += direction[0]
            c += direction[1]
        # Check in the negative direction
        r, c = row - direction[0], col - direction[1]
        while 0 <= r < self.board_size and 0 <= c < self.board_size and self.board[r][c] == symbol:
            count += 1
            r -= direction[0]
            c -= direction[1]
        # Return True if there are five consecutive symbols, False otherwise
        return count >= 5
```",0.18181818181818182,0.21879063924212314,0.8,0.45528455284552843,0.5803108762060727,0.5547445255474452,0.30522088353413657,0.39378237884064005,0.8,0.45528455284552843,0.5803108762060727
Llama,42,"class Hotel:
    def __init__(self, name, rooms):
        self.name = name
        self.available_rooms = rooms
        # available_rooms = {room_type1: room_number1, room_type2: room_number2, ...}
        # available_rooms = {'single': 5, 'double': 3}
        self.booked_rooms = {}
        # booked_rooms = {room_type1: {name1: room_number1, name2: room_number2, ...}, room_type2: {...}, ...}
        # booked_rooms = {'single': {'name1': 2, 'name2':1}, 'double': {}}

    def book_room(self, room_type, room_number, name):
        # Check if there are any rooms of the specified type available
        if room_type not in self.available_rooms.keys():
            return False

        if room_number <= self.available_rooms[room_type]:
            # Book the room by adding it to the booked_rooms dictionary
            if room_type not in self.booked_rooms.keys():
                self.booked_rooms[room_type] = {}
            self.booked_rooms[room_type][name] = room_number
            self.available_rooms[room_type] -= room_number
            return ""Success!""
        elif self.available_rooms[room_type] != 0:
            return self.available_rooms[room_type]
        else:
            return False

    def check_in(self, room_type, room_number, name):
        # Check if the room of the specified type and number is booked
        if room_type not in self.booked_rooms.keys():
            return False
        if name in self.booked_rooms[room_type]:
            if room_number > self.booked_rooms[room_type][name]:
                return False
            elif room_number == self.booked_rooms[room_type][name]:
                # Check in the room by removing it from the booked_rooms dictionary
                self.booked_rooms[room_type].pop(name)
            else:
                self.booked_rooms[room_type][name] -= room_number


    def check_out(self, room_type, room_number):
        if room_type in self.available_rooms:
            self.available_rooms[room_type] += room_number
        else:
            self.available_rooms[room_type] = room_number

    def get_available_rooms(self, room_type):
        return self.available_rooms[room_type]",ZeroShot,"

```python
class Hotel:
    def __init__(self, name, rooms):
        """"""
        Initialize the three fields in Hotel System.
        name is the hotel name.
        available_rooms stores the remaining rooms in the hotel
        booked_rooms stores the rooms that have been booked and the person's name who booked rooms.
        """"""
        self.name = name  # Hotel name
        self.available_rooms = rooms  # Dictionary with room types and quantities
        self.booked_rooms = {}  # Dictionary with room types and booking information

    def book_room(self, room_type, room_number, name):
        """"""
        Check if there are any rooms of the specified type available.
        if rooms are adequate, modify available_rooms and booked_rooms and finish booking, or fail to book otherwise.
        :return: if number of rooms about to be booked doesn't exceed the remaining rooms, return str 'Success!'
                if exceeds but quantity of available rooms is not equal to zero, return int(the remaining quantity of this room type).
                if exceeds and quantity is zero or the room_type isn't in available_room, return False.
        """"""
        # Check if room type is available
        if room_type not in self.available_rooms:
            return False
        
        # Check if there are enough rooms available
        if self.available_rooms[room_type] < room_number:
            # Return the remaining quantity of this room type
            if self.available_rooms[room_type] > 0:
                return self.available_rooms[room_type]
            else:
                return False
        
        # Update available rooms
        self.available_rooms[room_type] -= room_number
        
        # Update booked rooms
        if room_type not in self.booked_rooms:
            self.booked_rooms[room_type] = {}
        self.booked_rooms[room_type][name] = room_number
        
        return 'Success!'

    def check_in(self, room_type, room_number, name):
        """"""
        Check if the room of the specified type and number is booked by the person named name.
        Remove this name when check in successfuly(room_number is equal to specific person's booked_rooms. When the actual check in quantity (room_number) is less than the booked quantity, number in booked_rooms will be booked quantity minus actual quantity
        :return False: only if the room_type is not in the booked_rooms or room_number is higher than quantity in booked rooms.
        """"""
        # Check if room type is booked
        if room_type not in self.booked_rooms:
            return False
        
        # Check if person has booked rooms of this type
        if name not in self.booked_rooms[room_type]:
            return False
        
        # Check if the room number is valid
        if room_number > self.booked_rooms[room_type][name]:
            return False
        
        # Update booked rooms
        if room_number == self.booked_rooms[room_type][name]:
            del self.booked_rooms[room_type][name]
            if not self.booked_rooms[room_type]:
                del self.booked_rooms[room_type]
        else:
            self.booked_rooms[room_type][name] -= room_number
        
        return True

    def check_out(self, room_type, room_number):
        """"""
        Check out rooms, add number for specific type in available_rooms.
        If room_type is new, add new type in available_rooms.
        """"""
        # Add room number to available rooms
        if room_type in self.available_rooms:
            self.available_rooms[room_type] += room_number
        else:
            self.available_rooms[room_type] = room_number

    def get_available_rooms(self, room_type):
        """"""
        Get the number of specific type of available rooms.
        :return: int, the remaining number of this type rooms.
        """"""
        # Return the number of available rooms of the specified type
        if room_type in self.available_rooms:
            return self.available_rooms[room_type]
        else:
            return 0
```",0.16703296703296702,0.1961608296249266,0.6590909090909091,0.3972602739726027,0.4957264910336768,0.5569620253164557,0.2626865671641791,0.3569979672469338,0.6590909090909091,0.3972602739726027,0.4957264910336768
Llama,43,"class HRManagementSystem:
    def __init__(self):
        self.employees = {}

    def add_employee(self, employee_id, name, position, department, salary):
        if employee_id in self.employees:
            return False
        else:
            self.employees[employee_id] = {
                'name': name,
                'position': position,
                'department': department,
                'salary': salary
            }
            return True

    def remove_employee(self, employee_id):
        if employee_id in self.employees:
            del self.employees[employee_id]
            return True
        else:
            return False

    def update_employee(self, employee_id: int, employee_info: dict):
        employee = self.get_employee(employee_id)
        if employee == False:
            return False
        else:
            for key, value in employee_info.items():
                if key not in employee:
                    return False
            for key, value in employee_info.items():
                employee[key] = value
            return True

    def get_employee(self, employee_id):
        if employee_id in self.employees:
            return self.employees[employee_id]
        else:
            return False

    def list_employees(self):
        employee_data = {}
        if self.employees:
            for employee_id, employee_info in self.employees.items():
                employee_details = {}
                employee_details[""employee_ID""] = employee_id
                for key, value in employee_info.items():
                    employee_details[key] = value
                employee_data[employee_id] = employee_details
        return employee_data",ZeroShot,"

```python
class HRManagementSystem:
    def __init__(self):
        # Initialize the HRManagementSystem with an attribute employees, which is an empty dictionary.
        self.employees = {}

    def add_employee(self, employee_id, name, position, department, salary):
        # Check if the employee is already in the HRManagementSystem.
        if employee_id in self.employees:
            # If the employee is already in the HRManagementSystem, return False.
            return False
        else:
            # If the employee is not in the HRManagementSystem, add the employee and return True.
            self.employees[employee_id] = {
                ""name"": name,
                ""position"": position,
                ""department"": department,
                ""salary"": salary
            }
            return True

    def remove_employee(self, employee_id):
        # Check if the employee is already in the HRManagementSystem.
        if employee_id in self.employees:
            # If the employee is in the HRManagementSystem, remove the employee and return True.
            del self.employees[employee_id]
            return True
        else:
            # If the employee is not in the HRManagementSystem, return False.
            return False

    def update_employee(self, employee_id: int, employee_info: dict):
        # Check if the employee is already in the HRManagementSystem.
        if employee_id in self.employees:
            # If the employee is in the HRManagementSystem, update the employee's information and return True.
            self.employees[employee_id].update(employee_info)
            return True
        else:
            # If the employee is not in the HRManagementSystem, return False.
            return False

    def get_employee(self, employee_id):
        # Check if the employee is already in the HRManagementSystem.
        if employee_id in self.employees:
            # If the employee is in the HRManagementSystem, return the employee's information.
            return self.employees[employee_id]
        else:
            # If the employee is not in the HRManagementSystem, return False.
            return False

    def list_employees(self):
        # Return a list of all employees' information.
        return list(self.employees.values())

# Example usage:
if __name__ == ""__main__"":
    hr_system = HRManagementSystem()
    print(hr_system.add_employee(1, ""John Doe"", ""Software Engineer"", ""IT"", 50000))  # True
    print(hr_system.add_employee(1, ""Jane Doe"", ""Data Scientist"", ""Data"", 60000))  # False
    print(hr_system.get_employee(1))  # {'name': 'John Doe', 'position': 'Software Engineer', 'department': 'IT', 'salary': 50000}
    print(hr_system.update_employee(1, {""position"": ""Senior Software Engineer""}))  # True
    print(hr_system.get_employee(1))  # {'name': 'John Doe', 'position': 'Senior Software Engineer', 'department': 'IT', 'salary': 50000}
    print(hr_system.remove_employee(1))  # True
    print(hr_system.get_employee(1))  # False
    print(hr_system.list_employees())  # []
```",0.11575562700964631,0.142828052522866,0.7241379310344828,0.3652173913043478,0.4855491284907615,0.4095238095238095,0.24855491329479767,0.3093525132847679,0.7241379310344828,0.3652173913043478,0.4855491284907615
Llama,44,"import re
import string
import gensim
from bs4 import BeautifulSoup


class HtmlUtil:

    def __init__(self):
        self.SPACE_MARK = '-SPACE-'
        self.JSON_MARK = '-JSON-'
        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'
        self.URL_MARK = '-URL-'
        self.NUMBER_MARK = '-NUMBER-'
        self.TRACE_MARK = '-TRACE-'
        self.COMMAND_MARK = '-COMMAND-'
        self.COMMENT_MARK = '-COMMENT-'
        self.CODE_MARK = '-CODE-'

    @staticmethod
    def __format_line_feed(text):
        return re.sub(re.compile(r'\n+'), '\n', text)

    def format_line_html_text(self, html_text):
        if html_text is None or len(html_text) == 0:
            return ''
        soup = BeautifulSoup(html_text, 'lxml')

        code_tag = soup.find_all(name=['pre', 'blockquote'])
        for tag in code_tag:
            tag.string = self.CODE_MARK

        ul_ol_group = soup.find_all(name=['ul', 'ol'])
        for ul_ol_item in ul_ol_group:
            li_group = ul_ol_item.find_all('li')
            for li_item in li_group:
                li_item_text = li_item.get_text().strip()
                if len(li_item_text) == 0:
                    continue
                if li_item_text[-1] in string.punctuation:
                    li_item.string = '[{0}]{1}'.format('-', li_item_text)
                    continue
                li_item.string = '[{0}]{1}.'.format('-', li_item_text)

        p_group = soup.find_all(name=['p'])
        for p_item in p_group:
            p_item_text = p_item.get_text().strip()
            if p_item_text:
                if p_item_text[-1] in string.punctuation:
                    p_item.string = p_item_text
                    continue
                next_sibling = p_item.find_next_sibling()
                if next_sibling and self.CODE_MARK in next_sibling.get_text():
                    p_item.string = p_item_text + ':'
                    continue
                p_item.string = p_item_text + '.'

        clean_text = gensim.utils.decode_htmlentities(soup.get_text())
        return self.__format_line_feed(clean_text)

    def extract_code_from_html_text(self, html_text):
        text_with_code_tag = self.format_line_html_text(html_text)

        if self.CODE_MARK not in text_with_code_tag:
            return []

        code_index_start = 0
        soup = BeautifulSoup(html_text, 'lxml')
        code_tag = soup.find_all(name=['pre', 'blockquote'])
        code_count = text_with_code_tag.count(self.CODE_MARK)
        code_list = []
        for code_index in range(code_index_start, code_index_start + code_count):
            code = code_tag[code_index].get_text()
            if code:
                code_list.append(code)
        return code_list",ZeroShot,"

```python
import re
import string
from bs4 import BeautifulSoup

class HtmlUtil:
    def __init__(self):
        # Initialize a series of labels
        self.code_tag = ""-CODE-""
        self.html_tags = [""pre"", ""code""]

    @staticmethod
    def __format_line_feed(text):
        # Replace consecutive line breaks with a single line break
        return re.sub(r'\n+', '\n', text)

    def format_line_html_text(self, html_text):
        # Parse HTML text using BeautifulSoup
        soup = BeautifulSoup(html_text, 'html.parser')
        
        # Find all code elements in the HTML text
        code_elements = soup.find_all(self.html_tags)
        
        # Initialize an empty list to store the extracted code
        codes = []
        
        # Iterate over each code element
        for i, code_element in enumerate(code_elements):
            # Extract the code from the element
            code = code_element.get_text()
            codes.append(code)
            
            # Replace the code element with the code tag
            code_element.replace_with(self.code_tag + str(i))
        
        # Get the text from the BeautifulSoup object
        text = soup.get_text()
        
        # Format the line breaks in the text
        text = self.__format_line_feed(text)
        
        return text, codes

    def extract_code_from_html_text(self, html_text):
        # Parse HTML text using BeautifulSoup
        soup = BeautifulSoup(html_text, 'html.parser')
        
        # Find all code elements in the HTML text
        code_elements = soup.find_all(self.html_tags)
        
        # Initialize an empty list to store the extracted code
        codes = []
        
        # Iterate over each code element
        for code_element in code_elements:
            # Extract the code from the element
            code = code_element.get_text()
            codes.append(code)
        
        return codes
```",0.075,0.09904645522022651,0.26495726495726496,0.3563218390804598,0.3039215637355825,0.12558139534883722,0.18243243243243243,0.14876032574884854,0.26495726495726496,0.3563218390804598,0.3039215637355825
Llama,45,"from PIL import Image, ImageEnhance, ImageChops


class ImageProcessor:
    def __init__(self):
        self.image = None

    def load_image(self, image_path):
        self.image = Image.open(image_path)

    def save_image(self, save_path):
        if self.image:
            self.image.save(save_path)

    def resize_image(self, width, height):
        if self.image:
            self.image = self.image.resize((width, height))

    def rotate_image(self, degrees):
        if self.image:
            self.image = self.image.rotate(degrees)

    def adjust_brightness(self, factor):
        if self.image:
            enhancer = ImageEnhance.Brightness(self.image)
            self.image = enhancer.enhance(factor)",ZeroShot,"

```python
# This is a class to process image, including loading, saving, resizing, rotating, and adjusting the brightness of images.
from PIL import Image, ImageEnhance

class ImageProcessor:
    def __init__(self):
        # Initialize self.image as None
        self.image = None

    def load_image(self, image_path):
        # Use Image util in PIL to open a image
        try:
            self.image = Image.open(image_path)
        except FileNotFoundError:
            print(""File not found. Please check the image path."")

    def save_image(self, save_path):
        # Save image to a path if image has opened
        if self.image is not None:
            self.image.save(save_path)
        else:
            print(""No image has been loaded."")

    def resize_image(self, width, height):
        # Resize the image if image has opened
        if self.image is not None:
            self.image = self.image.resize((width, height))
        else:
            print(""No image has been loaded."")

    def rotate_image(self, degrees):
        # Rotate image if image has opened
        if self.image is not None:
            self.image = self.image.rotate(degrees)
        else:
            print(""No image has been loaded."")

    def adjust_brightness(self, factor):
        # Adjust the brightness of image if image has opened
        if self.image is not None:
            enhancer = ImageEnhance.Brightness(self.image)
            self.image = enhancer.enhance(factor)
        else:
            print(""No image has been loaded."")


# Example usage:
if __name__ == ""__main__"":
    processor = ImageProcessor()
    processor.load_image(""path_to_your_image.jpg"")
    processor.resize_image(800, 600)
    processor.rotate_image(45)
    processor.adjust_brightness(1.5)
    processor.save_image(""processed_image.jpg"")
```",0.1135135135135135,0.128474401166103,0.9210526315789473,0.36082474226804123,0.5185185144735254,0.6923076923076923,0.24161073825503357,0.35820895138833203,0.9210526315789473,0.36082474226804123,0.5185185144735254
Llama,46,"class Interpolation:
    def __init__(self):
        pass

    @staticmethod
    def interpolate_1d(x, y, x_interp):
        y_interp = []
        for xi in x_interp:
            for i in range(len(x) - 1):
                if x[i] <= xi <= x[i+1]:
                    yi = y[i] + (y[i+1] - y[i]) * (xi - x[i]) / (x[i+1] - x[i])
                    y_interp.append(yi)
                    break
        return y_interp
    
    @staticmethod
    def interpolate_2d(x, y, z, x_interp, y_interp):
        z_interp = []
        for xi, yi in zip(x_interp, y_interp):
            for i in range(len(x) - 1):
                if x[i] <= xi <= x[i+1]:
                    for j in range(len(y) - 1):
                        if y[j] <= yi <= y[j+1]:
                            z00 = z[i][j]
                            z01 = z[i][j+1]
                            z10 = z[i+1][j]
                            z11 = z[i+1][j+1]
                            zi = (z00 * (x[i+1] - xi) * (y[j+1] - yi) +
                                  z10 * (xi - x[i]) * (y[j+1] - yi) +
                                  z01 * (x[i+1] - xi) * (yi - y[j]) +
                                  z11 * (xi - x[i]) * (yi - y[j])) / ((x[i+1] - x[i]) * (y[j+1] - y[j]))
                            z_interp.append(zi)
                            break
                    break
        return z_interp",ZeroShot,"

```python
# This is a class that implements the Linear interpolation operation of one-dimensional and two-dimensional data

class Interpolation:
    def __init__(self):
        pass

    @staticmethod
    def interpolate_1d(x, y, x_interp):
        """"""
        Linear interpolation of one-dimensional data
        :return: The y-coordinate of the interpolation point, list.
        """"""
        # Initialize an empty list to store the interpolated y-coordinates
        y_interp = []
        
        # Iterate over each x-coordinate to be interpolated
        for x_val in x_interp:
            # Find the indices of the two x-coordinates in the original data that x_val lies between
            idx = [i for i, val in enumerate(x) if val <= x_val]
            # If x_val is less than the smallest x-coordinate, use the first two points for interpolation
            if not idx:
                idx = [0]
            # If x_val is greater than the largest x-coordinate, use the last two points for interpolation
            elif idx[-1] == len(x) - 1:
                idx = [len(x) - 2]
            else:
                idx = [idx[-1]]
            
            # Calculate the slope of the line segment between the two points
            slope = (y[idx[0] + 1] - y[idx[0]]) / (x[idx[0] + 1] - x[idx[0]])
            
            # Calculate the interpolated y-coordinate using the point-slope form of a line
            y_val = y[idx[0]] + slope * (x_val - x[idx[0]])
            
            # Append the interpolated y-coordinate to the list
            y_interp.append(y_val)
        
        # Return the list of interpolated y-coordinates
        return y_interp

    @staticmethod
    def interpolate_2d(x, y, z, x_interp, y_interp):
        """"""
        Linear interpolation of two-dimensional data
        :return: The z-coordinate of the interpolation point, list.
        """"""
        # Initialize an empty list to store the interpolated z-coordinates
        z_interp = []
        
        # Iterate over each point to be interpolated
        for x_val, y_val in zip(x_interp, y_interp):
            # Find the indices of the four points in the original data that the point (x_val, y_val) lies within
            idx_x = [i for i, val in enumerate(x) if val <= x_val]
            idx_y = [i for i, val in enumerate(y) if val <= y_val]
            
            # If the point is outside the bounds of the data, use the nearest point for interpolation
            if not idx_x:
                idx_x = [0]
            elif idx_x[-1] == len(x) - 1:
                idx_x = [len(x) - 2]
            else:
                idx_x = [idx_x[-1]]
            
            if not idx_y:
                idx_y = [0]
            elif idx_y[-1] == len(y) - 1:
                idx_y = [len(y) - 2]
            else:
                idx_y = [idx_y[-1]]
            
            # Get the z-coordinates of the four points
            z11 = z[idx_x[0], idx_y[0]]
            z12 = z[idx_x[0], idx_y[0] + 1]
            z21 = z[idx_x[0] + 1, idx_y[0]]
            z22 = z[idx_x[0] + 1, idx_y[0] + 1]
            
            # Calculate the interpolated z-coordinate using bilinear interpolation
            z_val = (z11 * (x[idx_x[0] + 1] - x_val) * (y[idx_y[0] + 1] - y_val) +
                     z21 * (x_val - x[idx_x[0]]) * (y[idx_y[0] + 1] - y_val) +
                     z12 * (x[idx_x[0] + 1] - x_val) * (y_val - y[idx_y[0]]) +
                     z22 * (x_val - x[idx_x[0]]) * (y_val - y[idx_y[0]])) / ((x[idx_x[0] + 1] - x[idx_x[0]]) * (y[idx_y[0] + 1] - y[idx_y[0]]))
            
            # Append the interpolated z-coordinate to the list
            z_interp.append(z_val)
        
        # Return the list of interpolated z-coordinates
        return z_interp
```",0.03742203742203742,0.05569380784594814,0.4393939393939394,0.17682926829268292,0.25217390895122876,0.21052631578947367,0.0761904761904762,0.11188810798572071,0.4393939393939394,0.17682926829268292,0.25217390895122876
Llama,47,"class IPAddress:
    def __init__(self, ip_address):
        self.ip_address = ip_address

    def is_valid(self):
        octets = self.ip_address.split('.')
        if len(octets) != 4:
            return False
        for octet in octets:
            if not octet.isdigit() or int(octet) < 0 or int(octet) > 255:
                return False
        return True

    def get_octets(self):
        if self.is_valid():
            return self.ip_address.split('.')
        else:
            return []

    def get_binary(self):
        if self.is_valid():
            binary_octets = []
            for octet in self.get_octets():
                binary_octets.append(format(int(octet), '08b'))
            return '.'.join(binary_octets)
        else:
            return ''",ZeroShot,"

```python
class IPAddress:
    def __init__(self, ip_address):
        # Initialize the IP address to the specified address
        self.ip_address = ip_address

    def is_valid(self):
        # Split the IP address into four parts
        parts = self.ip_address.split('.')
        
        # Check if the IP address has four parts
        if len(parts) != 4:
            return False
        
        # Check each part of the IP address
        for part in parts:
            # Check if the part is a digit
            if not part.isdigit():
                return False
            
            # Convert the part to an integer
            num = int(part)
            
            # Check if the number is between 0 and 255
            if num < 0 or num > 255:
                return False
            
            # Check if the number has a leading zero
            if len(part) > 1 and part[0] == '0':
                return False
        
        # If all checks pass, the IP address is valid
        return True


    def get_octets(self):
        # Check if the IP address is valid
        if not self.is_valid():
            return []
        
        # Split the IP address into four parts and convert each part to an integer
        return [int(part) for part in self.ip_address.split('.')]


    def get_binary(self):
        # Check if the IP address is valid
        if not self.is_valid():
            return ''
        
        # Split the IP address into four parts
        parts = self.ip_address.split('.')
        
        # Convert each part to binary and remove the '0b' prefix
        binary_parts = [bin(int(part))[2:].zfill(8) for part in parts]
        
        # Join the binary parts with '.'
        return '.'.join(binary_parts)
```",0.05909090909090909,0.08244278393396569,0.7209302325581395,0.34444444444444444,0.4661654091582339,0.4626865671641791,0.2,0.2792792750649299,0.7209302325581395,0.34444444444444444,0.4661654091582339
Llama,48,"import socket


class IpUtil:

    @staticmethod
    def is_valid_ipv4(ip_address):
        try:
            socket.inet_pton(socket.AF_INET, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def is_valid_ipv6(ip_address):
        try:
            socket.inet_pton(socket.AF_INET6, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def get_hostname(ip_address):
        try:
            hostname = socket.gethostbyaddr(ip_address)[0]
            return hostname
        except socket.herror:
            return None",ZeroShot,"

```python
# This is a class as tool for ip that can be used to obtain the local IP address, validate its validity, and also provides the functionality to retrieve the corresponding hostname.

import socket
import netifaces
import ipaddress


class IpUtil:

    # Check if the given IP address is a valid IPv4 address.
    @staticmethod
    def is_valid_ipv4(ip_address):
        """"""
        Check if the given IP address is a valid IPv4 address.
        :return: bool, True if the IP address is valid, False otherwise
        """"""
        try:
            # Attempt to create an IPv4 address object
            ipaddress.IPv4Address(ip_address)
            return True
        except ipaddress.AddressValueError:
            # If the address is not valid, return False
            return False

    # Check if the given IP address is a valid IPv6 address.
    @staticmethod
    def is_valid_ipv6(ip_address):
        """"""
        Check if the given IP address is a valid IPv6 address.
        :return: bool, True if the IP address is valid, False otherwise
        """"""
        try:
            # Attempt to create an IPv6 address object
            ipaddress.IPv6Address(ip_address)
            return True
        except ipaddress.AddressValueError:
            # If the address is not valid, return False
            return False

    # Get the hostname associated with the given IP address.
    @staticmethod
    def get_hostname(ip_address):
        """"""
        Get the hostname associated with the given IP address.
        :return: string, the hostname associated with the IP address
        """"""
        try:
            # Use the socket.gethostbyaddr function to get the hostname
            hostname, _, _ = socket.gethostbyaddr(ip_address)
            return hostname
        except socket.herror:
            # If the hostname cannot be found, return None
            return None


# Example usage
if __name__ == ""__main__"":
    ip_address = ""8.8.8.8""
    print(f""Is {ip_address} a valid IPv4 address? {IpUtil.is_valid_ipv4(ip_address)}"")
    print(f""Is {ip_address} a valid IPv6 address? {IpUtil.is_valid_ipv6(ip_address)}"")
    print(f""The hostname for {ip_address} is: {IpUtil.get_hostname(ip_address)}"")
```",0.026819923371647507,0.030938171443102017,0.75,0.17647058823529413,0.2857142826303855,0.42857142857142855,0.09090909090909091,0.14999999711250006,0.75,0.17647058823529413,0.2857142826303855
Llama,49,"class JobMarketplace:
    def __init__(self):
        self.job_listings = []
        self.resumes = []

    def post_job(self, job_title, company, requirements):
        # requirements = ['requirement1', 'requirement2']
        job = {""job_title"": job_title, ""company"": company, ""requirements"": requirements}
        self.job_listings.append(job)

    def remove_job(self, job):
        self.job_listings.remove(job)

    def submit_resume(self, name, skills, experience):
        resume = {""name"": name, ""skills"": skills, ""experience"": experience}
        self.resumes.append(resume)

    def withdraw_resume(self, resume):
        self.resumes.remove(resume)

    def search_jobs(self, criteria):
        matching_jobs = []
        for job_listing in self.job_listings:
            if criteria.lower() in job_listing[""job_title""].lower() or criteria.lower() in [r.lower() for r in job_listing[""requirements""]]:
                matching_jobs.append(job_listing)
        return matching_jobs

    def get_job_applicants(self, job):
        applicants = []
        for resume in self.resumes:
            if self.matches_requirements(resume, job[""requirements""]):
                applicants.append(resume)
        return applicants

    @staticmethod
    def matches_requirements(resume, requirements):
        for skill in resume[""skills""]:
            if skill not in requirements:
                return False
        return True",ZeroShot,"

```python
class JobMarketplace:
    def __init__(self):
        # Initialize empty lists to store job listings and resumes
        self.job_listings = []
        self.resumes = []

    def post_job(self, job_title, company, requirements):
        """"""
        This function is used to publish positions, and add the position information to the job_listings list.
        :return: None
        """"""
        # Create a dictionary to store job information
        job = {
            ""job_title"": job_title,
            ""company"": company,
            ""requirements"": requirements,
            ""applicants"": []
        }
        # Add the job to the job_listings list
        self.job_listings.append(job)

    def remove_job(self, job_title):
        """"""
        This function is used to remove positions, and remove the position information from the job_listings list.
        :return: None
        """"""
        # Iterate over the job_listings list to find the job to be removed
        for job in self.job_listings:
            if job[""job_title""] == job_title:
                # Remove the job from the job_listings list
                self.job_listings.remove(job)
                break

    def submit_resume(self, name, skills, experience):
        """"""
        This function is used to submit resumes, and add the resume information to the resumes list.
        :return: None
        """"""
        # Create a dictionary to store resume information
        resume = {
            ""name"": name,
            ""skills"": skills,
            ""experience"": experience,
            ""applied_jobs"": []
        }
        # Add the resume to the resumes list
        self.resumes.append(resume)

    def withdraw_resume(self, name):
        """"""
        This function is used to withdraw resumes, and remove the resume information from the resumes list.
        :return: None
        """"""
        # Iterate over the resumes list to find the resume to be withdrawn
        for resume in self.resumes:
            if resume[""name""] == name:
                # Remove the resume from the resumes list
                self.resumes.remove(resume)
                break

    def search_jobs(self, criteria):
        """"""
        This function is used to search for positions, and return the position information that meets the requirements.
        :return: The position information that meets the requirements, list.
        """"""
        # Initialize an empty list to store the search results
        search_results = []
        # Iterate over the job_listings list to find jobs that match the search criteria
        for job in self.job_listings:
            if criteria in job[""job_title""] or criteria in job[""company""] or criteria in job[""requirements""]:
                # Add the job to the search results list
                search_results.append(job)
        # Return the search results
        return search_results

    def get_job_applicants(self, job_title):
        """"""
        This function is used to obtain candidate information, and return the candidate information that meets the requirements.
        :return: The candidate information that meets the requirements, list.
        """"""
        # Initialize an empty list to store the applicants
        applicants = []
        # Iterate over the job_listings list to find the job
        for job in self.job_listings:
            if job[""job_title""] == job_title:
                # Iterate over the resumes list to find applicants who match the job requirements
                for resume in self.resumes:
                    if self.matches_requirements(job[""requirements""], resume[""skills""], resume[""experience""]):
                        # Add the applicant to the applicants list
                        applicants.append(resume)
                break
        # Return the applicants
        return applicants

    def matches_requirements(self, requirements, skills, experience):
        """"""
        This function checks if a candidate's skills and experience match the job requirements.
        :return: True if the candidate matches the requirements, False otherwise.
        """"""
        # Iterate over the requirements to check if the candidate has the required skills and experience
        for requirement in requirements:
            if requirement not in skills and requirement not in experience:
                # Return False if the candidate does not match the requirements
                return False
        # Return True if the candidate matches the requirements
        return True


# Example usage:
job_marketplace = JobMarketplace()
job_marketplace.post_job(""Software Engineer"", ""Google"", [""Python"", ""Java"", ""5 years of experience""])
job_marketplace.submit_resume(""John Doe"", [""Python"", ""Java"", ""C++""], ""5 years of experience"")
print(job_marketplace.search_jobs(""Software""))
print(job_marketplace.get_job_applicants(""Software Engineer""))
```",0.04841713221601489,0.06479351544377746,0.6911764705882353,0.30128205128205127,0.4196428529145408,0.46551724137931033,0.17419354838709677,0.25352112279750494,0.6764705882352942,0.2948717948717949,0.4107142814859694
Llama,50,"import json
import os


class JSONProcessor:
    def read_json(self, file_path):
        if not os.path.exists(file_path):
            return 0
        try:
            with open(file_path, 'r') as file:
                data = json.load(file)
            return data
        except:
            return -1

    def write_json(self, data, file_path):
        try:
            with open(file_path, 'w') as file:
                json.dump(data, file)
            return 1
        except:
            return -1

    def process_json(self, file_path, remove_key):
        data = self.read_json(file_path)
        if data == 0 or data == -1:
            return 0
        if remove_key in data:
            del data[remove_key]
            self.write_json(data, file_path)
            return 1
        else:
            return 0",ZeroShot,"

```python
# This is a class to process JSON file, including reading and writing JSON files, as well as processing JSON data by removing a specified key from the JSON object.

import json
import os

class JSONProcessor:
    def read_json(self, file_path):
        """"""
        Read a JSON file and return the data.
        :return: dict, the data from the JSON file if read successfully, or return -1 if an error occurs during the reading process.
                    return 0 if the file does not exist.
        """"""
        # Check if the file exists
        if not os.path.exists(file_path):
            return 0  # Return 0 if the file does not exist
        
        try:
            # Attempt to open and read the JSON file
            with open(file_path, 'r') as file:
                data = json.load(file)
                return data  # Return the data if read successfully
        except Exception as e:
            # Handle any exceptions that occur during the reading process
            print(f""An error occurred: {e}"")
            return -1  # Return -1 if an error occurs

    def write_json(self, data, file_path):
        """"""
        Write data to a JSON file and save it to the given path.
        :return: 1 if the writing process is successful, or -1, if an error occurs during the writing process.
        """"""
        try:
            # Attempt to open and write to the JSON file
            with open(file_path, 'w') as file:
                json.dump(data, file, indent=4)  # Write the data to the file with indentation
                return 1  # Return 1 if the writing process is successful
        except Exception as e:
            # Handle any exceptions that occur during the writing process
            print(f""An error occurred: {e}"")
            return -1  # Return -1 if an error occurs

    def process_json(self, file_path, remove_key):
        """"""
        read a JSON file and process the data by removing a specified key and rewrite the modified data back to the file.
        :return: 1, if the specified key is successfully removed and the data is written back.
                    0, if the file does not exist or the specified key does not exist in the data.
        
        """"""
        # Read the JSON file
        data = self.read_json(file_path)
        
        # Check if the file does not exist or an error occurred during reading
        if data == 0 or data == -1:
            return 0  # Return 0 if the file does not exist or an error occurred
        
        # Check if the specified key exists in the data
        if remove_key not in data:
            return 0  # Return 0 if the specified key does not exist
        
        # Remove the specified key from the data
        del data[remove_key]
        
        # Write the modified data back to the file
        result = self.write_json(data, file_path)
        
        # Return 1 if the writing process is successful, otherwise return 0
        return 1 if result == 1 else 0

# Example usage
if __name__ == ""__main__"":
    processor = JSONProcessor()
    file_path = ""example.json""
    remove_key = ""key_to_remove""
    
    # Create a sample JSON file
    sample_data = {
        ""key1"": ""value1"",
        ""key_to_remove"": ""value2"",
        ""key3"": ""value3""
    }
    processor.write_json(sample_data, file_path)
    
    # Process the JSON file
    result = processor.process_json(file_path, remove_key)
    print(f""Result: {result}"")
```",0.07563025210084033,0.09177796235678451,0.9361702127659575,0.29931972789115646,0.45360824375119574,0.7391304347826086,0.17288135593220338,0.28021977714723467,0.9361702127659575,0.29931972789115646,0.45360824375119574
Llama,51,"import numpy as np


class KappaCalculator:

    @staticmethod
    def kappa(testData, k):
        dataMat = np.mat(testData)
        P0 = 0.0
        for i in range(k):
            P0 += dataMat[i, i] * 1.0
        xsum = np.sum(dataMat, axis=1)
        ysum = np.sum(dataMat, axis=0)
        sum = np.sum(dataMat)
        Pe = float(ysum * xsum) / sum / sum
        P0 = float(P0 / sum * 1.0)
        cohens_coefficient = float((P0 - Pe) / (1 - Pe))
        return cohens_coefficient

    @staticmethod
    def fleiss_kappa(testData, N, k, n):
        dataMat = np.mat(testData, float)
        oneMat = np.ones((k, 1))
        sum = 0.0
        P0 = 0.0
        for i in range(N):
            temp = 0.0
            for j in range(k):
                sum += dataMat[i, j]
                temp += 1.0 * dataMat[i, j] ** 2
            temp -= n
            temp /= (n - 1) * n
            P0 += temp
        P0 = 1.0 * P0 / N
        ysum = np.sum(dataMat, axis=0)
        for i in range(k):
            ysum[0, i] = (ysum[0, i] / sum) ** 2
        Pe = ysum * oneMat * 1.0
        ans = (P0 - Pe) / (1 - Pe)
        return ans[0, 0]",ZeroShot,"

```python
import numpy as np

class KappaCalculator:

    @staticmethod
    def kappa(testData, k):
        """"""
        Calculate the cohens kappa value of a k-dimensional matrix
        :return: float, the cohens kappa value of the matrix
        """"""
        # Calculate the observed agreement
        po = np.sum(np.diag(testData)) / np.sum(testData)
        
        # Calculate the expected agreement
        pe = np.sum(np.sum(testData, axis=0) * np.sum(testData, axis=1)) / (np.sum(testData) ** 2)
        
        # Calculate Cohen's kappa
        kappa = (po - pe) / (1 - pe)
        
        return kappa

    @staticmethod
    def fleiss_kappa(testData, N, k, n):
        """"""
        Calculate the fliss kappa value of an N * k matrix
        :return: float, fleiss kappa value
        """"""
        # Calculate the proportion of raters that assigned each category to each item
        proportions = np.sum(testData, axis=0) / (N * n)
        
        # Calculate the proportion of items that were assigned to each category
        item_proportions = np.sum(testData, axis=1) / n
        
        # Calculate the expected proportion of agreement for each category
        expected_proportions = np.sum(item_proportions ** 2)
        
        # Calculate the observed proportion of agreement for each category
        observed_proportions = np.sum(proportions ** 2)
        
        # Calculate Fleiss' kappa
        kappa = (observed_proportions - expected_proportions) / (1 - expected_proportions)
        
        return kappa
```",0.07821229050279328,0.10496309014110182,0.3611111111111111,0.32098765432098764,0.3398692760630527,0.12307692307692308,0.12121212121212122,0.12213739958044424,0.3611111111111111,0.32098765432098764,0.3398692760630527
Llama,52,"import nltk
from nltk.stem import WordNetLemmatizer
from nltk import pos_tag, word_tokenize
import string

nltk.download('averaged_perceptron_tagger')
nltk.download('punkt')
nltk.download('wordnet')


class Lemmatization:
    def __init__(self):
        self.lemmatizer = WordNetLemmatizer()

    def lemmatize_sentence(self, sentence):
        lemmatized_words = []
        sentence = self.remove_punctuation(sentence)
        words = word_tokenize(sentence)
        tagged_words = pos_tag(words)
        for word, tag in tagged_words:
            if tag.startswith('V'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='v')
            elif tag.startswith('J'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='a')
            elif tag.startswith('R'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='r')
            else:
                lemmatized_word = self.lemmatizer.lemmatize(word)
            lemmatized_words.append(lemmatized_word)
        return lemmatized_words

    def get_pos_tag(self, sentence):
        pos_tags = []
        sentence = self.remove_punctuation(sentence)
        words = word_tokenize(sentence)
        tagged_words = pos_tag(words)
        for tagged_word in tagged_words:
            pos_tags.append(tagged_word[1])
        return pos_tags

    def remove_punctuation(self, sentence):
        return sentence.translate(str.maketrans('', '', string.punctuation))",ZeroShot,"

```python
import nltk
from nltk.stem import WordNetLemmatizer
from nltk import pos_tag, word_tokenize
import string

# Download required NLTK resources
nltk.download('averaged_perceptron_tagger')
nltk.download('punkt')
nltk.download('wordnet')

class Lemmatization:
    def __init__(self):
        # Create a WordNetLemmatizer object
        self.lemmatizer = WordNetLemmatizer()

    def lemmatize_sentence(self, sentence):
        # Remove punctuation from the sentence
        sentence_no_punct = self.remove_punctuation(sentence)
        
        # Tokenize the sentence
        tokens = word_tokenize(sentence_no_punct)
        
        # Get part of speech tags for each word
        pos_tags = self.get_pos_tag(sentence_no_punct)
        
        # Initialize an empty list to store lemmatized words
        lemmatized_words = []
        
        # Map part of speech tags to WordNet tags
        for word, pos in zip(tokens, pos_tags):
            # Convert NLTK pos tag to WordNet tag
            if pos.startswith('J'):
                wordnet_pos = 'a'  # Adjective
            elif pos.startswith('V'):
                wordnet_pos = 'v'  # Verb
            elif pos.startswith('N'):
                wordnet_pos = 'n'  # Noun
            elif pos.startswith('R'):
                wordnet_pos = 'r'  # Adverb
            else:
                wordnet_pos = 'n'  # Default to noun
            
            # Lemmatize the word
            lemmatized_word = self.lemmatizer.lemmatize(word, wordnet_pos)
            
            # Add the lemmatized word to the list
            lemmatized_words.append(lemmatized_word)
        
        return lemmatized_words

    def get_pos_tag(self, sentence):
        # Remove punctuation from the sentence
        sentence_no_punct = self.remove_punctuation(sentence)
        
        # Tokenize the sentence
        tokens = word_tokenize(sentence_no_punct)
        
        # Get part of speech tags for each word
        pos_tags = pos_tag(tokens)
        
        # Return a list of part of speech tags
        return [pos[1] for pos in pos_tags]

    def remove_punctuation(self, sentence):
        # Use string translation to remove punctuation
        translator = str.maketrans('', '', string.punctuation)
        return sentence.translate(translator)
```",0.12442396313364054,0.15973695556301684,0.7894736842105263,0.41284403669724773,0.5421686701894326,0.5054945054945055,0.24864864864864866,0.3333333289133061,0.7719298245614035,0.4036697247706422,0.5301204774183481
Llama,53,"import re
import string


class LongestWord:

    def __init__(self):
        self.word_list = []

    def add_word(self, word):
        self.word_list.append(word)

    def find_longest_word(self, sentence):
        longest_word = """"
        sentence = sentence.lower()
        sentence = re.sub('[%s]' % re.escape(string.punctuation), '', sentence)
        sentence = re.split(' ', sentence)
        for word in sentence:
            if word in self.word_list and len(word) > len(longest_word):
                longest_word = word
        return longest_word",ZeroShot,"

```python
import re
import string

class LongestWord:
    def __init__(self):
        # Initialize an empty list to store words
        self.word_list = []

    def add_word(self, word):
        # Append the input word into self.word_list
        self.word_list.append(word)

    def find_longest_word(self, sentence):
        # Remove punctuation marks from the sentence
        sentence_without_punctuation = re.sub('['+string.punctuation+']', '', sentence)
        
        # Split the sentence into a list of words
        words_in_sentence = sentence_without_punctuation.split()
        
        # Initialize the longest word and its length
        longest_word = ''
        max_length = 0
        
        # Iterate over each word in the sentence
        for word in words_in_sentence:
            # Check if the word is in the word list and its length is greater than the current max length
            if word in self.word_list and len(word) > max_length:
                # Update the longest word and its length
                longest_word = word
                max_length = len(word)
        
        # Return the longest word, or an empty string if the word list is empty
        return longest_word
```",0.13380281690140847,0.16388128604905547,0.7368421052631579,0.37333333333333335,0.495575216775002,0.5370370370370371,0.23015873015873015,0.3222222180222223,0.7368421052631579,0.37333333333333335,0.495575216775002
Llama,54,"import random


class MahjongConnect:
    def __init__(self, BOARD_SIZE, ICONS):
        self.BOARD_SIZE = BOARD_SIZE
        self.ICONS = ICONS
        self.board = self.create_board()

    def create_board(self):
        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]
        return board

    def is_valid_move(self, pos1, pos2):
        x1, y1 = pos1
        x2, y2 = pos2

        # Check if positions are within the game board range
        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and 0 <= x2 < self.BOARD_SIZE[
            0] and 0 <= y2 <
                self.BOARD_SIZE[1]):
            return False

        # Check if the two positions are the same
        if pos1 == pos2:
            return False

        # Check if the two positions have the same icon
        if self.board[x1][y1] != self.board[x2][y2]:
            return False

        # Check if there is a valid path between the two positions
        if not self.has_path(pos1, pos2):
            return False

        return True

    def has_path(self, pos1, pos2):
        visited = set()
        stack = [pos1]

        while stack:
            current_pos = stack.pop()
            if current_pos == pos2:
                return True

            if current_pos in visited:
                continue

            visited.add(current_pos)
            x, y = current_pos

            # Check adjacent positions (up, down, left, right)
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                new_x, new_y = x + dx, y + dy
                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:
                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:
                        stack.append((new_x, new_y))

        return False

    def remove_icons(self, pos1, pos2):
        x1, y1 = pos1
        x2, y2 = pos2
        self.board[x1][y1] = ' '
        self.board[x2][y2] = ' '

    def is_game_over(self):
        for row in self.board:
            if any(icon != ' ' for icon in row):
                return False
        return True",ZeroShot,"

```python
import random

class MahjongConnect:
    def __init__(self, BOARD_SIZE, ICONS):
        # Initialize the board size and the icon list
        self.BOARD_SIZE = BOARD_SIZE
        self.ICONS = ICONS
        # Create the game board
        self.board = self.create_board()

    def create_board(self):
        # Create the game board with the given board size and icons
        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]
        return board

    def is_valid_move(self, pos1, pos2):
        # Check if the positions are within the game board range
        if (pos1[0] < 0 or pos1[0] >= self.BOARD_SIZE[0] or pos1[1] < 0 or pos1[1] >= self.BOARD_SIZE[1] or
            pos2[0] < 0 or pos2[0] >= self.BOARD_SIZE[0] or pos2[1] < 0 or pos2[1] >= self.BOARD_SIZE[1]):
            return False
        # Check if the two positions are not the same
        if pos1 == pos2:
            return False
        # Check if the two positions have the same icon
        if self.board[pos1[0]][pos1[1]] != self.board[pos2[0]][pos2[1]]:
            return False
        # Check if there is a valid path between the two positions
        if not self.has_path(pos1, pos2):
            return False
        return True

    def has_path(self, pos1, pos2):
        # Define the possible movements (up, down, left, right)
        movements = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        # Create a queue for BFS and add the first position
        queue = [(pos1, [pos1])]
        # Create a set to store the visited positions
        visited = set()
        while queue:
            # Dequeue the current position and the path
            (current_pos, path) = queue.pop(0)
            # If the current position is the second position, return True
            if current_pos == pos2:
                return True
            # Mark the current position as visited
            visited.add(current_pos)
            # Check all possible movements
            for movement in movements:
                # Calculate the new position
                new_pos = (current_pos[0] + movement[0], current_pos[1] + movement[1])
                # Check if the new position is within the game board range and not visited
                if (0 <= new_pos[0] < self.BOARD_SIZE[0] and 0 <= new_pos[1] < self.BOARD_SIZE[1] and
                    new_pos not in visited):
                    # Check if the new position has the same icon or is empty
                    if self.board[new_pos[0]][new_pos[1]] == self.board[pos1[0]][pos1[1]] or self.board[new_pos[0]][new_pos[1]] == '':
                        # Add the new position to the queue
                        queue.append((new_pos, path + [new_pos]))
        return False

    def remove_icons(self, pos1, pos2):
        # Remove the connected icons on the game board
        self.board[pos1[0]][pos1[1]] = ''
        self.board[pos2[0]][pos2[1]] = ''

    def is_game_over(self):
        # Check if the game is over (i.e., if there are no more icons on the game board)
        for row in self.board:
            for icon in row:
                if icon != '':
                    return False
        return True
```",0.28316326530612246,0.32161148911411813,0.6910569105691057,0.5279503105590062,0.5985915443852907,0.527027027027027,0.37142857142857144,0.4357541850940982,0.6910569105691057,0.5279503105590062,0.5985915443852907
Llama,55,"class Manacher:
    def __init__(self, input_string) -> None:
        self.input_string = input_string

    def palindromic_length(self, center, diff, string):
        if (center - diff == -1 or center + diff == len(string)
                or string[center - diff] != string[center + diff]):
            return 0
        return 1 + self.palindromic_length(center, diff + 1, string)


    def palindromic_string(self):
        max_length = 0

        new_input_string = """"
        output_string = """"

        for i in self.input_string[:len(self.input_string) - 1]:
            new_input_string += i + ""|""
        new_input_string += self.input_string[-1]

        for i in range(len(new_input_string)):

            length =self.palindromic_length(i, 1, new_input_string)

            if max_length < length:
                max_length = length
                start = i

        for i in new_input_string[start - max_length:start + max_length + 1]:
            if i != ""|"":
                output_string += i

        return output_string",ZeroShot,"

```python
# This is a class that implements a Manacher algorithm to find the Longest palindromic substring in a given string.

class Manacher:
    def __init__(self, input_string) -> None:
        """"""
        Initializes the Manacher class with the given input_string.
        """"""
        # Preprocess the input string to handle even-length palindromes
        self.input_string = '#' + '#'.join(input_string) + '#'
        self.length = len(self.input_string)

    def palindromic_length(self, center, diff, string):
        """"""
        Recursively calculates the length of the palindromic substring based on a given center, difference value, and input string.
        :return: The length of the palindromic substring, int.
        """"""
        # Base case: if the difference is 0, return 0
        if diff == 0:
            return 0
        
        # Check if the characters at the current positions are equal
        while center - diff >= 0 and center + diff < self.length and string[center - diff] == string[center + diff]:
            # If they are equal, increase the difference
            diff += 1
        
        # Return the length of the palindromic substring
        return diff - 1

    def palindromic_string(self):
        """"""
        Finds the longest palindromic substring in the given string.
        :return: The longest palindromic substring, str.
        """"""
        # Initialize variables to store the maximum length and center of the longest palindromic substring
        max_length = 0
        center = 0
        
        # Iterate over the string to find the longest palindromic substring
        for i in range(self.length):
            # Calculate the length of the palindromic substring centered at the current position
            length = self.palindromic_length(i, 1, self.input_string)
            
            # Update the maximum length and center if a longer palindromic substring is found
            if length > max_length:
                max_length = length
                center = i
        
        # Extract the longest palindromic substring from the input string
        longest_palindromic_substring = self.input_string[center - max_length:center + max_length + 1]
        
        # Remove the '#' characters from the longest palindromic substring
        longest_palindromic_substring = longest_palindromic_substring.replace('#', '')
        
        # Return the longest palindromic substring
        return longest_palindromic_substring

# Example usage:
manacher = Manacher(""babad"")
print(manacher.palindromic_string())  # Output: ""bab""
```",0.04560260586319219,0.06436684301022985,0.603448275862069,0.26717557251908397,0.37037036611629015,0.2912621359223301,0.1214574898785425,0.17142856727493888,0.5862068965517241,0.2595419847328244,0.35978835553427957
Llama,56,"class MetricsCalculator:
    def __init__(self):
        self.true_positives = 0
        self.false_positives = 0
        self.false_negatives = 0
        self.true_negatives = 0

    def update(self, predicted_labels, true_labels):
        for predicted, true in zip(predicted_labels, true_labels):
            if predicted == 1 and true == 1:
                self.true_positives += 1
            elif predicted == 1 and true == 0:
                self.false_positives += 1
            elif predicted == 0 and true == 1:
                self.false_negatives += 1
            elif predicted == 0 and true == 0:
                self.true_negatives += 1

    def precision(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        if self.true_positives + self.false_positives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_positives)

    def recall(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        if self.true_positives + self.false_negatives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_negatives)

    def f1_score(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        precision = self.precision(predicted_labels, true_labels)
        recall = self.recall(predicted_labels, true_labels)
        if precision + recall == 0.0:
            return 0.0
        return (2 * precision * recall) / (precision + recall)

    def accuracy(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives
        if total == 0:
            return 0.0
        return (self.true_positives + self.true_negatives) / total",ZeroShot,"

```python
class MetricsCalculator:
    def __init__(self):
        # Initialize the number of all four samples to 0
        self.true_positives = 0
        self.false_positives = 0
        self.false_negatives = 0
        self.true_negatives = 0

    def update(self, predicted_labels, true_labels):
        # Update the number of all four samples
        for predicted, true in zip(predicted_labels, true_labels):
            if predicted == 1 and true == 1:
                self.true_positives += 1  # Correctly predicted positive
            elif predicted == 1 and true == 0:
                self.false_positives += 1  # Incorrectly predicted positive
            elif predicted == 0 and true == 1:
                self.false_negatives += 1  # Missed positive
            else:
                self.true_negatives += 1  # Correctly predicted negative

    def precision(self):
        # Calculate precision: true positives / (true positives + false positives)
        if self.true_positives + self.false_positives == 0:
            return 0  # Avoid division by zero
        return self.true_positives / (self.true_positives + self.false_positives)

    def recall(self):
        # Calculate recall: true positives / (true positives + false negatives)
        if self.true_positives + self.false_negatives == 0:
            return 0  # Avoid division by zero
        return self.true_positives / (self.true_positives + self.false_negatives)

    def f1_score(self):
        # Calculate f1 score: harmonic mean of precision and recall
        precision_value = self.precision()
        recall_value = self.recall()
        if precision_value + recall_value == 0:
            return 0  # Avoid division by zero
        return 2 * precision_value * recall_value / (precision_value + recall_value)

    def accuracy(self):
        # Calculate accuracy: (true positives + true negatives) / total
        total = self.true_positives + self.false_positives + self.false_negatives + self.true_negatives
        if total == 0:
            return 0  # Avoid division by zero
        return (self.true_positives + self.true_negatives) / total
```",0.3389121338912134,0.37976762751281445,0.78,0.4588235294117647,0.5777777731138547,0.5963302752293578,0.40625,0.48327137064440795,0.78,0.4588235294117647,0.5777777731138547
Llama,57,"import numpy as np


class MetricsCalculator2:
    def __init__(self):
        pass

    @staticmethod
    def mrr(data):
        if type(data) != list and type(data) != tuple:
            raise Exception(""the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple"")

        if len(data) == 0:
            return 0.0, [0.0]
        if type(data) == tuple:
            (sub_list, total_num) = data
            sub_list = np.array(sub_list)
            if total_num == 0:
                return 0.0, [0.0]
            else:
                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                mr_np = sub_list * ranking_array

                mr = 0.0
                for team in mr_np:
                    if team > 0:
                        mr = team
                        break
                return mr, [mr]

        if type(data) == list:
            separate_result = []
            for (sub_list, total_num) in data:
                sub_list = np.array(sub_list)

                if total_num == 0:
                    mr = 0.0
                else:
                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                    mr_np = sub_list * ranking_array

                    mr = 0.0
                    for team in mr_np:
                        if team > 0:
                            mr = team
                            break

                separate_result.append(mr)
            return np.mean(separate_result), separate_result

    @staticmethod
    def map(data):
        if type(data) != list and type(data) != tuple:
            raise Exception(""the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple"")

        if len(data) == 0:
            return 0.0, [0.0]
        if type(data) == tuple:
            (sub_list, total_num) = data
            sub_list = np.array(sub_list)
            if total_num == 0:
                return 0.0, [0.0]
            else:
                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)

                right_ranking_list = []
                count = 1
                for t in sub_list:
                    if t == 0:
                        right_ranking_list.append(0)
                    else:
                        right_ranking_list.append(count)
                        count += 1

                ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num
                return ap, [ap]

        if type(data) == list:
            separate_result = []
            for (sub_list, total_num) in data:
                sub_list = np.array(sub_list)

                if total_num == 0:
                    ap = 0.0
                else:
                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)

                    right_ranking_list = []
                    count = 1
                    for t in sub_list:
                        if t == 0:
                            right_ranking_list.append(0)
                        else:
                            right_ranking_list.append(count)
                            count += 1

                    ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num

                separate_result.append(ap)
            return np.mean(separate_result), separate_result",ZeroShot,"

```python
import numpy as np

class MetricsCalculator2:
    def __init__(self):
        pass

    @staticmethod
    def mrr(data):
        """"""
        compute the MRR of the input data. MRR is a widely used evaluation index. It is the mean of reciprocal rank.
        :return: if input data is list, return the recall of this list. if the input data is list of list, return the
        average recall on all list. The second return value is a list of precision for each input.
        """"""
        # Check if input data is a list of lists
        if isinstance(data[0], list):
            # Initialize list to store MRR for each sublist
            mrr_list = []
            # Iterate over each sublist
            for sublist in data:
                # Find the index of the first relevant item (assuming relevant items are marked as 1)
                relevant_index = next((i for i, x in enumerate(sublist) if x == 1), None)
                # If a relevant item is found, calculate the reciprocal rank
                if relevant_index is not None:
                    mrr_list.append(1 / (relevant_index + 1))
                # If no relevant item is found, set the reciprocal rank to 0
                else:
                    mrr_list.append(0)
            # Calculate the mean of the reciprocal ranks
            mrr_value = np.mean(mrr_list)
            return mrr_value, mrr_list
        # If input data is a single list
        else:
            # Find the index of the first relevant item (assuming relevant items are marked as 1)
            relevant_index = next((i for i, x in enumerate(data) if x == 1), None)
            # If a relevant item is found, calculate the reciprocal rank
            if relevant_index is not None:
                mrr_value = 1 / (relevant_index + 1)
            # If no relevant item is found, set the reciprocal rank to 0
            else:
                mrr_value = 0
            return mrr_value, [mrr_value]

    @staticmethod
    def map(data):
        """"""
        compute the MAP of the input data. MAP is a widely used evaluation index. It is the mean of AP (average precision).
        :return: if input data is list, return the recall of this list. if the input data is list of list, return the
        average recall on all list. The second return value is a list of precision for each input.
        """"""
        # Check if input data is a list of lists
        if isinstance(data[0], list):
            # Initialize list to store AP for each sublist
            ap_list = []
            # Iterate over each sublist
            for sublist in data:
                # Initialize variables to calculate precision and recall
                relevant_count = 0
                precision_sum = 0
                # Iterate over each item in the sublist
                for i, item in enumerate(sublist):
                    # If the item is relevant (assuming relevant items are marked as 1)
                    if item == 1:
                        relevant_count += 1
                        # Calculate the precision at this point
                        precision = relevant_count / (i + 1)
                        precision_sum += precision
                # If there are relevant items, calculate the average precision
                if relevant_count > 0:
                    ap = precision_sum / relevant_count
                # If there are no relevant items, set the average precision to 0
                else:
                    ap = 0
                ap_list.append(ap)
            # Calculate the mean of the average precisions
            map_value = np.mean(ap_list)
            return map_value, ap_list
        # If input data is a single list
        else:
            # Initialize variables to calculate precision and recall
            relevant_count = 0
            precision_sum = 0
            # Iterate over each item in the list
            for i, item in enumerate(data):
                # If the item is relevant (assuming relevant items are marked as 1)
                if item == 1:
                    relevant_count += 1
                    # Calculate the precision at this point
                    precision = relevant_count / (i + 1)
                    precision_sum += precision
            # If there are relevant items, calculate the average precision
            if relevant_count > 0:
                map_value = precision_sum / relevant_count
            # If there are no relevant items, set the average precision to 0
            else:
                map_value = 0
            return map_value, [map_value]
```",0.020168067226890758,0.042447086706283374,0.4470588235294118,0.2900763358778626,0.351851847078618,0.16551724137931034,0.08695652173913043,0.11401424726558772,0.43529411764705883,0.2824427480916031,0.3425925878193588
Llama,58,"import random

class MinesweeperGame:
    def __init__(self, n, k) -> None:
        self.n = n
        self.k = k
        self.minesweeper_map = self.generate_mine_sweeper_map()
        self.player_map = self.generate_playerMap()
        self.score = 0

    def generate_mine_sweeper_map(self):
        arr = [[0 for row in range(self.n)] for column in range(self.n)]
        for num in range(self.k):
            x = random.randint(0, self.n-1)
            y = random.randint(0, self.n-1)
            arr[y][x] = 'X'
            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-1):
                if arr[y][x+1] != 'X':
                    arr[y][x+1] += 1
            if (x >=1 and x <= self.n-1) and (y >= 0 and y <= self.n-1):
                if arr[y][x-1] != 'X':
                    arr[y][x-1] += 1
            if (x >= 1 and x <= self.n-1) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x-1] != 'X':
                    arr[y-1][x-1] += 1
    
            if (x >= 0 and x <= self.n-2) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x+1] != 'X':
                    arr[y-1][x+1] += 1 
            if (x >= 0 and x <= self.n-1) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x] != 'X':
                    arr[y-1][x] += 1
    
            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x+1] != 'X':
                    arr[y+1][x+1] += 1
            if (x >= 1 and x <= self.n-1) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x-1] != 'X':
                    arr[y+1][x-1] += 1
            if (x >= 0 and x <= self.n-1) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x] != 'X':
                    arr[y+1][x] += 1
        return arr
    
    def generate_playerMap(self):
        arr = [['-' for row in range(self.n)] for column in range(self.n)]
        return arr

    def check_won(self, map):
        for i in range(self.n):
            for j in range(self.n):
                if map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':
                    return False
        return True
    
    def sweep(self, x, y):

        if (self.minesweeper_map[x][y] == 'X'):
            return False
        else:
            self.player_map[x][y] = self.minesweeper_map[x][y]
            self.score += 1
            if self.check_won(self.player_map) == True:
                return True
            return self.player_map",ZeroShot,"

```python
import random

class MinesweeperGame:
    def __init__(self, n, k) -> None:
        # Initialize the size of the board and the number of mines
        self.n = n
        self.k = k
        # Initialize the minesweeper map and the player map
        self.minesweeper_map = self.generate_mine_sweeper_map()
        self.player_map = self.generate_playerMap()

    def generate_mine_sweeper_map(self):
        # Create an empty map with the given size
        map = [['0' for _ in range(self.n)] for _ in range(self.n)]
        # Randomly place the mines
        mines = random.sample(range(self.n * self.n), self.k)
        for mine in mines:
            x, y = mine // self.n, mine % self.n
            map[x][y] = 'X'
        # Calculate the number of mines around each position
        for i in range(self.n):
            for j in range(self.n):
                if map[i][j] != 'X':
                    count = 0
                    for x in range(max(0, i - 1), min(self.n, i + 2)):
                        for y in range(max(0, j - 1), min(self.n, j + 2)):
                            if map[x][y] == 'X':
                                count += 1
                    map[i][j] = str(count)
        return map

    def generate_playerMap(self):
        # Create a map with the given size and all positions unknown
        return [['-' for _ in range(self.n)] for _ in range(self.n)]

    def check_won(self, map):
        # Check if there are just mines in the player map
        for i in range(self.n):
            for j in range(self.n):
                if map[i][j] != 'X' and map[i][j] == '-':
                    return False
        return True

    def sweep(self, x, y):
        # Check if the position is within the board
        if x < 0 or x >= self.n or y < 0 or y >= self.n:
            return False
        # Check if the position is a mine
        if self.minesweeper_map[x][y] == 'X':
            self.player_map[x][y] = 'X'
            return self.check_won(self.player_map)
        # Reveal the position and recursively reveal adjacent positions
        else:
            self.player_map[x][y] = self.minesweeper_map[x][y]
            if self.minesweeper_map[x][y] == '0':
                for i in range(max(0, x - 1), min(self.n, x + 2)):
                    for j in range(max(0, y - 1), min(self.n, y + 2)):
                        if self.player_map[i][j] == '-':
                            self.sweep(i, j)
            return self.check_won(self.player_map)

# Example usage:
game = MinesweeperGame(10, 10)
print(""Minesweeper Map:"")
for row in game.minesweeper_map:
    print(row)
print(""Player Map:"")
for row in game.player_map:
    print(row)
print(game.sweep(5, 5))
```",0.1134969325153374,0.15777598454631,0.6470588235294118,0.41353383458646614,0.5045871512057066,0.38011695906432746,0.24253731343283583,0.2961275578864784,0.6470588235294118,0.41353383458646614,0.5045871512057066
Llama,59,"from datetime import datetime
import numpy as np

class MovieBookingSystem:
    def __init__(self):
        self.movies = []

    def add_movie(self, name, price, start_time, end_time, n):
        movie = {
            'name': name,
            'price': price,
            'start_time': datetime.strptime(start_time, '%H:%M'),
            'end_time': datetime.strptime(end_time, '%H:%M'),
            'seats': np.zeros((n, n))
        }
        self.movies.append(movie)

    def book_ticket(self, name, seats_to_book):
        for movie in self.movies:
            if movie['name'] == name:
                for seat in seats_to_book:
                    if movie['seats'][seat[0]][seat[1]] == 0:
                        movie['seats'][seat[0]][seat[1]] = 1
                    else:
                        return ""Booking failed.""
                return ""Booking success.""
        return ""Movie not found.""


    def available_movies(self, start_time, end_time):
        start_time = datetime.strptime(start_time, '%H:%M')
        end_time = datetime.strptime(end_time, '%H:%M')

        available_movies = []
        for movie in self.movies:
            if start_time <= movie['start_time'] and movie['end_time'] <= end_time:
                available_movies.append(movie['name'])

        return available_movies",ZeroShot,"

```python
from datetime import datetime
import numpy as np

class MovieBookingSystem:
    def __init__(self):
        # Initialize movies as an empty list
        self.movies = []

    def add_movie(self, name, price, start_time, end_time, n):
        # Create a new movie dictionary with given information
        new_movie = {
            'name': name,
            'price': price,
            'start_time': start_time,
            'end_time': end_time,
            # Initialize seats as a 2D array with all zeros
            'seats': np.zeros((n, n))
        }
        # Add the new movie to the list of movies
        self.movies.append(new_movie)

    def book_ticket(self, name, seats_to_book):
        # Find the movie with the given name
        for movie in self.movies:
            if movie['name'] == name:
                # Check if the seats to book are available
                for seat in seats_to_book:
                    if movie['seats'][seat[0], seat[1]] == 1:
                        # If any seat is not available, return booking failed
                        return ""Booking failed.""
                # If all seats are available, mark them as booked
                for seat in seats_to_book:
                    movie['seats'][seat[0], seat[1]] = 1
                # Return booking success
                return ""Booking success.""
        # If the movie is not found, return movie not found
        return ""Movie not found.""

    def available_movies(self, start_time, end_time):
        # Initialize an empty list to store available movie names
        available_movie_names = []
        # Iterate over each movie
        for movie in self.movies:
            # Check if the movie's start time is within the given time range
            if start_time <= movie['start_time'] < end_time:
                # Check if the movie's end time is within the given time range
                if start_time < movie['end_time'] <= end_time:
                    # Add the movie's name to the list of available movie names
                    available_movie_names.append(movie['name'])
        # Return the list of available movie names
        return available_movie_names

# Example usage:
system = MovieBookingSystem()
system.add_movie('Batman', 49.9, datetime(1900, 1, 1, 17, 5), datetime(1900, 1, 1, 19, 25), 3)
print(system.movies)
print(system.book_ticket('Batman', [(0, 0), (0, 1)]))
print(system.book_ticket('Batman', [(0, 0), (0, 1)]))
print(system.available_movies(datetime(1900, 1, 1, 16, 0), datetime(1900, 1, 1, 20, 0)))
```",0.1678082191780822,0.19028373714985714,0.8405797101449275,0.4142857142857143,0.5550239190220004,0.6153846153846154,0.26337448559670784,0.3688760764939499,0.8405797101449275,0.4142857142857143,0.5550239190220004
Llama,60,"import sqlite3


class MovieTicketDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS tickets (
                id INTEGER PRIMARY KEY,
                movie_name TEXT,
                theater_name TEXT,
                seat_number TEXT,
                customer_name TEXT
            )
        ''')
        self.connection.commit()

    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):
        self.cursor.execute('''
            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)
            VALUES (?, ?, ?, ?)
        ''', (movie_name, theater_name, seat_number, customer_name))
        self.connection.commit()

    def search_tickets_by_customer(self, customer_name):
        self.cursor.execute('''
            SELECT * FROM tickets WHERE customer_name = ?
        ''', (customer_name,))
        tickets = self.cursor.fetchall()
        return tickets

    def delete_ticket(self, ticket_id):
        self.cursor.execute('''
            DELETE FROM tickets WHERE id = ?
        ''', (ticket_id,))
        self.connection.commit()",ZeroShot,"

```python
import sqlite3

class MovieTicketDB:
    def __init__(self, db_name):
        # Connect to the SQLite database
        self.conn = sqlite3.connect(db_name)
        # Create a cursor object
        self.cursor = self.conn.cursor()

    def create_table(self):
        # SQL query to create the ""tickets"" table
        query = """"""
            CREATE TABLE IF NOT EXISTS tickets (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                movie_name TEXT,
                theater_name TEXT,
                seat_number TEXT,
                customer_name TEXT
            )
        """"""
        # Execute the query
        self.cursor.execute(query)
        # Commit the changes
        self.conn.commit()

    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):
        # SQL query to insert a new ticket into the ""tickets"" table
        query = """"""
            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)
            VALUES (?, ?, ?, ?)
        """"""
        # Execute the query with the provided values
        self.cursor.execute(query, (movie_name, theater_name, seat_number, customer_name))
        # Commit the changes
        self.conn.commit()

    def search_tickets_by_customer(self, customer_name):
        # SQL query to search for tickets by customer name
        query = """"""
            SELECT * FROM tickets
            WHERE customer_name = ?
        """"""
        # Execute the query with the provided customer name
        self.cursor.execute(query, (customer_name,))
        # Fetch all the rows that match the search criteria
        rows = self.cursor.fetchall()
        # Return the rows
        return rows

    def delete_ticket(self, ticket_id):
        # SQL query to delete a ticket by ticket ID
        query = """"""
            DELETE FROM tickets
            WHERE id = ?
        """"""
        # Execute the query with the provided ticket ID
        self.cursor.execute(query, (ticket_id,))
        # Commit the changes
        self.conn.commit()

# Example usage:
if __name__ == ""__main__"":
    db = MovieTicketDB(""movie_tickets.db"")
    db.create_table()
    db.insert_ticket(""Movie 1"", ""Theater 1"", ""A1"", ""John Doe"")
    db.insert_ticket(""Movie 2"", ""Theater 2"", ""B2"", ""Jane Doe"")
    print(db.search_tickets_by_customer(""John Doe""))
    db.delete_ticket(1)
    print(db.search_tickets_by_customer(""John Doe""))
```",0.1991869918699187,0.22670396059177841,0.921875,0.4645669291338583,0.6178010426644006,0.648936170212766,0.30198019801980197,0.41216215782779403,0.921875,0.4645669291338583,0.6178010426644006
Llama,61,"class MusicPlayer:
    def __init__(self):
        self.playlist = []
        self.current_song = None
        self.volume = 50

    def add_song(self, song):
        self.playlist.append(song)

    def remove_song(self, song):
        if song in self.playlist:
            self.playlist.remove(song)
            if self.current_song == song:
                self.stop()

    def play(self):
        if self.playlist and self.current_song:
            return self.playlist[0]
        elif len(self.playlist): 
            return False

    def stop(self):
        if self.current_song:
            self.current_song = None
            return True
        else:
            return False

    def switch_song(self):
        if self.current_song:
            current_index = self.playlist.index(self.current_song)
            if current_index < len(self.playlist) - 1:
                self.current_song = self.playlist[current_index + 1]
                return True
            else:
                return False
        else:
            return False

    def previous_song(self):
        if self.current_song:
            current_index = self.playlist.index(self.current_song)
            if current_index > 0:
                self.current_song = self.playlist[current_index - 1]
                return True
            else:
                return False
        else:
            return False

    def set_volume(self, volume):
        if 0 <= volume <= 100:
            self.volume = volume
        else:
            return False

    def shuffle(self):
        if self.playlist:
            import random
            random.shuffle(self.playlist)
            return True
        else:
            return False",ZeroShot,"

```python
import random

class MusicPlayer:
    def __init__(self):
        # Initializes the music player with an empty playlist, no current song, and a default volume of 50
        self.playlist = []
        self.current_song = None
        self.volume = 50
        self.current_index = 0

    def add_song(self, song):
        # Adds a song to the playlist
        self.playlist.append(song)
        # If the playlist was empty, set the current song to the newly added song
        if len(self.playlist) == 1:
            self.current_song = song
            self.current_index = 0

    def remove_song(self, song):
        # Removes a song from the playlist
        if song in self.playlist:
            self.playlist.remove(song)
            # If the removed song was the current song, set the current song to None
            if song == self.current_song:
                self.current_song = None
                self.current_index = 0
            # If the removed song was not the current song, but was before the current song in the playlist,
            # decrement the current index to keep the current song correct
            elif self.playlist.index(song) < self.current_index:
                self.current_index -= 1

    def play(self):
        # Plays the current song in the playlist
        if self.current_song is not None:
            print(f""Playing {self.current_song} at volume {self.volume}"")
            return self.current_song
        else:
            print(""No song to play"")
            return False

    def stop(self):
        # Stops the current song in the playlist
        if self.current_song is not None:
            print(f""Stopped {self.current_song}"")
            return True
        else:
            print(""No song to stop"")
            return False

    def switch_song(self):
        # Switches to the next song in the playlist
        if self.current_index < len(self.playlist) - 1:
            self.current_index += 1
            self.current_song = self.playlist[self.current_index]
            print(f""Switched to {self.current_song}"")
            return True
        else:
            print(""No next song"")
            return False

    def previous_song(self):
        # Switches to the previous song in the playlist
        if self.current_index > 0:
            self.current_index -= 1
            self.current_song = self.playlist[self.current_index]
            print(f""Switched to {self.current_song}"")
            return True
        else:
            print(""No previous song"")
            return False

    def set_volume(self, volume):
        # Sets the volume of the music player if the volume is between 0 and 100
        if 0 <= volume <= 100:
            self.volume = volume
            print(f""Volume set to {self.volume}"")
            return True
        else:
            print(""Invalid volume"")
            return False

    def shuffle(self):
        # Shuffles the playlist
        if len(self.playlist) > 0:
            random.shuffle(self.playlist)
            self.current_index = 0
            self.current_song = self.playlist[self.current_index]
            print(""Playlist shuffled"")
            return True
        else:
            print(""Playlist is empty"")
            return False

# Example usage:
music_player = MusicPlayer()
music_player.add_song(""Song 1"")
music_player.add_song(""Song 2"")
music_player.add_song(""Song 3"")
music_player.play()
music_player.switch_song()
music_player.play()
music_player.previous_song()
music_player.play()
music_player.set_volume(75)
music_player.play()
music_player.shuffle()
music_player.play()
```",0.11484593837535015,0.1412240969468187,0.847457627118644,0.373134328358209,0.5181347107809606,0.5865384615384616,0.23461538461538461,0.33516483108320255,0.847457627118644,0.373134328358209,0.5181347107809606
Llama,62,"class NLPDataProcessor:

    def construct_stop_word_list(self):
        stop_word_list = ['a', 'an', 'the']
        return stop_word_list

    def remove_stop_words(self, string_list, stop_word_list):
        answer = []
        for string in string_list:
            string_split = string.split()
            for word in string_split:
                if word in stop_word_list:
                    string_split.remove(word)
            answer.append(string_split)
        return answer

    def process(self, string_list):
        stop_word_list = self.construct_stop_word_list()
        words_list = self.remove_stop_words(string_list, stop_word_list)
        return words_list",ZeroShot,"

```python
class NLPDataProcessor:

    def construct_stop_word_list(self):
        """"""
        Construct a stop word list including 'a', 'an', 'the'.
        :return: a list of stop words
        """"""
        # Define the initial stop words
        stop_words = ['a', 'an', 'the']
        return stop_words

    def remove_stop_words(self, string_list, stop_word_list):
        """"""
        Remove all the stop words from the list of strings.
        :return: a list of words without stop words
        """"""
        # Initialize an empty list to store the result
        result = []
        # Iterate over each string in the list
        for string in string_list:
            # Split the string into words
            words = string.split()
            # Filter out the stop words
            filtered_words = [word for word in words if word.lower() not in stop_word_list]
            # Add the filtered words to the result
            result.extend(filtered_words)
        return result

    def process(self, string_list):
        """"""
        Construct a stop word list including 'a', 'an', 'the', and remove all the stop words from the list of strings.
        :return: a list of words without stop words
        """"""
        # Construct the stop word list
        stop_word_list = self.construct_stop_word_list()
        # Remove the stop words from the string list
        result = self.remove_stop_words(string_list, stop_word_list)
        return result

# Example usage:
if __name__ == ""__main__"":
    processor = NLPDataProcessor()
    string_list = [""I am going to the store"", ""I have an apple""]
    result = processor.process(string_list)
    print(result)
```",0.06896551724137931,0.08175431275961546,0.7941176470588235,0.2967032967032967,0.4319999960396801,0.54,0.17307692307692307,0.26213591865397307,0.7941176470588235,0.2967032967032967,0.4319999960396801
Llama,63,"from collections import Counter
import re

class NLPDataProcessor2:

    def process_data(self, string_list):
        words_list = []
        for string in string_list:
            # Remove non-English letters and convert to lowercase
            processed_string = re.sub(r'[^a-zA-Z\s]', '', string.lower())
            # Split the string into words
            words = processed_string.split()
            words_list.append(words)
        return words_list

    def calculate_word_frequency(self, words_list):
        word_frequency = Counter()
        for words in words_list:
            word_frequency.update(words)
        sorted_word_frequency = dict(sorted(word_frequency.items(), key=lambda x: x[1], reverse=True))
        top_5_word_frequency = dict(list(sorted_word_frequency.items())[:5])
        return top_5_word_frequency

    def process(self, string_list):
        words_list = self.process_data(string_list)
        word_frequency_dict = self.calculate_word_frequency(words_list)
        return word_frequency_dict",ZeroShot,"

```python
import re
from collections import Counter

class NLPDataProcessor2:

    def process_data(self, string_list):
        # Initialize an empty list to store the list of words
        words_list = []
        
        # Iterate over each string in the string list
        for string in string_list:
            # Keep only English letters and spaces in the string
            cleaned_string = re.sub(r'[^a-zA-Z\s]', '', string)
            
            # Convert the string to lower case
            cleaned_string = cleaned_string.lower()
            
            # Split the string into a list of words
            words = cleaned_string.split()
            
            # Add the list of words to the words list
            words_list.append(words)
        
        # Return the list of words
        return words_list

    def calculate_word_frequency(self, words_list):
        # Initialize an empty list to store all words
        all_words = []
        
        # Flatten the list of words into a single list
        for words in words_list:
            all_words.extend(words)
        
        # Calculate the word frequency of each word
        word_frequency = Counter(all_words)
        
        # Sort the word frequency dictionary by value in descending order
        sorted_word_frequency = dict(sorted(word_frequency.items(), key=lambda item: item[1], reverse=True))
        
        # Get the top 5 most frequent words
        top_5_word_frequency = dict(list(sorted_word_frequency.items())[:5])
        
        # Return the top 5 word frequency dictionary
        return top_5_word_frequency

    def process(self, string_list):
        # Process the data
        words_list = self.process_data(string_list)
        
        # Calculate the word frequency
        top_5_word_frequency = self.calculate_word_frequency(words_list)
        
        # Return the top 5 word frequency dictionary
        return top_5_word_frequency

# Example usage:
nlp_data_processor = NLPDataProcessor2()
string_list = [""This is a test string."", ""This string is another test."", ""Test string for NLP.""]
print(nlp_data_processor.process(string_list))
```",0.11555555555555556,0.13772097043949258,0.8070175438596491,0.41818181818181815,0.550898199096418,0.573170731707317,0.25268817204301075,0.35074626440966805,0.8070175438596491,0.41818181818181815,0.550898199096418
Llama,64,"class NumberConverter:
    @staticmethod
    def decimal_to_binary(decimal_num):
        binary_num = bin(decimal_num)[2:]
        return binary_num

    @staticmethod
    def binary_to_decimal(binary_num):
        decimal_num = int(binary_num, 2)
        return decimal_num

    @staticmethod
    def decimal_to_octal(decimal_num):
        octal_num = oct(decimal_num)[2:]
        return octal_num

    @staticmethod
    def octal_to_decimal(octal_num):
        decimal_num = int(octal_num, 8)
        return decimal_num

    @staticmethod
    def decimal_to_hex(decimal_num):
        hex_num = hex(decimal_num)[2:]
        return hex_num

    @staticmethod
    def hex_to_decimal(hex_num):
        decimal_num = int(hex_num, 16)
        return decimal_num",ZeroShot,"

```python
# The class allows to convert decimal to binary, octal and hexadecimal respectively and contrarily
class NumberConverter:
    @staticmethod
    def decimal_to_binary(decimal_num):
        # Convert a number from decimal format to binary format.
        # :return: str, the binary representation of an integer.
        return bin(decimal_num)[2:]  # Remove '0b' prefix from binary string

    @staticmethod
    def binary_to_decimal(binary_num):
        # Convert a number from binary format to decimal format.
        # :return: int, the decimal representation of binary number str.
        return int(binary_num, 2)  # Base 2 for binary conversion

    @staticmethod
    def decimal_to_octal(decimal_num):
        # Convert a number from decimal format to octal format.
        # :return: str, the octal representation of an integer.
        return oct(decimal_num)[2:]  # Remove '0o' prefix from octal string

    @staticmethod
    def octal_to_decimal(octal_num):
        # Convert a number from octal format to decimal format.
        # :return: int, the decimal representation of octal number str.
        return int(octal_num, 8)  # Base 8 for octal conversion

    @staticmethod
    def decimal_to_hex(decimal_num):
        # Convert a number from decimal format to hex format.
        # :return hex_num: str, the hex representation of an integer.
        return hex(decimal_num)[2:]  # Remove '0x' prefix from hex string

    @staticmethod
    def hex_to_decimal(hex_num):
        # Convert a number from hex format to decimal format.
        # :return: int, the decimal representation of hex number str.
        return int(hex_num, 16)  # Base 16 for hex conversion


# Example usage:
if __name__ == ""__main__"":
    decimal_num = 123
    binary_num = NumberConverter.decimal_to_binary(decimal_num)
    print(f""Decimal {decimal_num} to Binary: {binary_num}"")

    octal_num = NumberConverter.decimal_to_octal(decimal_num)
    print(f""Decimal {decimal_num} to Octal: {octal_num}"")

    hex_num = NumberConverter.decimal_to_hex(decimal_num)
    print(f""Decimal {decimal_num} to Hex: {hex_num}"")

    decimal_from_binary = NumberConverter.binary_to_decimal(binary_num)
    print(f""Binary {binary_num} to Decimal: {decimal_from_binary}"")

    decimal_from_octal = NumberConverter.octal_to_decimal(octal_num)
    print(f""Octal {octal_num} to Decimal: {decimal_from_octal}"")

    decimal_from_hex = NumberConverter.hex_to_decimal(hex_num)
    print(f""Hex {hex_num} to Decimal: {decimal_from_hex}"")
```",0.03018867924528302,0.04176642208608407,1.0,0.2403846153846154,0.38759689609999404,0.38095238095238093,0.09302325581395349,0.14953270712551323,0.92,0.22115384615384615,0.35658914416200954
Llama,65,"class NumberWordFormatter:
    def __init__(self):
        self.NUMBER = ["""", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""]
        self.NUMBER_TEEN = [""TEN"", ""ELEVEN"", ""TWELVE"", ""THIRTEEN"", ""FOURTEEN"", ""FIFTEEN"", ""SIXTEEN"", ""SEVENTEEN"",
                            ""EIGHTEEN"",
                            ""NINETEEN""]
        self.NUMBER_TEN = [""TEN"", ""TWENTY"", ""THIRTY"", ""FORTY"", ""FIFTY"", ""SIXTY"", ""SEVENTY"", ""EIGHTY"", ""NINETY""]
        self.NUMBER_MORE = ["""", ""THOUSAND"", ""MILLION"", ""BILLION""]
        self.NUMBER_SUFFIX = [""k"", ""w"", """", ""m"", """", """", ""b"", """", """", ""t"", """", """", ""p"", """", """", ""e""]

    def format(self, x):
        if x is not None:
            return self.format_string(str(x))
        else:
            return """"

    def format_string(self, x):
        lstr, rstr = (x.split('.') + [''])[:2]
        lstrrev = lstr[::-1]
        a = [''] * 5

        if len(lstrrev) % 3 == 1:
            lstrrev += ""00""
        elif len(lstrrev) % 3 == 2:
            lstrrev += ""0""

        lm = """"
        for i in range(len(lstrrev) // 3):
            a[i] = lstrrev[3 * i:3 * i + 3][::-1]
            if a[i] != ""000"":
                lm = self.trans_three(a[i]) + "" "" + self.parse_more(i) + "" "" + lm
            else:
                lm += self.trans_three(a[i])

        xs = f""AND CENTS {self.trans_two(rstr)} "" if rstr else """"
        if not lm.strip():
            return ""ZERO ONLY""
        else:
            return f""{lm.strip()} {xs}ONLY""

    def trans_two(self, s):
        s = s.zfill(2)
        if s[0] == ""0"":
            return self.NUMBER[int(s[-1])]
        elif s[0] == ""1"":
            return self.NUMBER_TEEN[int(s) - 10]
        elif s[1] == ""0"":
            return self.NUMBER_TEN[int(s[0]) - 1]
        else:
            return self.NUMBER_TEN[int(s[0]) - 1] + "" "" + self.NUMBER[int(s[-1])]

    def trans_three(self, s):
        if s[0] == ""0"":
            return self.trans_two(s[1:])
        elif s[1:] == ""00"":
            return f""{self.NUMBER[int(s[0])]} HUNDRED""
        else:
            return f""{self.NUMBER[int(s[0])]} HUNDRED AND {self.trans_two(s[1:])}""

    def parse_more(self, i):
        return self.NUMBER_MORE[i]",ZeroShot,"

```python
class NumberWordFormatter:
    def __init__(self):
        # Initialize a dictionary to store the word representation of numbers from 0 to 19
        self.ones = {
            0: '', 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five',
            6: 'six', 7: 'seven', 8: 'eight', 9: 'nine', 10: 'ten',
            11: 'eleven', 12: 'twelve', 13: 'thirteen', 14: 'fourteen',
            15: 'fifteen', 16: 'sixteen', 17: 'seventeen', 18: 'eighteen', 19: 'nineteen'
        }
        # Initialize a dictionary to store the word representation of tens
        self.tens = {
            0: '', 1: 'ten', 2: 'twenty', 3: 'thirty', 4: 'forty', 5: 'fifty',
            6: 'sixty', 7: 'seventy', 8: 'eighty', 9: 'ninety'
        }
        # Initialize a dictionary to store the word representation of thousands, millions, and billions
        self.scales = {
            0: '', 1: 'thousand', 2: 'million', 3: 'billion'
        }

    def format(self, x):
        # Convert a number into words format
        return self.format_string(str(x))

    def format_string(self, x):
        # Convert a string representation of a number into words format
        # Split the number into integer and decimal parts
        parts = x.split('.')
        integer_part = parts[0]
        decimal_part = parts[1] if len(parts) > 1 else ''
        
        # Format the integer part
        integer_words = self.format_integer(integer_part)
        
        # Format the decimal part
        decimal_words = self.format_decimal(decimal_part)
        
        # Combine the integer and decimal parts
        if decimal_words:
            return f""{integer_words} point {decimal_words}""
        else:
            return integer_words

    def trans_two(self, s):
        # Convert a two-digit number into words format
        # If the number is less than 20, return its word representation directly
        if int(s) < 20:
            return self.ones[int(s)]
        # If the number is 20 or more, return the word representation of its tens and ones places
        else:
            return self.tens[int(s[0])] + ('' if int(s[1]) == 0 else ' ' + self.ones[int(s[1])])

    def trans_three(self, s):
        # Convert a three-digit number into words format
        # If the number is less than 100, return its word representation using trans_two
        if int(s) < 100:
            return self.trans_two(s)
        # If the number is 100 or more, return the word representation of its hundreds place and the rest
        else:
            return self.ones[int(s[0])] + ' hundred' + ('' if int(s[1:]) == 0 else ' and ' + self.trans_two(s[1:]))

    def parse_more(self, i):
        # Parse the thousand/million/billion suffix based on the index
        if i == 0:
            return ''
        else:
            return ' ' + self.scales[i]

    def format_integer(self, s):
        # Format the integer part of a number
        # Split the number into groups of three digits
        groups = []
        while s:
            groups.append(s[-3:])
            s = s[:-3]
        
        # Format each group and combine them
        words = ''
        for i in range(len(groups)):
            group = groups[-1 - i]
            # If the group is not empty, format it and add the corresponding suffix
            if group != '000':
                group_words = self.trans_three(group)
                words = group_words + self.parse_more(i) + ('' if words == '' else ' ') + words
        return words

    def format_decimal(self, s):
        # Format the decimal part of a number
        # Convert each digit to its word representation
        words = ' '.join(self.ones[int(d)] for d in s)
        return words
```",0.01890756302521008,0.02421057986931688,0.2571428571428571,0.17307692307692307,0.20689654691504833,0.1187214611872146,0.07262569832402235,0.09012131244787953,0.2571428571428571,0.17307692307692307,0.20689654691504833
Llama,66,"class NumericEntityUnescaper:
    def __init__(self):
        pass

    def replace(self, string):
        out = []
        pos = 0
        length = len(string)

        while pos < length - 2:
            if string[pos] == '&' and string[pos + 1] == '#':
                start = pos + 2
                is_hex = False
                first_char = string[start]

                if first_char == 'x' or first_char == 'X':
                    start += 1
                    is_hex = True

                if start == length:
                    return ''.join(out)

                end = start
                while end < length and self.is_hex_char(string[end]):
                    end += 1

                if end < length and string[end] == ';':
                    try:
                        entity_value = int(string[start:end], 16 if is_hex else 10)
                    except:
                        return ''.join(out)

                    out.append(chr(entity_value))
                    pos = end + 1
                    continue

            out.append(string[pos])
            pos += 1

        return ''.join(out)

    @staticmethod
    def is_hex_char(char):
        return char.isdigit() or ('a' <= char.lower() <= 'f')",ZeroShot,"

```python
# This is a class that provides functionality to replace numeric entities with their corresponding characters in a given string.

class NumericEntityUnescaper:
    def __init__(self):
        # Initialize an empty dictionary to store the mapping of numeric entities to their corresponding Unicode characters
        pass

    def replace(self, string):
        """"""
        Replaces numeric character references (HTML entities) in the input string with their corresponding Unicode characters.
        :return: str, the input string with numeric character references replaced with their corresponding Unicode characters.
        """"""
        # Import the html module which has a function to unescape HTML entities
        import html
        # Use the unescape function from the html module to replace numeric character references with their corresponding Unicode characters
        return html.unescape(string)

    @staticmethod
    def is_hex_char(char):
        """"""
        Determines whether a given character is a hexadecimal digit.
        :return: bool, True if the character is a hexadecimal digit, False otherwise.
        """"""
        # Check if the character is a digit (0-9) or a letter (a-f or A-F)
        return char.isdigit() or (char.lower() >= 'a' and char.lower() <= 'f')

# Example usage:
unescaper = NumericEntityUnescaper()
print(unescaper.replace(""Hello &#x4F60;&#x597D;""))  # Output: Hello 
print(NumericEntityUnescaper.is_hex_char('A'))  # Output: True
print(NumericEntityUnescaper.is_hex_char('G'))  # Output: False
```",0.03825136612021859,0.04475842975155201,0.3181818181818182,0.21212121212121213,0.2545454497454546,0.13157894736842105,0.09740259740259741,0.11194029361884629,0.3181818181818182,0.21212121212121213,0.2545454497454546
Llama,67,"class Order:

    def __init__(self):
        self.menu = []
        # menu = [{""dish"": dish name, ""price"": price, ""count"": count}, ...]
        self.selected_dishes = []
        # selected_dish = {""dish"": dish name, ""count"": count, price: price}
        self.sales = {}
        # 


    def add_dish(self, dish):
        for menu_dish in self.menu:
            if dish[""dish""] == menu_dish[""dish""]:
                if menu_dish[""count""] < dish[""count""]:
                    return False
                else:
                    menu_dish[""count""] -= dish[""count""]
                    break
        self.selected_dishes.append(dish)
        return True

    def calculate_total(self):
        total = 0
        for dish in self.selected_dishes:
            total += dish[""price""] * dish[""count""] * self.sales[dish[""dish""]]
        return total

    def checkout(self):
        if len(self.selected_dishes) == 0:
            return False
        total = self.calculate_total()
        self.selected_dishes = []
        return total",ZeroShot,"

```python
class Order:
    def __init__(self, menu=None):
        # Initialize the order management system
        # self.menu stores the dishes of restaurant inventory
        # self.selected_dishes stores the dishes that have been ordered
        self.menu = menu if menu else {}
        self.selected_dishes = {}

    def add_dish(self, dish, count=1):
        # Check the self.menu and add into self.selected_dish if the dish count is valid
        # And if the dish has successfully been added, change the count in self.menu
        # :return: True if successfully added, or False otherwise
        if dish in self.menu and self.menu[dish]['count'] >= count:
            if dish in self.selected_dishes:
                self.selected_dishes[dish]['count'] += count
            else:
                self.selected_dishes[dish] = {'price': self.menu[dish]['price'], 'sales': self.menu[dish]['sales'], 'count': count}
            self.menu[dish]['count'] -= count
            return True
        return False

    def calculate_total(self):
        # Calculate the total price of dishes that have been ordered
        # Multiply the count, price and sales
        # :return total: float, the final total price
        total = 0
        for dish, details in self.selected_dishes.items():
            total += details['count'] * details['price'] * (1 - details['sales'])
        return total

    def checkout(self):
        # Check out the dishes ordered
        # IF the self.selected_dishes is not empty, invoke the calculate_total method to check out
        # :return False if the self.selected_dishes is empty, or total(return value of calculate_total) otherwise
        if not self.selected_dishes:
            return False
        return self.calculate_total()


# Example usage:
menu = {
    'dish1': {'price': 10.0, 'sales': 0.1, 'count': 10},
    'dish2': {'price': 20.0, 'sales': 0.2, 'count': 5},
}

order = Order(menu)
order.add_dish('dish1', 2)
order.add_dish('dish2', 1)
print(order.checkout())
```",0.026200873362445417,0.04649151665721332,0.5084745762711864,0.24390243902439024,0.3296703252886125,0.2391304347826087,0.1004566210045662,0.1414790955122467,0.4915254237288136,0.23577235772357724,0.3186813142996015
Llama,68,"class PageUtil:
    def __init__(self, data, page_size):
        self.data = data
        self.page_size = page_size
        self.total_items = len(data)
        self.total_pages = (self.total_items + page_size - 1) // page_size

    def get_page(self, page_number):
        if page_number < 1 or page_number > self.total_pages:
            return []

        start_index = (page_number - 1) * self.page_size
        end_index = start_index + self.page_size
        return self.data[start_index:end_index]

    def get_page_info(self, page_number):
        if page_number < 1 or page_number > self.total_pages:
            return {}

        start_index = (page_number - 1) * self.page_size
        end_index = min(start_index + self.page_size, self.total_items)
        page_data = self.data[start_index:end_index]

        page_info = {
            ""current_page"": page_number,
            ""per_page"": self.page_size,
            ""total_pages"": self.total_pages,
            ""total_items"": self.total_items,
            ""has_previous"": page_number > 1,
            ""has_next"": page_number < self.total_pages,
            ""data"": page_data
        }
        return page_info

    def search(self, keyword):
        results = [item for item in self.data if keyword in str(item)]
        num_results = len(results)
        num_pages = (num_results + self.page_size - 1) // self.page_size

        search_info = {
            ""keyword"": keyword,
            ""total_results"": num_results,
            ""total_pages"": num_pages,
            ""results"": results
        }
        return search_info",ZeroShot,"

```python
class PageUtil:
    def __init__(self, data, page_size):
        # Initialize the PageUtil object with the given data and page size
        self.data = data
        self.page_size = page_size

    def get_page(self, page_number):
        # Calculate the start and end indices for the specified page
        start_index = (page_number - 1) * self.page_size
        end_index = page_number * self.page_size
        
        # Return the data on the specified page
        return self.data[start_index:end_index]

    def get_page_info(self, page_number):
        # Calculate the total number of pages
        total_pages = -(-len(self.data) // self.page_size)  # Ceiling division
        
        # Retrieve information about the specified page
        page_info = {
            'current_page': page_number,
            'total_pages': total_pages,
            'page_size': self.page_size,
            'total_items': len(self.data)
        }
        
        return page_info

    def search(self, keyword):
        # Search for items in the data that contain the given keyword
        matching_items = [item for item in self.data if keyword.lower() in str(item).lower()]
        
        # Return search information
        search_info = {
            'keyword': keyword,
            'total_results': len(matching_items),
            'matching_items': matching_items
        }
        
        return search_info
```",0.22536882546028694,0.2587097704016436,0.5405405405405406,0.449438202247191,0.49079754105461254,0.3700787401574803,0.34057971014492755,0.35471697614069075,0.5405405405405406,0.449438202247191,0.49079754105461254
Llama,69,"import PyPDF2


class PDFHandler:
    def __init__(self, filepaths):
        self.filepaths = filepaths
        # PdfFileReader is deprecated and was removed in PyPDF2 3.0.0. Use PdfReader instead.
        self.readers = [PyPDF2.PdfReader(fp) for fp in filepaths]

    def merge_pdfs(self, output_filepath):
        pdf_writer = PyPDF2.PdfWriter()

        for reader in self.readers:
            # reader.getNumPages is deprecated and was removed in PyPDF2 3.0.0. Use len(reader.pages) instead.
            for page_num in range(len(reader.pages)):
                # reader.getPage(pageNumber) is deprecated and was removed in PyPDF2 3.0.0. Use reader.pages[page_number] instead.
                page = reader.pages[page_num]
                # addPage is deprecated and was removed in PyPDF2 3.0.0. Use add_page instead.
                pdf_writer.add_page(page)

        with open(output_filepath, 'wb') as out:
            pdf_writer.write(out)
        return f""Merged PDFs saved at {output_filepath}""

    def extract_text_from_pdfs(self):
        pdf_texts = []
        for reader in self.readers:
            for page_num in range(len(reader.pages)):
                page = reader.pages[page_num]
                pdf_texts.append(page.extract_text())
        return pdf_texts",ZeroShot,"

```python
import PyPDF2

class PDFHandler:
    def __init__(self, filepaths):
        # Create a list to store PyPDF2 readers for each file
        self.readers = [PyPDF2.PdfReader(filepath) for filepath in filepaths]

    def merge_pdfs(self, output_filepath):
        # Create a writer to store the merged PDF
        writer = PyPDF2.PdfWriter()
        
        # Iterate over each reader and add its pages to the writer
        for reader in self.readers:
            for page in reader.pages:
                writer.add_page(page)
        
        # Open the output file in write-binary mode
        with open(output_filepath, 'wb') as output_file:
            # Write the merged PDF to the output file
            writer.write(output_file)
        
        # Return a success message with the output filepath
        return f""Merged PDFs saved at {output_filepath}""

    def extract_text_from_pdfs(self):
        # Initialize an empty list to store the extracted text
        pdf_texts = []
        
        # Iterate over each reader and extract its text
        for reader in self.readers:
            # Initialize an empty string to store the text of the current PDF
            pdf_text = ''
            # Iterate over each page in the PDF
            for page in reader.pages:
                # Extract the text from the page and append it to the PDF text
                pdf_text += page.extract_text()
            # Append the PDF text to the list of PDF texts
            pdf_texts.append(pdf_text)
        
        # Return the list of extracted PDF texts
        return pdf_texts
```",0.11855670103092782,0.14958602171289945,0.5538461538461539,0.41379310344827586,0.4736842056310596,0.33663366336633666,0.20987654320987653,0.2585551283488269,0.5538461538461539,0.41379310344827586,0.4736842056310596
Llama,70,"class PersonRequest:
    def __init__(self, name: str, sex: str, phoneNumber: str):
        self.name = self._validate_name(name)
        self.sex = self._validate_sex(sex)
        self.phoneNumber = self._validate_phoneNumber(phoneNumber)

    def _validate_name(self, name: str) -> str:
        if not name:
            return None
        if len(name) > 33:
            return None
        return name

    def _validate_sex(self, sex: str) -> str:
        if sex not in [""Man"", ""Woman"", ""UGM""]:
            return None
        return sex

    def _validate_phoneNumber(self, phoneNumber: str) -> str:
        if not phoneNumber:
            return None
        if len(phoneNumber) != 11 or not phoneNumber.isdigit():
            return None
        return phoneNumber",ZeroShot,"

```python
# This class validates input personal information data and sets invalid fields to None based to specific rules.

class PersonRequest:
    def __init__(self, name: str, sex: str, phoneNumber: str):
        """"""
        Initialize PersonRequest object with the provided information.
        """"""
        self.name = self._validate_name(name)
        self.sex = self._validate_sex(sex)
        self.phoneNumber = self._validate_phoneNumber(phoneNumber)


    def _validate_name(self, name: str) -> str:
        """"""
        Validate the name and return it. If name is empty or exceeds 33 characters in length, set to None.
        :return: str, the validated name or None if invalid
        """"""
        # Check if name is not empty and does not exceed 33 characters
        if name and len(name) <= 33:
            return name
        else:
            # If name is invalid, return None
            return None


    def _validate_sex(self, sex: str) -> str:
        """"""
        Validate the sex and return it. If sex is not Man, Woman, or UGM, set to None.
        :return: str, the validated sex or None if invalid
        """"""
        # Define valid sex options
        valid_sex_options = [""Man"", ""Woman"", ""UGM""]
        # Check if sex is in valid options
        if sex in valid_sex_options:
            return sex
        else:
            # If sex is invalid, return None
            return None


    def _validate_phoneNumber(self, phoneNumber: str) -> str:
        """"""
        Validate the phone number and return it. If phoneNumber is empty or not an 11 digit number, set to None.
        :return: str, the validated phone number or None if invalid
        """"""
        # Check if phoneNumber is not empty and has exactly 11 digits
        if phoneNumber and phoneNumber.isdigit() and len(phoneNumber) == 11:
            return phoneNumber
        else:
            # If phoneNumber is invalid, return None
            return None
```",0.12749003984063745,0.1632284614081755,0.8974358974358975,0.36082474226804123,0.514705878262327,0.6417910447761194,0.24293785310734464,0.35245901240963456,0.8717948717948718,0.35051546391752575,0.49999999590938576
Llama,71,"class PushBoxGame:
    def __init__(self, map):
        self.map = map
        self.player_row = 0
        self.player_col = 0
        self.targets = []
        self.boxes = []
        self.target_count = 0
        self.is_game_over = False

        self.init_game()

    def init_game(self):
        for row in range(len(self.map)):
            for col in range(len(self.map[row])):
                if self.map[row][col] == ""O"":
                    self.player_row = row
                    self.player_col = col
                elif self.map[row][col] == ""G"":
                    self.targets.append((row, col))
                    self.target_count += 1
                elif self.map[row][col] == ""X"":
                    self.boxes.append((row, col))

    def check_win(self):
        box_on_target_count = 0
        for box in self.boxes:
            if box in self.targets:
                box_on_target_count += 1
        if box_on_target_count == self.target_count:
            self.is_game_over = True
        return self.is_game_over

    def move(self, direction):
        new_player_row = self.player_row
        new_player_col = self.player_col

        if direction == ""w"":
            new_player_row -= 1
        elif direction == ""s"":
            new_player_row += 1
        elif direction == ""a"":
            new_player_col -= 1
        elif direction == ""d"":
            new_player_col += 1

        if self.map[new_player_row][new_player_col] != ""#"":
            if (new_player_row, new_player_col) in self.boxes:
                new_box_row = new_player_row + (new_player_row - self.player_row)
                new_box_col = new_player_col + (new_player_col - self.player_col)

                if self.map[new_box_row][new_box_col] != ""#"":
                    self.boxes.remove((new_player_row, new_player_col))
                    self.boxes.append((new_box_row, new_box_col))
                    self.player_row = new_player_row
                    self.player_col = new_player_col
            else:
                self.player_row = new_player_row
                self.player_col = new_player_col

        return self.check_win()",ZeroShot,"

```python
class PushBoxGame:
    def __init__(self, map):
        """"""
        Initialize the push box game with the map and various attributes.               
        """"""
        self.map = map
        self.player_row = 0
        self.player_col = 0
        self.targets = []
        self.boxes = []
        self.target_count = 0
        self.is_game_over = False
        self.init_game()

    def init_game(self):
        """"""
        Initialize the game by setting the positions of the player, targets, and boxes based on the map.
        """"""
        # Iterate through the map to find the player, targets, and boxes
        for i in range(len(self.map)):
            for j in range(len(self.map[i])):
                if self.map[i][j] == 'P':  # Player
                    self.player_row = i
                    self.player_col = j
                elif self.map[i][j] == 'T':  # Target
                    self.targets.append((i, j))
                    self.target_count += 1
                elif self.map[i][j] == 'B':  # Box
                    self.boxes.append((i, j))

    def check_win(self):
        """"""
        Check if the game is won. The game is won when all the boxes are placed on target positions.
        And update the value of self.is_game_over.
        :return self.is_game_over: True if all the boxes are placed on target positions, or False otherwise.
        """"""
        # Check if all boxes are on target positions
        self.is_game_over = set(self.boxes).issubset(set(self.targets))
        return self.is_game_over

    def move(self, direction):
        """"""
        Move the player based on the specified direction and check if the game is won.
        :return: True if the game is won, False otherwise.
        """"""
        # Define possible directions
        directions = {
            'up': (-1, 0),
            'down': (1, 0),
            'left': (0, -1),
            'right': (0, 1)
        }

        # Calculate new player position
        new_row = self.player_row + directions[direction][0]
        new_col = self.player_col + directions[direction][1]

        # Check if new position is within the map boundaries
        if 0 <= new_row < len(self.map) and 0 <= new_col < len(self.map[0]):
            # Check if new position is a box
            if (new_row, new_col) in self.boxes:
                # Calculate new box position
                new_box_row = new_row + directions[direction][0]
                new_box_col = new_col + directions[direction][1]

                # Check if new box position is within the map boundaries and not a wall
                if 0 <= new_box_row < len(self.map) and 0 <= new_box_col < len(self.map[0]) and self.map[new_box_row][new_box_col] != 'W':
                    # Move the box
                    self.boxes.remove((new_row, new_col))
                    self.boxes.append((new_box_row, new_box_col))

                    # Move the player
                    self.player_row = new_row
                    self.player_col = new_col
                else:
                    # Cannot move the box, so do not move the player
                    pass
            elif self.map[new_row][new_col] != 'W':  # Not a wall
                # Move the player
                self.player_row = new_row
                self.player_col = new_col

        # Check if the game is won
        return self.check_win()
```",0.08310991957104559,0.12022336223296358,0.6,0.2922077922077922,0.39301309603173085,0.3561643835616438,0.18118466898954705,0.24018475303596487,0.6,0.2922077922077922,0.39301309603173085
Llama,72,"import re


class RegexUtils:

    def match(self, pattern, text):
        ans = re.match(pattern, text)
        if ans:
            return True
        else:
            return False

    def findall(self, pattern, text):
        return re.findall(pattern, text)

    def split(self, pattern, text):
        return re.split(pattern, text)

    def sub(self, pattern, replacement, text):
        return re.sub(pattern, replacement, text)

    def generate_email_pattern(self):
        pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        return pattern

    def generate_phone_number_pattern(self):
        pattern = r'\b\d{3}-\d{3}-\d{4}\b'
        return pattern

    def generate_split_sentences_pattern(self):
        pattern = r'[.!?][\s]{1,2}(?=[A-Z])'
        return pattern

    def split_sentences(self, text):
        pattern = self.generate_split_sentences_pattern()
        return self.split(pattern, text)

    def validate_phone_number(self, phone_number):
        pattern = self.generate_phone_number_pattern()
        return self.match(pattern, phone_number)

    def extract_email(self, text):
        pattern = self.generate_email_pattern()
        return self.findall(pattern, text)",ZeroShot,"

```python
import re

class RegexUtils:

    # Check if the text matches the regular expression
    def match(self, pattern, text):
        # Use re.match to check if the text matches the pattern
        return bool(re.match(pattern, text))

    # Find all matching substrings and return a list of all matching substrings
    def findall(self, pattern, text):
        # Use re.findall to find all matching substrings
        return re.findall(pattern, text)

    # Split text based on regular expression patterns and return a list of substrings
    def split(self, pattern, text):
        # Use re.split to split the text into substrings
        return re.split(pattern, text)

    # Replace the substring matched by a regular expression with the specified string
    def sub(self, pattern, replacement, text):
        # Use re.sub to replace the matched substring
        return re.sub(pattern, replacement, text)

    # Generate regular expression patterns that match email addresses
    def generate_email_pattern(self):
        # Email pattern: one or more alphanumeric characters or special characters, 
        # followed by '@', then one or more alphanumeric characters or '.', 
        # and finally the domain extension
        return r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'

    # Generate regular expression patterns that match phone numbers
    def generate_phone_number_pattern(self):
        # Phone number pattern: 3 digits, followed by a '-', 
        # then 3 more digits, another '-', and finally 4 more digits
        return r'(\d{3}[-\.\s]??\d{3}[-\.\s]??\d{4}|\(\d{3}\)\s*\d{3}[-\.\s]??\d{4}|\d{3}[-\.\s]??\d{4})'

    # Generate regular expression patterns that match the middle characters of two sentences
    def generate_split_sentences_pattern(self):
        # Split sentences pattern: one or more whitespace characters, 
        # followed by a period, a question mark, or an exclamation mark, 
        # and then one or more whitespace characters
        return r'(?<=[.!?])\s+'

    # Split the text into a list of sentences without Punctuation except the last sentence
    def split_sentences(self, text):
        # Use the split sentences pattern to split the text
        return re.split(self.generate_split_sentences_pattern(), text)

    # Verify if the phone number is valid
    def validate_phone_number(self, phone_number):
        # Use the phone number pattern to check if the phone number is valid
        return bool(re.match(self.generate_phone_number_pattern(), phone_number))

    # Extract all email addresses from the text
    def extract_email(self, text):
        # Use the email pattern to extract all email addresses
        return re.findall(self.generate_email_pattern(), text)


# Example usage
if __name__ == ""__main__"":
    regex_utils = RegexUtils()
    
    # Test match
    print(regex_utils.match('hello', 'hello world'))  # True
    
    # Test findall
    print(regex_utils.findall('hello', 'hello world hello'))  # ['hello', 'hello']
    
    # Test split
    print(regex_utils.split(' ', 'hello world'))  # ['hello', 'world']
    
    # Test sub
    print(regex_utils.sub('hello', 'hi', 'hello world'))  # hi world
    
    # Test generate_email_pattern
    print(regex_utils.generate_email_pattern())  # \b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b
    
    # Test generate_phone_number_pattern
    print(regex_utils.generate_phone_number_pattern())  # (\d{3}[-\.\s]??\d{3}[-\.\s]??\d{4}|\(\d{3}\)\s*\d{3}[-\.\s]??\d{4}|\d{3}[-\.\s]??\d{4})
    
    # Test generate_split_sentences_pattern
    print(regex_utils.generate_split_sentences_pattern())  # (?<=[.!?])\s+
    
    # Test split_sentences
    print(regex_utils.split_sentences('Hello world. This is a test.'))  # ['Hello world.', 'This is a test.']
    
    # Test validate_phone_number
    print(regex_utils.validate_phone_number('123-456-7890'))  # True
    
    # Test extract_email
    print(regex_utils.extract_email('My email is test@example.com.'))  # ['test@example.com']
```",0.04265402843601896,0.05334576305859343,0.7333333333333333,0.17553191489361702,0.2832617994584538,0.4358974358974359,0.09855072463768116,0.16075649817413618,0.7333333333333333,0.17553191489361702,0.2832617994584538
Llama,73,"class RPGCharacter:
    def __init__(self, name, hp, attack_power, defense, level=1):
        self.name = name
        self.hp = hp
        self.attack_power = attack_power
        self.defense = defense
        self.level = level
        self.exp = 0

    def attack(self, other_character):
        damage = max(self.attack_power - other_character.defense, 1)
        other_character.hp -= damage

    def heal(self):
        self.hp += 10
        if self.hp > 100:
            self.hp = 100
        return self.hp

    def gain_exp(self, amount):
        while amount != 0:
            if self.exp + amount >= self.level * 100:
                amount -= (self.level * 100 - self.exp)
                self.level_up()
            else:
                self.exp += amount
                amount = 0

    def level_up(self):
        if self.level < 100:
            self.level += 1
            self.exp = 0
            self.hp += 20
            self.attack_power += 5
            self.defense += 5
        return self.level, self.hp, self.attack_power, self.defense

    def is_alive(self):
        return self.hp > 0",ZeroShot,"

```python
class RPGCharacter:
    def __init__(self, name, hp, attack_power, defense, level=1):
        # Initialize character attributes
        self.name = name
        self.hp = hp
        self.attack_power = attack_power
        self.defense = defense
        self.level = level
        self.exp = 0  # Initialize experience points

    def attack(self, other_character):
        # Calculate damage caused to the other character
        damage = max(0, self.attack_power - other_character.defense)
        # Apply damage to the other character
        other_character.hp -= damage
        # Print attack details
        print(f""{self.name} attacks {other_character.name} for {damage} damage."")

    def heal(self):
        # Calculate new health points after healing
        self.hp = min(100, self.hp + 10)
        # Return current health points
        return self.hp

    def gain_exp(self, amount):
        # Add experience points
        self.exp += amount
        # Check if character can level up
        while self.exp >= 100 * self.level and self.level < 100:
            # Level up character
            self.level_up()

    def level_up(self):
        # Increase level
        self.level += 1
        # Reset experience points
        self.exp -= 100 * (self.level - 1)
        # Increase health points, attack power, and defense
        self.hp = min(100, self.hp + 20)
        self.attack_power += 5
        self.defense += 5
        # Print level up details
        print(f""{self.name} has leveled up to level {self.level}."")
        # Return new character stats
        return self.level, self.hp, self.attack_power, self.defense

    def is_alive(self):
        # Check if character's health points are greater than 0
        return self.hp > 0


# Example usage
character1 = RPGCharacter(""Player1"", 100, 20, 10)
character2 = RPGCharacter(""Player2"", 80, 15, 8)

character1.attack(character2)
print(f""{character2.name}'s HP: {character2.hp}"")

character2.heal()
print(f""{character2.name}'s HP after healing: {character2.hp}"")

character1.gain_exp(500)
print(f""{character1.name}'s level: {character1.level}"")
print(f""{character1.name}'s HP: {character1.hp}"")
print(f""{character1.name}'s attack power: {character1.attack_power}"")
print(f""{character1.name}'s defense: {character1.defense}"")

print(f""Is {character1.name} alive? {character1.is_alive()}"")
```",0.17073170731707318,0.20959301828483506,0.8703703703703703,0.3533834586466165,0.5026737926838056,0.5826086956521739,0.27125506072874495,0.3701657415211685,0.8518518518518519,0.3458646616541353,0.49197860551803024
Llama,74,"class Server:

    def __init__(self):
        self.white_list = []
        self.send_struct = {}
        self.receive_struct = {}

    def add_white_list(self, addr):
        if addr in self.white_list:
            return False
        else:
            self.white_list.append(addr)
            return self.white_list

    def del_white_list(self, addr):
        if addr not in self.white_list:
            return False
        else:
            self.white_list.remove(addr)
            return self.white_list

    def recv(self, info):
        if not isinstance(info, dict) or ""addr"" not in info or ""content"" not in info:
            return -1
        addr = info[""addr""]
        content = info[""content""]
        if addr not in self.white_list:
            return False
        else:
            self.receive_struct = {""addr"": addr, ""content"": content}
            return self.receive_struct[""content""]

    def send(self, info):
        if not isinstance(info, dict) or ""addr"" not in info or ""content"" not in info:
            return ""info structure is not correct""
        self.send_struct = {""addr"": info[""addr""], ""content"": info[""content""]}

    def show(self, type):
        if type == ""send"":
            return self.send_struct
        elif type == ""receive"":
            return self.receive_struct
        else:
            return False",ZeroShot,"

```python
class Server:
    # Initialize the whitelist as an empty list, and initialize the sending and receiving information as an empty dictionary
    def __init__(self):
        # Initialize the whitelist as an empty list
        self.white_list = []
        # Initialize the sending and receiving information as an empty dictionary
        self.send_info = {}
        self.recv_info = {}

    # Add an address to the whitelist and do nothing if it already exists
    def add_white_list(self, addr):
        # Check if the address already exists in the whitelist
        if addr not in self.white_list:
            # Add the address to the whitelist
            self.white_list.append(addr)
            # Return the new whitelist
            return self.white_list
        else:
            # Return False if the address already exists
            return False

    # Remove an address from the whitelist and do nothing if it does not exist
    def del_white_list(self, addr):
        # Check if the address exists in the whitelist
        if addr in self.white_list:
            # Remove the address from the whitelist
            self.white_list.remove(addr)
            # Return the new whitelist
            return self.white_list
        else:
            # Return False if the address does not exist
            return False

    # Receive information containing address and content. If the address is on the whitelist, receive the content; otherwise, do not receive it
    def recv(self, info):
        # Extract the address from the information
        addr = info['addr']
        # Extract the content from the information
        content = info['content']
        # Check if the address is on the whitelist
        if addr in self.white_list:
            # Receive the content and store it in the receiving information dictionary
            self.recv_info[addr] = content
            # Return the content of the information
            return content
        else:
            # Return False if the address is not on the whitelist
            return False

    # Send information containing address and content
    def send(self, info):
        # Extract the address from the information
        addr = info['addr']
        # Extract the content from the information
        content = info['content']
        # Try to send the information
        try:
            # Store the sent information in the sending information dictionary
            self.send_info[addr] = content
            # Return nothing if successfully sent
            return None
        except Exception as e:
            # Return an error message if failed to send
            return f""Error: {str(e)}""

    # Returns struct of the specified type
    def show(self, type):
        # Check if the type is 'send'
        if type == 'send':
            # Return the sending information dictionary
            return self.send_info
        # Check if the type is 'receive'
        elif type == 'receive':
            # Return the receiving information dictionary
            return self.recv_info
        else:
            # Return False if the type is neither 'send' nor 'receive'
            return False
```",0.032581453634085204,0.047157600548563265,0.5714285714285714,0.3018867924528302,0.3950617238713611,0.3626373626373626,0.14666666666666667,0.20886075539276563,0.5714285714285714,0.3018867924528302,0.3950617238713611
Llama,75,"class ShoppingCart:
    def __init__(self):
        self.items = {}

    def add_item(self, item, price, quantity=1):
        if item in self.items:
            self.items[item] = {'price': price, 'quantity': quantity}
        else:
            self.items[item] = {'price': price, 'quantity': quantity}

    def remove_item(self, item, quantity=1):
        if item in self.items:
            self.items[item]['quantity'] -= quantity
        else:
            pass

    def view_items(self) -> dict:
        return self.items

    def total_price(self) -> float:
        return sum([item['quantity'] * item['price'] for item in self.items.values()])",ZeroShot,"

```python
class ShoppingCart:
    def __init__(self):
        # Initialize the items representing the shopping list as an empty dictionary
        self.items = {}

    def add_item(self, item, price, quantity=1):
        # Check if the item already exists in the shopping list
        if item in self.items:
            # If the item exists, update its quantity
            self.items[item]['quantity'] += quantity
        else:
            # If the item does not exist, add it to the shopping list
            self.items[item] = {'price': price, 'quantity': quantity}

    def remove_item(self, item, quantity=1):
        # Check if the item exists in the shopping list
        if item in self.items:
            # If the item exists, subtract the specified quantity
            if self.items[item]['quantity'] <= quantity:
                # If the quantity to be removed is greater than or equal to the existing quantity, remove the item from the shopping list
                del self.items[item]
            else:
                # If the quantity to be removed is less than the existing quantity, update the quantity
                self.items[item]['quantity'] -= quantity
        else:
            # If the item does not exist, print an error message
            print(f""Item '{item}' not found in the shopping list."")

    def view_items(self) -> dict:
        # Return the current shopping list items
        return self.items

    def total_price(self) -> float:
        # Initialize the total price to 0
        total = 0
        # Iterate over each item in the shopping list
        for item in self.items:
            # Calculate the total price by multiplying the quantity of each item by its price and adding it to the total
            total += self.items[item]['price'] * self.items[item]['quantity']
        # Return the total price
        return total


# Example usage:
def main():
    cart = ShoppingCart()
    cart.add_item('apple', 1.00, 2)
    cart.add_item('banana', 0.50, 3)
    print(cart.view_items())
    print(f""Total price: ${cart.total_price():.2f}"")
    cart.remove_item('apple', 1)
    print(cart.view_items())
    print(f""Total price: ${cart.total_price():.2f}"")


if __name__ == ""__main__"":
    main()
```",0.10820895522388058,0.1218605709454185,0.8918918918918919,0.2682926829268293,0.41249999644453134,0.7307692307692307,0.18627450980392157,0.2968749967626953,0.8918918918918919,0.2682926829268293,0.41249999644453134
Llama,76,"class SignInSystem:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username in self.users:
            return False
        else:
            self.users[username] = False
            return True

    def sign_in(self, username):
        if username not in self.users:
            return False
        else:
            self.users[username] = True
            return True

    def check_sign_in(self, username):
        if username not in self.users:
            return False
        else:
            if self.users[username]:
                return True
            else:
                return False

    def all_signed_in(self):
        if all(self.users.values()):
            return True
        else:
            return False

    def all_not_signed_in(self):
        not_signed_in_users = []
        for username, signed_in in self.users.items():
            if not signed_in:
                not_signed_in_users.append(username)
        return not_signed_in_users",ZeroShot,"

```python
class SignInSystem:
    def __init__(self):
        # Initialize an empty dictionary to store users and their sign-in status
        self.users = {}

    def add_user(self, username):
        # Check if the user already exists in the system
        if username not in self.users:
            # Add the user with initial sign-in status as False
            self.users[username] = False
            return True  # Return True if the user is added successfully
        return False  # Return False if the user already exists

    def sign_in(self, username):
        # Check if the user exists in the system
        if username in self.users:
            # Sign in the user by changing their status to True
            self.users[username] = True
            return True  # Return True if the user is signed in successfully
        return False  # Return False if the user does not exist

    def check_sign_in(self, username):
        # Check if the user exists in the system and is signed in
        return username in self.users and self.users[username]

    def all_signed_in(self):
        # Check if all users are signed in by verifying that all values in the dictionary are True
        return all(self.users.values())

    def all_not_signed_in(self):
        # Get a list of usernames that are not signed in by filtering the dictionary
        return [username for username, signed_in in self.users.items() if not signed_in]
```",0.1076923076923077,0.13965697276452702,0.7714285714285715,0.36,0.49090908657024795,0.5483870967741935,0.2446043165467626,0.3383084534452118,0.7714285714285715,0.36,0.49090908657024795
Llama,77,"import random


class Snake:
    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):
        self.length = 1
        self.SCREEN_WIDTH = SCREEN_WIDTH
        self.SCREEN_HEIGHT = SCREEN_HEIGHT
        self.BLOCK_SIZE = BLOCK_SIZE
        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]
        self.score = 0
        self.food_position = food_position

    def move(self, direction):
        cur = self.positions[0]
        x, y = direction

        new = (
            ((cur[0] + (x * self.BLOCK_SIZE)) % self.SCREEN_WIDTH),
            (cur[1] + (y * self.BLOCK_SIZE)) % self.SCREEN_HEIGHT,
        )

        if new == self.food_position:
            self.eat_food()

        if len(self.positions) > 2 and new in self.positions[2:]:
            self.reset()
        else:
            self.positions.insert(0, new)
            if len(self.positions) > self.length:
                self.positions.pop()

    def random_food_position(self):
        while self.food_position in self.positions:
            self.food_position = (random.randint(0, self.SCREEN_WIDTH // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE,
                                  random.randint(0, self.SCREEN_HEIGHT // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE)

    def reset(self):
        self.length = 1
        self.positions = [((self.SCREEN_WIDTH / 2), (self.SCREEN_HEIGHT / 2))]
        self.score = 0
        self.random_food_position()

    def eat_food(self):
        self.length += 1
        self.score += 100
        self.random_food_position()",ZeroShot,"

```python
import random

class Snake:
    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):
        # Initialize the length of the snake
        self.length = 1
        # Initialize the screen width, screen height, and block size
        self.SCREEN_WIDTH = SCREEN_WIDTH
        self.SCREEN_HEIGHT = SCREEN_HEIGHT
        self.BLOCK_SIZE = BLOCK_SIZE
        # Initialize the snake head position to the center of the screen
        self.snake_head_position = [(SCREEN_WIDTH // 2), (SCREEN_HEIGHT // 2)]
        # Initialize the snake body positions
        self.snake_body_positions = [[(SCREEN_WIDTH // 2), (SCREEN_HEIGHT // 2)]]
        # Initialize the score
        self.score = 0
        # Initialize the food position
        self.food_position = food_position
        # Initialize the direction
        self.direction = 'right'

    def move(self, direction):
        # Update the direction
        self.direction = direction
        # Calculate the new head position based on the direction
        if direction == 'right':
            new_head_position = [self.snake_head_position[0] + self.BLOCK_SIZE, self.snake_head_position[1]]
        elif direction == 'left':
            new_head_position = [self.snake_head_position[0] - self.BLOCK_SIZE, self.snake_head_position[1]]
        elif direction == 'up':
            new_head_position = [self.snake_head_position[0], self.snake_head_position[1] - self.BLOCK_SIZE]
        elif direction == 'down':
            new_head_position = [self.snake_head_position[0], self.snake_head_position[1] + self.BLOCK_SIZE]
        
        # Check if the new head position is equal to the food position
        if new_head_position == self.food_position:
            # Eat the food
            self.eat_food()
        else:
            # Remove the last body position if the snake has not eaten food
            if len(self.snake_body_positions) >= self.length:
                self.snake_body_positions.pop(0)
        
        # Update the snake head position
        self.snake_head_position = new_head_position
        # Add the new head position to the snake body positions
        self.snake_body_positions.append(self.snake_head_position[:])
        
        # Check if the snake has collided with its body
        if self.snake_head_position in self.snake_body_positions[:-1]:
            # Reset the snake
            self.reset()

    def random_food_position(self):
        # Randomly generate a new food position
        while True:
            new_food_position = [random.randint(0, self.SCREEN_WIDTH - self.BLOCK_SIZE) // self.BLOCK_SIZE * self.BLOCK_SIZE, 
                                 random.randint(0, self.SCREEN_HEIGHT - self.BLOCK_SIZE) // self.BLOCK_SIZE * self.BLOCK_SIZE]
            # Check if the new food position is not on the snake
            if new_food_position not in self.snake_body_positions:
                self.food_position = new_food_position
                break

    def reset(self):
        # Reset the length to 1
        self.length = 1
        # Reset the snake head position to the center of the screen
        self.snake_head_position = [(self.SCREEN_WIDTH // 2), (self.SCREEN_HEIGHT // 2)]
        # Reset the snake body positions
        self.snake_body_positions = [[(self.SCREEN_WIDTH // 2), (self.SCREEN_HEIGHT // 2)]]
        # Reset the score
        self.score = 0
        # Randomly generate a new food position
        self.random_food_position()

    def eat_food(self):
        # Increase the length of the snake by 1
        self.length += 1
        # Increase the score by 100
        self.score += 100
        # Randomly generate a new food position
        self.random_food_position()
```",0.06896551724137931,0.09433366821973549,0.6538461538461539,0.4112903225806452,0.5049504903087934,0.45985401459854014,0.25,0.3239074504498385,0.6538461538461539,0.4112903225806452,0.5049504903087934
Llama,78,"import re


class SplitSentence:

    def split_sentences(self, sentences_string):
        sentences = re.split(r'(?<!\w\.\w.)(?<![A-Z][a-z]\.)(?<=\.|\?)\s', sentences_string)
        return sentences

    def count_words(self, sentence):
        sentence = re.sub(r'[^a-zA-Z\s]', '', sentence)
        words = sentence.split()
        return len(words)

    def process_text_file(self, sentences_string):
        sentences = self.split_sentences(sentences_string)
        max_count = 0
        for sentence in sentences:
            count = self.count_words(sentence)
            if count > max_count:
                max_count = count

        return max_count",ZeroShot,"

```python
import re

class SplitSentence:

    def split_sentences(self, sentences_string):
        # Use regular expression to split sentences, considering Mr., Mrs., etc.
        sentences = re.split(r'(?<=[.!?]) +', sentences_string)
        # Remove leading and trailing spaces from each sentence
        sentences = [sentence.strip() for sentence in sentences]
        # Remove empty strings from the list
        sentences = [sentence for sentence in sentences if sentence]
        return sentences

    def count_words(self, sentence):
        # Remove punctuation marks and numbers, then split the sentence into words
        words = re.sub(r'[^\w\s]|[\d_]', '', sentence).split()
        # Return the number of words in the sentence
        return len(words)

    def process_text_file(self, text):
        # Split the text into sentences
        sentences = self.split_sentences(text)
        # Initialize the maximum word count
        max_word_count = 0
        # Iterate over each sentence
        for sentence in sentences:
            # Count the words in the current sentence
            word_count = self.count_words(sentence)
            # Update the maximum word count if necessary
            if word_count > max_word_count:
                max_word_count = word_count
        # Return the maximum word count
        return max_word_count
```",0.07894736842105263,0.1124893146784958,0.7631578947368421,0.3372093023255814,0.4677419312330906,0.4444444444444444,0.17518248175182483,0.2513088964677504,0.7368421052631579,0.32558139534883723,0.4516128989750261
Llama,79,"class SQLGenerator:
    def __init__(self, table_name):
        self.table_name = table_name

    def select(self, fields=None, condition=None):
        if fields is None:
            fields = ""*""
        else:
            fields = "", "".join(fields)
        sql = f""SELECT {fields} FROM {self.table_name}""
        if condition is not None:
            sql += f"" WHERE {condition}""
        return sql + "";""

    def insert(self, data):
        fields = "", "".join(data.keys())
        values = "", "".join([f""'{value}'"" for value in data.values()])
        sql = f""INSERT INTO {self.table_name} ({fields}) VALUES ({values})""
        return sql + "";""

    def update(self, data, condition):
        set_clause = "", "".join([f""{field} = '{value}'"" for field, value in data.items()])
        sql = f""UPDATE {self.table_name} SET {set_clause} WHERE {condition}""
        return sql + "";""

    def delete(self, condition):
        sql = f""DELETE FROM {self.table_name} WHERE {condition}""
        return sql + "";""

    def select_female_under_age(self, age):
        condition = f""age < {age} AND gender = 'female'""
        return self.select(condition=condition)

    def select_by_age_range(self, min_age, max_age):
        condition = f""age BETWEEN {min_age} AND {max_age}""
        return self.select(condition=condition)",ZeroShot,"

```python
class SQLGenerator:
    def __init__(self, table_name):
        # Initialize the table name
        self.table_name = table_name

    def select(self, fields=None, condition=None):
        # Start building the SELECT statement
        sql = ""SELECT ""
        
        # If fields are specified, use them; otherwise, use '*'
        if fields:
            # Convert the fields list to a comma-separated string
            sql += "", "".join(fields)
        else:
            sql += ""*""
        
        # Specify the table name
        sql += f"" FROM {self.table_name}""
        
        # If a condition is specified, add it to the statement
        if condition:
            sql += f"" WHERE {condition}""
        
        # Return the generated SQL statement
        return sql

    def insert(self, data):
        # Start building the INSERT statement
        sql = f""INSERT INTO {self.table_name} ""
        
        # Get the column names and values from the data dictionary
        columns = list(data.keys())
        values = list(data.values())
        
        # Add the column names to the statement
        sql += f""({', '.join(columns)}) ""
        
        # Add the VALUES keyword and the values
        sql += ""VALUES (""
        # Convert the values to a comma-separated string, wrapping each value in single quotes
        sql += "", "".join(f""'{value}'"" for value in values)
        sql += "")""
        
        # Return the generated SQL statement
        return sql

    def update(self, data, condition):
        # Start building the UPDATE statement
        sql = f""UPDATE {self.table_name} ""
        
        # Add the SET keyword and the column-value pairs
        sql += ""SET ""
        # Convert the data dictionary to a comma-separated string of column-value pairs
        sql += "", "".join(f""{column} = '{value}'"" for column, value in data.items())
        
        # Add the WHERE keyword and the condition
        sql += f"" WHERE {condition}""
        
        # Return the generated SQL statement
        return sql

    def delete(self, condition):
        # Start building the DELETE statement
        sql = f""DELETE FROM {self.table_name} ""
        
        # Add the WHERE keyword and the condition
        sql += f""WHERE {condition}""
        
        # Return the generated SQL statement
        return sql

    def select_female_under_age(self, age):
        # Generate a SQL statement to select females under a specified age
        # Assuming the table has columns 'gender' and 'age'
        return self.select(condition=f""gender = 'female' AND age < {age}"")

    def select_by_age_range(self, min_age, max_age):
        # Generate a SQL statement to select records within a specified age range
        # Assuming the table has a column 'age'
        return self.select(condition=f""age >= {min_age} AND age <= {max_age}"")
```",0.07909604519774012,0.10841109457634185,0.7125,0.3931034482758621,0.5066666620839507,0.4396551724137931,0.21428571428571427,0.28813558881419776,0.6875,0.3793103448275862,0.4888888843061729
Llama,80,"class SQLQueryBuilder:

    @staticmethod
    def select(table, columns='*', where=None):
        if columns != '*':
            columns = ', '.join(columns)
        query = f""SELECT {columns} FROM {table}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query

    @staticmethod
    def insert(table, data):
        keys = ', '.join(data.keys())
        values = ', '.join(f""'{v}'"" for v in data.values())
        return f""INSERT INTO {table} ({keys}) VALUES ({values})""

    @staticmethod
    def delete(table, where=None):
        query = f""DELETE FROM {table}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query

    @staticmethod
    def update(table, data, where=None):
        update_str = ', '.join(f""{k}='{v}'"" for k, v in data.items())
        query = f""UPDATE {table} SET {update_str}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query",ZeroShot,"

```python
# This class provides to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements.
class SQLQueryBuilder:

    # Generate the SELECT SQL statement from the given parameters.
    @staticmethod
    def select(table, columns='*', where=None):
        # Initialize the query with the SELECT statement
        query = f""SELECT {columns} FROM {table}""
        
        # Add the WHERE clause if provided
        if where:
            query += f"" WHERE {where}""
        
        # Return the generated query
        return query

    # Generate the INSERT SQL statement from the given parameters.
    @staticmethod
    def insert(table, data):
        # Initialize the query with the INSERT statement
        query = f""INSERT INTO {table} (""
        
        # Extract the column names and values from the data
        columns = ', '.join(data.keys())
        values = ', '.join(f""'{value}'"" for value in data.values())
        
        # Add the column names and values to the query
        query += f""{columns}) VALUES ({values})""
        
        # Return the generated query
        return query

    # Generate the DELETE SQL statement from the given parameters.
    @staticmethod
    def delete(table, where=None):
        # Initialize the query with the DELETE statement
        query = f""DELETE FROM {table}""
        
        # Add the WHERE clause if provided
        if where:
            query += f"" WHERE {where}""
        
        # Return the generated query
        return query

    # Generate the UPDATE SQL statement from the given parameters.
    @staticmethod
    def update(table, data, where=None):
        # Initialize the query with the UPDATE statement
        query = f""UPDATE {table} SET ""
        
        # Extract the column names and values from the data
        updates = ', '.join(f""{key} = '{value}'"" for key, value in data.items())
        
        # Add the updates to the query
        query += updates
        
        # Add the WHERE clause if provided
        if where:
            query += f"" WHERE {where}""
        
        # Return the generated query
        return query

# Example usage:
if __name__ == ""__main__"":
    print(SQLQueryBuilder.select('users', 'name, email', 'age > 18'))
    print(SQLQueryBuilder.insert('users', {'name': 'John Doe', 'email': 'john@example.com'}))
    print(SQLQueryBuilder.delete('users', 'age < 18'))
    print(SQLQueryBuilder.update('users', {'name': 'Jane Doe', 'email': 'jane@example.com'}, 'id = 1'))
```",0.10666666666666669,0.13312404799734764,0.7543859649122807,0.3739130434782609,0.4999999955685506,0.4875,0.2215909090909091,0.30468749570312503,0.7192982456140351,0.3565217391304348,0.47674418161506227
Llama,81,"import math
class Statistics3:
    @staticmethod
    def median(data):
        sorted_data = sorted(data)
        n = len(sorted_data)
        if n % 2 == 1:
            return sorted_data[n // 2]
        else:
            return (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2

    @staticmethod
    def mode(data):
        counts = {}
        for value in data:
            counts[value] = counts.get(value, 0) + 1
        max_count = max(counts.values())
        mode_values = [value for value, count in counts.items() if count == max_count]
        return mode_values

    @staticmethod
    def correlation(x, y):
        n = len(x)
        mean_x = sum(x) / n
        mean_y = sum(y) / n
        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))
        denominator = math.sqrt(sum((xi - mean_x) ** 2 for xi in x) * sum((yi - mean_y) ** 2 for yi in y))
        if denominator == 0:
            return None
        return numerator / denominator

    @staticmethod
    def mean(data):
        if len(data) == 0:
            return None
        return sum(data) / len(data)

    @staticmethod
    def correlation_matrix(data):
        matrix = []
        for i in range(len(data[0])):
            row = []
            for j in range(len(data[0])):
                column1 = [row[i] for row in data]
                column2 = [row[j] for row in data]
                correlation = Statistics3.correlation(column1, column2)
                row.append(correlation)
            matrix.append(row)
        return matrix

    @staticmethod
    def standard_deviation(data):
        n = len(data)
        if n < 2:
            return None
        mean_value = Statistics3.mean(data)
        variance = sum((x - mean_value) ** 2 for x in data) / (n - 1)
        return math.sqrt(variance)

    @staticmethod
    def z_score(data):
        mean = Statistics3.mean(data)
        std_deviation = Statistics3.standard_deviation(data)
        if std_deviation is None or std_deviation == 0:
            return None
        return [(x - mean) / std_deviation for x in data]",ZeroShot,"

```python
# This is a class that implements methods for calculating indicators such as median, mode, correlation matrix, and Z-score in statistics.

import math
import statistics
import numpy as np
from scipy import stats

class Statistics3:
    # calculates the median of the given list.
    @staticmethod
    def median(data):
        # Check if the list is empty
        if not data:
            return None
        # Use the statistics module to calculate the median
        return statistics.median(data)

    # calculates the mode of the given list.
    @staticmethod
    def mode(data):
        # Check if the list is empty
        if not data:
            return None
        # Use the statistics module to calculate the mode
        return statistics.multimode(data)

    # calculates the correlation of the given list.
    @staticmethod
    def correlation(x, y):
        # Check if the lists are empty
        if not x or not y:
            return None
        # Check if the lists have the same length
        if len(x) != len(y):
            return None
        # Use the numpy module to calculate the correlation
        return np.corrcoef(x, y)[0, 1]

    # calculates the mean of the given list.
    @staticmethod
    def mean(data):
        # Check if the list is empty
        if not data:
            return None
        # Use the statistics module to calculate the mean
        return statistics.mean(data)

    # calculates the correlation matrix of the given list.
    @staticmethod
    def correlation_matrix(data):
        # Check if the list is empty
        if not data:
            return None
        # Use the numpy module to calculate the correlation matrix
        return np.corrcoef(data)

    # calculates the standard deviation of the given list.
    @staticmethod
    def standard_deviation(data):
        # Check if the list is empty
        if not data:
            return None
        # Use the statistics module to calculate the standard deviation
        return statistics.stdev(data)

    # calculates the z-score of the given list.
    @staticmethod
    def z_score(data):
        # Check if the list is empty
        if not data:
            return None
        # Calculate the mean and standard deviation
        mean = Statistics3.mean(data)
        std_dev = Statistics3.standard_deviation(data)
        # Use a list comprehension to calculate the z-score for each value
        return [(x - mean) / std_dev for x in data]
```",0.043478260869565216,0.05890140263723402,0.33043478260869563,0.3958333333333333,0.3601895685002583,0.10697674418604651,0.1419753086419753,0.12201591021818227,0.30434782608695654,0.3645833333333333,0.3317535495429124
Llama,82,"class StockPortfolioTracker:
    def __init__(self, cash_balance):
        self.portfolio = []
        self.cash_balance = cash_balance

    def add_stock(self, stock):
        for pf in self.portfolio:
            if pf['name'] == stock['name']:
                pf['quantity'] += stock['quantity']
                return

        self.portfolio.append(stock)

    def remove_stock(self, stock):
        for pf in self.portfolio:
            if pf['name'] == stock['name'] and pf['quantity'] >= stock['quantity']:
                pf['quantity'] -= stock['quantity']
                if pf['quantity'] == 0:
                    self.portfolio.remove(pf)
                return True
        return False

    def buy_stock(self, stock):
        if stock['price'] * stock['quantity'] > self.cash_balance:
            return False
        else:
            self.add_stock(stock)
            self.cash_balance -= stock['price'] * stock['quantity']
            return True

    def sell_stock(self, stock):
        if self.remove_stock(stock) == False:
            return False
        self.cash_balance += stock['price'] * stock['quantity']
        return True

    def calculate_portfolio_value(self):
        total_value = self.cash_balance
        for stock in self.portfolio:
            total_value += stock['price'] * stock['quantity']
        return total_value

    def get_portfolio_summary(self):
        summary = []
        for stock in self.portfolio:
            value = self.get_stock_value(stock)
            summary.append({""name"": stock[""name""], ""value"": value})
        portfolio_value = self.calculate_portfolio_value()
        return portfolio_value, summary

    def get_stock_value(self, stock):
        return stock['price'] * stock['quantity']",ZeroShot,"

```python
class Stock:
    def __init__(self, name, price, quantity):
        """"""
        Initialize the Stock class with a name, price, and quantity.
        """"""
        self.name = name
        self.price = price
        self.quantity = quantity

class StockPortfolioTracker:
    def __init__(self, cash_balance):
        """"""
        Initialize the StockPortfolioTracker class with a cash balance and an empty portfolio.
        """"""
        # Initialize cash balance
        self.cash_balance = cash_balance
        # Initialize an empty portfolio
        self.portfolio = {}

    def add_stock(self, stock):
        """"""
        Add a stock to the portfolio.
        """"""
        # Check if the stock is already in the portfolio
        if stock.name in self.portfolio:
            # If the stock is already in the portfolio, increase its quantity
            self.portfolio[stock.name].quantity += stock.quantity
        else:
            # If the stock is not in the portfolio, add it
            self.portfolio[stock.name] = stock

    def remove_stock(self, stock):
        """"""
        Remove a stock from the portfolio.
        """"""
        # Check if the stock is in the portfolio
        if stock.name in self.portfolio:
            # If the stock is in the portfolio, remove it
            del self.portfolio[stock.name]
        else:
            # If the stock is not in the portfolio, print an error message
            print(""Stock not found in portfolio."")

    def buy_stock(self, stock):
        """"""
        Buy a stock and add it to the portfolio.
        :return: True if the stock was bought successfully, False if the cash balance is not enough.
        """"""
        # Calculate the total cost of the stock
        total_cost = stock.price * stock.quantity
        # Check if the cash balance is enough to buy the stock
        if self.cash_balance >= total_cost:
            # If the cash balance is enough, subtract the total cost from the cash balance
            self.cash_balance -= total_cost
            # Add the stock to the portfolio
            self.add_stock(stock)
            # Return True to indicate that the stock was bought successfully
            return True
        else:
            # If the cash balance is not enough, return False
            return False

    def sell_stock(self, stock):
        """"""
        Sell a stock and remove it from the portfolio and add the cash to the cash balance.
        :return: True if the stock was sold successfully, False if the quantity of the stock is not enough.
        """"""
        # Check if the stock is in the portfolio
        if stock.name in self.portfolio:
            # If the stock is in the portfolio, check if the quantity is enough
            if self.portfolio[stock.name].quantity >= stock.quantity:
                # If the quantity is enough, subtract the quantity from the portfolio
                self.portfolio[stock.name].quantity -= stock.quantity
                # Calculate the total revenue from selling the stock
                total_revenue = stock.price * stock.quantity
                # Add the total revenue to the cash balance
                self.cash_balance += total_revenue
                # If the quantity of the stock in the portfolio is 0, remove it from the portfolio
                if self.portfolio[stock.name].quantity == 0:
                    self.remove_stock(stock)
                # Return True to indicate that the stock was sold successfully
                return True
            else:
                # If the quantity is not enough, return False
                return False
        else:
            # If the stock is not in the portfolio, return False
            return False

    def calculate_portfolio_value(self):
        """"""
        Calculate the total value of the portfolio.
        :return: the total value of the portfolio, float.
        """"""
        # Initialize the total value of the portfolio to 0
        total_value = self.cash_balance
        # Iterate over each stock in the portfolio
        for stock in self.portfolio.values():
            # Add the value of the stock to the total value
            total_value += stock.price * stock.quantity
        # Return the total value of the portfolio
        return total_value

    def get_portfolio_summary(self):
        """"""
        Get a summary of the portfolio.
        :return: a tuple of the total value of the portfolio and a list of dictionaries with keys ""name"" and ""value""
        """"""
        # Initialize a list to store the summary of each stock
        stock_summaries = []
        # Iterate over each stock in the portfolio
        for stock in self.portfolio.values():
            # Calculate the value of the stock
            stock_value = stock.price * stock.quantity
            # Add a dictionary with the name and value of the stock to the list
            stock_summaries.append({""name"": stock.name, ""value"": stock_value})
        # Calculate the total value of the portfolio
        total_value = self.calculate_portfolio_value()
        # Return a tuple of the total value and the list of stock summaries
        return (total_value, stock_summaries)

    def get_stock_value(self, stock):
        """"""
        Get the value of a stock.
        :return: the value of the stock, float.
        """"""
        # Check if the stock is in the portfolio
        if stock.name in self.portfolio:
            # If the stock is in the portfolio, return its value
            return self.portfolio[stock.name].price * self.portfolio[stock.name].quantity
        else:
            # If the stock is not in the portfolio, return 0
            return 0

# Example usage
if __name__ == ""__main__"":
    # Create a new StockPortfolioTracker with a cash balance of 1000
    tracker = StockPortfolioTracker(1000)
    # Create a new stock with a name, price, and quantity
    stock1 = Stock(""Apple"", 100, 10)
    stock2 = Stock(""Google"", 500, 5)
    # Buy the stocks
    tracker.buy_stock(stock1)
    tracker.buy_stock(stock2)
    # Print the portfolio summary
    print(tracker.get_portfolio_summary())
    # Sell a stock
    tracker.sell_stock(stock1)
    # Print the portfolio summary again
    print(tracker.get_portfolio_summary())
```",0.020860495436766626,0.027647977245531134,0.7,0.25925925925925924,0.3783783744338933,0.3893805309734513,0.1116751269035533,0.1735700162597793,0.7,0.25925925925925924,0.3783783744338933
Llama,83,"import sqlite3


class StudentDatabaseProcessor:

    def __init__(self, database_name):
        self.database_name = database_name

    def create_student_table(self):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        create_table_query = """"""
        CREATE TABLE IF NOT EXISTS students (
            id INTEGER PRIMARY KEY,
            name TEXT,
            age INTEGER,
            gender TEXT,
            grade INTEGER
        )
        """"""
        cursor.execute(create_table_query)

        conn.commit()
        conn.close()

    def insert_student(self, student_data):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        insert_query = """"""
        INSERT INTO students (name, age, gender, grade)
        VALUES (?, ?, ?, ?)
        """"""
        cursor.execute(insert_query,
                       (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))

        conn.commit()
        conn.close()

    def search_student_by_name(self, name):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        select_query = ""SELECT * FROM students WHERE name = ?""
        cursor.execute(select_query, (name,))
        result = cursor.fetchall()

        conn.close()

        return result

    def delete_student_by_name(self, name):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        delete_query = ""DELETE FROM students WHERE name = ?""
        cursor.execute(delete_query, (name,))

        conn.commit()
        conn.close()",ZeroShot,"

```python
import sqlite3

class StudentDatabaseProcessor:
    def __init__(self, database_name):
        # Connect to the SQLite database
        self.conn = sqlite3.connect(database_name)
        # Create a cursor object
        self.cursor = self.conn.cursor()

    def create_student_table(self):
        # SQL query to create the ""students"" table
        query = """"""
            CREATE TABLE IF NOT EXISTS students (
                id INTEGER PRIMARY KEY,
                name TEXT NOT NULL,
                age INTEGER NOT NULL,
                gender TEXT NOT NULL,
                grade INTEGER NOT NULL
            )
        """"""
        # Execute the query
        self.cursor.execute(query)
        # Commit the changes
        self.conn.commit()

    def insert_student(self, student_data):
        # SQL query to insert a new student into the ""students"" table
        query = """"""
            INSERT INTO students (id, name, age, gender, grade)
            VALUES (?, ?, ?, ?, ?)
        """"""
        # Execute the query with the provided student data
        self.cursor.execute(query, student_data)
        # Commit the changes
        self.conn.commit()

    def search_student_by_name(self, name):
        # SQL query to search for a student by their name
        query = """"""
            SELECT * FROM students
            WHERE name = ?
        """"""
        # Execute the query with the provided name
        self.cursor.execute(query, (name,))
        # Fetch all the rows that match the search criteria
        return self.cursor.fetchall()

    def delete_student_by_name(self, name):
        # SQL query to delete a student by their name
        query = """"""
            DELETE FROM students
            WHERE name = ?
        """"""
        # Execute the query with the provided name
        self.cursor.execute(query, (name,))
        # Commit the changes
        self.conn.commit()

# Example usage
if __name__ == ""__main__"":
    processor = StudentDatabaseProcessor(""students.db"")
    processor.create_student_table()
    
    # Insert a new student
    student_data = (1, ""John Doe"", 20, ""Male"", 90)
    processor.insert_student(student_data)
    
    # Search for a student by name
    name = ""John Doe""
    result = processor.search_student_by_name(name)
    print(result)
    
    # Delete a student by name
    processor.delete_student_by_name(name)
```",0.14285714285714285,0.170099853617316,0.7027027027027027,0.4126984126984127,0.5199999953380001,0.46788990825688076,0.25757575757575757,0.33224755242347404,0.7027027027027027,0.4126984126984127,0.5199999953380001
Llama,84,"import json


class TextFileProcessor:
    def __init__(self, file_path):
        self.file_path = file_path

    def read_file_as_json(self):
        with open(self.file_path, 'r') as file:
            data = json.load(file)

        return data

    def read_file(self):
        with open(self.file_path, 'r') as file:
            return file.read()

    def write_file(self, content):
        with open(self.file_path, 'w') as file:
            file.write(content)

    def process_file(self):
        content = self.read_file()
        content = ''.join([char for char in content if char.isalpha()])
        self.write_file(content)
        return content",ZeroShot,"

```python
import json

class TextFileProcessor:
    # Initialize the file path
    def __init__(self, file_path):
        self.file_path = file_path  # Store the file path as an instance variable

    # Read the file as JSON
    def read_file_as_json(self):
        try:
            # Attempt to open and read the file as JSON
            with open(self.file_path, 'r') as file:
                data = json.load(file)
            return data
        except json.JSONDecodeError:
            # If the file is not in JSON format, raise an error
            raise ValueError(""The file is not in JSON format"")

    # Read the file
    def read_file(self):
        # Open and read the file
        with open(self.file_path, 'r') as file:
            return file.read()

    # Write content to the file
    def write_file(self, content):
        # Open and write to the file, overwriting any existing content
        with open(self.file_path, 'w') as file:
            file.write(str(content))

    # Process the file by removing non-alphabetic characters
    def process_file(self):
        # Read the file content
        content = self.read_file()
        
        # Filter out non-alphabetic characters
        processed_content = ''.join(filter(str.isalpha, content))
        
        # Overwrite the processed content to the file
        self.write_file(processed_content)
```",0.15384615384615385,0.18347653554497978,0.8157894736842105,0.38271604938271603,0.5210083990141939,0.603448275862069,0.26717557251908397,0.37037036611629015,0.8157894736842105,0.38271604938271603,0.5210083990141939
Llama,85,"import time

class Thermostat:
    def __init__(self, current_temperature, target_temperature, mode):
        self.current_temperature = current_temperature
        self.target_temperature = target_temperature
        self.mode = mode

    def get_target_temperature(self):
        return self.target_temperature

    def set_target_temperature(self, temperature):
        self.target_temperature = temperature

    def get_mode(self):
        return self.mode

    def set_mode(self, mode):
        if mode in ['heat', 'cool']:
            self.mode = mode
        else:
            return False

    def auto_set_mode(self):
        if self.current_temperature < self.target_temperature:
            self.mode = 'heat'
        else:
            self.mode = 'cool'

    def auto_check_conflict(self):
        if self.current_temperature > self.target_temperature:
            if self.mode == 'cool':
                return True
            else:
                self.auto_set_mode()
                return False
        else:
            if self.mode == 'heat':
                return True
            else:
                self.auto_set_mode()
                return False

    def simulate_operation(self):
        self.auto_set_mode()
        use_time = 0
        if self.mode == 'heat':
            while(self.current_temperature < self.target_temperature):
                self.current_temperature += 1
                use_time += 1
        else:
            while(self.current_temperature > self.target_temperature):
                self.current_temperature -= 1
                use_time += 1
        return use_time",ZeroShot,"

```python
import time

class Thermostat:
    def __init__(self, current_temperature, target_temperature, mode):
        # Initialize instances of the Thermostat class
        self.current_temperature = current_temperature
        self.target_temperature = target_temperature
        self.mode = mode

    def get_target_temperature(self):
        # Get the target temperature of an instance of the Thermostat class
        return self.target_temperature

    def set_target_temperature(self, temperature):
        # Set the target temperature
        self.target_temperature = temperature

    def get_mode(self):
        # Get the current work mode
        return self.mode

    def set_mode(self, mode):
        # Set the current work mode
        if mode in ['heat', 'cool']:
            self.mode = mode
        else:
            raise ValueError(""Invalid mode. Mode should be either 'heat' or 'cool'."")

    def auto_set_mode(self):
        # Automatically set the operating mode by comparing with the current temperature and target temperature
        if self.current_temperature < self.target_temperature:
            self.mode = 'heat'
        else:
            self.mode = 'cool'

    def auto_check_conflict(self):
        # Check if there is a conflict between the operating mode and the relationship between the current temperature and the target temperature
        if (self.mode == 'heat' and self.current_temperature >= self.target_temperature) or (self.mode == 'cool' and self.current_temperature <= self.target_temperature):
            return False
        else:
            return True

    def simulate_operation(self):
        # Simulate the operation of Thermostat
        start_time = time.time()
        self.auto_set_mode()
        while self.current_temperature != self.target_temperature:
            if self.mode == 'heat':
                self.current_temperature += 1
            else:
                self.current_temperature -= 1
            # Check for conflict and adjust mode if necessary
            if not self.auto_check_conflict():
                self.auto_set_mode()
            # Simulate time passing
            time.sleep(0.1)
        end_time = time.time()
        return end_time - start_time


# Example usage:
thermostat = Thermostat(20, 25, 'heat')
print(thermostat.get_mode())  # Output: heat
print(thermostat.get_target_temperature())  # Output: 25
thermostat.set_target_temperature(28)
print(thermostat.get_target_temperature())  # Output: 28
print(thermostat.auto_check_conflict())  # Output: True
print(thermostat.simulate_operation())  # Output: time it took to complete the simulation
```",0.2,0.23050160950598378,0.8936170212765957,0.35,0.5029940079314426,0.6847826086956522,0.2825112107623318,0.3999999958647518,0.8936170212765957,0.35,0.5029940079314426
Llama,86,"class TicTacToe:
    def __init__(self, N=3):
        self.board = [[' ' for _ in range(N)] for _ in range(3)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        else:
            return False

    def check_winner(self):
        for row in self.board:
            if row[0] == row[1] == row[2] != ' ':
                return row[0]
        for col in range(3):
            if self.board[0][col] == self.board[1][col] == self.board[2][col] != ' ':
                return self.board[0][col]
        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':
            return self.board[0][0]
        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':
            return self.board[0][2]
        return None

    def is_board_full(self):
        for row in self.board:
            if ' ' in row:
                return False
        return True",ZeroShot,"

```python
class TicTacToe:
    def __init__(self, N=3):
        """"""
        Initialize a NxN game board with all empty spaces and current symbol player, default is 'X'.
        """"""
        # Initialize the board with N rows and N columns
        self.board = [[' ' for _ in range(N)] for _ in range(N)]
        self.N = N  # Store the size of the board
        self.current_player = 'X'

    def make_move(self, row, col):
        """"""
        Place the current player's mark at the specified position on the board and switch the mark.
        :return: bool, indicating whether the move was successful or not
        """"""
        # Check if the move is within the board boundaries
        if row < 0 or row >= self.N or col < 0 or col >= self.N:
            return False
        # Check if the space is already occupied
        if self.board[row][col] != ' ':
            return False
        # Make the move
        self.board[row][col] = self.current_player
        # Switch the current player
        self.current_player = 'O' if self.current_player == 'X' else 'X'
        return True

    def check_winner(self):
        """"""
        Check if there is a winner on the board in rows, columns and diagonals three directions
        :return: str or None, the mark of the winner ('X' or 'O'), or None if there is no winner yet
        """"""
        # Check rows
        for row in self.board:
            if len(set(row)) == 1 and row[0] != ' ':
                return row[0]
        # Check columns
        for col in range(self.N):
            check = []
            for row in self.board:
                check.append(row[col])
            if len(set(check)) == 1 and check[0] != ' ':
                return check[0]
        # Check main diagonal
        main_diagonal = [self.board[i][i] for i in range(self.N)]
        if len(set(main_diagonal)) == 1 and main_diagonal[0] != ' ':
            return main_diagonal[0]
        # Check anti-diagonal
        anti_diagonal = [self.board[i][self.N - i - 1] for i in range(self.N)]
        if len(set(anti_diagonal)) == 1 and anti_diagonal[0] != ' ':
            return anti_diagonal[0]
        # If no winner, return None
        return None

    def is_board_full(self):
        """"""
        Check if the game board is completely filled.
        :return: bool, indicating whether the game board is full or not
        """"""
        # Check if any space is empty
        for row in self.board:
            if ' ' in row:
                return False
        # If no empty space, the board is full
        return True

# Example usage:
if __name__ == ""__main__"":
    game = TicTacToe()
    print(game.make_move(0, 0))  # True
    print(game.make_move(0, 0))  # False
    print(game.make_move(1, 1))  # True
    print(game.check_winner())  # None
    print(game.is_board_full())  # False
```",0.136,0.15940814494224842,0.74,0.25,0.37373736996224877,0.5463917525773195,0.17905405405405406,0.2697200980631794,0.74,0.25,0.37373736996224877
Llama,87,"import datetime
import time

class TimeUtils:

    def __init__(self):
        self.datetime = datetime.datetime.now()

    def get_current_time(self):
        format = ""%H:%M:%S""
        return self.datetime.strftime(format)

    def get_current_date(self):
        format = ""%Y-%m-%d""
        return self.datetime.strftime(format)

    def add_seconds(self, seconds):
        new_datetime = self.datetime + datetime.timedelta(seconds=seconds)
        format = ""%H:%M:%S""
        return new_datetime.strftime(format)

    def string_to_datetime(self, string):
        return datetime.datetime.strptime(string, ""%Y-%m-%d %H:%M:%S"")

    def datetime_to_string(self, datetime):
        return datetime.strftime(""%Y-%m-%d %H:%M:%S"")

    def get_minutes(self, string_time1, string_time2):
        time1 = self.string_to_datetime(string_time1)
        time2 = self.string_to_datetime(string_time2)
        return round((time2 - time1).seconds / 60)

    def get_format_time(self, year, month, day, hour, minute, second):
        format = ""%Y-%m-%d %H:%M:%S""
        time_item = datetime.datetime(year, month, day, hour, minute, second)
        return time_item.strftime(format)",ZeroShot,"

```python
import datetime
import time

class TimeUtils:

    # Initialize the class with the current datetime
    def __init__(self):
        self.current_datetime = datetime.datetime.now()

    # Return the current time in the format of '%H:%M:%S'
    def get_current_time(self):
        # Use strftime to format the current time
        return self.current_datetime.strftime('%H:%M:%S')

    # Return the current date in the format of ""%Y-%m-%d""
    def get_current_date(self):
        # Use strftime to format the current date
        return self.current_datetime.strftime('%Y-%m-%d')

    # Add the specified number of seconds to the current time
    def add_seconds(self, seconds):
        # Calculate the new datetime by adding the specified number of seconds
        new_datetime = self.current_datetime + datetime.timedelta(seconds=seconds)
        # Use strftime to format the new time
        return new_datetime.strftime('%H:%M:%S')

    # Convert the time string to a datetime instance
    def string_to_datetime(self, string, format='%Y-%m-%d %H:%M:%S'):
        # Use strptime to parse the time string into a datetime instance
        return datetime.datetime.strptime(string, format)

    # Convert a datetime instance to a string
    def datetime_to_string(self, datetime, format='%Y-%m-%d %H:%M:%S'):
        # Use strftime to format the datetime instance into a string
        return datetime.strftime(format)

    # Calculate how many minutes have passed between two times, and round the results to the nearest
    def get_minutes(self, string_time1, string_time2):
        # Convert the time strings to datetime instances
        datetime1 = self.string_to_datetime(string_time1, format='%H:%M:%S')
        datetime2 = self.string_to_datetime(string_time2, format='%H:%M:%S')
        # Calculate the time difference
        time_diff = datetime2 - datetime1
        # Calculate the total seconds
        total_seconds = time_diff.total_seconds()
        # Convert the total seconds to minutes and round to the nearest minute
        minutes = round(total_seconds / 60)
        return minutes

    # get format time
    def get_format_time(self, year, month, day, hour, minute, second):
        # Create a new datetime instance with the specified time
        datetime = datetime.datetime(year, month, day, hour, minute, second)
        # Use strftime to format the datetime instance into a string
        return datetime.strftime('%Y-%m-%d %H:%M:%S')
```",0.06474820143884892,0.09557385166012909,0.7407407407407407,0.37383177570093457,0.49689440547972685,0.47058823529411764,0.19900497512437812,0.2797202755428139,0.7222222222222222,0.3644859813084112,0.4844720452312797
Llama,88,"from math import pi, fabs


class TriCalculator:

    def __init__(self):
        pass

    def cos(self, x):
        return round(self.taylor(x, 50), 10)

    def factorial(self, a):
        b = 1
        while a != 1:
            b *= a
            a -= 1
        return b

    def taylor(self, x, n):
        a = 1
        x = x / 180 * pi
        count = 1
        for k in range(1, n):
            if count % 2 != 0:
                a -= (x ** (2 * k)) / self.factorial(2 * k)
            else:
                a += (x ** (2 * k)) / self.factorial(2 * k)
            count += 1
        return a

    def sin(self, x):
        x = x / 180 * pi
        g = 0
        t = x
        n = 1

        while fabs(t) >= 1e-15:
            g += t
            n += 1
            t = -t * x * x / (2 * n - 1) / (2 * n - 2)
        return round(g, 10)

    def tan(self, x):
        if self.cos(x) != 0:
            result = self.sin(x) / self.cos(x)
            return round(result, 10)
        else:
            return False",ZeroShot,"

```python
# The class allows to calculate trigonometric values, including cosine, sine, and tangent, using Taylor series approximations.

from math import pi, fabs

class TriCalculator:

    def __init__(self):
        # Initialize the class
        pass

    def cos(self, x):
        """"""
        Calculate the cos value of the x-degree angle
        :return: float
        """"""
        # Use the taylor method to calculate the cosine value
        return self.taylor(x, 10)

    def factorial(self, a):
        """"""
        Calculate the factorial of a
        :return: int
        """"""
        # Base case for factorial calculation
        if a == 0:
            return 1
        # Recursive case for factorial calculation
        else:
            return a * self.factorial(a-1)

    def taylor(self, x, n):
        """"""
        Finding the n-order Taylor expansion value of cos (x/180 * pi)
        :return: float
        """"""
        # Initialize the sum of the Taylor series
        sum = 0
        # Calculate the Taylor series
        for i in range(n):
            # Calculate the sign of the term
            sign = (-1)**i
            # Calculate the term
            term = (sign * (x/180*pi)**(2*i)) / self.factorial(2*i)
            # Add the term to the sum
            sum += term
        # Return the sum of the Taylor series
        return sum

    def sin(self, x):
        """"""
        Calculate the sin value of the x-degree angle
        :return: float
        """"""
        # Use the Taylor series expansion for sine
        sum = 0
        for i in range(10):
            # Calculate the sign of the term
            sign = (-1)**i
            # Calculate the term
            term = (sign * (x/180*pi)**(2*i+1)) / self.factorial(2*i+1)
            # Add the term to the sum
            sum += term
        # Return the sum of the Taylor series
        return sum

    def tan(self, x):
        """"""
        Calculate the tan value of the x-degree angle
        :return: float
        """"""
        # Calculate the tangent value using the sine and cosine values
        if self.cos(x) == 0:
            # Handle the case where cosine is zero
            return float('inf')
        else:
            return self.sin(x) / self.cos(x)
```",0.05517241379310345,0.07688358702939546,0.5068493150684932,0.34579439252336447,0.41111110628950626,0.2230769230769231,0.15104166666666666,0.18012421878785553,0.5068493150684932,0.34579439252336447,0.41111110628950626
Llama,89,"import random


class TwentyFourPointGame:
    def __init__(self) -> None:
        self.nums = []

    def _generate_cards(self):
        for i in range(4):
            self.nums.append(random.randint(1, 9))
        assert len(self.nums) == 4

    def get_my_cards(self):
        self.nums = []
        self._generate_cards()
        return self.nums

    def answer(self, expression):
        if expression == 'pass':
            return self.get_my_cards()
        statistic = {}
        for c in expression:
            if c.isdigit() and int(c) in self.nums:
                statistic[c] = statistic.get(c, 0) + 1

        nums_used = statistic.copy()

        for num in self.nums:
            if nums_used.get(str(num), -100) != -100 and nums_used[str(num)] > 0:
                nums_used[str(num)] -= 1
            else:
                return False

        if all(count == 0 for count in nums_used.values()) == True:
            return self.evaluate_expression(expression)
        else:
            return False

    def evaluate_expression(self, expression):
        try:
            if eval(expression) == 24:
                return True
            else:
                return False
        except Exception as e:
            return False",ZeroShot,"

```python
import random

class TwentyFourPointGame:
    def __init__(self) -> None:
        # Initialize an empty list to store the numbers
        self.nums = []

    def _generate_cards(self):
        # Generate four random numbers between 1 and 9
        self.nums = random.sample(range(1, 10), 4)

    def get_my_cards(self):
        # Generate the cards if they haven't been generated yet
        if not self.nums:
            self._generate_cards()
        # Return a list of the four numbers
        return self.nums

    def answer(self, expression):
        # Replace the numbers in the expression with the actual numbers
        for i, num in enumerate(self.nums):
            expression = expression.replace(f'num{i+1}', str(num))
        # Evaluate the expression and check if the result is 24
        return self.evaluate_expression(expression)

    def evaluate_expression(self, expression):
        # Try to evaluate the expression
        try:
            # Evaluate the expression
            result = eval(expression)
            # Check if the result is 24
            return result == 24
        except Exception as e:
            # If an error occurs during evaluation, return False
            print(f""Error evaluating expression: {e}"")
            return False

# Example usage:
game = TwentyFourPointGame()
cards = game.get_my_cards()
print(f""Your cards are: {cards}"")
expression = input(""Enter a mathematical expression using the numbers (e.g., 'num1 + num2 * num3 - num4'): "")
print(f""Is the expression equal to 24? {game.answer(expression)}"")
```",0.0819672131147541,0.1188488935343023,0.52,0.33620689655172414,0.4083769585811793,0.23275862068965517,0.1534090909090909,0.18493150206042422,0.5066666666666667,0.3275862068965517,0.3979057543926976
Llama,90,"class URLHandler:
    def __init__(self, url):
        self.url = url

    def get_scheme(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            return self.url[:scheme_end]
        return None

    def get_host(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            url_without_scheme = self.url[scheme_end + 3:]
            host_end = url_without_scheme.find(""/"")
            if host_end != -1:
                return url_without_scheme[:host_end]
            return url_without_scheme
        return None

    def get_path(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            url_without_scheme = self.url[scheme_end + 3:]
            host_end = url_without_scheme.find(""/"")
            if host_end != -1:
                return url_without_scheme[host_end:]
        return None

    def get_query_params(self):
        query_start = self.url.find(""?"")
        fragment_start = self.url.find(""#"")
        if query_start != -1:
            query_string = self.url[query_start + 1:fragment_start]
            params = {}
            if len(query_string) > 0:
                param_pairs = query_string.split(""&"")
                for pair in param_pairs:
                    key_value = pair.split(""="")
                    if len(key_value) == 2:
                        key, value = key_value
                        params[key] = value
            return params
        return None

    def get_fragment(self):
        fragment_start = self.url.find(""#"")
        if fragment_start != -1:
            return self.url[fragment_start + 1:]
        return None",ZeroShot,"

```python
# Import the required library for parsing URLs
from urllib.parse import urlparse, parse_qs

class URLHandler:
    def __init__(self, url):
        # Initialize URLHandler's URL by parsing it into its components
        self.parsed_url = urlparse(url)

    def get_scheme(self):
        # Get the scheme of the URL from the parsed URL
        return self.parsed_url.scheme

    def get_host(self):
        # Get the host domain name of the URL from the parsed URL
        return self.parsed_url.netloc

    def get_path(self):
        # Get the address of the resource of the URL from the parsed URL
        return self.parsed_url.path

    def get_query_params(self):
        # Get the request parameters of the URL from the parsed URL
        # and parse them into a dictionary
        return parse_qs(self.parsed_url.query)

    def get_fragment(self):
        # Get the fragment after '#' of the URL from the parsed URL
        return self.parsed_url.fragment

# Example usage:
if __name__ == ""__main__"":
    url = ""https://www.example.com/path/to/resource?param1=value1&param2=value2#fragment""
    handler = URLHandler(url)
    print(""Scheme:"", handler.get_scheme())
    print(""Host:"", handler.get_host())
    print(""Path:"", handler.get_path())
    print(""Query Parameters:"", handler.get_query_params())
    print(""Fragment:"", handler.get_fragment())
```",0.020689655172413793,0.0424706795330043,0.2982456140350877,0.20238095238095238,0.2411347469563906,0.10784313725490197,0.09016393442622951,0.09821428075414566,0.2982456140350877,0.20238095238095238,0.2411347469563906
Llama,91,"import urllib.parse


class UrlPath:
    def __init__(self):
        self.segments = []
        self.with_end_tag = False

    def add(self, segment):
        self.segments.append(self.fix_path(segment))

    def parse(self, path, charset):
        if path:
            if path.endswith('/'):
                self.with_end_tag = True

            path = self.fix_path(path)
            if path:
                split = path.split('/')
                for seg in split:
                    decoded_seg = urllib.parse.unquote(seg, encoding=charset)
                    self.segments.append(decoded_seg)

    @staticmethod
    def fix_path(path):
        if not path:
            return ''

        segment_str = path.strip('/')
        return segment_str",ZeroShot,"

```python
import urllib.parse

class UrlPath:
    def __init__(self):
        # Initialize the UrlPath object with an empty list of segments and a flag indicating the presence of an end tag.
        self.segments = []
        self.has_end_tag = False

    def add(self, segment):
        # Adds a segment to the list of segments in the UrlPath.
        # Ensure the segment is not empty and does not contain any invalid characters.
        if segment:
            self.segments.append(urllib.parse.quote(segment))

    def parse(self, path, charset):
        # Parses a given path string and populates the list of segments in the UrlPath.
        # Remove leading and trailing slashes from the path.
        fixed_path = UrlPath.fix_path(path)
        # Split the path into segments.
        self.segments = [urllib.parse.quote(segment, encoding=charset) for segment in fixed_path.split('/') if segment]

    @staticmethod
    def fix_path(path):
        # Fixes the given path string by removing leading and trailing slashes.
        # Remove leading slashes.
        while path.startswith('/'):
            path = path[1:]
        # Remove trailing slashes.
        while path.endswith('/'):
            path = path[:-1]
        return path

    def build(self, charset):
        # Builds the path string from the list of segments in the UrlPath.
        # Join the segments with slashes.
        path = '/'.join(self.segments)
        # If the path is not empty, add a leading slash.
        if path:
            path = '/' + path
        # If the has_end_tag flag is True, append a slash at the end of the path.
        if self.has_end_tag and path:
            path += '/'
        return path

    def __str__(self):
        # Returns the string representation of the UrlPath object.
        return self.build('utf-8')
```",0.04824561403508771,0.0646157072658199,0.6976744186046512,0.28846153846153844,0.4081632611671063,0.34375,0.11282051282051282,0.1698841661632952,0.6976744186046512,0.28846153846153844,0.4081632611671063
Llama,92,"import sqlite3


class UserLoginDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()

    def insert_user(self, username, password):
        self.cursor.execute('''
            INSERT INTO users (username, password)
            VALUES (?, ?)
        ''', (username, password))
        self.connection.commit()

    def search_user_by_username(self, username):
        self.cursor.execute('''
            SELECT * FROM users WHERE username = ?
        ''', (username,))
        user = self.cursor.fetchone()
        return user

    def delete_user_by_username(self, username):
        self.cursor.execute('''
            DELETE FROM users WHERE username = ?
        ''', (username,))
        self.connection.commit()

    def validate_user_login(self, username, password):
        user = self.search_user_by_username(username)
        if user is not None and user[1] == password:
            return True
        return False",ZeroShot,"

```python
import sqlite3

class UserLoginDB:
    def __init__(self, db_name):
        # Connect to the SQLite database
        self.conn = sqlite3.connect(db_name)
        # Create a cursor object
        self.cursor = self.conn.cursor()
        # Create the ""users"" table if it does not exist
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS users
            (username TEXT PRIMARY KEY, password TEXT)
        ''')
        # Commit the transaction
        self.conn.commit()

    def insert_user(self, username, password):
        # Insert a new user into the ""users"" table
        self.cursor.execute('INSERT INTO users VALUES (?, ?)', (username, password))
        # Commit the transaction
        self.conn.commit()

    def search_user_by_username(self, username):
        # Search for users in the ""users"" table by username
        self.cursor.execute('SELECT * FROM users WHERE username = ?', (username,))
        # Fetch all rows from the last executed statement
        return self.cursor.fetchall()

    def delete_user_by_username(self, username):
        # Delete a user from the ""users"" table by username
        self.cursor.execute('DELETE FROM users WHERE username = ?', (username,))
        # Commit the transaction
        self.conn.commit()

    def validate_user_login(self, username, password):
        # Search for the user in the ""users"" table
        self.cursor.execute('SELECT * FROM users WHERE username = ?', (username,))
        # Fetch the row from the last executed statement
        user = self.cursor.fetchone()
        # Check if the user exists and the password is correct
        if user and user[1] == password:
            return True
        else:
            return False

    # Close the connection when the object is destroyed
    def __del__(self):
        self.conn.close()
```",0.11165048543689324,0.14499780328060727,0.8333333333333334,0.4205607476635514,0.5590062067219629,0.5064935064935064,0.23493975903614459,0.3209876499917018,0.8333333333333334,0.4205607476635514,0.5590062067219629
Llama,93,"import numpy as np
from gensim import matutils
from numpy import dot, array


class VectorUtil:
    @staticmethod
    def similarity(vector_1, vector_2):
        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))

    @staticmethod
    def cosine_similarities(vector_1, vectors_all):
        norm = np.linalg.norm(vector_1)
        all_norms = np.linalg.norm(vectors_all, axis=1)
        dot_products = dot(vectors_all, vector_1)
        similarities = dot_products / (norm * all_norms)
        return similarities

    @staticmethod
    def n_similarity(vector_list_1, vector_list_2):
        if not (len(vector_list_1) and len(vector_list_2)):
            raise ZeroDivisionError('At least one of the passed list is empty.')

        return dot(matutils.unitvec(array(vector_list_1).mean(axis=0)),
                   matutils.unitvec(array(vector_list_2).mean(axis=0)))

    @staticmethod
    def compute_idf_weight_dict(total_num, number_dict):
        index_2_key_map = {}

        index = 0

        count_list = []
        for key, count in number_dict.items():
            index_2_key_map[index] = key
            count_list.append(count)
            index = index + 1

        a = np.array(count_list)
        ## smooth, in case the divide by zero error
        a = np.log((total_num + 1) / (a + 1))
        result = {}

        for index, w in enumerate(a):
            key = index_2_key_map[index]
            result[key] = w

        return result",ZeroShot,"

```python
import numpy as np
from gensim import matutils
from numpy import dot, array

class VectorUtil:
    @staticmethod
    def similarity(vector_1, vector_2):
        """"""
        Compute the cosine similarity between one vector and another vector.
        :return: numpy.ndarray, Contains cosine distance between `vector_1` and `vector_2`
        """"""
        # Ensure vectors are numpy arrays
        vector_1 = np.array(vector_1)
        vector_2 = np.array(vector_2)
        
        # Calculate cosine similarity using gensim's matutils
        similarity = matutils.cosine_similarities([vector_1], [vector_2])
        
        # Return the similarity
        return similarity[0][0]

    @staticmethod
    def cosine_similarities(vector_1, vectors_all):
        """"""
        Compute cosine similarities between one vector and a set of other vectors.
        :return: numpy.ndarray, Contains cosine distance between `vector_1` and each row in `vectors_all`, shape (num_vectors,).
        """"""
        # Ensure vector_1 is a numpy array and vectors_all is a 2D numpy array
        vector_1 = np.array(vector_1)
        vectors_all = np.array(vectors_all)
        
        # Calculate cosine similarities using gensim's matutils
        similarities = matutils.cosine_similarities([vector_1], vectors_all)
        
        # Return the similarities
        return similarities[0]

    @staticmethod
    def n_similarity(vector_list_1, vector_list_2):
        """"""
        Compute cosine similarity between two sets of vectors.
        :return: numpy.ndarray, Similarities between vector_list_1 and vector_list_2.
        """"""
        # Ensure both lists are numpy arrays
        vector_list_1 = np.array(vector_list_1)
        vector_list_2 = np.array(vector_list_2)
        
        # Calculate cosine similarities using gensim's matutils
        similarities = matutils.cossim(vector_list_1, vector_list_2)
        
        # Return the similarities
        return similarities

    @staticmethod
    def compute_idf_weight_dict(total_num, number_dict):
        """"""
        Calculate log(total_num+1/count+1) for each count in number_dict
        :return: dict
        """"""
        # Initialize an empty dictionary to store IDF weights
        idf_weight_dict = {}
        
        # Iterate over each key-value pair in number_dict
        for key, count in number_dict.items():
            # Calculate IDF weight
            idf_weight = np.log((total_num + 1) / (count + 1))
            
            # Store IDF weight in idf_weight_dict
            idf_weight_dict[key] = idf_weight
        
        # Return the idf_weight_dict
        return idf_weight_dict
```",0.12062256809338523,0.1485826898052712,0.45263157894736844,0.3706896551724138,0.40758293343815283,0.28888888888888886,0.1921182266009852,0.23076922597160474,0.45263157894736844,0.3706896551724138,0.40758293343815283
Llama,94,"class VendingMachine:
    def __init__(self):
        self.inventory = {}
        self.balance = 0

    def add_item(self, item_name, price, quantity):
        if not self.restock_item(item_name, quantity):
            self.inventory[item_name] = {'price': price, 'quantity': quantity}

    def insert_coin(self, amount):
        self.balance += amount
        return self.balance

    def purchase_item(self, item_name):
        if item_name in self.inventory:
            item = self.inventory[item_name]
            if item['quantity'] > 0 and self.balance >= item['price']:
                self.balance -= item['price']
                item['quantity'] -= 1
                return self.balance
            else:
                return False
        else:
            return False

    def restock_item(self, item_name, quantity):
        if item_name in self.inventory:
            self.inventory[item_name]['quantity'] += quantity
            return True
        else:
            return False

    def display_items(self):
        if not self.inventory:
            return False
        else:
            items = []
            for item_name, item_info in self.inventory.items():
                items.append(f""{item_name} - ${item_info['price']} [{item_info['quantity']}]"")
            return ""\n"".join(items)",ZeroShot,"

```python
class VendingMachine:
    def __init__(self):
        """"""
        Initializes the vending machine's inventory and balance.
        """"""
        # Initialize an empty dictionary to store the inventory
        self.inventory = {}
        # Initialize the balance to 0
        self.balance = 0

    def add_item(self, item_name, price, quantity):
        """"""
        Adds a product to the vending machine's inventory.
        :return: None
        """"""
        # Check if the item is already in the inventory
        if item_name in self.inventory:
            # If the item is already in the inventory, update its quantity
            self.inventory[item_name]['quantity'] += quantity
        else:
            # If the item is not in the inventory, add it
            self.inventory[item_name] = {'price': price, 'quantity': quantity}

    def insert_coin(self, amount):
        """"""
        Inserts coins into the vending machine.
        :return: The balance of the vending machine after the coins are inserted, float.
        """"""
        # Add the inserted amount to the balance
        self.balance += amount
        # Return the updated balance
        return self.balance

    def purchase_item(self, item_name):
        """"""
        Purchases a product from the vending machine and returns the balance after the purchase and display purchase unsuccessful if the product is out of stock.
        :return: If successful, returns the balance of the vending machine after the product is purchased, float, otherwise, returns False.
        """"""
        # Check if the item is in the inventory
        if item_name in self.inventory:
            # Check if the item is in stock
            if self.inventory[item_name]['quantity'] > 0:
                # Check if the balance is sufficient to purchase the item
                if self.balance >= self.inventory[item_name]['price']:
                    # Update the balance
                    self.balance -= self.inventory[item_name]['price']
                    # Update the quantity of the item
                    self.inventory[item_name]['quantity'] -= 1
                    # Return the updated balance
                    return self.balance
                else:
                    # If the balance is not sufficient, return False
                    return False
            else:
                # If the item is out of stock, return False
                return False
        else:
            # If the item is not in the inventory, return False
            return False

    def restock_item(self, item_name, quantity):
        """"""
        Replenishes the inventory of a product already in the vending machine.
        :return: If the product is already in the vending machine, returns True, otherwise, returns False.
        """"""
        # Check if the item is in the inventory
        if item_name in self.inventory:
            # Update the quantity of the item
            self.inventory[item_name]['quantity'] += quantity
            # Return True
            return True
        else:
            # If the item is not in the inventory, return False
            return False

    def display_items(self):
        """"""
        Displays the products in the vending machine.
        :return: If the vending machine is empty, returns False, otherwise, returns a list of the products in the vending machine, str.
        """"""
        # Check if the vending machine is empty
        if not self.inventory:
            # If the vending machine is empty, return False
            return False
        else:
            # Initialize an empty list to store the products
            products = []
            # Iterate over the items in the inventory
            for item, values in self.inventory.items():
                # Append the product information to the list
                products.append(f""{item}: ${values['price']} - {values['quantity']} in stock"")
            # Return the list of products
            return products

    def view_balance(self):
        """"""
        Displays the current balance of the vending machine.
        :return: The current balance of the vending machine, float.
        """"""
        # Return the current balance
        return self.balance


# Example usage:
vending_machine = VendingMachine()
vending_machine.add_item(""Soda"", 1.50, 10)
vending_machine.add_item(""Chips"", 2.00, 5)
print(vending_machine.display_items())
vending_machine.insert_coin(5.00)
print(vending_machine.view_balance())
print(vending_machine.purchase_item(""Soda""))
print(vending_machine.view_balance())
print(vending_machine.restock_item(""Chips"", 5))
print(vending_machine.display_items())
```",0.06976744186046512,0.08487761291019384,0.8275862068965517,0.3221476510067114,0.46376811190832934,0.5520833333333334,0.17549668874172186,0.2663316546309437,0.8275862068965517,0.3221476510067114,0.46376811190832934
Llama,95,"class Warehouse:
    def __init__(self):
        self.inventory = {}  # Product ID: Product
        self.orders = {}  # Order ID: Order

    def add_product(self, product_id, name, quantity):
        if product_id not in self.inventory:
            self.inventory[product_id] = {'name': name, 'quantity': quantity}
        else:
            self.inventory[product_id]['quantity'] += quantity

    def update_product_quantity(self, product_id, quantity):
        if product_id in self.inventory:
            self.inventory[product_id]['quantity'] += quantity

    def get_product_quantity(self, product_id):
        if product_id in self.inventory:
            return self.inventory[product_id]['quantity']
        else:
            return False

    def create_order(self, order_id, product_id, quantity):
        if self.get_product_quantity(product_id) >= quantity:
            self.update_product_quantity(product_id, -quantity)
            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}
        else:
            return False

    def change_order_status(self, order_id, status):
        if order_id in self.orders:
            self.orders[order_id]['status'] = status
        else:
            return False

    def track_order(self, order_id):
        if order_id in self.orders:
            return self.orders[order_id]['status']
        else:
            return False",ZeroShot,"

```python
class Warehouse:
    def __init__(self):
        """"""
        Initialize two fields.
        """"""
        # Dictionary to store products with product ID as key
        self.inventory = {}  
        # Dictionary to store orders with order ID as key
        self.orders = {}  

    def add_product(self, product_id, name, quantity):
        """"""
        Add product to inventory and plus the quantity if it has existed in inventory.
        Or just add new product to dict otherwise.
        """"""
        # Check if product already exists in inventory
        if product_id in self.inventory:
            # If product exists, update its quantity
            self.inventory[product_id]['quantity'] += quantity
        else:
            # If product does not exist, add it to inventory
            self.inventory[product_id] = {'name': name, 'quantity': quantity}

    def update_product_quantity(self, product_id, quantity):
        """"""
        According to product_id, add the quantity to the corresponding product in inventory.
        """"""
        # Check if product exists in inventory
        if product_id in self.inventory:
            # Update product quantity
            self.inventory[product_id]['quantity'] += quantity
        else:
            # Raise error if product does not exist
            raise ValueError(""Product does not exist in inventory"")

    def get_product_quantity(self, product_id):
        """"""
        Get the quantity of specific product by product_id.
        :return: if the product_id is in inventory then return the corresponding quantity,
                or False otherwise.
        """"""
        # Check if product exists in inventory
        if product_id in self.inventory:
            # Return product quantity
            return self.inventory[product_id]['quantity']
        else:
            # Return False if product does not exist
            return False

    def create_order(self, order_id, product_id, quantity):
        """"""
        Create a order which includes the infomation of product, like id and quantity.
        And put the new order into self.orders.
        The default value of status is 'Shipped'.
        :return False: only if product_id is not in inventory or the quantity is not adequate
        """"""
        # Check if product exists in inventory and quantity is adequate
        if product_id in self.inventory and self.inventory[product_id]['quantity'] >= quantity:
            # Create new order
            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}
            # Update product quantity
            self.inventory[product_id]['quantity'] -= quantity
            # Return True to indicate successful order creation
            return True
        else:
            # Return False if product does not exist or quantity is not adequate
            return False

    def change_order_status(self, order_id, status):
        """"""
        Change the status of order if the input order_id is in self.orders.
        :return False: only if the order_id is not in self.orders
        """"""
        # Check if order exists
        if order_id in self.orders:
            # Update order status
            self.orders[order_id]['status'] = status
            # Return True to indicate successful status update
            return True
        else:
            # Return False if order does not exist
            return False

    def track_order(self, order_id):
        """"""
        Get the status of specific order.
        :return False: only if the order_id is not in self.orders.
        """"""
        # Check if order exists
        if order_id in self.orders:
            # Return order status
            return self.orders[order_id]['status']
        else:
            # Return False if order does not exist
            return False


# Example usage:
warehouse = Warehouse()
warehouse.add_product('P1', 'Product 1', 100)
print(warehouse.get_product_quantity('P1'))  # Output: 100
warehouse.create_order('O1', 'P1', 50)
print(warehouse.track_order('O1'))  # Output: Shipped
warehouse.change_order_status('O1', 'Delivered')
print(warehouse.track_order('O1'))  # Output: Delivered
```",0.09935205183585313,0.11646593218241857,0.8909090909090909,0.32450331125827814,0.4757281514256764,0.6593406593406593,0.19801980198019803,0.3045685243663841,0.8909090909090909,0.32450331125827814,0.4757281514256764
Llama,96,"class WeatherSystem:
    def __init__(self, city) -> None:
        self.temperature = None
        self.weather = None
        self.city = city
        self.weather_list = {}
    
    def query(self, weather_list, tmp_units = 'celsius'):
        self.weather_list = weather_list
        if self.city not in weather_list:
            return False
        else:
            self.temperature = self.weather_list[self.city]['temperature']
            self.weather = self.weather_list[self.city]['weather']
        if self.weather_list[self.city]['temperature units'] != tmp_units:
            if tmp_units == 'celsius':
                return self.fahrenheit_to_celsius(), self.weather
            elif tmp_units == 'fahrenheit':
                return self.celsius_to_fahrenheit(), self.weather
        else:
            return self.temperature, self.weather
    
    def set_city(self, city):
        self.city = city

    def celsius_to_fahrenheit(self):
        return (self.temperature * 9/5) + 32

    def fahrenheit_to_celsius(self):
        return (self.temperature - 32) * 5/9",ZeroShot,"

```python
class WeatherSystem:
    def __init__(self, city) -> None:
        # Initialize the city name and temperature in Celsius
        self.city = city
        self.temperature_celsius = None
        self.weather = None

    def query(self, weather_list, tmp_units='celsius'):
        # Query the weather system for the weather and temperature of the city
        for weather in weather_list:
            if weather['city'] == self.city:
                self.weather = weather['weather']
                self.temperature_celsius = weather['temperature_celsius']
                break
        
        # Convert the temperature units based on the input parameter
        if tmp_units == 'celsius':
            return self.temperature_celsius, self.weather
        elif tmp_units == 'fahrenheit':
            return self.celsius_to_fahrenheit(), self.weather
        else:
            raise ValueError(""Invalid temperature unit. Please use 'celsius' or 'fahrenheit'."")

    def set_city(self, city):
        # Set the city of the weather system
        self.city = city
        self.temperature_celsius = None
        self.weather = None

    def celsius_to_fahrenheit(self):
        # Convert the temperature from Celsius to Fahrenheit
        if self.temperature_celsius is not None:
            return (self.temperature_celsius * 9/5) + 32
        else:
            raise ValueError(""Temperature not available. Please query the weather system first."")

    def fahrenheit_to_celsius(self, temperature_fahrenheit):
        # Convert the temperature from Fahrenheit to Celsius
        return (temperature_fahrenheit - 32) * 5/9


# Example usage:
weather_list = [
    {'city': 'New York', 'weather': 'Sunny', 'temperature_celsius': 25},
    {'city': 'Los Angeles', 'weather': 'Cloudy', 'temperature_celsius': 22},
]

weather_system = WeatherSystem('New York')
print(weather_system.query(weather_list))  # Output: (25, 'Sunny')
print(weather_system.query(weather_list, tmp_units='fahrenheit'))  # Output: (77.0, 'Sunny')
```",0.1326530612244898,0.16308435442394867,0.75,0.34513274336283184,0.4727272684106521,0.4823529411764706,0.23295454545454544,0.3141762408185435,0.75,0.34513274336283184,0.4727272684106521
Llama,97,"class Words2Numbers:

    def __init__(self):
        self.numwords = {}
        self.units = [
            ""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"",
            ""nine"", ""ten"", ""eleven"", ""twelve"", ""thirteen"", ""fourteen"", ""fifteen"",
            ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen"",
        ]
        self.tens = ["""", """", ""twenty"", ""thirty"", ""forty"", ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""]
        self.scales = [""hundred"", ""thousand"", ""million"", ""billion"", ""trillion""]

        self.numwords[""and""] = (1, 0)
        for idx, word in enumerate(self.units):
            self.numwords[word] = (1, idx)
        for idx, word in enumerate(self.tens):
            self.numwords[word] = (1, idx * 10)
        for idx, word in enumerate(self.scales):
            self.numwords[word] = (10 ** (idx * 3 or 2), 0)

        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}
        self.ordinal_endings = [('ieth', 'y'), ('th', '')]

    def text2int(self, textnum):
        textnum = textnum.replace('-', ' ')

        current = result = 0
        curstring = """"
        onnumber = False
        for word in textnum.split():
            if word in self.ordinal_words:
                scale, increment = (1, self.ordinal_words[word])
                current = current * scale + increment
                onnumber = True
            else:
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = ""%s%s"" % (word[:-len(ending)], replacement)

                if word not in self.numwords:
                    if onnumber:
                        curstring += repr(result + current) + "" ""
                    curstring += word + "" ""
                    result = current = 0
                    onnumber = False
                else:
                    scale, increment = self.numwords[word]
                    current = current * scale + increment
                    if scale > 100:
                        result += current
                        current = 0
                    onnumber = True

        if onnumber:
            curstring += repr(result + current)

        return curstring

    def is_valid_input(self, textnum):

        textnum = textnum.replace('-', ' ')

        for word in textnum.split():
            if word in self.ordinal_words:
                continue
            else:
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = ""%s%s"" % (word[:-len(ending)], replacement)

                if word not in self.numwords:
                    return False

        return True",ZeroShot,"

```python
class Words2Numbers:

    def __init__(self):
        """"""
        Initialize the word lists and dictionaries required for conversion
        """"""
        self.numwords = {}
        self.units = [
            ""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"",
            ""nine"", ""ten"", ""eleven"", ""twelve"", ""thirteen"", ""fourteen"", ""fifteen"",
            ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen"",
        ]
        self.tens = ["""", """", ""twenty"", ""thirty"", ""forty"", ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""]
        self.scales = [""hundred"", ""thousand"", ""million"", ""billion"", ""trillion""]

        self.numwords[""and""] = (1, 0)
        for idx, word in enumerate(self.units):
            self.numwords[word] = (1, idx)
        for idx, word in enumerate(self.tens):
            self.numwords[word] = (1, idx * 10)
        for idx, word in enumerate(self.scales):
            self.numwords[word] = (10 ** (idx * 3 or 2), 0)

        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}
        self.ordinal_endings = [('ieth', 'y'), ('th', '')]


    def text2int(self, textnum):
        """"""
        Convert the word string to the corresponding integer string
        :return: string, the final converted integer string
        """"""
        # Split the input string into words
        current = result = 0
        textnum = textnum.replace('-', ' ')
        words = textnum.split()
        
        # Iterate over each word in the input string
        for word in words:
            # Check if the word is in the numwords dictionary
            if word in self.numwords:
                scale, increment = self.numwords[word]
                # Update the current and result values
                current = current * scale + increment
                # If the scale is greater than 1, update the result
                if scale > 1:
                    result += current
                    current = 0
            # If the word is not in the numwords dictionary, check if it's an ordinal word
            elif word in self.ordinal_words:
                # Update the current value
                current = self.ordinal_words[word]
            # If the word is not in the numwords dictionary or ordinal words, check if it's a word with an ordinal ending
            else:
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        # Update the current value
                        current = int(word[:-len(ending)].replace(replacement, ''))
                        break
                else:
                    # If the word is not recognized, raise a ValueError
                    raise ValueError(""Invalid input: {}"".format(word))
        
        # Add the current value to the result
        result += current
        return str(result)


    def is_valid_input(self, textnum):
        """"""
        Check if the input text contains only valid words that can be converted into numbers.
        :return: True if input is valid, False otherwise.
        """"""
        # Split the input string into words
        textnum = textnum.replace('-', ' ')
        words = textnum.split()
        
        # Iterate over each word in the input string
        for word in words:
            # Check if the word is in the numwords dictionary or ordinal words
            if word not in self.numwords and word not in self.ordinal_words:
                # Check if the word is a word with an ordinal ending
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        break
                else:
                    # If the word is not recognized, return False
                    return False
        # If all words are recognized, return True
        return True


# Example usage:
w2n = Words2Numbers()
print(w2n.text2int(""one hundred and twenty five""))  # Output: 125
print(w2n.is_valid_input(""one hundred and twenty five""))  # Output: True
```",0.32264957264957267,0.35454589505906514,0.8872180451127819,0.5728155339805825,0.6961651869722679,0.7355769230769231,0.45132743362831856,0.5594149861460049,0.8872180451127819,0.5728155339805825,0.6961651869722679
Llama,98,"import xml.etree.ElementTree as ET


class XMLProcessor:
    def __init__(self, file_name):
        self.file_name = file_name
        self.root = None

    def read_xml(self):
        try:
            tree = ET.parse(self.file_name)
            self.root = tree.getroot()
            return self.root
        except:
            return None

    def write_xml(self, file_name):
        try:
            tree = ET.ElementTree(self.root)
            tree.write(file_name)
            return True
        except:
            return False

    def process_xml_data(self, file_name):
        for element in self.root.iter('item'):
            text = element.text
            element.text = text.upper()
        return self.write_xml(file_name)

    def find_element(self, element_name):
        elements = self.root.findall(element_name)
        return elements",ZeroShot,"

```python
import xml.etree.ElementTree as ET

class XMLProcessor:
    def __init__(self, file_name):
        # Initialize the XMLProcessor object with the given file name
        self.file_name = file_name
        self.root = None
        try:
            # Attempt to parse the XML file
            self.tree = ET.parse(file_name)
            self.root = self.tree.getroot()
        except FileNotFoundError:
            # Handle the case where the file does not exist
            print(f""File {file_name} not found."")
        except ET.ParseError:
            # Handle the case where the file is not a valid XML
            print(f""File {file_name} is not a valid XML."")

    def read_xml(self):
        # Reads the XML file and returns the root element
        return self.root

    def write_xml(self, file_name):
        # Writes the XML data to the specified file
        if self.root is not None:
            self.tree.write(file_name)
            return True
        else:
            return False

    def process_xml_data(self, file_name):
        # Modifies the data in XML elements and writes the updated XML data to a new file
        # For demonstration purposes, we'll modify the text of all elements
        if self.root is not None:
            for elem in self.root.iter():
                # Modify the text of each element
                elem.text = ""Modified""
            self.tree.write(file_name)
            return True
        else:
            return False

    def find_element(self, element_name):
        # Finds the XML elements with the specified name
        if self.root is not None:
            # Use the findall method to find all elements with the specified name
            return self.root.findall("".//{}"".format(element_name))
        else:
            return []

# Example usage:
if __name__ == ""__main__"":
    processor = XMLProcessor(""example.xml"")
    root = processor.read_xml()
    print(""Root element:"", root.tag)

    # Write the XML data to a new file
    processor.write_xml(""new_example.xml"")

    # Process the XML data and write it to a new file
    processor.process_xml_data(""processed_example.xml"")

    # Find elements with a specific name
    elements = processor.find_element(""element"")
    print(""Found elements:"")
    for elem in elements:
        print(elem.tag, elem.text)
```",0.06130268199233717,0.08321522660862896,0.7857142857142857,0.2619047619047619,0.3928571391071429,0.5211267605633803,0.16591928251121077,0.2517006766085891,0.7857142857142857,0.2619047619047619,0.3928571391071429
Llama,0,"import logging
import datetime


class AccessGatewayFilter:

    def __init__(self):
        pass

    def filter(self, request):
        request_uri = request['path']
        method = request['method']

        if self.is_start_with(request_uri):
            return True

        try:
            token = self.get_jwt_user(request)
            user = token['user']
            if user['level'] > 2:
                self.set_current_user_info_and_log(user)
                return True
        except:
            return False

    def is_start_with(self, request_uri):
        start_with = [""/api"", '/login']
        for s in start_with:
            if request_uri.startswith(s):
                return True
        return False

    def get_jwt_user(self, request):
        token = request['headers']['Authorization']
        user = token['user']
        if token['jwt'].startswith(user['name']):
            jwt_str_date = token['jwt'].split(user['name'])[1]
            jwt_date = datetime.datetime.strptime(jwt_str_date, ""%Y-%m-%d"")
            if datetime.datetime.today() - jwt_date >= datetime.timedelta(days=3):
                return None
        return token

    def set_current_user_info_and_log(self, user):
        host = user['address']
        logging.log(msg=user['name'] + host + str(datetime.datetime.now()), level=1)",FewShot,"

```python
import logging
import datetime
import jwt  # assuming you're using PyJWT library

class AccessGatewayFilter:
    """"""
    This class is a filter used for accessing gateway filtering, primarily for authentication and access log recording.
    """"""

    def __init__(self):
        # Initialize the logger
        self.logger = logging.getLogger(__name__)

    def filter(self, request):
        """"""
        Filter the incoming request based on certain rules and conditions.
        :param request: dict, the incoming request details
        :return: bool, True if the request is allowed, False otherwise
        """"""
        # Check if the request path starts with certain prefixes
        if not self.is_start_with(request['path']):
            return False
        
        # Get the user information from the JWT token in the request
        user = self.get_jwt_user(request)
        if user is None:
            return False
        
        # Set the current user information and log the access
        self.set_current_user_info_and_log(user)
        
        return True

    def is_start_with(self, request_uri):
        """"""
        Check if the request URI starts with certain prefixes.
        :param request_uri: str, the URI of the request
        :return: bool, True if the URI starts with certain prefixes, False otherwise
        """"""
        # Define the allowed prefixes
        allowed_prefixes = ['/api', '/login']
        
        # Check if the request URI starts with any of the allowed prefixes
        for prefix in allowed_prefixes:
            if request_uri.startswith(prefix):
                return True
        
        return False

    def get_jwt_user(self, request):
        """"""
        Get the user information from the JWT token in the request.
        :param request: dict, the incoming request details
        :return: dict or None, the user information if the token is valid, None otherwise
        """"""
        # Get the JWT token from the request headers
        token = request.get('headers', {}).get('Authorization', {}).get('jwt')
        
        # Check if the token is valid
        if token is None:
            return None
        
        try:
            # Decode the JWT token
            user = jwt.decode(token, options={'verify_signature': False})
            return user
        except jwt.ExpiredSignatureError:
            # Handle expired token
            self.logger.warning('Expired JWT token')
            return None
        except jwt.InvalidTokenError:
            # Handle invalid token
            self.logger.warning('Invalid JWT token')
            return None

    def set_current_user_info_and_log(self, user):
        """"""
        Set the current user information and log the access.
        :param user: dict, the user information
        :return: None
        """"""
        # Set the current user information
        self.current_user = user
        
        # Log the access
        self.logger.info(f'Access logged for user {user[""name""]}')
```",0.03353658536585366,0.05048164383000502,0.46875,0.23076923076923078,0.30927834609416516,0.25,0.1037344398340249,0.14662756183727363,0.46875,0.23076923076923078,0.30927834609416516
Llama,1,"import math


class AreaCalculator:

    def __init__(self, radius):
        self.radius = radius

    def calculate_circle_area(self):
        return math.pi * self.radius ** 2

    def calculate_sphere_area(self):
        return 4 * math.pi * self.radius ** 2

    def calculate_cylinder_area(self, height):
        return 2 * math.pi * self.radius * (self.radius + height)

    def calculate_sector_area(self, angle):
        return self.radius ** 2 * angle / 2

    def calculate_annulus_area(self, inner_radius, outer_radius):
        return math.pi * (outer_radius ** 2 - inner_radius ** 2)",FewShot,"

```python
import math

class AreaCalculator:
    """"""
    This is a class for calculating the area of different shapes, including circle, sphere, cylinder, sector and annulus.
    """"""

    def __init__(self, radius):
        """"""
        Initialize the radius for shapes.
        :param radius: float
        """"""
        self.radius = radius

    # Calculate the area of a circle using the formula: πr^2
    def calculate_circle_area(self):
        """"""
        calculate the area of circle based on self.radius
        :return: area of circle, float
        >>> areaCalculator = AreaCalculator(2)
        >>> areaCalculator.calculate_circle_area()
        12.566370614359172
        """"""
        return math.pi * (self.radius ** 2)

    # Calculate the area of a sphere using the formula: 4πr^2
    def calculate_sphere_area(self):
        """"""
        calculate the area of sphere based on self.radius
        :return: area of sphere, float
        >>> areaCalculator = AreaCalculator(2)
        >>> areaCalculator.calculate_sphere_area()
        50.26548245743669
        """"""
        return 4 * math.pi * (self.radius ** 2)

    # Calculate the area of a cylinder using the formula: 2πr(h + r)
    def calculate_cylinder_area(self, height):
        """"""
        calculate the area of cylinder based on self.radius and height
        :param height: height of cylinder, float
        :return: area of cylinder, float
        >>> areaCalculator = AreaCalculator(2)
        >>> areaCalculator.calculate_cylinder_area(3)
        62.83185307179586
        """"""
        return 2 * math.pi * self.radius * (height + self.radius)

    # Calculate the area of a sector using the formula: (θ/360)πr^2
    def calculate_sector_area(self, angle):
        """"""
        calculate the area of sector based on self.radius and angle
        :param angle: angle of sector, float
        :return: area of sector, float
        >>> areaCalculator = AreaCalculator(2)
        >>> areaCalculator.calculate_sector_area(math.pi)
        6.283185307179586
        """"""
        # Convert angle from radians to degrees
        angle_in_degrees = math.degrees(angle)
        return (angle_in_degrees / 360) * math.pi * (self.radius ** 2)

    # Calculate the area of an annulus using the formula: π(R^2 - r^2)
    def calculate_annulus_area(self, inner_radius, outer_radius):
        """"""
        calculate the area of annulus based on inner_radius and out_radius
        :param inner_radius: inner radius of sector, float
        :param outer_radius: outer radius of sector, float
        :return: area of annulus, float
        >>> areaCalculator = AreaCalculator(2)
        >>> areaCalculator.calculate_annulus_area(2, 3)
        15.707963267948966
        """"""
        return math.pi * ((outer_radius ** 2) - (inner_radius ** 2))
```",0.05806451612903226,0.07354147420408448,0.9411764705882353,0.26666666666666666,0.4155844121437005,0.5849056603773585,0.1497584541062802,0.2384615352156805,0.9117647058823529,0.25833333333333336,0.4025973991566875
Llama,2,"class ArgumentParser:
    def __init__(self):
        self.arguments = {}
        self.required = set()
        self.types = {}

    def parse_arguments(self, command_string):
        args = command_string.split()[1:]
        for i in range(len(args)):
            arg = args[i]
            if arg.startswith('--'):
                key_value = arg[2:].split('=')
                if len(key_value) == 2:
                    self.arguments[key_value[0]] = self._convert_type(key_value[0], key_value[1])
                else:
                    self.arguments[key_value[0]] = True
            elif arg.startswith('-'):
                key = arg[1:]
                if i + 1 < len(args) and not args[i + 1].startswith('-'):
                    self.arguments[key] = self._convert_type(key, args[i + 1])
                else:
                    self.arguments[key] = True
        missing_args = self.required - set(self.arguments.keys())
        if missing_args:
            return False, missing_args

        return True, None

    def get_argument(self, key):
        return self.arguments.get(key)

    def add_argument(self, arg, required=False, arg_type=str):
        if required:
            self.required.add(arg)
        self.types[arg] = arg_type

    def _convert_type(self, arg, value):
        try:
            return self.types[arg](value)
        except (ValueError, KeyError):
            return value",FewShot,"

```python
class ArgumentParser:
    """"""
    This is a class for parsing command line arguments to a dictionary.
    """"""

    def __init__(self):
        """"""
        Initialize the fields.
        self.arguments is a dict that stores the args in a command line
        self.requried is a set that stores the required arguments
        self.types is a dict that stores type of every arguments.
        """"""
        self.arguments = {}
        self.required = set()
        self.types = {}

    def parse_arguments(self, command_string):
        # Split the command string into parts
        parts = command_string.split()
        
        # Initialize index to track current part
        i = 1
        
        # Iterate over each part
        while i < len(parts):
            # Check if part is an option
            if parts[i].startswith('-'):
                # Check if option has a value
                if '=' in parts[i]:
                    # Split option and value
                    arg, value = parts[i][2:].split('=')
                    # Store argument and value in dictionary
                    self.arguments[arg] = self._convert_type(arg, value)
                # Check if option is a flag
                elif i + 1 < len(parts) and not parts[i + 1].startswith('-'):
                    # Store argument and value in dictionary
                    arg = parts[i][1:]
                    self.arguments[arg] = self._convert_type(arg, parts[i + 1])
                    # Increment index to skip value
                    i += 1
                # If option is a flag with no value
                else:
                    # Store argument and value in dictionary
                    arg = parts[i][1:]
                    self.arguments[arg] = True
            # Increment index
            i += 1
        
        # Check for missing required arguments
        missing_args = self.required - set(self.arguments.keys())
        
        # Return result
        if missing_args:
            return False, missing_args
        else:
            return True, None

    def get_argument(self, key):
        # Return value of argument from dictionary
        return self.arguments.get(key)

    def add_argument(self, arg, required=False, arg_type=str):
        # Store argument type in dictionary
        self.types[arg] = arg_type
        
        # If argument is required, add to set
        if required:
            self.required.add(arg)

    def _convert_type(self, arg, value):
        # Get type of argument from dictionary
        arg_type = self.types.get(arg)
        
        # Try to convert value to type
        if arg_type == int:
            try:
                return int(value)
            except ValueError:
                pass
        elif arg_type == float:
            try:
                return float(value)
            except ValueError:
                pass
        elif arg_type == bool:
            if value.lower() == 'true':
                return True
            elif value.lower() == 'false':
                return False
        
        # If conversion fails, return original value
        return value
```",0.09309309309309309,0.12408514993193322,0.7435897435897436,0.4084507042253521,0.5272727226958679,0.5,0.2114695340501792,0.29722921496589666,0.7435897435897436,0.4084507042253521,0.5272727226958679
Llama,3,"import itertools


class ArrangementCalculator:
    def __init__(self, datas):
        self.datas = datas

    @staticmethod
    def count(n, m=None):
        if m is None or n == m:
            return ArrangementCalculator.factorial(n)
        else:
            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)

    @staticmethod
    def count_all(n):
        total = 0
        for i in range(1, n + 1):
            total += ArrangementCalculator.count(n, i)
        return total

    def select(self, m=None):
        if m is None:
            m = len(self.datas)
        result = []
        for permutation in itertools.permutations(self.datas, m):
            result.append(list(permutation))
        return result

    def select_all(self):
        result = []
        for i in range(1, len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    @staticmethod
    def factorial(n):
        result = 1
        for i in range(2, n + 1):
            result *= i
        return result",FewShot,"

```python
import itertools
import math

class ArrangementCalculator:
    """"""
    The Arrangement class provides permutation calculations and selection operations for a given set of data elements.
    """"""

    def __init__(self, datas):
        """"""
        Initializes the ArrangementCalculator object with a list of datas.
        :param datas: List, the data elements to be used for arrangements.
        """"""
        self.datas = datas

    @staticmethod
    def count(n, m=None):
        """"""
        Counts the number of arrangements by choosing m items from n items (permutations).
        If m is not provided or n equals m, returns factorial(n).
        :param n: int, the total number of items.
        :param m: int, the number of items to be chosen (default=None).
        :return: int, the count of arrangements.
        """"""
        # If m is not provided, set m to n
        if m is None:
            m = n
        # Calculate the permutation using the formula n! / (n-m)!
        return math.factorial(n) // math.factorial(n - m)

    @staticmethod
    def count_all(n):
        """"""
        Counts the total number of all possible arrangements by choosing at least 1 item and at most n items from n items.
        :param n: int, the total number of items.
        :return: int, the count of all arrangements.
        """"""
        # Initialize the total count to 0
        total_count = 0
        # Iterate over all possible values of m from 1 to n
        for m in range(1, n + 1):
            # Add the count of arrangements for the current m to the total count
            total_count += ArrangementCalculator.count(n, m)
        return total_count

    def select(self, m=None):
        """"""
        Generates a list of arrangements by selecting m items from the internal datas.
        If m is not provided, selects all items.
        :param m: int, the number of items to be chosen (default=None).
        :return: List, a list of arrangements.
        """"""
        # If m is not provided, set m to the length of the datas
        if m is None:
            m = len(self.datas)
        # Use itertools.permutations to generate all permutations of m items from the datas
        return [list(p) for p in itertools.permutations(self.datas, m)]

    def select_all(self):
        """"""
        Generates a list of all arrangements by selecting at least 1 item and at most the number of internal datas.
        :return: List, a list of all arrangements.
        """"""
        # Initialize an empty list to store all arrangements
        all_arrangements = []
        # Iterate over all possible values of m from 1 to the length of the datas
        for m in range(1, len(self.datas) + 1):
            # Add the arrangements for the current m to the list of all arrangements
            all_arrangements.extend(self.select(m))
        return all_arrangements

    @staticmethod
    def factorial(n):
        """"""
        Calculates the factorial of a given number.
        :param n: int, the number to calculate the factorial.
        :return: int, the factorial of the given number.
        """"""
        # Use math.factorial to calculate the factorial
        return math.factorial(n)
```",0.052752293577981654,0.07182265548625065,0.8103448275862069,0.34814814814814815,0.4870466279202127,0.44565217391304346,0.15018315018315018,0.22465753047611187,0.8103448275862069,0.34814814814814815,0.4870466279202127
Llama,4,"class AssessmentSystem:
    def __init__(self):
        self.students = {}

    def add_student(self, name, grade, major):
        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}

    def add_course_score(self, name, course, score):
        if name in self.students:
            self.students[name]['courses'][course] = score

    def get_gpa(self, name):
        if name in self.students and self.students[name]['courses']:
            return sum(self.students[name]['courses'].values()) / len(self.students[name]['courses'])
        else:
            return None

    def get_all_students_with_fail_course(self):
        students = []
        for name, student in self.students.items():
            for course, score in student['courses'].items():
                if score < 60:
                    students.append(name)
                    break
        return students

    def get_course_average(self, course):
        total = 0
        count = 0
        for student in self.students.values():
            if course in student['courses']:
                score = student['courses'][course]
                if score is not None:
                    total += score
                    count += 1
        return total / count if count > 0 else None

    def get_top_student(self):
        top_student = None
        top_gpa = 0
        for name, student in self.students.items():
            gpa = self.get_gpa(name)
            if gpa is not None and gpa > top_gpa:
                top_gpa = gpa
                top_student = name
        return top_student",FewShot,"

```python
class AssessmentSystem:
    """"""
    This is a class as an student assessment system, which supports add student, add course score, calculate GPA, and other functions for students and courses.
    """"""

    def __init__(self):
        """"""
        Initialize the students dict in assessment system.
        """"""
        # Initialize an empty dictionary to store student information
        self.students = {}

    def add_student(self, name, grade, major):
        """"""
        Add a new student into self.students dict
        :param name: str, student name
        :param grade: int, student grade
        :param major: str, student major
        """"""
        # Create a new dictionary for the student with name, grade, major, and an empty courses dictionary
        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}

    def add_course_score(self, name, course, score):
        """"""
        Add score of specific course for student in self.students
        :param name: str, student name
        :param course: str, course name
        :param score: int, course score
        """"""
        # Check if the student exists in the system
        if name in self.students:
            # Add the course score to the student's courses dictionary
            self.students[name]['courses'][course] = score

    def get_gpa(self, name):
        """"""
        Get average grade of one student.
        :param name: str, student name
        :return: if name is in students and this students have courses grade, return average grade(float)
                    or None otherwise
        """"""
        # Check if the student exists in the system and has courses
        if name in self.students and self.students[name]['courses']:
            # Calculate the average grade
            average_grade = sum(self.students[name]['courses'].values()) / len(self.students[name]['courses'])
            return average_grade
        else:
            return None

    def get_all_students_with_fail_course(self):
        """"""
        Get all students who have any score below 60
        :return: list of str, student name
        """"""
        # Initialize an empty list to store students with failed courses
        failed_students = []
        # Iterate over each student in the system
        for student in self.students:
            # Iterate over each course the student has
            for course, score in self.students[student]['courses'].items():
                # Check if the score is below 60
                if score < 60:
                    # Add the student to the list of failed students
                    failed_students.append(student)
                    # Break out of the loop to avoid adding the same student multiple times
                    break
        return failed_students

    def get_course_average(self, course):
        """"""
        Get the average score of a specific course.
        :param course: str, course name
        :return: float, average scores of this course if anyone have score of this course, or None if nobody have records.
        """"""
        # Initialize a list to store scores for the course
        course_scores = []
        # Iterate over each student in the system
        for student in self.students:
            # Check if the student has the course
            if course in self.students[student]['courses']:
                # Add the score to the list of course scores
                course_scores.append(self.students[student]['courses'][course])
        # Check if there are any scores for the course
        if course_scores:
            # Calculate and return the average score
            return sum(course_scores) / len(course_scores)
        else:
            return None

    def get_top_student(self):
        """"""
        Calculate every student's gpa with get_gpa method, and find the student with highest gpa
        :return: str, name of student whose gpa is highest
        """"""
        # Initialize the top student and their GPA
        top_student = None
        top_gpa = 0
        # Iterate over each student in the system
        for student in self.students:
            # Calculate the student's GPA
            gpa = self.get_gpa(student)
            # Check if the GPA is not None and is higher than the current top GPA
            if gpa is not None and gpa > top_gpa:
                # Update the top student and their GPA
                top_student = student
                top_gpa = gpa
        return top_student
```",0.0974264705882353,0.12122474219203115,0.8356164383561644,0.3567251461988304,0.4999999958065709,0.5714285714285714,0.20100502512562815,0.2973977656665884,0.8356164383561644,0.3567251461988304,0.4999999958065709
Llama,5,"class AutomaticGuitarSimulator:
    def __init__(self, text) -> None:
        self.play_text = text

    def interpret(self, display=False):
        if len(self.play_text) == 0:
            return
        else:
            play_list = []
            play_segs = self.play_text.split("" "")
            for play_seg in play_segs:
                pos = 0
                for ele in play_seg:
                    if ele.isalpha():
                        pos += 1
                        continue
                    break
                play_chord = play_seg[0:pos]
                play_value = play_seg[pos:]
                play_list.append({'Chord': play_chord, 'Tune': play_value})
                if display:
                    self.display(play_chord, play_value)
            return play_list

    def display(self, key, value):
        return ""Normal Guitar Playing -- Chord: %s, Play Tune: %s"" % (key, value)",FewShot,"

```python
class AutomaticGuitarSimulator:
    """"""
    This class is an automatic guitar simulator that can interpret and play based on the input guitar sheet music.
    """"""

    def __init__(self, text) -> None:
        """"""
        Initialize the score to be played
        :param text:str, score to be played
        """"""
        self.play_text = text

    def interpret(self, display=False):
        """"""
        Interpret the music score to be played
        :param display:Bool, representing whether to print the interpreted score
        :return:list of dict, The dict includes two fields, Chore and Tune, which are letters and numbers, respectively
        """"""
        # Split the input text into individual notes
        notes = self.play_text.split()
        
        # Initialize an empty list to store the interpreted notes
        interpreted_notes = []
        
        # Iterate over each note
        for note in notes:
            # Extract the chord and tune from the note
            chord = ''
            tune = ''
            for char in note:
                if char.isalpha():
                    chord += char
                else:
                    tune += char
            
            # Create a dictionary to store the chord and tune
            note_dict = {'Chord': chord, 'Tune': tune}
            
            # Add the note dictionary to the list of interpreted notes
            interpreted_notes.append(note_dict)
        
        # If display is True, print out the interpreted notes
        if display:
            for note in interpreted_notes:
                self.display(note['Chord'], note['Tune'])
        
        # Return the list of interpreted notes
        return interpreted_notes


    def display(self, key, value):
        """"""
        Print out chord and play tune with following format: Normal Guitar Playing -- Chord: %s, Play Tune: %s
        :param key:str, chord
        :param value:str, play tune
        :return: str
        """"""
        # Print out the chord and tune in the specified format
        print(f""Normal Guitar Playing -- Chord: {key}, Play Tune: {value}"")
```",0.05555555555555554,0.07379478499934378,0.515625,0.24444444444444444,0.3316582870937603,0.2804878048780488,0.10599078341013825,0.15384614986543788,0.515625,0.24444444444444444,0.3316582870937603
Llama,6,"class AvgPartition:
    def __init__(self, lst, limit):
        self.lst = lst
        self.limit = limit

    def setNum(self):
        size = len(self.lst) // self.limit
        remainder = len(self.lst) % self.limit
        return size, remainder

        
    def get(self, index):
        size, remainder = self.setNum()
        start = index * size + min(index, remainder)
        end = start + size
        if index + 1 <= remainder:
            end += 1
        return self.lst[start:end]",FewShot,"

```python
class AvgPartition:
    """"""
    This is a class that partitions the given list into different blocks by specifying the number of partitions, with each block having a uniformly distributed length.
    """"""

    def __init__(self, lst, limit):
        """"""
        Initialize the class with the given list and the number of partitions, and check if the number of partitions is greater than 0.
        """"""
        # Check if the number of partitions is greater than 0
        if limit <= 0:
            raise ValueError(""Number of partitions must be greater than 0"")
        self.lst = lst
        self.limit = limit

    def setNum(self):
        """"""
        Calculate the size of each block and the remainder of the division.
        :return: the size of each block and the remainder of the division, tuple.
        >>> a = AvgPartition([1, 2, 3, 4], 2)
        >>> a.setNum()
        (2, 0)
        """"""
        # Calculate the size of each block
        block_size = len(self.lst) // self.limit
        # Calculate the remainder of the division
        remainder = len(self.lst) % self.limit
        return block_size, remainder

    def get(self, index):
        """"""
        calculate the size of each block and the remainder of the division, and calculate the corresponding start and end positions based on the index of the partition.
        :param index: the index of the partition,int.
        :return: the corresponding block, list.
        >>> a = AvgPartition([1, 2, 3, 4], 2)
        >>> a.get(0)
        [1, 2]
        """"""
        # Calculate the size of each block and the remainder of the division
        block_size, remainder = self.setNum()
        # Calculate the start position of the block
        start = index * block_size + min(index, remainder)
        # Calculate the end position of the block
        end = (index + 1) * block_size + min(index + 1, remainder)
        # Return the corresponding block
        return self.lst[start:end]
```",0.07326007326007325,0.09118856215065146,0.8857142857142857,0.29523809523809524,0.4428571391071429,0.576271186440678,0.1827956989247312,0.2775510167516868,0.8857142857142857,0.29523809523809524,0.4428571391071429
Llama,7,"class BalancedBrackets:
    def __init__(self, expr):
        self.stack = []
        self.left_brackets = [""("", ""{"", ""[""]
        self.right_brackets = ["")"", ""}"", ""]""]
        self.expr = expr

    def clear_expr(self):
        self.expr = ''.join(c for c in self.expr if (c in self.left_brackets or c in self.right_brackets))

    def check_balanced_brackets(self):
        self.clear_expr()
        for Brkt in self.expr:
            if Brkt in self.left_brackets:
                self.stack.append(Brkt)
            else:
                Current_Brkt = self.stack.pop()
                if Current_Brkt == ""("":
                    if Brkt != "")"":
                        return False
                if Current_Brkt == ""{"":
                    if Brkt != ""}"":
                        return False
                if Current_Brkt == ""["":
                    if Brkt != ""]"":
                        return False
        if self.stack:
            return False
        return True",FewShot,"

```python
class BalancedBrackets:
    """"""
    This is a class that checks for bracket matching
    """"""

    def __init__(self, expr):
        """"""
        Initializes the class with an expression.
        :param expr: The expression to check for balanced brackets,str.
        """"""
        self.stack = []
        self.left_brackets = [""("", ""{"", ""[""]
        self.right_brackets = ["")"", ""}"", ""]""]
        self.expr = expr

    def clear_expr(self):
        """"""
        Clears the expression of all characters that are not brackets.
        >>> b = BalancedBrackets(""a(b)c"")
        >>> b.clear_expr()
        >>> b.expr
        '()'
        """"""
        # Use a list comprehension to filter out non-bracket characters
        self.expr = ''.join([char for char in self.expr if char in self.left_brackets + self.right_brackets])

    def check_balanced_brackets(self):
        """"""
        Checks if the expression has balanced brackets.
        :return: True if the expression has balanced brackets, False otherwise.
        >>> b = BalancedBrackets(""a(b)c"")
        >>> b.check_balanced_brackets()
        True
        """"""
        # Create a dictionary to map closing brackets to opening brackets
        bracket_map = {')': '(', '}': '{', ']': '['}
        
        # Iterate over each character in the expression
        for char in self.expr:
            # If the character is an opening bracket, push it onto the stack
            if char in self.left_brackets:
                self.stack.append(char)
            # If the character is a closing bracket, check if the stack is empty or the top of the stack does not match
            elif char in self.right_brackets:
                if not self.stack or self.stack.pop() != bracket_map[char]:
                    return False
        
        # If the stack is empty after iterating over the entire expression, the brackets are balanced
        return not self.stack
```",0.07929515418502203,0.11059188483026273,0.673469387755102,0.28695652173913044,0.4024390202000298,0.4125,0.1625615763546798,0.23321554364769198,0.673469387755102,0.28695652173913044,0.4024390202000298
Llama,8,"class BankAccount:
    def __init__(self, balance=0):
        self.balance = balance

    def deposit(self, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        self.balance += amount
        return self.balance

    def withdraw(self, amount):
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient balance."")
        self.balance -= amount
        return self.balance

    def view_balance(self):
        return self.balance

    def transfer(self, other_account, amount):
        self.withdraw(amount)
        other_account.deposit(amount)",FewShot,"

```python
class BankAccount:
    """"""
    This is a class as a bank account system, which supports deposit money, withdraw money, view balance, and transfer money.
    """"""

    def __init__(self, balance=0):
        """"""
        Initializes a bank account object with an attribute balance, default value is 0.
        """"""
        self.balance = balance

    # Deposit method to add amount to the account balance
    def deposit(self, amount):
        """"""
        Deposits a certain amount into the account, increasing the account balance, return the current account balance.
        If amount is negative, raise a ValueError(""Invalid amount"").
        :param amount: int
        """"""
        if amount < 0:
            raise ValueError(""Invalid amount"")
        self.balance += amount
        return self.balance

    # Withdraw method to subtract amount from the account balance
    def withdraw(self, amount):
        """"""
        Withdraws a certain amount from the account, decreasing the account balance, return the current account balance.
        If amount is negative, raise a ValueError(""Invalid amount"").
        If the withdrawal amount is greater than the account balance, raise a ValueError(""Insufficient balance."").
        :param amount: int
        """"""
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient balance."")
        self.balance -= amount
        return self.balance

    # Method to view the current account balance
    def view_balance(self):
        """"""
        Return the account balance.
        """"""
        return self.balance

    # Method to transfer amount from one account to another
    def transfer(self, other_account, amount):
        """"""
        Transfers a certain amount from the current account to another account.
        :param other_account: BankAccount
        :param amount: int
        """"""
        if amount < 0:
            raise ValueError(""Invalid amount"")
        if amount > self.balance:
            raise ValueError(""Insufficient balance."")
        self.balance -= amount
        other_account.balance += amount
        return self.balance, other_account.balance
```",0.13709677419354838,0.15392912808182294,0.9354838709677419,0.3258426966292135,0.48333332950138896,0.8222222222222222,0.23125,0.3609756063295658,0.9354838709677419,0.3258426966292135,0.48333332950138896
Llama,9,"class BigNumCalculator:
    @staticmethod
    def add(num1, num2):
        max_length = max(len(num1), len(num2))
        num1 = num1.zfill(max_length)
        num2 = num2.zfill(max_length)

        carry = 0
        result = []
        for i in range(max_length - 1, -1, -1):
            digit_sum = int(num1[i]) + int(num2[i]) + carry
            carry = digit_sum // 10
            digit = digit_sum % 10
            result.insert(0, str(digit))

        if carry > 0:
            result.insert(0, str(carry))

        return ''.join(result)

    @staticmethod
    def subtract(num1, num2):

        if len(num1) < len(num2):
            num1, num2 = num2, num1
            negative = True
        elif len(num1) > len(num2):
            negative = False
        else:
            if num1 < num2:
                num1, num2 = num2, num1
                negative = True
            else:
                negative = False

        max_length = max(len(num1), len(num2))
        num1 = num1.zfill(max_length)
        num2 = num2.zfill(max_length)

        borrow = 0
        result = []
        for i in range(max_length - 1, -1, -1):
            digit_diff = int(num1[i]) - int(num2[i]) - borrow

            if digit_diff < 0:
                digit_diff += 10
                borrow = 1
            else:
                borrow = 0

            result.insert(0, str(digit_diff))

        while len(result) > 1 and result[0] == '0':
            result.pop(0)

        if negative:
            result.insert(0, '-')

        return ''.join(result)

    @staticmethod
    def multiply(num1, num2):
        len1, len2 = len(num1), len(num2)
        result = [0] * (len1 + len2)

        for i in range(len1 - 1, -1, -1):
            for j in range(len2 - 1, -1, -1):
                mul = int(num1[i]) * int(num2[j])
                p1, p2 = i + j, i + j + 1
                total = mul + result[p2]

                result[p1] += total // 10
                result[p2] = total % 10

        start = 0
        while start < len(result) - 1 and result[start] == 0:
            start += 1

        return ''.join(map(str, result[start:]))",FewShot,"

```python
class BigNumCalculator:
    """"""
    This is a class that implements big number calculations, including adding, subtracting and multiplying.
    """"""

    @staticmethod
    def add(num1, num2):
        # Convert input strings to integers
        num1 = int(num1)
        num2 = int(num2)
        
        # Calculate the sum
        result = num1 + num2
        
        # Convert the result back to a string
        return str(result)

    @staticmethod
    def subtract(num1, num2):
        # Convert input strings to integers
        num1 = int(num1)
        num2 = int(num2)
        
        # Calculate the difference
        result = num1 - num2
        
        # Convert the result back to a string
        return str(result)

    @staticmethod
    def multiply(num1, num2):
        # Convert input strings to integers
        num1 = int(num1)
        num2 = int(num2)
        
        # Calculate the product
        result = num1 * num2
        
        # Convert the result back to a string
        return str(result)
```",0.019285054020785355,0.03457595114356836,0.18478260869565216,0.3541666666666667,0.24285713835102046,0.06417112299465241,0.18181818181818182,0.09486165622271885,0.15217391304347827,0.2916666666666667,0.19999999549387765
Llama,10,"class BinaryDataProcessor:
    def __init__(self, binary_string):
        self.binary_string = binary_string
        self.clean_non_binary_chars()

    def clean_non_binary_chars(self):
        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))

    def calculate_binary_info(self):
        zeroes_count = self.binary_string.count('0')
        ones_count = self.binary_string.count('1')
        total_length = len(self.binary_string)

        zeroes_percentage = (zeroes_count / total_length)
        ones_percentage = (ones_count / total_length)

        return {
            'Zeroes': zeroes_percentage,
            'Ones': ones_percentage,
            'Bit length': total_length
        }

    def convert_to_ascii(self):
        byte_array = bytearray()
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            decimal = int(byte, 2)
            byte_array.append(decimal)

        return byte_array.decode('ascii')

    def convert_to_utf8(self):
        byte_array = bytearray()
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            decimal = int(byte, 2)
            byte_array.append(decimal)

        return byte_array.decode('utf-8')",FewShot,"

```python
class BinaryDataProcessor:
    """"""
    This is a class used to process binary data, which includes functions such as clearing non 0 or 1 characters, 
    counting binary string information, and converting to corresponding strings based on different encoding methods.
    """"""

    def __init__(self, binary_string):
        # Initialize the class with a binary string and clean it by removing all non 0 or 1 characters.
        self.binary_string = binary_string
        self.clean_non_binary_chars()

    def clean_non_binary_chars(self):
        # Clean the binary string by removing all non 0 or 1 characters.
        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))

    def calculate_binary_info(self):
        # Calculate the binary string information, including the percentage of 0 and 1, and the total length of the binary string.
        zero_count = self.binary_string.count('0')
        one_count = self.binary_string.count('1')
        total_length = len(self.binary_string)
        
        # Calculate the percentage of 0 and 1
        zero_percentage = zero_count / total_length if total_length > 0 else 0
        one_percentage = one_count / total_length if total_length > 0 else 0
        
        return {'Zeroes': zero_percentage, 'Ones': one_percentage, 'Bit length': total_length}

    def convert_to_ascii(self):
        # Convert the binary string to ascii string.
        ascii_string = ''
        # Split the binary string into 8-bit chunks
        for i in range(0, len(self.binary_string), 8):
            byte = self.binary_string[i:i+8]
            # Convert each chunk to its corresponding ASCII character
            ascii_string += chr(int(byte, 2))
        return ascii_string

    def convert_to_utf8(self):
        # Convert the binary string to utf-8 string.
        # Since UTF-8 is a superset of ASCII, we can use the same conversion method as ASCII
        return self.convert_to_ascii()
```",0.09956709956709955,0.12600901222940827,0.6491228070175439,0.29133858267716534,0.40217390876713144,0.48148148148148145,0.1989795918367347,0.28158844351522894,0.6491228070175439,0.29133858267716534,0.40217390876713144
Llama,11,"class BitStatusUtil:
    @staticmethod
    def add(states, stat):
        BitStatusUtil.check([states, stat])
        return states | stat

    @staticmethod
    def has(states, stat):
        BitStatusUtil.check([states, stat])
        return (states & stat) == stat

    @staticmethod
    def remove(states, stat):
        BitStatusUtil.check([states, stat])
        if BitStatusUtil.has(states, stat):
            return states ^ stat
        return states

    @staticmethod
    def check(args):
        for arg in args:
            if arg < 0:
                raise ValueError(f""{arg} must be greater than or equal to 0"")
            if arg % 2 != 0:
                raise ValueError(f""{arg} not even"")",FewShot,"

```python
class BitStatusUtil:
    """"""
    This is a utility class that provides methods for manipulating and checking status using bitwise operations.
    """"""

    @staticmethod
    def add(states, stat):
        # Check if the parameters are legal
        BitStatusUtil.check([states, stat])
        # Add a status to the current status using bitwise OR operation
        return states | stat

    @staticmethod
    def has(states, stat):
        # Check if the parameters are legal
        BitStatusUtil.check([states, stat])
        # Check if the current status contains the specified status using bitwise AND operation
        return (states & stat) == stat

    @staticmethod
    def remove(states, stat):
        # Check if the parameters are legal
        BitStatusUtil.check([states, stat])
        # Remove the specified status from the current status using bitwise AND and NOT operations
        return states & (~stat)

    @staticmethod
    def check(args):
        # Check if all parameters are greater than or equal to 0 and even
        for arg in args:
            if arg < 0:
                raise ValueError(f""{arg} is less than 0"")
            if arg % 2 != 0:
                raise ValueError(f""{arg} is not even"")
```",0.22435897435897437,0.2640653948535801,0.9302325581395349,0.5128205128205128,0.6611570202117343,0.6964285714285714,0.3577981651376147,0.4727272682431589,0.8372093023255814,0.46153846153846156,0.5950413177323954
Llama,12,"import random


class BlackjackGame:
    def __init__(self):
        self.deck = self.create_deck()
        self.player_hand = []
        self.dealer_hand = []

    def create_deck(self):
        deck = []
        suits = ['S', 'C', 'D', 'H']
        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
        for suit in suits:
            for rank in ranks:
                deck.append(rank + suit)
        random.shuffle(deck)
        return deck

    def calculate_hand_value(self, hand):
        value = 0
        num_aces = 0
        for card in hand:
            rank = card[:-1]
            if rank.isdigit():
                value += int(rank)
            elif rank in ['J', 'Q', 'K']:
                value += 10
            elif rank == 'A':
                value += 11
                num_aces += 1
        while value > 21 and num_aces > 0:
            value -= 10
            num_aces -= 1
        return value

    def check_winner(self, player_hand, dealer_hand):
        player_value = self.calculate_hand_value(player_hand)
        dealer_value = self.calculate_hand_value(dealer_hand)
        if player_value > 21 and dealer_value > 21:
            if player_value <= dealer_value:
                return 'Player wins'
            else:
                return 'Dealer wins'
        elif player_value > 21:
            return 'Dealer wins'
        elif dealer_value > 21:
            return 'Player wins'
        else:
            if player_value <= dealer_value:
                return 'Dealer wins'
            else:
                return 'Player wins'",FewShot,"

```python
import random

class BlackjackGame:
    """"""
    This is a class representing a game of blackjack, which includes creating a deck, calculating the value of a hand, and determine the winner based on the hand values of the player and dealer.
    """"""

    def __init__(self):
        """"""
        Initialize the Blackjack Game with the attribute deck, player_hand and dealer_hand.
        While initializing deck attribute, call the create_deck method to generate.
        The deck stores 52 rondom order poker with the Jokers removed, format is ['AS', '2S', ...].
        player_hand is a list which stores player's hand cards.
        dealer_hand is is a list which stores dealer's hand cards.
        """"""
        self.deck = self.create_deck()
        self.player_hand = []
        self.dealer_hand = []

    def create_deck(self):
        """"""
        Create a deck of 52 cards, which stores 52 rondom order poker with the Jokers removed.
        :return: a list of 52 rondom order poker with the Jokers removed, format is ['AS', '2S', ...].
        """"""
        # Define the suits and ranks of a deck of cards
        suits = ['S', 'H', 'D', 'C']
        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
        
        # Generate the deck using list comprehension
        deck = [rank + suit for suit in suits for rank in ranks]
        
        # Shuffle the deck to randomize the order of the cards
        random.shuffle(deck)
        
        return deck

    def calculate_hand_value(self, hand):
        """"""
        Calculate the value of the poker cards stored in hand list according to the rules of the Blackjack Game.
        If the card is a digit, its value is added to the total hand value.
        Value of J, Q, or K is 10, while Aces are worth 11.
        If the total hand value exceeds 21 and there are Aces present, one Ace is treated as having a value of 1 instead of 11,
        until the hand value is less than or equal to 21, or all Aces have been counted as value of 1.
        :param hand: list
        :return: the value of the poker cards stored in hand list, a number.
        """"""
        # Initialize the total hand value and the number of Aces
        total_value = 0
        num_aces = 0
        
        # Iterate over each card in the hand
        for card in hand:
            # Extract the rank of the card
            rank = card[0]
            
            # Check if the card is an Ace
            if rank == 'A':
                # Increment the number of Aces
                num_aces += 1
                # Add 11 to the total hand value (Ace is initially worth 11)
                total_value += 11
            # Check if the card is a face card (J, Q, K)
            elif rank in ['J', 'Q', 'K']:
                # Add 10 to the total hand value (face cards are worth 10)
                total_value += 10
            # If the card is not an Ace or a face card, it's a numbered card
            else:
                # Add the value of the numbered card to the total hand value
                total_value += int(rank)
        
        # If the total hand value exceeds 21 and there are Aces present, adjust the value of the Aces
        while total_value > 21 and num_aces:
            # Subtract 10 from the total hand value (one Ace is now worth 1 instead of 11)
            total_value -= 10
            # Decrement the number of Aces
            num_aces -= 1
        
        return total_value

    def check_winner(self, player_hand, dealer_hand):
        """"""
        Determines the winner of a game by comparing the hand values of the player and dealer.
        rule:
        If both players have hand values that are equal to or less than 21, the winner is the one whose hand value is closer to 21.
        Otherwise, the winner is the one with the lower hand value.
        :param player_hand: list
        :param dealer_hand: list
        :return: the result of the game, only two certain str: 'Dealer wins' or 'Player wins'
        """"""
        # Calculate the hand values of the player and dealer
        player_value = self.calculate_hand_value(player_hand)
        dealer_value = self.calculate_hand_value(dealer_hand)
        
        # Check if both players have hand values that are equal to or less than 21
        if player_value <= 21 and dealer_value <= 21:
            # The winner is the one whose hand value is closer to 21
            if player_value > dealer_value:
                return 'Player wins'
            elif player_value < dealer_value:
                return 'Dealer wins'
            else:
                # If the hand values are equal, it's a tie
                return 'Tie'
        # If one or both players have hand values that exceed 21, the winner is the one with the lower hand value
        elif player_value <= 21:
            return 'Player wins'
        elif dealer_value <= 21:
            return 'Dealer wins'
        else:
            # If both players have hand values that exceed 21, the winner is the one with the lower hand value
            if player_value < dealer_value:
                return 'Player wins'
            else:
                return 'Dealer wins'
```",0.09283819628647216,0.11105794036511164,0.8928571428571429,0.31645569620253167,0.46728971576207534,0.65,0.18346774193548387,0.28616351857917016,0.8333333333333334,0.29535864978902954,0.43613706778699746
Llama,13,"class BookManagement:
    def __init__(self):
        self.inventory = {}

    def add_book(self, title, quantity=1):
        if title in self.inventory:
            self.inventory[title] += quantity
        else:
            self.inventory[title] = quantity

    def remove_book(self, title, quantity):
        if title not in self.inventory or self.inventory[title] < quantity:
            raise False
        self.inventory[title] -= quantity
        if self.inventory[title] == 0:
            del (self.inventory[title])

    def view_inventory(self):
        return self.inventory

    def view_book_quantity(self, title):
        if title not in self.inventory:
            return 0
        return self.inventory[title]",FewShot,"

```python
class BookManagement:
    """"""
    This is a class as managing books system, which supports to add and remove books from the inventory dict, view the inventory, and check the quantity of a specific book.
    """"""

    def __init__(self):
        """"""
        Initialize the inventory of Book Manager.
        """"""
        # Initialize an empty dictionary to store the inventory
        self.inventory = {}

    def add_book(self, title, quantity=1):
        """"""
        Add one or several books to inventory which is sorted by book title.
        :param title: str, the book title
        :param quantity: int, default value is 1.
        """"""
        # Check if the title already exists in the inventory
        if title in self.inventory:
            # If it exists, increment the quantity
            self.inventory[title] += quantity
        else:
            # If it doesn't exist, add it to the inventory with the given quantity
            self.inventory[title] = quantity
        # Sort the inventory by book title
        self.inventory = dict(sorted(self.inventory.items()))

    def remove_book(self, title, quantity):
        """"""
        Remove one or several books from inventory which is sorted by book title.
        Raise false while get invalid input.
        :param title: str, the book title
        :param quantity: int
        """"""
        # Check if the title exists in the inventory
        if title in self.inventory:
            # Check if the quantity to remove is valid (not more than the available quantity)
            if quantity <= self.inventory[title]:
                # If it's valid, decrement the quantity
                self.inventory[title] -= quantity
                # If the quantity reaches 0, remove the book from the inventory
                if self.inventory[title] == 0:
                    del self.inventory[title]
            else:
                # If it's not valid, raise a ValueError
                raise ValueError(""Invalid quantity to remove"")
        else:
            # If the title doesn't exist, raise a ValueError
            raise ValueError(""Book not found in inventory"")

    def view_inventory(self):
        """"""
        Get the inventory of the Book Management.
        :return self.inventory: dictionary, {title(str): quantity(int), ...}
        >>> bookManagement = BookManagement()
        >>> bookManagement.add_book(""book1"", 1)
        >>> bookManagement.add_book(""book2"", 1)
        >>> bookManagement.view_inventory()
        {'book1': 1, 'book2': 1}
        """"""
        # Return the current inventory
        return self.inventory

    def view_book_quantity(self, title):
        """"""
        Get the quantity of a book.
        :param title: str, the title of the book.
        :return quantity: the quantity of this book title. return 0 when the title does not exist in self.invenroty
        >>> bookManagement = BookManagement()
        >>> bookManagement.add_book(""book1"", 1)
        >>> bookManagement.view_book_quantity(""book3"")
        0
        """"""
        # Check if the title exists in the inventory
        if title in self.inventory:
            # If it exists, return the quantity
            return self.inventory[title]
        else:
            # If it doesn't exist, return 0
            return 0
```",0.052219321148825056,0.06817588363985537,0.8947368421052632,0.2328767123287671,0.3695652141138942,0.603448275862069,0.13157894736842105,0.2160493797767109,0.8947368421052632,0.2328767123287671,0.3695652141138942
Llama,14,"import sqlite3

class BookManagementDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS books (
                id INTEGER PRIMARY KEY,
                title TEXT,
                author TEXT,
                available INTEGER
            )
        ''')
        self.connection.commit()

    def add_book(self, title, author):
        self.cursor.execute('''
            INSERT INTO books (title, author, available)
            VALUES (?, ?, 1)
        ''', (title, author))
        self.connection.commit()

    def remove_book(self, book_id):
        self.cursor.execute('''
            DELETE FROM books WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def borrow_book(self, book_id):
        self.cursor.execute('''
            UPDATE books SET available = 0 WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def return_book(self, book_id):
        self.cursor.execute('''
            UPDATE books SET available = 1 WHERE id = ?
        ''', (book_id,))
        self.connection.commit()

    def search_books(self):
        self.cursor.execute('''
            SELECT * FROM books
        ''')
        books = self.cursor.fetchall()
        return books",FewShot,"

```python
import sqlite3

class BookManagementDB:
    """"""
    This is a database class as a book management system, used to handle the operations of adding, removing, updating, and searching books.
    """"""

    def __init__(self, db_name):
        """"""
        Initializes the class by creating a database connection and cursor, 
        and creates the book table if it does not already exist
        :param db_name: str, the name of db file
        """"""
        # Create a connection to the SQLite database
        self.connection = sqlite3.connect(db_name)
        # Create a cursor object to execute SQL queries
        self.cursor = self.connection.cursor()
        # Create the book table if it does not already exist
        self.create_table()

    def create_table(self):
        """"""
        Creates the book table in the database if it does not already exist.
        >>> book_db = BookManagementDB(""test.db"")
        >>> book_db.create_table()
        """"""
        # SQL query to create the book table
        query = """"""
            CREATE TABLE IF NOT EXISTS books (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                author TEXT NOT NULL,
                available INTEGER NOT NULL DEFAULT 1
            )
        """"""
        # Execute the SQL query
        self.cursor.execute(query)
        # Commit the changes to the database
        self.connection.commit()

    def add_book(self, title, author):
        """"""
        Adds a book to the database with the specified title and author, 
        setting its availability to 1 as free to borrow.
        :param title: str, book title
        :param author: str, author name
        >>> book_db = BookManagementDB(""test.db"")
        >>> book_db.create_table()
        >>> book_db.add_book('book1', 'author')
        """"""
        # SQL query to insert a new book into the book table
        query = ""INSERT INTO books (title, author) VALUES (?, ?)""
        # Execute the SQL query with the provided title and author
        self.cursor.execute(query, (title, author))
        # Commit the changes to the database
        self.connection.commit()

    def remove_book(self, book_id):
        """"""
        Removes a book from the database based on the given book ID.
        :param book_id: int
        >>> book_db = BookManagementDB(""test.db"")
        >>> book_db.remove_book(1)
        """"""
        # SQL query to delete a book from the book table
        query = ""DELETE FROM books WHERE id = ?""
        # Execute the SQL query with the provided book ID
        self.cursor.execute(query, (book_id,))
        # Commit the changes to the database
        self.connection.commit()

    def borrow_book(self, book_id):
        """"""
        Marks a book as borrowed in the database based on the given book ID.
        :param book_id: int
        >>> book_db = BookManagementDB(""test.db"")
        >>> book_db.borrow_book(1)
        """"""
        # SQL query to update the availability of a book in the book table
        query = ""UPDATE books SET available = 0 WHERE id = ?""
        # Execute the SQL query with the provided book ID
        self.cursor.execute(query, (book_id,))
        # Commit the changes to the database
        self.connection.commit()

    def return_book(self, book_id):
        """"""
        Marks a book as returned in the database based on the given book ID.
        :param book_id: int
        >>> book_db = BookManagementDB(""test.db"")
        >>> book_db.return_book(1)
        """"""
        # SQL query to update the availability of a book in the book table
        query = ""UPDATE books SET available = 1 WHERE id = ?""
        # Execute the SQL query with the provided book ID
        self.cursor.execute(query, (book_id,))
        # Commit the changes to the database
        self.connection.commit()

    def search_books(self):
        """"""
        Retrieves all books from the database and returns their information.
        :return books: list[tuple], the information of all books in database
        >>> book_db.search_books()
        [(1, 'book1', 'author', 1)]
        """"""
        # SQL query to select all books from the book table
        query = ""SELECT * FROM books""
        # Execute the SQL query
        self.cursor.execute(query)
        # Fetch all the rows from the query result
        rows = self.cursor.fetchall()
        # Return the list of books
        return rows
```",0.07272727272727272,0.08780954626486114,0.803030303030303,0.29775280898876405,0.43442622556167704,0.5555555555555556,0.16717325227963525,0.25700934223829597,0.7727272727272727,0.28651685393258425,0.4180327829387262
Llama,15,"class BoyerMooreSearch:
    def __init__(self, text, pattern):
        self.text, self.pattern = text, pattern
        self.textLen, self.patLen = len(text), len(pattern)

    def match_in_pattern(self, char):
        for i in range(self.patLen - 1, -1, -1):
            if char == self.pattern[i]:
                return i
        return -1

    def mismatch_in_text(self, currentPos):
        for i in range(self.patLen - 1, -1, -1):
            if self.pattern[i] != self.text[currentPos + i]:
                return currentPos + i
        return -1

    def bad_character_heuristic(self):
        positions = []
        for i in range(self.textLen - self.patLen + 1):
            mismatch_index = self.mismatch_in_text(i)
            if mismatch_index == -1:
                positions.append(i)
            else:
                match_index = self.match_in_pattern(self.text[mismatch_index])
                i = (mismatch_index - match_index)
        return positions",FewShot,"

```python
class BoyerMooreSearch:
    """"""
    This is a class that implements the Boyer-Moore algorithm for string searching, 
    which is used to find occurrences of a pattern within a given text.
    """"""

    def __init__(self, text, pattern):
        """"""
        Initializes the BoyerMooreSearch class with the given text and pattern.
        :param text: The text to be searched, str.
        :param pattern: The pattern to be searched for, str.
        """"""
        self.text, self.pattern = text, pattern
        self.textLen, self.patLen = len(text), len(pattern)

    def match_in_pattern(self, char):
        """"""
        Finds the rightmost occurrence of a character in the pattern.
        :param char: The character to be searched for, str.
        :return: The index of the rightmost occurrence of the character in the pattern, int.
        """"""
        # Iterate over the pattern from right to left to find the rightmost occurrence of the character
        for i in range(self.patLen - 1, -1, -1):
            if self.pattern[i] == char:
                return i
        # Return -1 if the character is not found in the pattern
        return -1

    def mismatch_in_text(self, currentPos):
        """"""
        Determines the position of the first mismatch between the pattern and the text.
        :param currentPos: The current position in the text, int.
        :return: The position of the first mismatch between the pattern and the text, int, otherwise -1.
        """"""
        # Iterate over the pattern and the corresponding substring in the text
        for i in range(self.patLen):
            # Check if the current position is within the text boundaries
            if currentPos + i >= self.textLen:
                return -1
            # Check if the characters at the current positions in the pattern and the text match
            if self.pattern[i] != self.text[currentPos + i]:
                # Return the position of the first mismatch
                return currentPos + i
        # Return -1 if no mismatch is found
        return -1

    def bad_character_heuristic(self):
        """"""
        Finds all occurrences of the pattern in the text using the bad character heuristic.
        :return: A list of all positions of the pattern in the text, list.
        """"""
        # Initialize an empty list to store the positions of the pattern in the text
        positions = []
        # Initialize the current position in the text
        currentPos = 0
        # Iterate over the text
        while currentPos <= self.textLen - self.patLen:
            # Find the position of the first mismatch between the pattern and the text
            mismatchPos = self.mismatch_in_text(currentPos)
            # Check if a mismatch is found
            if mismatchPos == -1:
                # If no mismatch is found, the pattern is found at the current position
                positions.append(currentPos)
                # Move the current position to the next possible position
                currentPos += self.patLen
            else:
                # If a mismatch is found, move the current position based on the bad character heuristic
                char = self.text[mismatchPos]
                matchPos = self.match_in_pattern(char)
                if matchPos == -1:
                    # If the character is not found in the pattern, move the current position to the next character
                    currentPos += 1
                else:
                    # If the character is found in the pattern, move the current position based on the match position
                    currentPos += mismatchPos - matchPos
        # Return the list of positions of the pattern in the text
        return positions
```",0.06938775510204083,0.08379864974633607,0.8076923076923077,0.2876712328767123,0.4242424203693501,0.5977011494252874,0.16199376947040497,0.2549019574289937,0.8076923076923077,0.2876712328767123,0.4242424203693501
Llama,16,"class Calculator:
    def __init__(self):
        self.operators = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '/': lambda x, y: x / y,
            '^': lambda x, y: x ** y
        }

    def calculate(self, expression):
        operand_stack = []
        operator_stack = []
        num_buffer = ''

        for char in expression:
            if char.isdigit() or char == '.':
                num_buffer += char
            else:
                if num_buffer:
                    operand_stack.append(float(num_buffer))
                    num_buffer = ''

                if char in '+-*/^':
                    while (
                            operator_stack and
                            operator_stack[-1] != '(' and
                            self.precedence(operator_stack[-1]) >= self.precedence(char)
                    ):
                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

                    operator_stack.append(char)
                elif char == '(':
                    operator_stack.append(char)
                elif char == ')':
                    while operator_stack and operator_stack[-1] != '(':
                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

                    operator_stack.pop()

        if num_buffer:
            operand_stack.append(float(num_buffer))

        while operator_stack:
            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)

        return operand_stack[-1] if operand_stack else None

    def precedence(self, operator):
        precedences = {
            '+': 1,
            '-': 1,
            '*': 2,
            '/': 2,
            '^': 3
        }
        return precedences.get(operator, 0)

    def apply_operator(self, operand_stack, operator_stack):
        operator = operator_stack.pop()
        if operator == '^':
            operand2 = operand_stack.pop()
            operand1 = operand_stack.pop()
            result = self.operators[operator](operand1, operand2)
            operand_stack.append(result)
        else:
            operand2 = operand_stack.pop()
            operand1 = operand_stack.pop()
            result = self.operators[operator](operand1, operand2)
            operand_stack.append(result)
        return operand_stack, operator_stack",FewShot,"

```python
class Calculator:
    """"""
    This is a class for a calculator, capable of performing basic arithmetic calculations on numerical expressions using the operators +, -, *, /, and ^ (exponentiation).
    """"""

    def __init__(self):
        """"""
        Initialize the operations performed by the five operators'+','-','*','/','^'
        """"""
        self.operators = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '/': lambda x, y: x / y,
            '^': lambda x, y: x ** y
        }

    def calculate(self, expression):
        """"""
        Calculate the value of a given expression
        :param expression: string, given expression
        :return:If successful, returns the value of the expression; otherwise, returns None
        """"""
        # Split the expression into numbers and operators
        tokens = self.tokenize(expression)
        
        # Initialize operand and operator stacks
        operand_stack = []
        operator_stack = []
        
        # Process each token
        for token in tokens:
            # If the token is a number, push it to the operand stack
            if isinstance(token, float):
                operand_stack.append(token)
            # If the token is an operator, apply operators with higher or equal precedence
            elif token in self.operators:
                while (operator_stack and 
                       self.precedence(operator_stack[-1]) >= self.precedence(token)):
                    operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)
                operator_stack.append(token)
        
        # Apply any remaining operators
        while operator_stack:
            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)
        
        # The final result is the only element left in the operand stack
        return operand_stack[0]

    def precedence(self, operator):
        """"""
        Returns the priority of the specified operator, where the higher the priority, the greater the assignment. The priority of '^' is greater than '/' and '*', and the priority of '/' and '*' is greater than '+' and '-'
        :param operator: string, given operator
        :return: int, the priority of the given operator, otherwise return 0
        """"""
        # Define operator precedence
        precedence = {
            '+': 1,
            '-': 1,
            '*': 2,
            '/': 2,
            '^': 3
        }
        return precedence.get(operator, 0)

    def apply_operator(self, operand_stack, operator_stack):
        """"""
        Use the operator at the top of the operator stack to perform the operation on the two numbers at the top of the operator stack, and store the results at the top of the operator stack
        :param operand_stack:list
        :param operator_stack:list
        :return: the updated operand_stack and operator_stack
        """"""
        # Pop the operator and two operands from their respective stacks
        operator = operator_stack.pop()
        operand2 = operand_stack.pop()
        operand1 = operand_stack.pop()
        
        # Apply the operator
        result = self.operators[operator](operand1, operand2)
        
        # Push the result back to the operand stack
        operand_stack.append(result)
        
        return operand_stack, operator_stack

    def tokenize(self, expression):
        """"""
        Split the expression into numbers and operators
        :param expression: string, given expression
        :return: list, tokens
        """"""
        tokens = []
        current_token = """"
        
        # Iterate over each character in the expression
        for char in expression:
            # If the character is a digit or a decimal point, add it to the current token
            if char.isdigit() or char == '.':
                current_token += char
            # If the character is an operator, add the current token to the list and reset the current token
            elif char in self.operators:
                if current_token:
                    tokens.append(float(current_token))
                    current_token = """"
                tokens.append(char)
        
        # Add the last token to the list
        if current_token:
            tokens.append(float(current_token))
        
        return tokens
```",0.1696969696969697,0.19296602736734975,0.8045977011494253,0.33653846153846156,0.47457626702763583,0.6026490066225165,0.22469135802469137,0.32733812553989183,0.7931034482758621,0.3317307692307692,0.4677966060106866
Llama,17,"from datetime import datetime, timedelta

class CalendarUtil:
    def __init__(self):
        self.events = []

    def add_event(self, event):
        self.events.append(event)

    def remove_event(self, event):
        if event in self.events:
            self.events.remove(event)

    def get_events(self, date):
        events_on_date = []
        for event in self.events:
            if event['date'].date() == date.date():
                events_on_date.append(event)
        return events_on_date

    def is_available(self, start_time, end_time):
        for event in self.events:
            if start_time < event['end_time'] and end_time > event['start_time']:
                return False
        return True

    def get_available_slots(self, date):
        available_slots = []
        start_time = datetime(date.year, date.month, date.day, 0, 0)
        end_time = datetime(date.year, date.month, date.day, 23, 59)

        while start_time < end_time:
            slot_end_time = start_time + timedelta(minutes=60)
            if self.is_available(start_time, slot_end_time):
                available_slots.append((start_time, slot_end_time))
            start_time += timedelta(minutes=60)


        return available_slots

    def get_upcoming_events(self, num_events):
        now = datetime.now()
        upcoming_events = []
        for event in self.events:
            if event['start_time'] >= now:
                upcoming_events.append(event)
            if len(upcoming_events) == num_events:
                break
        return upcoming_events",FewShot,"

```python
from datetime import datetime, timedelta

class CalendarUtil:
    """"""
    This is a class as CalendarUtil that provides functionalities to manage calendar events, schedule appointments, and perform conflict checks.
    """"""

    def __init__(self):
        # Initialize the calendar with an empty list of events.
        self.events = []

    def add_event(self, event):
        # Add an event to the calendar.
        self.events.append(event)

    def remove_event(self, event):
        # Remove an event from the calendar.
        if event in self.events:
            self.events.remove(event)

    def get_events(self, date):
        # Get all events on a given date.
        return [event for event in self.events if event['date'].date() == date.date()]

    def is_available(self, start_time, end_time):
        # Check if the calendar is available for a given time slot.
        for event in self.events:
            if (start_time >= event['start_time'] and start_time < event['end_time']) or \
               (end_time > event['start_time'] and end_time <= event['end_time']) or \
               (start_time <= event['start_time'] and end_time >= event['end_time']):
                return False
        return True

    def get_available_slots(self, date):
        # Get all available time slots on a given date.
        available_slots = []
        start_time = datetime.combine(date, datetime.min.time())
        end_time = datetime.combine(date, datetime.min.time()) + timedelta(hours=1)
        
        while end_time <= datetime.combine(date, datetime.max.time()):
            if self.is_available(start_time, end_time):
                available_slots.append((start_time, end_time))
            start_time += timedelta(hours=1)
            end_time += timedelta(hours=1)
        
        return available_slots

    def get_upcoming_events(self, num_events):
        # Get the next n upcoming events from a given date.
        upcoming_events = sorted(self.events, key=lambda x: x['start_time'])
        return upcoming_events[:num_events]
```",0.16990291262135923,0.21167938328291497,0.6933333333333334,0.45217391304347826,0.5473684162742383,0.475,0.3,0.3677419307388138,0.6666666666666666,0.43478260869565216,0.5263157846952908
Llama,18,"class CamelCaseMap:
    def __init__(self):
        self._data = {}

    def __getitem__(self, key):
        return self._data[self._convert_key(key)]

    def __setitem__(self, key, value):
        self._data[self._convert_key(key)] = value

    def __delitem__(self, key):
        del self._data[self._convert_key(key)]

    def __iter__(self):
        return iter(self._data)

    def __len__(self):
        return len(self._data)

    def _convert_key(self, key):
        if isinstance(key, str):
            return self._to_camel_case(key)
        return key

    @staticmethod
    def _to_camel_case(key):
        parts = key.split('_')
        return parts[0] + ''.join(part.title() for part in parts[1:])",FewShot,"

```python
class CamelCaseMap:
    """"""
    This is a custom class that allows keys to be in camel case style by converting them from underscore style, which provides dictionary-like functionality.
    """"""

    def __init__(self):
        """"""
        Initialize data to an empty dictionary
        """"""
        # Initialize an empty dictionary to store the data
        self._data = {}

    def __getitem__(self, key):
        """"""
        Return the value corresponding to the key
        :param key:str
        :return:str,the value corresponding to the key
        >>> camelize_map = CamelCaseMap()
        >>> camelize_map['first_name'] = 'John'
        >>> camelize_map.__getitem__('first_name')
        'John'
        """"""
        # Convert the key to camel case and return the corresponding value
        return self._data[self._to_camel_case(key)]

    def __setitem__(self, key, value):
        """"""
        Set the value corresponding to the key to the specified value
        :param key:str
        :param value:str, the specified value
        :return:None
        >>> camelize_map = CamelCaseMap()
        >>> camelize_map['first_name'] = 'John'
        >>> camelize_map.__setitem__('first_name', 'new name')
        camelize_map['first_name'] = 'new name'
        """"""
        # Convert the key to camel case and set the corresponding value
        self._data[self._to_camel_case(key)] = value

    def __delitem__(self, key):
        """"""
        Delete the value corresponding to the key
        :param key:str
        :return:None
        >>> camelize_map = CamelCaseMap()
        >>> camelize_map['first_name'] = 'John'
        >>> camelize_map.__delitem__('first_name')
        >>> flag = 'first_name' in camelize_map
        flag = False
        """"""
        # Convert the key to camel case and delete the corresponding value
        del self._data[self._to_camel_case(key)]

    def __iter__(self):
        """"""
        Returning Iterateable Objects with Own Data
        :return:Iterator
        >>> camelize_map = CamelCaseMap()
        >>> camelize_map['first_name'] = 'John'
        >>> camelize_map['last_name'] = 'Doe'
        >>> camelize_map['age'] = 30
        >>> camelize_map.__iter__()
        <dict_keyiterator object at 0x0000026739977C20>
        """"""
        # Return an iterator over the dictionary keys
        return iter(self._data)

    def __len__(self):
        """"""
        Returns the length of the own data
        :return:int, length of data
        >>> camelize_map = CamelCaseMap()
        >>> camelize_map['first_name'] = 'John'
        >>> camelize_map['last_name'] = 'Doe'
        >>> camelize_map['age'] = 30
        >>> camelize_map.__len__()
        3
        """"""
        # Return the number of items in the dictionary
        return len(self._data)

    def _convert_key(self, key):
        """"""
        convert key string into camel case
        :param key:str
        :return:str, converted key string
        >>> camelize_map = CamelCaseMap()
        >>> camelize_map._convert_key('first_name')
        'firstName'
        """"""
        # Split the key into words and capitalize the first letter of each word except the first one
        words = key.split('_')
        return words[0] + ''.join(word.capitalize() for word in words[1:])

    @staticmethod
    def _to_camel_case(key):
        """"""
        convert key string into camel case
        :param key:str
        :return:str, converted key string
        >>> camelize_map = CamelCaseMap()
        >>> camelize_map._to_camel_case('first_name')
        'firstName'
        """"""
        # Split the key into words and capitalize the first letter of each word except the first one
        words = key.split('_')
        return words[0] + ''.join(word.capitalize() for word in words[1:])
```",0.04071246819338422,0.0511981355015165,0.7441860465116279,0.22535211267605634,0.345945942377794,0.5409836065573771,0.13414634146341464,0.21498371017071802,0.7441860465116279,0.22535211267605634,0.345945942377794
Llama,19,"class ChandrasekharSieve:
    def __init__(self, n):
        self.n = n
        self.primes = self.generate_primes()

    def generate_primes(self):
        if self.n < 2:
            return []

        sieve = [True] * (self.n + 1)
        sieve[0] = sieve[1] = False

        p = 2
        while p * p <= self.n:
            if sieve[p]:
                for i in range(p * p, self.n + 1, p):
                    sieve[i] = False
            p += 1

        primes = []
        for i in range(2, self.n + 1):
            if sieve[i]:
                primes.append(i)

        return primes

    def get_primes(self):
        return self.primes",FewShot,"

```python
class ChandrasekharSieve:
    """"""
    This is a class that uses the Chandrasekhar's Sieve method to find all prime numbers within the range
    """"""

    def __init__(self, n):
        """"""
        Initialize the ChandrasekharSieve class with the given limit.
        :param n: int, the upper limit for generating prime numbers
        """"""
        self.n = n
        self.primes = self.generate_primes()

    # Generate prime numbers up to the specified limit using the Chandrasekhar sieve algorithm
    def generate_primes(self):
        # Create a boolean array, prime, of size n+1
        prime = [True] * (self.n + 1)
        prime[0] = prime[1] = False  # 0 and 1 are not prime numbers

        # Iterate from 2 to sqrt(n)
        for p in range(2, int(self.n ** 0.5) + 1):
            # If p is a prime, mark as composite all the multiples of p
            if prime[p]:
                for i in range(p * p, self.n + 1, p):
                    prime[i] = False

        # Return a list of all prime numbers in the range
        return [p for p in range(2, self.n + 1) if prime[p]]

    # Get the list of generated prime numbers
    def get_primes(self):
        """"""
        Get the list of generated prime numbers.
        :return: list, a list of prime numbers
        """"""
        return self.primes
```",0.10000000000000002,0.13560377266279475,0.7391304347826086,0.3300970873786408,0.4563758346578984,0.4266666666666667,0.18823529411764706,0.26122448554768846,0.7391304347826086,0.3300970873786408,0.4563758346578984
Llama,20,"from datetime import datetime

class Chat:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username in self.users:
            return False
        else:
            self.users[username] = []
            return True

    def remove_user(self, username):
        if username in self.users:
            del self.users[username]
            return True
        else:
            return False

    def send_message(self, sender, receiver, message):
        if sender not in self.users or receiver not in self.users:
            return False

        timestamp = datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
        message_info = {
            'sender': sender,
            'receiver': receiver,
            'message': message,
            'timestamp': timestamp
        }
        self.users[sender].append(message_info)
        self.users[receiver].append(message_info)
        return True

    def get_messages(self, username):
        if username not in self.users:
            return []
        return self.users[username]",FewShot,"

```python
class Chat:
    """"""
    This is a chat class with the functions of adding users, removing users, sending messages, and obtaining messages.
    """"""

    def __init__(self):
        """"""
        Initialize the Chat with an attribute users, which is an empty dictionary.
        """"""
        # Initialize an empty dictionary to store users and their messages
        self.users = {}

    def add_user(self, username):
        """"""
        Add a new user to the Chat.
        :param username: The user's name, str.
        :return: If the user is already in the Chat, returns False, otherwise, returns True.
        """"""
        # Check if the user already exists in the chat
        if username in self.users:
            # If the user exists, return False
            return False
        else:
            # If the user does not exist, add them to the chat with an empty list of messages
            self.users[username] = []
            # Return True to indicate that the user was added successfully
            return True

    def remove_user(self, username):
        """"""
        Remove a user from the Chat.
        :param username: The user's name, str.
        :return: If the user is already in the Chat, returns True, otherwise, returns False.
        """"""
        # Check if the user exists in the chat
        if username in self.users:
            # If the user exists, remove them from the chat
            del self.users[username]
            # Return True to indicate that the user was removed successfully
            return True
        else:
            # If the user does not exist, return False
            return False

    def send_message(self, sender, receiver, message):
        """"""
        Send a message from a user to another user.
        :param sender: The sender's name, str.
        :param receiver: The receiver's name, str.
        :param message: The message, str.
        :return: If the sender or the receiver is not in the Chat, returns False, otherwise, returns True.
        """"""
        # Check if both the sender and receiver exist in the chat
        if sender in self.users and receiver in self.users:
            # If both users exist, create a new message with the current timestamp
            new_message = {
                'sender': sender,
                'receiver': receiver,
                'message': message,
                'timestamp': datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
            }
            # Add the new message to the receiver's list of messages
            self.users[receiver].append(new_message)
            # Return True to indicate that the message was sent successfully
            return True
        else:
            # If either the sender or receiver does not exist, return False
            return False

    def get_messages(self, username):
        """"""
        Get all the messages of a user from the Chat.
        :param username: The user's name, str.
        :return: A list of messages, each message is a dictionary with keys 'sender', 'receiver', 'message', 'timestamp'.
        """"""
        # Check if the user exists in the chat
        if username in self.users:
            # If the user exists, return their list of messages
            return self.users[username]
        else:
            # If the user does not exist, return an empty list
            return []
```",0.06206896551724138,0.08562262413785582,0.9183673469387755,0.3358208955223881,0.49180327476723706,0.6025641025641025,0.17669172932330826,0.2732558104468632,0.9183673469387755,0.3358208955223881,0.49180327476723706
Llama,21,"from datetime import datetime


class Classroom:
    def __init__(self, id):
        self.id = id
        self.courses = []

    def add_course(self, course):

        if course not in self.courses:
            self.courses.append(course)

    def remove_course(self, course):
        if course in self.courses:
            self.courses.remove(course)

    def is_free_at(self, check_time):
        check_time = datetime.strptime(check_time, '%H:%M')

        for course in self.courses:
            if datetime.strptime(course['start_time'], '%H:%M') <= check_time <= datetime.strptime(course['end_time'],
                                                                                                   '%H:%M'):
                return False
        return True

    def check_course_conflict(self, new_course):
        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M')
        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M')

        flag = True
        for course in self.courses:
            start_time = datetime.strptime(course['start_time'], '%H:%M')
            end_time = datetime.strptime(course['end_time'], '%H:%M')
            if start_time <= new_start_time and end_time >= new_start_time:
                flag = False
            if start_time <= new_end_time and end_time >= new_end_time:
                flag = False
        return flag",FewShot,"

```python
from datetime import datetime

class Classroom:
    """"""
    This is a class representing a classroom, capable of adding and removing courses, checking availability at a given time, and detecting conflicts when scheduling new courses.
    """"""

    def __init__(self, id):
        """"""
        Initialize the classroom management system.
        :param id: int, the id of classroom
        """"""
        self.id = id
        self.courses = []

    def add_course(self, course):
        """"""
        Add course to self.courses list if the course wasn't in it.
        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'
        >>> classroom = Classroom(1)
        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})
        """"""
        # Check if the course already exists in the list
        if course not in self.courses:
            self.courses.append(course)

    def remove_course(self, course):
        """"""
        Remove course from self.courses list if the course was in it.
        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'
        >>> classroom = Classroom(1)
        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})
        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})
        """"""
        # Check if the course exists in the list
        if course in self.courses:
            self.courses.remove(course)

    def is_free_at(self, check_time):
        """"""
        change the time format as '%H:%M' and check the time is free or not in the classroom.
        :param check_time: str, the time need to be checked
        :return: True if the check_time does not conflict with every course time, or False otherwise.
        >>> classroom = Classroom(1)
        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})
        >>> classroom.is_free_at('10:00')
        True
        >>> classroom.is_free_at('9:00')
        False
        """"""
        # Convert check_time to minutes
        check_time_minutes = self.time_to_minutes(check_time)
        
        # Check each course in the classroom
        for course in self.courses:
            # Convert course times to minutes
            start_time_minutes = self.time_to_minutes(course['start_time'])
            end_time_minutes = self.time_to_minutes(course['end_time'])
            
            # Check if check_time is within a course time
            if start_time_minutes <= check_time_minutes < end_time_minutes:
                return False
        
        # If no conflicts are found, return True
        return True

    def check_course_conflict(self, new_course):
        """"""
        Before adding a new course, check if the new course time conflicts with any other course.
        :param new_course: dict, information of the course, including 'start_time', 'end_time' and 'name'
        :return: False if the new course time conflicts(including two courses have the same boundary time) with other courses, or True otherwise.
        >>> classroom = Classroom(1)
        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})
        >>> classroom.check_course_conflict({'name': 'SE', 'start_time': '9:40', 'end_time': '10:40'})
        False
        """"""
        # Convert new course times to minutes
        new_start_time_minutes = self.time_to_minutes(new_course['start_time'])
        new_end_time_minutes = self.time_to_minutes(new_course['end_time'])
        
        # Check each course in the classroom
        for course in self.courses:
            # Convert course times to minutes
            start_time_minutes = self.time_to_minutes(course['start_time'])
            end_time_minutes = self.time_to_minutes(course['end_time'])
            
            # Check if new course time conflicts with a course time
            if (new_start_time_minutes < end_time_minutes and new_end_time_minutes > start_time_minutes) or \
               (new_start_time_minutes == start_time_minutes) or (new_end_time_minutes == end_time_minutes):
                return False
        
        # If no conflicts are found, return True
        return True

    def time_to_minutes(self, time_str):
        """"""
        Convert time string to minutes.
        :param time_str: str, time in 'HH:MM' format
        :return: int, time in minutes
        """"""
        # Split time string into hours and minutes
        hours, minutes = map(int, time_str.split(':'))
        
        # Convert time to minutes
        return hours * 60 + minutes
```",0.06557377049180328,0.07935306519107996,0.6938775510204082,0.2,0.3105022796313672,0.42391304347826086,0.11818181818181818,0.18483411981312192,0.6938775510204082,0.2,0.3105022796313672
Llama,22,"class ClassRegistrationSystem:

    def __init__(self):
        self.students = []
        self.students_registration_classes = {}

    def register_student(self, student):
        if student in self.students:
            return 0
        else:
            self.students.append(student)
            return 1

    def register_class(self, student_name, class_name):
        if student_name in self.students_registration_classes:
            self.students_registration_classes[student_name].append(class_name)
        else:
            self.students_registration_classes[student_name] = [class_name]
        return self.students_registration_classes[student_name]

    def get_students_by_major(self, major):
        student_list = []
        for student in self.students:
            if student[""major""] == major:
                student_list.append(student[""name""])
        return student_list

    def get_all_major(self):
        major_list = []
        for student in self.students:
            if student[""major""] not in major_list:
                major_list.append(student[""major""])
        return major_list

    def get_most_popular_class_in_major(self, major):
        class_list = []
        for student in self.students:
            if student[""major""] == major:
                class_list += self.students_registration_classes[student[""name""]]
        most_popular_class = max(set(class_list), key=class_list.count)
        return most_popular_class",FewShot,"

```python
class ClassRegistrationSystem:
    """"""
    This is a class as a class registration system, allowing to register students, register them for classes, retrieve students by major, get a list of all majors, and determine the most popular class within a specific major.
    """"""

    def __init__(self):
        """"""
        Initialize the registration system with the attribute students and students_registration_class.
        students is a list of student dictionaries, each student dictionary has the key of name and major.
        students_registration_class is a dictionaries, key is the student name, value is a list of class names
        """"""
        self.students = []
        self.students_registration_classes = {}

    def register_student(self, student):
        """"""
        register a student to the system, add the student to the students list, if the student is already registered, return 0, else return 1
        """"""
        # Check if the student is already registered
        for existing_student in self.students:
            if existing_student[""name""] == student[""name""]:
                return 0
        # If not, add the student to the list and return 1
        self.students.append(student)
        return 1

    def register_class(self, student_name, class_name):
        """"""
        register a class to the student.
        :param student_name: str
        :param class_name: str
        :return a list of class names that the student has registered
        """"""
        # Check if the student is registered
        for student in self.students:
            if student[""name""] == student_name:
                # If the student is registered, add the class to their list of classes
                if student_name in self.students_registration_classes:
                    self.students_registration_classes[student_name].append(class_name)
                else:
                    self.students_registration_classes[student_name] = [class_name]
                # Return the list of classes the student is registered for
                return self.students_registration_classes[student_name]
        # If the student is not registered, return an empty list
        return []

    def get_students_by_major(self, major):
        """"""
        get all students in the major
        :param major: str
        :return a list of student name
        """"""
        # Initialize an empty list to store the students in the major
        students_in_major = []
        # Iterate over the students
        for student in self.students:
            # Check if the student's major matches the given major
            if student[""major""] == major:
                # If it does, add the student's name to the list
                students_in_major.append(student[""name""])
        # Return the list of students in the major
        return students_in_major

    def get_all_major(self):
        """"""
        get all majors in the system
        :return a list of majors
        """"""
        # Initialize an empty set to store the majors (using a set to avoid duplicates)
        majors = set()
        # Iterate over the students
        for student in self.students:
            # Add the student's major to the set
            majors.add(student[""major""])
        # Convert the set to a list and return it
        return list(majors)

    def get_most_popular_class_in_major(self, major):
        """"""
        get the class with the highest enrollment in the major.
        :return  a string of the most popular class in this major
        """"""
        # Initialize an empty dictionary to store the count of each class
        class_counts = {}
        # Iterate over the students in the major
        for student_name in self.get_students_by_major(major):
            # Get the classes the student is registered for
            classes = self.students_registration_classes.get(student_name, [])
            # Iterate over the classes
            for class_name in classes:
                # Increment the count for the class
                if class_name in class_counts:
                    class_counts[class_name] += 1
                else:
                    class_counts[class_name] = 1
        # Find the class with the highest count
        most_popular_class = max(class_counts, key=class_counts.get) if class_counts else None
        # Return the most popular class
        return most_popular_class
```",0.06078431372549019,0.0782928421690334,0.82,0.271523178807947,0.407960195267444,0.5476190476190477,0.13031161473087818,0.21052631268404823,0.82,0.271523178807947,0.407960195267444
Llama,23,"import math
from typing import List

class CombinationCalculator:
    def __init__(self, datas: List[str]):
        self.datas = datas

    @staticmethod
    def count(n: int, m: int) -> int:
        if m == 0 or n == m:
            return 1
        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))

    @staticmethod
    def count_all(n: int) -> int:
        if n < 0 or n > 63:
            return False
        return (1 << n) - 1 if n != 63 else float(""inf"")

    def select(self, m: int) -> List[List[str]]:
        result = []
        self._select(0, [None] * m, 0, result)
        return result

    def select_all(self) -> List[List[str]]:
        result = []
        for i in range(1, len(self.datas) + 1):
            result.extend(self.select(i))
        return result

    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):
        resultLen = len(resultList)
        resultCount = resultIndex + 1
        if resultCount > resultLen:
            result.append(resultList.copy())
            return

        for i in range(dataIndex, len(self.datas) + resultCount - resultLen):
            resultList[resultIndex] = self.datas[i]
            self._select(i + 1, resultList, resultIndex + 1, result)",FewShot,"

```python
import math
from typing import List
import itertools

class CombinationCalculator:
    """"""
    This is a class that provides methods to calculate the number of combinations for a specific count, 
    calculate all possible combinations, and generate combinations with a specified number of elements.
    """"""

    def __init__(self, datas: List[str]):
        """"""
        Initialize the calculator with a list of data.
        """"""
        self.datas = datas

    @staticmethod
    def count(n: int, m: int) -> int:
        # Calculate the number of combinations using the formula n! / (m! * (n-m)!)
        if n < m:
            return 0
        return math.comb(n, m)

    @staticmethod
    def count_all(n: int) -> int:
        # Calculate the number of all possible combinations using the formula 2^n - 1
        # If the number of combinations is greater than 2^63-1, return float(""inf"")
        count = 2 ** n - 1
        if count > 2 ** 63 - 1:
            return float(""inf"")
        return count

    def select(self, m: int) -> List[List[str]]:
        # Generate combinations with a specified number of elements using itertools.combinations
        return [list(combination) for combination in itertools.combinations(self.datas, m)]

    def select_all(self) -> List[List[str]]:
        # Generate all possible combinations of selecting elements from the given data list
        # Use the select method to generate combinations of each size
        all_combinations = []
        for i in range(1, len(self.datas) + 1):
            all_combinations.extend(self.select(i))
        return all_combinations

    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]], m: int):
        # Generate combinations with a specified number of elements by recursion
        if resultIndex == m:
            result.append(resultList[:])
            return
        for i in range(dataIndex, len(self.datas)):
            resultList[resultIndex] = self.datas[i]
            self._select(i + 1, resultList, resultIndex + 1, result, m)

# Example usage
calc = CombinationCalculator([""A"", ""B"", ""C"", ""D""])
print(CombinationCalculator.count(4, 2))  # Output: 6
print(CombinationCalculator.count_all(4))  # Output: 15
print(calc.select(2))  # Output: [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]
print(calc.select_all())  # Output: [['A'], ['B'], ['C'], ['D'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D'], ['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D'], ['A', 'B', 'C', 'D']]
result = []
calc._select(0, [None] * 2, 0, result, 2)
print(result)  # Output: [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]
```",0.1536231884057971,0.18228006036950384,0.7333333333333333,0.3905325443786982,0.5096525051176937,0.5036496350364964,0.24555160142348753,0.3301435362632495,0.7222222222222222,0.38461538461538464,0.5019304973956858
Llama,24,"class ComplexCalculator:
    def __init__(self):
        pass

    @staticmethod
    def add(c1, c2):
        real = c1.real + c2.real
        imaginary = c1.imag + c2.imag
        answer = complex(real, imaginary)
        return answer
    
    @staticmethod
    def subtract(c1, c2):
        real = c1.real - c2.real
        imaginary = c1.imag - c2.imag
        return complex(real, imaginary)
    
    @staticmethod
    def multiply(c1, c2):
        real = c1.real * c2.real - c1.imag * c2.imag
        imaginary = c1.real * c2.imag + c1.imag * c2.real
        return complex(real, imaginary)
    
    @staticmethod
    def divide(c1, c2):
        denominator = c2.real**2 + c2.imag**2
        real = (c1.real * c2.real + c1.imag * c2.imag) / denominator
        imaginary = (c1.imag * c2.real - c1.real * c2.imag) / denominator
        return complex(real, imaginary)",FewShot,"

```python
class ComplexCalculator:
    """"""
    This is a class that implements addition, subtraction, multiplication, and division operations for complex numbers.
    """"""

    def __init__(self):
        pass

    # Method to add two complex numbers
    @staticmethod
    def add(c1, c2):
        # Simply add the real and imaginary parts of the two complex numbers
        return c1 + c2

    # Method to subtract two complex numbers
    @staticmethod
    def subtract(c1, c2):
        # Simply subtract the real and imaginary parts of the two complex numbers
        return c1 - c2

    # Method to multiply two complex numbers
    @staticmethod
    def multiply(c1, c2):
        # Use the formula for complex multiplication: (a + bi)(c + di) = (ac - bd) + (ad + bc)i
        # However, Python's built-in complex number support handles this automatically
        return c1 * c2

    # Method to divide two complex numbers
    @staticmethod
    def divide(c1, c2):
        # Use the formula for complex division: (a + bi)/(c + di) = ((ac + bd) / (c^2 + d^2)) + ((bc - ad) / (c^2 + d^2))i
        # However, Python's built-in complex number support handles this automatically
        if c2 == 0:
            raise ZeroDivisionError(""Cannot divide by zero"")
        return c1 / c2
```",0.04864864864864866,0.06615683758877032,0.7,0.25301204819277107,0.371681412029133,0.2459016393442623,0.11904761904761904,0.16042780309073765,0.6666666666666666,0.24096385542168675,0.3539822969848853
Llama,25,"import json

class CookiesUtil:
    def __init__(self, cookies_file):
        self.cookies_file = cookies_file
        self.cookies = None

    def get_cookies(self, reponse):
        self.cookies = reponse['cookies']
        self._save_cookies()

    def load_cookies(self):
        try:
            with open(self.cookies_file, 'r') as file:
                cookies_data = json.load(file)
                return cookies_data
        except FileNotFoundError:
            return {}

    def _save_cookies(self):
        try:
            with open(self.cookies_file, 'w') as file:
                json.dump(self.cookies, file)
            return True
        except:
            return False

    def set_cookies(self, request):
        request['cookies'] = '; '.join([f'{key}={value}' for key, value in self.cookies.items()])",FewShot,"

```python
import json

class CookiesUtil:
    """"""
    This is a class as utility for managing and manipulating Cookies, including methods for retrieving, saving, and setting Cookies data.
    """"""

    def __init__(self, cookies_file):
        """"""
        Initializes the CookiesUtil with the specified cookies file.
        :param cookies_file: The cookies file to use, str.
        """"""
        self.cookies_file = cookies_file
        self.cookies = None

    def get_cookies(self, response):
        """"""
        Gets the cookies from the specified response, and save it to cookies_file.
        :param response: The response to get cookies from, dict.
        """"""
        # Extract cookies from the response
        self.cookies = response.get('cookies')
        # Save the cookies to the file
        self._save_cookies()

    def load_cookies(self):
        """"""
        Loads the cookies from the cookies_file to the cookies data.
        :return: The cookies data, dict.
        """"""
        try:
            # Open the cookies file and load the data
            with open(self.cookies_file, 'r') as file:
                self.cookies = json.load(file)
            return self.cookies
        except FileNotFoundError:
            # If the file does not exist, return an empty dictionary
            return {}
        except json.JSONDecodeError:
            # If the file is not a valid JSON, return an empty dictionary
            return {}

    def _save_cookies(self):
        """"""
        Saves the cookies to the cookies_file, and returns True if successful, False otherwise.
        :return: True if successful, False otherwise.
        """"""
        try:
            # Open the cookies file and save the data
            with open(self.cookies_file, 'w') as file:
                json.dump(self.cookies, file)
            return True
        except Exception as e:
            # If an error occurs, print the error and return False
            print(f""Error saving cookies: {e}"")
            return False
```",0.10000000000000002,0.11884173719920305,0.7142857142857143,0.32407407407407407,0.44585986831757884,0.5588235294117647,0.1958762886597938,0.29007633203426375,0.7142857142857143,0.32407407407407407,0.44585986831757884
Llama,26,"import csv


class CSVProcessor:

    def __init__(self):
        pass

    def read_csv(self, file_name):
        data = []
        with open(file_name, 'r') as file:
            reader = csv.reader(file)
            title = next(reader)
            for row in reader:
                data.append(row)
        return title, data

    def write_csv(self, data, file_name):
        try:
            with open(file_name, 'w', newline='') as file:
                writer = csv.writer(file)
                writer.writerows(data)
            return 1
        except:
            return 0

    def process_csv_data(self, N, save_file_name):
        title, data = self.read_csv(save_file_name)
        column_data = [row[N] for row in data]
        column_data = [row.upper() for row in column_data]
        new_data = [title, column_data]
        return self.write_csv(new_data, save_file_name.split('.')[0] + '_process.csv')",FewShot,"

```python
import csv

class CSVProcessor:
    """"""
    This is a class for processing CSV files, including reading and writing CSV data, as well as processing specific operations and saving as a new CSV file.
    """"""

    def __init__(self):
        # Initialize the CSVProcessor object
        pass

    def read_csv(self, file_name):
        """"""
        Read the csv file by file_name, get the title and data from it
        :param file_name: str, name of the csv file
        :return title, data: (list, list), first row is title, the rest is data
        """"""
        try:
            # Open the CSV file in read mode
            with open(file_name, 'r') as file:
                # Create a CSV reader object
                csv_reader = csv.reader(file)
                # Read the title (first row)
                title = next(csv_reader)
                # Read the data (rest of the rows)
                data = list(csv_reader)
                # Return the title and data
                return title, data
        except FileNotFoundError:
            # Handle the case when the file is not found
            print(f""File '{file_name}' not found."")
            return None
        except Exception as e:
            # Handle any other exceptions
            print(f""An error occurred: {e}"")
            return None

    def write_csv(self, data, file_name):
        """"""
        Write data into a csv file.
        :param file_name: str, name of the csv file
        :return:int, if success return 1, or 0 otherwise
        """"""
        try:
            # Open the CSV file in write mode
            with open(file_name, 'w', newline='') as file:
                # Create a CSV writer object
                csv_writer = csv.writer(file)
                # Write the data to the CSV file
                csv_writer.writerows(data)
                # Return success (1)
                return 1
        except Exception as e:
            # Handle any exceptions
            print(f""An error occurred: {e}"")
            # Return failure (0)
            return 0

    def process_csv_data(self, N, save_file_name):
        """"""
        Read a csv file into variable title and data.
        Only remain the N th (from 0) column data and Capitalize them, store the title and new data into a new csv file.
        Add '_process' suffix after old file name, as a new file name.
        :param N: int, the N th column(from 0)
        :param save_file_name, the name of file that needs to be processed.
        :return:int, if success return 1, or 0 otherwise
        """"""
        # Read the CSV file
        title, data = self.read_csv(save_file_name)
        if title is None or data is None:
            # If reading the file failed, return failure (0)
            return 0
        # Process the data (capitalize the Nth column)
        new_data = [[row[N].upper()] for row in data]
        # Create the new title (only the Nth column)
        new_title = [title[N]]
        # Create the new CSV data
        new_csv_data = [new_title] + new_data
        # Create the new file name by adding '_process' to the original file name
        new_file_name = save_file_name.split('.')[0] + '_process.csv'
        # Write the new CSV data to the new file
        return self.write_csv(new_csv_data, new_file_name)
```",0.051764705882352935,0.06884074770759943,0.7796610169491526,0.25842696629213485,0.38818565026900964,0.5,0.12615384615384614,0.20147419825655455,0.7796610169491526,0.25842696629213485,0.38818565026900964
Llama,27,"class CurrencyConverter:
    def __init__(self):
        self.rates = {
            'USD': 1.0,
            'EUR': 0.85,
            'GBP': 0.72,
            'JPY': 110.15,
            'CAD': 1.23,
            'AUD': 1.34,
            'CNY': 6.40,
        }

    def convert(self, amount, from_currency, to_currency):
        if from_currency == to_currency:
            return amount

        if from_currency not in self.rates or to_currency not in self.rates:
            return False

        from_rate = self.rates[from_currency]
        to_rate = self.rates[to_currency]

        converted_amount = (amount / from_rate) * to_rate
        return converted_amount

    def get_supported_currencies(self):
        return list(self.rates.keys())

    def add_currency_rate(self, currency, rate):
        if currency in self.rates:
            return False
        self.rates[currency] = rate

    def update_currency_rate(self, currency, new_rate):
        if currency not in self.rates:
            return False
        self.rates[currency] = new_rate",FewShot,"

```python
class CurrencyConverter:
    """"""
    This is a class for currency conversion, which supports to convert amounts between different currencies, retrieve supported currencies, add new currency rates, and update existing currency rates.
    """"""

    def __init__(self):
        """"""
        Initialize the exchange rate of the US dollar against various currencies
        """"""
        # Initialize the exchange rates dictionary
        self.rates = {
            'USD': 1.0,
            'EUR': 0.85,
            'GBP': 0.72,
            'JPY': 110.15,
            'CAD': 1.23,
            'AUD': 1.34,
            'CNY': 6.40,
        }

    def convert(self, amount, from_currency, to_currency):
        """"""
        Convert the value of a given currency to another currency type
        :param amount: float, The value of a given currency
        :param from_currency: string, source currency type
        :param to_currency: string, target currency type
        :return: float, value converted to another currency type
        """"""
        # Check if both currencies are supported
        if from_currency not in self.rates or to_currency not in self.rates:
            raise ValueError(""Unsupported currency"")
        
        # Convert the amount to USD first
        usd_amount = amount / self.rates[from_currency]
        
        # Then convert the USD amount to the target currency
        converted_amount = usd_amount * self.rates[to_currency]
        
        return converted_amount

    def get_supported_currencies(self):
        """"""
        Returns a list of supported currency types
        :return:list, All supported currency types
        """"""
        # Return a list of supported currencies
        return list(self.rates.keys())

    def add_currency_rate(self, currency, rate):
        """"""
        Add a new supported currency type, return False if the currency type is already in the support list
        :param currency:string, currency type to be added
        :param rate:float, exchange rate for this type of currency
        :return:If successful, returns None; if unsuccessful, returns False
        """"""
        # Check if the currency is already supported
        if currency in self.rates:
            return False
        
        # Add the new currency to the rates dictionary
        self.rates[currency] = rate

    def update_currency_rate(self, currency, new_rate):
        """"""
        Update the exchange rate for a certain currency
        :param currency:string
        :param new_rate:float
        :return:If successful, returns None; if unsuccessful, returns False
        """"""
        # Check if the currency is supported
        if currency not in self.rates:
            return False
        
        # Update the exchange rate for the currency
        self.rates[currency] = new_rate
```",0.15822784810126586,0.18060726021842455,0.921875,0.4125874125874126,0.5700483049069991,0.7333333333333333,0.2558139534883721,0.37931034099286565,0.921875,0.4125874125874126,0.5700483049069991
Llama,28,"import sqlite3
import pandas as pd


class DatabaseProcessor:

    def __init__(self, database_name):
        self.database_name = database_name

    def create_table(self, table_name, key1, key2):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        create_table_query = f""CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)""
        cursor.execute(create_table_query)

        conn.commit()
        conn.close()

    def insert_into_database(self, table_name, data):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        for item in data:
            insert_query = f""INSERT INTO {table_name} (name, age) VALUES (?, ?)""
            cursor.execute(insert_query, (item['name'], item['age']))

        conn.commit()
        conn.close()

    def search_database(self, table_name, name):

        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        select_query = f""SELECT * FROM {table_name} WHERE name = ?""
        cursor.execute(select_query, (name,))
        result = cursor.fetchall()

        if result:
            return result
        else:
            return None

    def delete_from_database(self, table_name, name):

        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        delete_query = f""DELETE FROM {table_name} WHERE name = ?""
        cursor.execute(delete_query, (name,))

        conn.commit()
        conn.close()",FewShot,"

```python
import sqlite3
import pandas as pd

class DatabaseProcessor:
    """"""
    This is a class for processing a database, supporting to create tables, insert data into the database, search for data based on name, and delete data from the database.
    """"""

    def __init__(self, database_name):
        """"""
        Initialize database name of database processor
        """"""
        self.database_name = database_name
        # Connect to the SQLite database
        self.conn = sqlite3.connect(self.database_name)
        # Create a cursor object
        self.cursor = self.conn.cursor()

    def create_table(self, table_name, key1, key2):
        """"""
        Create a new table in the database if it doesn't exist.
        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER
        :param table_name: str, the name of the table to create.
        :param key1: str, the name of the first column in the table.
        :param key2: str, the name of the second column in the table.
        """"""
        # SQL query to create a new table
        query = f""""""
            CREATE TABLE IF NOT EXISTS {table_name} (
                id INTEGER PRIMARY KEY,
                {key1} TEXT,
                {key2} INTEGER
            )
        """"""
        # Execute the query
        self.cursor.execute(query)
        # Commit the changes
        self.conn.commit()

    def insert_into_database(self, table_name, data):
        """"""
        Insert data into the specified table in the database.
        :param table_name: str, the name of the table to insert data into.
        :param data: list, a list of dictionaries where each dictionary represents a row of data.
        """"""
        # SQL query to insert data into the table
        query = f""""""
            INSERT INTO {table_name} ({list(data[0].keys())[0]}, {list(data[0].keys())[1]})
            VALUES (?, ?)
        """"""
        # Execute the query for each row of data
        for row in data:
            self.cursor.execute(query, (row[list(row.keys())[0]], row[list(row.keys())[1]]))
        # Commit the changes
        self.conn.commit()

    def search_database(self, table_name, name):
        """"""
        Search the specified table in the database for rows with a matching name.
        :param table_name: str, the name of the table to search.
        :param name: str, the name to search for.
        :return: list, a list of tuples representing the rows with matching name, if any;
                    otherwise, returns None.
        """"""
        # SQL query to search for rows with a matching name
        query = f""""""
            SELECT * FROM {table_name} WHERE {list(self.get_columns(table_name))[0]} = ?
        """"""
        # Execute the query
        self.cursor.execute(query, (name,))
        # Fetch all the rows
        rows = self.cursor.fetchall()
        # Return the rows if any, otherwise return None
        return rows if rows else None

    def delete_from_database(self, table_name, name):
        """"""
        Delete rows from the specified table in the database with a matching name.
        :param table_name: str, the name of the table to delete rows from.
        :param name: str, the name to match for deletion.
        """"""
        # SQL query to delete rows with a matching name
        query = f""""""
            DELETE FROM {table_name} WHERE {list(self.get_columns(table_name))[0]} = ?
        """"""
        # Execute the query
        self.cursor.execute(query, (name,))
        # Commit the changes
        self.conn.commit()

    def get_columns(self, table_name):
        # SQL query to get the column names
        query = f""""""
            PRAGMA table_info({table_name})
        """"""
        # Execute the query
        self.cursor.execute(query)
        # Fetch all the rows
        rows = self.cursor.fetchall()
        # Return a list of column names
        return [row[1] for row in rows]

    def close_connection(self):
        # Close the connection
        self.conn.close()
```",0.05761316872427984,0.07324970682789053,0.6962025316455697,0.3179190751445087,0.43650793220364076,0.44642857142857145,0.15723270440251572,0.23255813568242298,0.6708860759493671,0.3063583815028902,0.42063491633062483
Llama,29,"from collections import Counter


class DataStatistics:
    def mean(self, data):
        return round(sum(data) / len(data), 2)

    def median(self, data):
        sorted_data = sorted(data)
        n = len(sorted_data)
        if n % 2 == 0:
            middle = n // 2
            return round((sorted_data[middle - 1] + sorted_data[middle]) / 2, 2)
        else:
            middle = n // 2
            return sorted_data[middle]

    def mode(self, data):
        counter = Counter(data)
        mode_count = max(counter.values())
        mode = [x for x, count in counter.items() if count == mode_count]
        return mode",FewShot,"

```python
from collections import Counter

class DataStatistics:
    """"""
    This is a class for performing data statistics, supporting to calculate the mean, median, and mode of a given data set.
    """"""

    # Method to calculate the mean of a given data set
    def mean(self, data):
        # Check if the data list is empty
        if not data:
            return None
        
        # Calculate the sum of all elements in the data list
        total = sum(data)
        
        # Calculate the mean by dividing the sum by the number of elements
        mean_value = total / len(data)
        
        # Return the mean value rounded to two decimal places
        return round(mean_value, 2)

    # Method to calculate the median of a given data set
    def median(self, data):
        # Check if the data list is empty
        if not data:
            return None
        
        # Sort the data list in ascending order
        sorted_data = sorted(data)
        
        # Get the length of the data list
        n = len(sorted_data)
        
        # If the length is even, calculate the median as the average of the two middle numbers
        if n % 2 == 0:
            median_value = (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2
        # If the length is odd, calculate the median as the middle number
        else:
            median_value = sorted_data[n // 2]
        
        # Return the median value rounded to two decimal places
        return round(median_value, 2)

    # Method to calculate the mode of a given data set
    def mode(self, data):
        # Check if the data list is empty
        if not data:
            return None
        
        # Use the Counter class to count the frequency of each element in the data list
        frequency = Counter(data)
        
        # Find the maximum frequency
        max_frequency = max(frequency.values())
        
        # Get the elements with the maximum frequency
        modes = [num for num, freq in frequency.items() if freq == max_frequency]
        
        # Return the modes
        return modes
```",0.04697986577181208,0.06194957641848774,0.7551020408163265,0.3217391304347826,0.45121950800490784,0.35714285714285715,0.12315270935960591,0.18315017933690247,0.7346938775510204,0.3130434782608696,0.4390243860536884
Llama,30,"import numpy as np


class DataStatistics2:
    def __init__(self, data):
        self.data = np.array(data)

    def get_sum(self):
        return np.sum(self.data)

    def get_min(self):
        return np.min(self.data)

    def get_max(self):
        return np.max(self.data)

    def get_variance(self):
        return round(np.var(self.data), 2)

    def get_std_deviation(self):
        return round(np.std(self.data), 2)

    def get_correlation(self):
        return np.corrcoef(self.data, rowvar=False)",FewShot,"

```python
import numpy as np

class DataStatistics2:
    """"""
    This is a class for performing data statistics, supporting to get the sum, minimum, maximum, variance, standard deviation, and correlation of a given dataset.
    """"""

    def __init__(self, data):
        # Initialize Data List
        self.data = np.array(data)

    def get_sum(self):
        # Calculate the sum of data
        return np.sum(self.data)

    def get_min(self):
        # Calculate the minimum value in the data
        return np.min(self.data)

    def get_max(self):
        # Calculate the maximum value in the data
        return np.max(self.data)

    def get_variance(self):
        # Calculate variance, accurate to two digits after the Decimal separator
        return round(np.var(self.data), 2)

    def get_std_deviation(self):
        # Calculate standard deviation, accurate to two digits after the Decimal separator
        return round(np.std(self.data), 2)

    def get_correlation(self):
        # Calculate correlation
        # Since correlation requires two datasets, we assume the correlation is with itself
        return 1.0  # np.corrcoef(self.data, self.data)[0, 1]

# Example usage:
ds2 = DataStatistics2([1, 2, 3, 4])
print(ds2.get_sum())  # 10
print(ds2.get_min())  # 1
print(ds2.get_max())  # 4
print(ds2.get_variance())  # 1.25
print(ds2.get_std_deviation())  # 1.12
print(ds2.get_correlation())  # 1.0
```",0.12500000000000003,0.1400630947506398,0.96875,0.31,0.4696969660238751,0.7954545454545454,0.22727272727272727,0.35353535007856346,0.96875,0.31,0.4696969660238751
Llama,31,"import math

class DataStatistics4:

    @staticmethod
    def correlation_coefficient(data1, data2):
        n = len(data1)
        mean1 = sum(data1) / n
        mean2 = sum(data2) / n

        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))
        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n))) * math.sqrt(sum((data2[i] - mean2) ** 2 for i in range(n)))

        return numerator / denominator if denominator != 0 else 0
    
    @staticmethod
    def skewness(data):
        n = len(data)
        mean = sum(data) / n
        variance = sum((x - mean) ** 2 for x in data) / n
        std_deviation = math.sqrt(variance)

        skewness = sum((x - mean) ** 3 for x in data) * n / ((n - 1) * (n - 2) * std_deviation ** 3) if std_deviation != 0 else 0

        return skewness
    
    @staticmethod
    def kurtosis(data):

        n = len(data)
        mean = sum(data) / n
        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / n)

        if std_dev == 0:
            return math.nan

        centered_data = [(x - mean) for x in data]
        fourth_moment = sum(x ** 4 for x in centered_data) / n

        kurtosis_value = (fourth_moment / std_dev ** 4) - 3

        return kurtosis_value
    
    @staticmethod
    def pdf(data, mu, sigma):
        pdf_values = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]
        return pdf_values",FewShot,"

```python
import math

class DataStatistics4:
    """"""
    This is a class that performs advanced mathematical calculations and statistics, 
    including correlation coefficient, skewness, kurtosis, and probability density function (PDF) for a normal distribution.
    """"""

    # Calculate the correlation coefficient of two sets of data
    @staticmethod
    def correlation_coefficient(data1, data2):
        # Check if the lengths of the two datasets are equal
        if len(data1) != len(data2):
            raise ValueError(""Both datasets must have the same length"")

        # Calculate the means of the two datasets
        mean1 = sum(data1) / len(data1)
        mean2 = sum(data2) / len(data2)

        # Calculate the deviations from the means
        deviations1 = [x - mean1 for x in data1]
        deviations2 = [x - mean2 for x in data2]

        # Calculate the covariance and the variances
        covariance = sum(x * y for x, y in zip(deviations1, deviations2))
        variance1 = sum(x ** 2 for x in deviations1)
        variance2 = sum(x ** 2 for x in deviations2)

        # Calculate the correlation coefficient
        correlation_coefficient = covariance / math.sqrt(variance1 * variance2)

        return correlation_coefficient

    # Calculate the skewness of a set of data
    @staticmethod
    def skewness(data):
        # Calculate the mean of the dataset
        mean = sum(data) / len(data)

        # Calculate the deviations from the mean
        deviations = [x - mean for x in data]

        # Calculate the variance
        variance = sum(x ** 2 for x in deviations) / len(data)

        # Calculate the standard deviation
        std_dev = math.sqrt(variance)

        # Calculate the skewness
        skewness = sum((x - mean) ** 3 for x in data) / (len(data) * std_dev ** 3)

        return skewness

    # Calculate the kurtosis of a set of data
    @staticmethod
    def kurtosis(data):
        # Calculate the mean of the dataset
        mean = sum(data) / len(data)

        # Calculate the deviations from the mean
        deviations = [x - mean for x in data]

        # Calculate the variance
        variance = sum(x ** 2 for x in deviations) / len(data)

        # Calculate the standard deviation
        std_dev = math.sqrt(variance)

        # Calculate the kurtosis
        kurtosis = sum((x - mean) ** 4 for x in data) / (len(data) * std_dev ** 4) - 3

        return kurtosis

    # Calculate the probability density function (PDF) of a set of data under a normal distribution
    @staticmethod
    def pdf(data, mu, sigma):
        # Calculate the PDF for each data point
        pdf_values = [math.exp(-((x - mu) ** 2) / (2 * sigma ** 2)) / (sigma * math.sqrt(2 * math.pi)) for x in data]

        return pdf_values
```",0.14910025706940874,0.18519257497132627,0.6046511627906976,0.3880597014925373,0.4727272679652893,0.3592814371257485,0.24896265560165975,0.2941176422233036,0.5697674418604651,0.3656716417910448,0.4454545406925621
Llama,32,"class DecryptionUtils:
    def __init__(self, key):
        self.key = key
    
    def caesar_decipher(self, ciphertext, shift):
        plaintext = """"
        for char in ciphertext:
            if char.isalpha():
                if char.isupper():
                    ascii_offset = 65
                else:
                    ascii_offset = 97
                shifted_char = chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)
                plaintext += shifted_char
            else:
                plaintext += char
        return plaintext
    
    def vigenere_decipher(self, ciphertext):
        decrypted_text = """"
        key_index = 0
        for char in ciphertext:
            if char.isalpha():
                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')
                decrypted_char = chr((ord(char.lower()) - ord('a') - shift) % 26 + ord('a'))
                decrypted_text += decrypted_char.upper() if char.isupper() else decrypted_char
                key_index += 1
            else:
                decrypted_text += char
        return decrypted_text
    
    def rail_fence_decipher(self, encrypted_text, rails):
        fence = [['\n' for _ in range(len(encrypted_text))] for _ in range(rails)]
        direction = -1
        row, col = 0, 0

        for _ in range(len(encrypted_text)):
            if row == 0 or row == rails - 1:
                direction = -direction

            fence[row][col] = ''
            col += 1
            row += direction

        index = 0
        for i in range(rails):
            for j in range(len(encrypted_text)):
                if fence[i][j] == '':
                    fence[i][j] = encrypted_text[index]
                    index += 1

        plain_text = ''
        direction = -1
        row, col = 0, 0
        for _ in range(len(encrypted_text)):
            if row == 0 or row == rails - 1:
                direction = -direction

            plain_text += fence[row][col]
            col += 1
            row += direction

        return plain_text",FewShot,"

```python
class DecryptionUtils:
    """"""
    This is a class that provides methods for decryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.
    """"""

    def __init__(self, key):
        """"""
        Initializes the decryption utility with a key.
        :param key: The key to use for decryption,str.
        """"""
        self.key = key

    def caesar_decipher(self, ciphertext, shift):
        """"""
        Deciphers the given ciphertext using the Caesar cipher
        :param ciphertext: The ciphertext to decipher,str.
        :param shift: The shift to use for decryption,int.
        :return: The deciphered plaintext,str.
        """"""
        # Initialize an empty string to store the deciphered text
        plaintext = """"
        
        # Iterate over each character in the ciphertext
        for char in ciphertext:
            # Check if the character is an uppercase letter
            if char.isupper():
                # Calculate the ASCII value of the deciphered character
                # and convert it back to a character
                plaintext += chr((ord(char) - 65 - shift) % 26 + 65)
            # Check if the character is a lowercase letter
            elif char.islower():
                # Calculate the ASCII value of the deciphered character
                # and convert it back to a character
                plaintext += chr((ord(char) - 97 - shift) % 26 + 97)
            # If the character is not a letter, add it to the plaintext as is
            else:
                plaintext += char
        
        # Return the deciphered plaintext
        return plaintext

    def vigenere_decipher(self, ciphertext):
        """"""
        Deciphers the given ciphertext using the Vigenere cipher
        :param ciphertext: The ciphertext to decipher,str.
        :return: The deciphered plaintext,str.
        """"""
        # Initialize an empty string to store the deciphered text
        plaintext = """"
        
        # Initialize a counter to keep track of the current position in the key
        key_index = 0
        
        # Iterate over each character in the ciphertext
        for char in ciphertext:
            # Check if the character is an uppercase letter
            if char.isupper():
                # Calculate the shift value based on the current character in the key
                shift = ord(self.key[key_index % len(self.key)].upper()) - 65
                
                # Calculate the ASCII value of the deciphered character
                # and convert it back to a character
                plaintext += chr((ord(char) - 65 - shift) % 26 + 65)
                
                # Move to the next character in the key
                key_index += 1
            # Check if the character is a lowercase letter
            elif char.islower():
                # Calculate the shift value based on the current character in the key
                shift = ord(self.key[key_index % len(self.key)].lower()) - 97
                
                # Calculate the ASCII value of the deciphered character
                # and convert it back to a character
                plaintext += chr((ord(char) - 97 - shift) % 26 + 97)
                
                # Move to the next character in the key
                key_index += 1
            # If the character is not a letter, add it to the plaintext as is
            else:
                plaintext += char
        
        # Return the deciphered plaintext
        return plaintext

    def rail_fence_decipher(self, encrypted_text, rails):
        """"""
        Deciphers the given ciphertext using the Rail Fence cipher
        :param encrypted_text: The ciphertext to decipher,str.
        :param rails: The number of rails to use for decryption,int.
        :return: The deciphered plaintext,str.
        """"""
        # Initialize a list to store the rails
        rail_list = [''] * rails
        
        # Initialize a counter to keep track of the current rail
        rail_index = 0
        
        # Initialize a flag to indicate the direction of the rail
        going_down = True
        
        # Iterate over each character in the encrypted text
        for char in encrypted_text:
            # Add the character to the current rail
            rail_list[rail_index] += char
            
            # If we are going down and we are not at the last rail, move to the next rail
            if going_down and rail_index < rails - 1:
                rail_index += 1
            # If we are going up and we are not at the first rail, move to the previous rail
            elif not going_down and rail_index > 0:
                rail_index -= 1
            # If we are at the last rail and going down, change direction and move to the previous rail
            elif going_down and rail_index == rails - 1:
                going_down = False
                rail_index -= 1
            # If we are at the first rail and going up, change direction and move to the next rail
            elif not going_down and rail_index == 0:
                going_down = True
                rail_index += 1
        
        # Initialize an empty string to store the deciphered text
        plaintext = """"
        
        # Iterate over each rail
        for rail in rail_list:
            # Add the characters from the rail to the plaintext
            plaintext += rail
        
        # Return the deciphered plaintext
        return plaintext
```",0.04674220963172805,0.06395703615708472,0.5783132530120482,0.2874251497005988,0.38399999556448006,0.3051948051948052,0.1390532544378698,0.19105690626842498,0.5783132530120482,0.2874251497005988,0.38399999556448006
Llama,33,"class DiscountStrategy:
    def __init__(self, customer, cart, promotion=None):
        self.customer = customer
        self.cart = cart
        self.promotion = promotion
        self.__total = self.total()

    def total(self):
        self.__total = sum(item['quantity'] * item['price'] for item in self.cart)
        return self.__total

    def due(self):
        if self.promotion is None:
            discount = 0
        else:
            discount = self.promotion(self)
        return self.__total - discount

    @staticmethod
    def FidelityPromo(order):
        return order.total() * 0.05 if order.customer['fidelity'] >= 1000 else 0

    @staticmethod
    def BulkItemPromo(order):
        discount = 0
        for item in order.cart:
            if item['quantity'] >= 20:
                discount += item['quantity'] * item['price'] * 0.1
        return discount

    @staticmethod
    def LargeOrderPromo(order):
        return order.total() * 0.07 if len({item['product'] for item in order.cart}) >= 10 else 0",FewShot,"

```python
class DiscountStrategy:
    """"""
    This is a class that allows to use different discount strategy based on shopping credit or shopping cart in supermarket.
    """"""

    def __init__(self, customer, cart, promotion=None):
        """"""
        Initialize the DiscountStrategy with customer information, a cart of items, and an optional promotion.
        :param customer: dict, customer information
        :param cart: list of dicts, a cart of items with details
        :param promotion: function, optional promotion applied to the order
        """"""
        self.customer = customer
        self.cart = cart
        self.promotion = promotion
        self.total_cost = self.total()  # calculate total cost when initializing

    def total(self):
        """"""
        Calculate the total cost of items in the cart.
        :return: float, total cost of items
        """"""
        # calculate total cost by summing up the cost of each item in the cart
        total_cost = sum(item['quantity'] * item['price'] for item in self.cart)
        return total_cost

    def due(self):
        """"""
        Calculate the final amount to be paid after applying the discount.
        :return: float, final amount to be paid
        """"""
        # calculate the final amount by applying the discount to the total cost
        if self.promotion:
            discount = self.promotion(self)
            return self.total_cost - discount
        else:
            return self.total_cost

    @staticmethod
    def FidelityPromo(order):
        """"""
        Calculate the discount based on the fidelity points of the customer.
        Customers with over 1000 points can enjoy a 5% discount on the entire order.
        :param order: object, the order to apply the discount to
        :return: float, discount amount
        """"""
        # check if the customer has over 1000 fidelity points
        if order.customer['fidelity'] > 1000:
            # calculate the discount as 5% of the total cost
            discount = order.total_cost * 0.05
            return discount
        else:
            return 0.0

    @staticmethod
    def BulkItemPromo(order):
        """"""
        Calculate the discount based on bulk item quantity in the order.
        In the same order, if the quantity of a single item reaches 20 or more, each item will enjoy a 10% discount.
        :param order: object, the order to apply the discount to
        :return: float, discount amount
        """"""
        # initialize the discount amount
        discount = 0.0
        # iterate over each item in the cart
        for item in order.cart:
            # check if the quantity of the item is 20 or more
            if item['quantity'] >= 20:
                # calculate the discount for the item as 10% of the item's cost
                item_discount = item['quantity'] * item['price'] * 0.1
                # add the item's discount to the total discount
                discount += item_discount
        return discount

    @staticmethod
    def LargeOrderPromo(order):
        """"""
        Calculate the discount based on the number of different products in the order.
        If the quantity of different products in the order reaches 10 or more, the entire order will enjoy a 7% discount.
        :param order: object, the order to apply the discount to
        :return: float, discount amount
        """"""
        # get the number of different products in the order
        num_products = len(set(item['product'] for item in order.cart))
        # check if the number of products is 10 or more
        if num_products >= 10:
            # calculate the discount as 7% of the total cost
            discount = order.total_cost * 0.07
            return discount
        else:
            return 0.0
```",0.06597938144329896,0.08631920005618803,0.9019607843137255,0.3150684931506849,0.46700507230487776,0.6105263157894737,0.1806853582554517,0.2788461503218611,0.9019607843137255,0.3150684931506849,0.46700507230487776
Llama,34,"from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT


class DocFileHandler:
    def __init__(self, file_path):
        self.file_path = file_path

    def read_text(self):
        doc = Document(self.file_path)
        text = []
        for paragraph in doc.paragraphs:
            text.append(paragraph.text)
        return ""\n"".join(text)

    def write_text(self, content, font_size=12, alignment='left'):
        try:
            doc = Document()
            paragraph = doc.add_paragraph()
            run = paragraph.add_run(content)
            font = run.font
            font.size = Pt(font_size)
            alignment_value = self._get_alignment_value(alignment)
            paragraph.alignment = alignment_value
            doc.save(self.file_path)
            return True
        except:
            return False

    def add_heading(self, heading, level=1):
        try:
            doc = Document(self.file_path)
            doc.add_heading(heading, level)
            doc.save(self.file_path)
            return True
        except:
            return False

    def add_table(self, data):
        try:
            doc = Document(self.file_path)
            table = doc.add_table(rows=len(data), cols=len(data[0]))
            for i, row in enumerate(data):
                for j, cell_value in enumerate(row):
                    table.cell(i, j).text = str(cell_value)
            doc.save(self.file_path)
            return True
        except:
            return False

    def _get_alignment_value(self, alignment):
        alignment_options = {
            'left': WD_PARAGRAPH_ALIGNMENT.LEFT,
            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,
            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT
        }
        return alignment_options.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)",FewShot,"

```python
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT


class DocFileHandler:
    """"""
    This is a class that handles Word documents and provides functionalities for reading, writing, and modifying the content of Word documents.
    """"""

    def __init__(self, file_path):
        """"""
        Initializes the DocFileHandler object with the specified file path.
        :param file_path: str, the path to the Word document file.
        """"""
        self.file_path = file_path

    # Method to read the content of a Word document
    def read_text(self):
        """"""
        Reads the content of a Word document and returns it as a string.
        :return: str, the content of the Word document.
        """"""
        try:
            # Open the Word document
            document = Document(self.file_path)
            # Initialize an empty string to store the content
            content = """"
            # Iterate over each paragraph in the document
            for paragraph in document.paragraphs:
                # Append the paragraph text to the content string
                content += paragraph.text + ""\n""
            # Return the content string
            return content
        except Exception as e:
            # Handle any exceptions that occur during the read operation
            print(f""Error reading document: {e}"")
            return None

    # Method to write text to a Word document
    def write_text(self, content, font_size=12, alignment='left'):
        """"""
        Writes the specified content to a Word document.
        :param content: str, the text content to write.
        :param font_size: int, optional, the font size of the text (default is 12).
        :param alignment: str, optional, the alignment of the text ('left', 'center', or 'right'; default is 'left').
        :return: bool, True if the write operation is successful, False otherwise.
        """"""
        try:
            # Create a new Word document or open an existing one
            document = Document(self.file_path)
            # Add a paragraph to the document
            paragraph = document.add_paragraph()
            # Set the paragraph alignment
            paragraph.alignment = self._get_alignment_value(alignment)
            # Add a run to the paragraph
            run = paragraph.add_run(content)
            # Set the font size of the run
            font = run.font
            font.size = Pt(font_size)
            # Save the document
            document.save(self.file_path)
            # Return True to indicate a successful write operation
            return True
        except Exception as e:
            # Handle any exceptions that occur during the write operation
            print(f""Error writing to document: {e}"")
            return False

    # Method to add a heading to a Word document
    def add_heading(self, heading, level=1):
        """"""
        Adds a heading to the Word document.
        :param heading: str, the text of the heading.
        :param level: int, optional, the level of the heading (1, 2, 3, etc.; default is 1).
        :return: bool, True if the heading is successfully added, False otherwise.
        """"""
        try:
            # Create a new Word document or open an existing one
            document = Document(self.file_path)
            # Add a heading to the document
            document.add_heading(heading, level=level)
            # Save the document
            document.save(self.file_path)
            # Return True to indicate a successful add operation
            return True
        except Exception as e:
            # Handle any exceptions that occur during the add operation
            print(f""Error adding heading to document: {e}"")
            return False

    # Method to add a table to a Word document
    def add_table(self, data):
        """"""
        Adds a table to the Word document with the specified data.
        :param data: list of lists, the data to populate the table.
        :return: bool, True if the table is successfully added, False otherwise.
        """"""
        try:
            # Create a new Word document or open an existing one
            document = Document(self.file_path)
            # Add a table to the document
            table = document.add_table(rows=len(data), cols=len(data[0]))
            # Populate the table with data
            for i, row in enumerate(data):
                for j, cell in enumerate(row):
                    table.cell(i, j).text = str(cell)
            # Save the document
            document.save(self.file_path)
            # Return True to indicate a successful add operation
            return True
        except Exception as e:
            # Handle any exceptions that occur during the add operation
            print(f""Error adding table to document: {e}"")
            return False

    # Helper method to get the alignment value from a string
    def _get_alignment_value(self, alignment):
        """"""
        Returns the alignment value corresponding to the given alignment string.
        :param alignment: str, the alignment string ('left', 'center', or 'right').
        :return: int, the alignment value.
        """"""
        if alignment == 'left':
            return WD_PARAGRAPH_ALIGNMENT.LEFT
        elif alignment == 'center':
            return WD_PARAGRAPH_ALIGNMENT.CENTER
        elif alignment == 'right':
            return WD_PARAGRAPH_ALIGNMENT.RIGHT
        else:
            return WD_PARAGRAPH_ALIGNMENT.LEFT
```",0.05359877488514547,0.07185306050262624,0.7710843373493976,0.32323232323232326,0.45551601007231424,0.5074626865671642,0.17,0.2546816441807292,0.7710843373493976,0.32323232323232326,0.45551601007231424
Llama,35,"class EightPuzzle:
    def __init__(self, initial_state):
        self.initial_state = initial_state
        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

    def find_blank(self, state):
        for i in range(3):
            for j in range(3):
                if state[i][j] == 0:
                    return i, j

    def move(self, state, direction):
        i, j = self.find_blank(state)
        new_state = [row[:] for row in state]

        if direction == 'up':
            new_state[i][j], new_state[i - 1][j] = new_state[i - 1][j], new_state[i][j]
        elif direction == 'down':
            new_state[i][j], new_state[i + 1][j] = new_state[i + 1][j], new_state[i][j]
        elif direction == 'left':
            new_state[i][j], new_state[i][j - 1] = new_state[i][j - 1], new_state[i][j]
        elif direction == 'right':
            new_state[i][j], new_state[i][j + 1] = new_state[i][j + 1], new_state[i][j]

        return new_state

    def get_possible_moves(self, state):
        moves = []
        i, j = self.find_blank(state)

        if i > 0:
            moves.append('up')
        if i < 2:
            moves.append('down')
        if j > 0:
            moves.append('left')
        if j < 2:
            moves.append('right')

        return moves

    def solve(self):
        open_list = [(self.initial_state, [])]
        closed_list = []

        while open_list:
            current_state, path = open_list.pop(0)
            closed_list.append(current_state)

            if current_state == self.goal_state:
                return path

            for move in self.get_possible_moves(current_state):
                new_state = self.move(current_state, move)
                if new_state not in closed_list:
                    open_list.append((new_state, path + [move]))

        return None",FewShot,"

```python
class EightPuzzle:
    """"""
    This class is an implementation of the classic 8-puzzle game, including methods for finding the blank tile, making moves, getting possible moves, and solving the puzzle using a breadth-first search algorithm.
    """"""

    def __init__(self, initial_state):
        """"""
        Initializing the initial state of Eight Puzzle Game, stores in attribute self.initial_state.
        And set the goal state of this game, stores in self.goal_state. In this case, set the size as 3*3
        :param initial_state: a 3*3 size list of Integer, stores the initial state
        """"""
        self.initial_state = initial_state
        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

    def find_blank(self, state):
        """"""
        Find the blank position of current state, which is the 0 element.
        :param state: a 3*3 size list of Integer, stores the current state.
        :return i, j: two Integers, represent the coordinate of the blank block.
        """"""
        # Iterate over each row and column in the state to find the blank tile (0)
        for i in range(len(state)):
            for j in range(len(state[i])):
                if state[i][j] == 0:
                    # Return the coordinates of the blank tile
                    return i, j

    def move(self, state, direction):
        """"""
        Find the blank block, then makes the board moves forward the given direction.
        :param state: a 3*3 size list of Integer, stores the state before moving.
        :param direction: str, only has 4 direction 'up', 'down', 'left', 'right'
        :return new_state: a 3*3 size list of Integer, stores the state after moving.
        """"""
        # Find the coordinates of the blank tile
        i, j = self.find_blank(state)
        
        # Create a copy of the current state to avoid modifying the original state
        new_state = [row[:] for row in state]
        
        # Move the blank tile according to the given direction
        if direction == 'up' and i > 0:
            # Swap the blank tile with the tile above it
            new_state[i][j], new_state[i-1][j] = new_state[i-1][j], new_state[i][j]
        elif direction == 'down' and i < 2:
            # Swap the blank tile with the tile below it
            new_state[i][j], new_state[i+1][j] = new_state[i+1][j], new_state[i][j]
        elif direction == 'left' and j > 0:
            # Swap the blank tile with the tile to its left
            new_state[i][j], new_state[i][j-1] = new_state[i][j-1], new_state[i][j]
        elif direction == 'right' and j < 2:
            # Swap the blank tile with the tile to its right
            new_state[i][j], new_state[i][j+1] = new_state[i][j+1], new_state[i][j]
        
        # Return the new state after moving the blank tile
        return new_state

    def get_possible_moves(self, state):
        """"""
        According the current state, find all the possible moving directions. Only has 4 direction 'up', 'down', 'left', 'right'.
        :param state: a 3*3 size list of Integer, stores the current state.
        :return moves: a list of str, store all the possible moving directions according to the current state.
        """"""
        # Find the coordinates of the blank tile
        i, j = self.find_blank(state)
        
        # Initialize an empty list to store the possible moves
        moves = []
        
        # Check if the blank tile can move up
        if i > 0:
            moves.append('up')
        # Check if the blank tile can move down
        if i < 2:
            moves.append('down')
        # Check if the blank tile can move left
        if j > 0:
            moves.append('left')
        # Check if the blank tile can move right
        if j < 2:
            moves.append('right')
        
        # Return the list of possible moves
        return moves

    def solve(self):
        """"""
        Use BFS algorithm to find the path solution which makes the initial state to the goal method.
        Maintain a list as a queue, named as open_list, append the initial state.
        Always visit and pop the 0 index element, invoke get_possible_moves method find all the possible directions.
        Traversal the possible_moves list and invoke move method to get several new states.Then append them.
        redo the above steps until the open_list is empty or the state has changed to the goal state.
        :return path: list of str, the solution to the goal state.
        """"""
        # Initialize the open list with the initial state
        open_list = [(self.initial_state, [])]
        
        # Initialize the closed list to keep track of visited states
        closed_list = []
        
        # Loop until the open list is empty
        while open_list:
            # Dequeue the first state from the open list
            state, path = open_list.pop(0)
            
            # Check if the current state is the goal state
            if state == self.goal_state:
                # Return the path to the goal state
                return path
            
            # Add the current state to the closed list
            closed_list.append(state)
            
            # Get the possible moves from the current state
            possible_moves = self.get_possible_moves(state)
            
            # Loop through each possible move
            for move in possible_moves:
                # Get the new state after making the move
                new_state = self.move(state, move)
                
                # Check if the new state has not been visited before
                if new_state not in closed_list:
                    # Add the new state to the open list with the updated path
                    open_list.append((new_state, path + [move]))
        
        # If the open list is empty and no solution is found, return None
        return None
```",0.08778625954198471,0.10305096544915696,0.8068181818181818,0.27734375,0.4127906938669552,0.5911949685534591,0.18146718146718147,0.27769571280185196,0.8068181818181818,0.27734375,0.4127906938669552
Llama,36,"from datetime import datetime

class EmailClient:
    def __init__(self, addr, capacity) -> None:
        self.addr = addr
        self.capacity = capacity
        self.inbox = []
    
    def send_to(self, recv, content, size):
        if not recv.is_full_with_one_more_email(size):
            timestamp = datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
            email = {
                ""sender"": self.addr,
                ""receiver"": recv.addr,
                ""content"": content,
                ""size"": size,
                ""time"": timestamp,
                ""state"": ""unread""
            }
            recv.inbox.append(email)
            return True
        else:
            self.clear_inbox(size)
            return False
    
    def fetch(self):
        if len(self.inbox) == 0:
            return None
        for i in range(len(self.inbox)):
            if self.inbox[i]['state'] == ""unread"":
                self.inbox[i]['state'] = ""read""
                return self.inbox[i]
        return None

    def is_full_with_one_more_email(self, size):
        occupied_size = self.get_occupied_size()
        return True if occupied_size + size > self.capacity else False
        
    def get_occupied_size(self):
        occupied_size = 0
        for email in self.inbox:
            occupied_size += email[""size""]
        return occupied_size

    def clear_inbox(self, size):
        if len(self.addr) == 0:
            return
        freed_space = 0
        while freed_space < size and self.inbox:
            email = self.inbox[0]
            freed_space += email['size']
            del self.inbox[0]",FewShot,"

```python
from datetime import datetime

class EmailClient:
    """"""
    This is a class that serves as an email client, implementing functions such as checking emails, determining whether there is sufficient space, and cleaning up space
    """"""

    def __init__(self, addr, capacity) -> None:
        """"""
        Initializes the EmailClient class with the email address and the capacity of the email box.
        :param addr: The email address, str.
        :param capacity: The capacity of the email box, float.
        """"""
        self.addr = addr
        self.capacity = capacity
        self.inbox = []

    # Method to send an email to the given email address
    def send_to(self, recv, content, size):
        """"""
        Sends an email to the given email address.
        :param recv: The email address of the receiver, str.
        :param content: The content of the email, str.
        :param size: The size of the email, float.
        :return: True if the email is sent successfully, False if the receiver's email box is full.
        """"""
        # Check if the receiver's email box has enough space
        if recv.is_full_with_one_more_email(size):
            return False
        
        # Create a new email and add it to the receiver's inbox
        email = {
            'sender': self.addr,
            'receiver': recv.addr,
            'content': content,
            'size': size,
            'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'state': 'unread'
        }
        recv.inbox.append(email)
        return True

    # Method to retrieve the first unread email in the email box and mark it as read
    def fetch(self):
        """"""
        Retrieves the first unread email in the email box and marks it as read.
        :return: The first unread email in the email box, dict.
        """"""
        # Find the first unread email in the inbox
        for email in self.inbox:
            if email['state'] == 'unread':
                # Mark the email as read
                email['state'] = 'read'
                return email
        return None

    # Method to determine whether the email box is full after adding an email of the given size
    def is_full_with_one_more_email(self, size):
        """"""
        Determines whether the email box is full after adding an email of the given size.
        :param size: The size of the email, float.
        :return: True if the email box is full, False otherwise.
        """"""
        # Calculate the total size of the emails in the inbox
        total_size = self.get_occupied_size()
        # Check if adding the new email would exceed the capacity
        return total_size + size > self.capacity

    # Method to get the total size of the emails in the email box
    def get_occupied_size(self):
        """"""
        Gets the total size of the emails in the email box.
        :return: The total size of the emails in the email box, float.
        """"""
        # Calculate the total size of the emails in the inbox
        total_size = sum(email['size'] for email in self.inbox)
        return total_size

    # Method to clear the email box by deleting the oldest emails until the email box has enough space to accommodate the given size
    def clear_inbox(self, size):
        """"""
        Clears the email box by deleting the oldest emails until the email box has enough space to accommodate the given size.
        :param size: The size of the email, float.
        """"""
        # Calculate the total size of the emails in the inbox
        total_size = self.get_occupied_size()
        # Delete the oldest emails until there is enough space
        while total_size + size > self.capacity:
            # Remove the oldest email from the inbox
            oldest_email = self.inbox.pop(0)
            # Update the total size
            total_size -= oldest_email['size']
```",0.05152671755725192,0.06820956855772364,0.5903614457831325,0.3006134969325153,0.39837397926862317,0.3829787234042553,0.16981132075471697,0.23529411339057635,0.5903614457831325,0.3006134969325153,0.39837397926862317
Llama,37,"class EncryptionUtils:
    def __init__(self, key):
        self.key = key

    def caesar_cipher(self, plaintext, shift):
        ciphertext = """"
        for char in plaintext:
            if char.isalpha():
                if char.isupper():
                    ascii_offset = 65
                else:
                    ascii_offset = 97
                shifted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)
                ciphertext += shifted_char
            else:
                ciphertext += char
        return ciphertext
    
    def vigenere_cipher(self, plain_text):
        encrypted_text = """"
        key_index = 0
        for char in plain_text:
            if char.isalpha():
                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')
                encrypted_char = chr((ord(char.lower()) - ord('a') + shift) % 26 + ord('a'))
                encrypted_text += encrypted_char.upper() if char.isupper() else encrypted_char
                key_index += 1
            else:
                encrypted_text += char
        return encrypted_text

    def rail_fence_cipher(self, plain_text, rails):
        fence = [['\n' for _ in range(len(plain_text))] for _ in range(rails)]
        direction = -1
        row, col = 0, 0

        for char in plain_text:
            if row == 0 or row == rails-1:
                direction = -direction

            fence[row][col] = char
            col += 1
            row += direction

        encrypted_text = ''
        for i in range(rails):
            for j in range(len(plain_text)):
                if fence[i][j] != '\n':
                    encrypted_text += fence[i][j]

        return encrypted_text",FewShot,"

```python
class EncryptionUtils:
    """"""
    This is a class that provides methods for encryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.
    """"""

    def __init__(self, key):
        """"""
        Initializes the class with a key.
        :param key: The key to use for encryption, str.
        """"""
        self.key = key

    def caesar_cipher(self, plaintext, shift):
        """"""
        Encrypts the plaintext using the Caesar cipher.
        :param plaintext: The plaintext to encrypt, str.
        :param shift: The number of characters to shift each character in the plaintext, int.
        :return: The ciphertext, str.
        """"""
        # Initialize an empty string to store the ciphertext
        ciphertext = """"
        
        # Iterate over each character in the plaintext
        for char in plaintext:
            # Check if the character is an uppercase letter
            if char.isupper():
                # Calculate the ASCII value of the encrypted character
                encrypted_char = chr((ord(char) - 65 + shift) % 26 + 65)
                # Append the encrypted character to the ciphertext
                ciphertext += encrypted_char
            # Check if the character is a lowercase letter
            elif char.islower():
                # Calculate the ASCII value of the encrypted character
                encrypted_char = chr((ord(char) - 97 + shift) % 26 + 97)
                # Append the encrypted character to the ciphertext
                ciphertext += encrypted_char
            # If the character is not a letter, append it to the ciphertext as is
            else:
                ciphertext += char
        
        # Return the ciphertext
        return ciphertext

    def vigenere_cipher(self, plaintext):
        """"""
        Encrypts the plaintext using the Vigenere cipher.
        :param plaintext: The plaintext to encrypt, str.
        :return: The ciphertext, str.
        """"""
        # Initialize an empty string to store the ciphertext
        ciphertext = """"
        
        # Initialize a counter to keep track of the current position in the key
        key_index = 0
        
        # Iterate over each character in the plaintext
        for char in plaintext:
            # Check if the character is an uppercase letter
            if char.isupper():
                # Calculate the ASCII value of the encrypted character
                encrypted_char = chr((ord(char) - 65 + ord(self.key[key_index].upper()) - 65) % 26 + 65)
                # Append the encrypted character to the ciphertext
                ciphertext += encrypted_char
                # Move to the next character in the key
                key_index = (key_index + 1) % len(self.key)
            # Check if the character is a lowercase letter
            elif char.islower():
                # Calculate the ASCII value of the encrypted character
                encrypted_char = chr((ord(char) - 97 + ord(self.key[key_index].lower()) - 97) % 26 + 97)
                # Append the encrypted character to the ciphertext
                ciphertext += encrypted_char
                # Move to the next character in the key
                key_index = (key_index + 1) % len(self.key)
            # If the character is not a letter, append it to the ciphertext as is
            else:
                ciphertext += char
        
        # Return the ciphertext
        return ciphertext

    def rail_fence_cipher(self, plaintext, rails):
        """"""
        Encrypts the plaintext using the Rail Fence cipher.
        :param plaintext: The plaintext to encrypt, str.
        :param rails: The number of rails to use, int.
        :return: The ciphertext, str.
        """"""
        # Initialize a list to store the rails
        rail_list = [""""] * rails
        
        # Initialize a counter to keep track of the current rail
        rail_index = 0
        
        # Initialize a flag to indicate the direction of the rail
        going_down = True
        
        # Iterate over each character in the plaintext
        for char in plaintext:
            # Append the character to the current rail
            rail_list[rail_index] += char
            
            # If we are going down and we are not at the last rail, move to the next rail
            if going_down and rail_index < rails - 1:
                rail_index += 1
            # If we are going down and we are at the last rail, start going up
            elif going_down and rail_index == rails - 1:
                going_down = False
                rail_index -= 1
            # If we are going up and we are not at the first rail, move to the previous rail
            elif not going_down and rail_index > 0:
                rail_index -= 1
            # If we are going up and we are at the first rail, start going down
            elif not going_down and rail_index == 0:
                going_down = True
                rail_index += 1
        
        # Initialize an empty string to store the ciphertext
        ciphertext = """"
        
        # Iterate over each rail and append its characters to the ciphertext
        for rail in rail_list:
            ciphertext += rail
        
        # Return the ciphertext
        return ciphertext
```",0.033873343151693665,0.0485043727278727,0.5308641975308642,0.2721518987341772,0.35983263150224964,0.2569444444444444,0.11746031746031746,0.16122003926694872,0.49382716049382713,0.25316455696202533,0.3347280289917894
Llama,38,"import openpyxl


class ExcelProcessor:
    def __init__(self):
        pass

    def read_excel(self, file_name):
        data = []
        try:
            workbook = openpyxl.load_workbook(file_name)
            sheet = workbook.active
            for row in sheet.iter_rows(values_only=True):
                data.append(row)
            workbook.close()
            return data
        except:
            return None

    def write_excel(self, data, file_name):
        try:
            workbook = openpyxl.Workbook()
            sheet = workbook.active
            for row in data:
                sheet.append(row)
            workbook.save(file_name)
            workbook.close()
            return 1
        except:
            return 0

    def process_excel_data(self, N, save_file_name):
        data = self.read_excel(save_file_name)
        if data is None or N >= len(data[0]):
            return 0
        new_data = []
        for row in data:
            new_row = list(row[:])
            if not str(row[N]).isdigit():
                new_row.append(str(row[N]).upper())
            else:
                new_row.append(row[N])
            new_data.append(new_row)
        new_file_name = save_file_name.split('.')[0] + '_process.xlsx'
        success = self.write_excel(new_data, new_file_name)
        return success, new_file_name",FewShot,"

```python
import openpyxl

class ExcelProcessor:
    """"""
    This is a class for processing excel files, including reading and writing excel data, as well as processing specific operations and saving as a new excel file.
    """"""

    def __init__(self):
        # Initialize an empty ExcelProcessor object
        pass

    def read_excel(self, file_name):
        """"""
        Reading data from Excel files
        :param file_name: str, Excel file name to read
        :return: list of data, Data in Excel
        """"""
        try:
            # Load the Excel file
            wb = openpyxl.load_workbook(file_name)
            # Select the first sheet
            sheet = wb.active
            # Initialize an empty list to store data
            data = []
            # Iterate over each row in the sheet
            for row in sheet.rows:
                # Initialize an empty list to store row data
                row_data = []
                # Iterate over each cell in the row
                for cell in row:
                    # Append the cell value to the row data
                    row_data.append(cell.value)
                # Append the row data to the data list
                data.append(tuple(row_data))
            # Return the data list
            return data
        except:
            # Return None if an error occurs
            return None

    def write_excel(self, data, file_name):
        """"""
        Write data to the specified Excel file
        :param data: list, Data to be written
        :param file_name: str, Excel file name to write to
        :return: 0 or 1, 1 represents successful writing, 0 represents failed writing
        """"""
        try:
            # Create a new Excel file
            wb = openpyxl.Workbook()
            # Select the first sheet
            sheet = wb.active
            # Iterate over each row in the data
            for row in data:
                # Write the row to the sheet
                sheet.append(row)
            # Save the Excel file
            wb.save(file_name)
            # Return 1 to indicate successful writing
            return 1
        except:
            # Return 0 to indicate failed writing
            return 0

    def process_excel_data(self, N, save_file_name):
        """"""
        Change the specified column in the Excel file to uppercase
        :param N: int, The serial number of the column that want to change
        :param save_file_name: str, source file name
        :return: (int, str), The former is the return value of write_excel, while the latter is the saved file name of the processed data
        """"""
        try:
            # Read the Excel file
            data = self.read_excel(save_file_name)
            # Check if data is not None
            if data is not None:
                # Initialize an empty list to store processed data
                processed_data = []
                # Iterate over each row in the data
                for row in data:
                    # Initialize an empty list to store row data
                    row_data = list(row)
                    # Check if the column index is within the row bounds
                    if N <= len(row):
                        # Convert the column value to uppercase
                        row_data[N-1] = str(row_data[N-1]).upper()
                    # Append the row data to the processed data
                    processed_data.append(tuple(row_data))
                # Write the processed data to a new Excel file
                success = self.write_excel(processed_data, 'processed_' + save_file_name)
                # Return the success value and the saved file name
                return success, 'processed_' + save_file_name
            else:
                # Return 0 and None if data is None
                return 0, None
        except:
            # Return 0 and None if an error occurs
            return 0, None
```",0.04801670146137786,0.06288733796201458,0.6818181818181818,0.2848101265822785,0.40178571012914543,0.3939393939393939,0.121875,0.18615751429075938,0.6363636363636364,0.26582278481012656,0.37499999584343113
Llama,39,"import re
from collections import deque
from decimal import Decimal


class ExpressionCalculator:
    def __init__(self):
        self.postfix_stack = deque()
        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]

    def calculate(self, expression):
        self.prepare(self.transform(expression))

        result_stack = deque()
        self.postfix_stack.reverse()

        while self.postfix_stack:
            current_op = self.postfix_stack.pop()
            if not self.is_operator(current_op):
                current_op = current_op.replace(""~"", ""-"")
                result_stack.append(current_op)
            else:
                second_value = result_stack.pop()
                first_value = result_stack.pop()

                first_value = first_value.replace(""~"", ""-"")
                second_value = second_value.replace(""~"", ""-"")

                temp_result = self._calculate(first_value, second_value, current_op)
                result_stack.append(str(temp_result))

        return float(eval(""*"".join(result_stack)))

    def prepare(self, expression):
        op_stack = deque([','])
        arr = list(expression)
        current_index = 0
        count = 0

        for i, current_op in enumerate(arr):
            if self.is_operator(current_op):
                if count > 0:
                    self.postfix_stack.append("""".join(arr[current_index: current_index + count]))
                peek_op = op_stack[-1]
                if current_op == ')':
                    while op_stack[-1] != '(':
                        self.postfix_stack.append(str(op_stack.pop()))
                    op_stack.pop()
                else:
                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):
                        self.postfix_stack.append(str(op_stack.pop()))
                        peek_op = op_stack[-1]
                    op_stack.append(current_op)

                count = 0
                current_index = i + 1
            else:
                count += 1

        if count > 1 or (count == 1 and not self.is_operator(arr[current_index])):
            self.postfix_stack.append("""".join(arr[current_index: current_index + count]))

        while op_stack[-1] != ',':
            self.postfix_stack.append(str(op_stack.pop()))

    @staticmethod
    def is_operator(c):
        return c in {'+', '-', '*', '/', '(', ')', '%'}

    def compare(self, cur, peek):
        if cur == '%':
            cur = '/'
        if peek == '%':
            peek = '/'
        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]

    @staticmethod
    def _calculate(first_value, second_value, current_op):
        if current_op == '+':
            return Decimal(first_value) + Decimal(second_value)
        elif current_op == '-':
            return Decimal(first_value) - Decimal(second_value)
        elif current_op == '*':
            return Decimal(first_value) * Decimal(second_value)
        elif current_op == '/':
            return Decimal(first_value) / Decimal(second_value)
        elif current_op == '%':
            return Decimal(first_value) % Decimal(second_value)
        else:
            raise ValueError(""Unexpected operator: {}"".format(current_op))

    @staticmethod
    def transform(expression):
        expression = re.sub(r""\s+"", """", expression)
        expression = re.sub(r""=$"", """", expression)
        arr = list(expression)

        for i, c in enumerate(arr):
            if c == '-':
                if i == 0:
                    arr[i] = '~'
                else:
                    prev_c = arr[i - 1]
                    if prev_c in {'+', '-', '*', '/', '(', 'E', 'e'}:
                        arr[i] = '~'

        if arr[0] == '~' and (len(arr) > 1 and arr[1] == '('):
            arr[0] = '-'
            return ""0"" + """".join(arr)
        else:
            return """".join(arr)",FewShot,"

```python
from collections import deque
from decimal import Decimal

class ExpressionCalculator:
    """"""
    This is a class in Python that can perform calculations with basic arithmetic operations, including addition, subtraction, multiplication, division, and modulo.
    """"""

    def __init__(self):
        """"""
        Initialize the expression calculator
        """"""
        # Initialize an empty stack to store operands
        self.postfix_stack = deque()
        # Define operator precedence
        self.operat_priority = {'+': 1, '-': 1, '*': 2, '/': 2, '%': 2}

    def calculate(self, expression):
        """"""
        Calculate the result of the given postfix expression
        :param expression: string, the postfix expression to be calculated
        :return: float, the calculated result
        """"""
        # Split the expression into tokens (operators and operands)
        tokens = expression.split()
        # Initialize an empty stack to store operands
        stack = deque()
        # Iterate over each token in the expression
        for token in tokens:
            # If the token is an operand, push it to the stack
            if token not in self.operat_priority:
                stack.append(Decimal(token))
            # If the token is an operator, pop two operands from the stack, perform the operation, and push the result back to the stack
            else:
                second_value = stack.pop()
                first_value = stack.pop()
                result = self._calculate(first_value, second_value, token)
                stack.append(result)
        # The final result is the only element left in the stack
        return stack[0]

    def prepare(self, expression):
        """"""
        Prepare the infix expression for conversion to postfix notation
        :param expression: string, the infix expression to be prepared
        """"""
        # Remove any whitespace from the expression
        expression = self.transform(expression)
        # Initialize an empty stack to store operators
        operator_stack = deque()
        # Initialize an empty list to store the postfix expression
        postfix_expression = []
        # Iterate over each character in the expression
        for char in expression:
            # If the character is an operand, add it to the postfix expression
            if char.isdigit():
                postfix_expression.append(char)
            # If the character is an operator, pop operators from the stack and add them to the postfix expression until an operator with lower precedence is found, then push the current operator to the stack
            elif char in self.operat_priority:
                while operator_stack and self.compare(operator_stack[-1], char):
                    postfix_expression.append(operator_stack.pop())
                operator_stack.append(char)
            # If the character is a left parenthesis, push it to the stack
            elif char == '(':
                operator_stack.append(char)
            # If the character is a right parenthesis, pop operators from the stack and add them to the postfix expression until a left parenthesis is found, then discard the left parenthesis
            elif char == ')':
                while operator_stack[-1] != '(':
                    postfix_expression.append(operator_stack.pop())
                operator_stack.pop()
        # Pop any remaining operators from the stack and add them to the postfix expression
        while operator_stack:
            postfix_expression.append(operator_stack.pop())
        # Join the postfix expression into a string and store it in the postfix_stack attribute
        self.postfix_stack = ' '.join(postfix_expression)

    @staticmethod
    def is_operator(c):
        """"""
        Check if a character is an operator in {'+', '-', '*', '/', '(', ')', '%'}
        :param c: string, the character to be checked
        :return: bool, True if the character is an operator, False otherwise
        """"""
        # Define the set of operators
        operators = {'+', '-', '*', '/', '(', ')', '%'}
        # Check if the character is in the set of operators
        return c in operators

    def compare(self, cur, peek):
        """"""
        Compare the precedence of two operators
        :param cur: string, the current operator
        :param peek: string, the operator at the top of the operator stack
        :return: bool, True if the current operator has higher or equal precedence, False otherwise
        """"""
        # Compare the precedence of the two operators
        return self.operat_priority[cur] >= self.operat_priority[peek]

    @staticmethod
    def _calculate(first_value, second_value, current_op):
        """"""
        Perform the mathematical calculation based on the given operands and operator
        :param first_value: string, the first operand
        :param second_value: string, the second operand
        :param current_op: string, the operator
        :return: decimal.Decimal, the calculated result
        """"""
        # Perform the calculation based on the operator
        if current_op == '+':
            return first_value + second_value
        elif current_op == '-':
            return first_value - second_value
        elif current_op == '*':
            return first_value * second_value
        elif current_op == '/':
            return first_value / second_value
        elif current_op == '%':
            return first_value % second_value

    @staticmethod
    def transform(expression):
        """"""
        Transform the infix expression to a format suitable for conversion
        :param expression: string, the infix expression to be transformed
        :return: string, the transformed expression
        """"""
        # Remove any whitespace from the expression
        return expression.replace(' ', '')
```",0.06774668630338733,0.08692123425643994,0.4557823129251701,0.29646017699115046,0.3592493249830015,0.21875,0.1349036402569593,0.16688741249959224,0.4421768707482993,0.28761061946902655,0.34852546439318915
Llama,40,"class FitnessTracker:
    def __init__(self, height, weight, age, sex) -> None:
        self.height = height
        self.weight = weight
        self.age = age
        self.sex = sex
        self.BMI_std = [
            {""male"": [20, 25]},
            {""female"": [19, 24]}
        ]

    def get_BMI(self):
        return self.weight / self.height ** 2

    def condition_judge(self):
        BMI = self.get_BMI()
        if self.sex == ""male"":
            BMI_range = self.BMI_std[0][""male""]
        else:
            BMI_range = self.BMI_std[1][""female""]
        if BMI > BMI_range[1]:
            # too fat
            return 1
        elif BMI < BMI_range[0]:
            # too thin
            return -1
        else:
            # normal
            return 0

    def calculate_calorie_intake(self):
        if self.sex == ""male"":
            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5
        else:
            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161
        if self.condition_judge() == 1:
            calorie_intake = BMR * 1.2  # Sedentary lifestyle
        elif self.condition_judge() == -1:
            calorie_intake = BMR * 1.6  # Active lifestyle
        else:
            calorie_intake = BMR * 1.4  # Moderate lifestyle
        return calorie_intake",FewShot,"

```python
class FitnessTracker:
    """"""
    This is a class as fitness tracker that implements to calculate BMI (Body Mass Index) and calorie intake based on the user's height, weight, age, and sex.
    """"""

    def __init__(self, height, weight, age, sex) -> None:
        """"""
        Initialize the class with height, weight, age, and sex, and calculate the BMI standard based on sex, and male is 20-25, female is 19-24.
        """"""
        self.height = height
        self.weight = weight
        self.age = age
        self.sex = sex
        self.BMI_std = {
            ""male"": [20, 25],
            ""female"": [19, 24]
        }  # Simplified the BMI_std dictionary

    def get_BMI(self):
        """"""
        Calculate the BMI based on the height and weight.
        :return: BMI, which is the weight divide by the square of height, float.
        """"""
        # Calculate BMI using the formula: BMI = weight / height^2
        return self.weight / (self.height ** 2)

    def condition_judge(self):
        """"""
        Judge the condition of the user based on the BMI standard.
        :return: 1 if the user is too fat, -1 if the user is too thin, 0 if the user is normal, int.
        """"""
        # Get the BMI standard for the user's sex
        bmi_std = self.BMI_std[self.sex]
        
        # Calculate the BMI
        bmi = self.get_BMI()
        
        # Judge the condition based on the BMI standard
        if bmi > bmi_std[1]:
            return 1  # Too fat
        elif bmi < bmi_std[0]:
            return -1  # Too thin
        else:
            return 0  # Normal

    def calculate_calorie_intake(self):
        """"""
        Calculate the calorie intake based on the user's condition and BMR (Basal Metabolic Rate).
        :return: calorie intake, float.
        """"""
        # Calculate BMR based on the user's sex
        if self.sex == ""male"":
            bmr = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5
        else:
            bmr = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161
        
        # Judge the condition
        condition = self.condition_judge()
        
        # Calculate calorie intake based on the condition
        if condition == 1:  # Too fat
            return bmr * 1.2
        elif condition == -1:  # Too thin
            return bmr * 1.6
        else:  # Normal
            return bmr * 1.4
```",0.13855421686746988,0.18671276028348652,0.7638888888888888,0.4263565891472868,0.5472636769941339,0.5,0.2558139534883721,0.338461533983432,0.7638888888888888,0.4263565891472868,0.5472636769941339
Llama,41,"class GomokuGame:
    def __init__(self, board_size):
        self.board_size = board_size
        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        return False

    def check_winner(self):
        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]
        for row in range(self.board_size):
            for col in range(self.board_size):
                if self.board[row][col] != ' ':
                    for direction in directions:
                        if self._check_five_in_a_row(row, col, direction):
                            return self.board[row][col]
        return None

    def _check_five_in_a_row(self, row, col, direction):
        dx, dy = direction
        count = 1
        symbol = self.board[row][col]
        for i in range(1, 5):
            new_row = row + dx * i
            new_col = col + dy * i
            if not (0 <= new_row < self.board_size and 0 <= new_col < self.board_size):
                return False
            if self.board[new_row][new_col] != symbol:
                return False
            count += 1
        return count == 5",FewShot,"

```python
class GomokuGame:
    """"""
    This class is an implementation of a Gomoku game, supporting for making moves, checking for a winner, and checking if there are five consecutive symbols on the game board.
    """"""

    def __init__(self, board_size):
        """"""
        Initializes the game with a given board size.
        It initializes the board with empty spaces and sets the current player symble as 'X'.
        """"""
        self.board_size = board_size
        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]
        self.current_player = 'X'

    def make_move(self, row, col):
        """"""
        Makes a move at the given row and column.
        If the move is valid, it places the current player's symbol on the board
        and changes the current player to the other player (if the current player is 'X', then it becomes 'O' and vice versa).
        :param row: int, the row index of this move
        :param col: int, the column index
        return: True if the move is valid, or False otherwise.
        """"""
        # Check if the move is within the board boundaries and the cell is empty
        if 0 <= row < self.board_size and 0 <= col < self.board_size and self.board[row][col] == ' ':
            # Place the current player's symbol on the board
            self.board[row][col] = self.current_player
            # Change the current player to the other player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        return False

    def check_winner(self):
        """"""
        Checks if there is a winner by looking for five in a row in all directions (horizontal, vertical, diagonal).
        return: the symbol of the winning player (either 'X' or 'O') if there is a winner, or None otherwise.
        """"""
        # Check all cells on the board for a winner
        for row in range(self.board_size):
            for col in range(self.board_size):
                # Check if the cell is not empty
                if self.board[row][col] != ' ':
                    # Check all directions (horizontal, vertical, diagonal) for five consecutive symbols
                    for direction in [(0, 1), (1, 0), (1, 1), (1, -1)]:
                        # Check if there are five consecutive symbols in the given direction
                        if self._check_five_in_a_row(row, col, direction):
                            return self.board[row][col]
        return None

    def _check_five_in_a_row(self, row, col, direction):
        """"""
        checks if there are five consecutive symbols of the same player in a row starting from a given cell in a given direction (horizontal, vertical, diagonal).
        Counts the number of consecutive symbols in that direction starting from the given cell,
        :param row: int, row of the given cell
        :param col: int, column of the given cell
        :param direction: tuple, (int, int), named as (dx, dy). Row and col will plus several dx and dy repectively.
        :return: True if there are five consecutive symbols of the same player, and False otherwise.
        """"""
        # Initialize the count of consecutive symbols
        count = 1
        # Check in the given direction
        dx, dy = direction
        for i in range(1, 5):
            # Calculate the next cell's coordinates
            next_row, next_col = row + i * dx, col + i * dy
            # Check if the next cell is within the board boundaries and has the same symbol
            if 0 <= next_row < self.board_size and 0 <= next_col < self.board_size and self.board[next_row][next_col] == self.board[row][col]:
                count += 1
            else:
                break
        # Check in the opposite direction
        dx, dy = -dx, -dy
        for i in range(1, 5):
            # Calculate the next cell's coordinates
            next_row, next_col = row + i * dx, col + i * dy
            # Check if the next cell is within the board boundaries and has the same symbol
            if 0 <= next_row < self.board_size and 0 <= next_col < self.board_size and self.board[next_row][next_col] == self.board[row][col]:
                count += 1
            else:
                break
        # Return True if there are five consecutive symbols, and False otherwise
        return count >= 5
```",0.12292358803986708,0.14140763039954465,0.9,0.3351063829787234,0.4883720890691666,0.6496350364963503,0.2282051282051282,0.3377609069683037,0.8714285714285714,0.324468085106383,0.4728682131001743
Llama,42,"class Hotel:
    def __init__(self, name, rooms):
        self.name = name
        self.available_rooms = rooms
        # available_rooms = {room_type1: room_number1, room_type2: room_number2, ...}
        # available_rooms = {'single': 5, 'double': 3}
        self.booked_rooms = {}
        # booked_rooms = {room_type1: {name1: room_number1, name2: room_number2, ...}, room_type2: {...}, ...}
        # booked_rooms = {'single': {'name1': 2, 'name2':1}, 'double': {}}

    def book_room(self, room_type, room_number, name):
        # Check if there are any rooms of the specified type available
        if room_type not in self.available_rooms.keys():
            return False

        if room_number <= self.available_rooms[room_type]:
            # Book the room by adding it to the booked_rooms dictionary
            if room_type not in self.booked_rooms.keys():
                self.booked_rooms[room_type] = {}
            self.booked_rooms[room_type][name] = room_number
            self.available_rooms[room_type] -= room_number
            return ""Success!""
        elif self.available_rooms[room_type] != 0:
            return self.available_rooms[room_type]
        else:
            return False

    def check_in(self, room_type, room_number, name):
        # Check if the room of the specified type and number is booked
        if room_type not in self.booked_rooms.keys():
            return False
        if name in self.booked_rooms[room_type]:
            if room_number > self.booked_rooms[room_type][name]:
                return False
            elif room_number == self.booked_rooms[room_type][name]:
                # Check in the room by removing it from the booked_rooms dictionary
                self.booked_rooms[room_type].pop(name)
            else:
                self.booked_rooms[room_type][name] -= room_number


    def check_out(self, room_type, room_number):
        if room_type in self.available_rooms:
            self.available_rooms[room_type] += room_number
        else:
            self.available_rooms[room_type] = room_number

    def get_available_rooms(self, room_type):
        return self.available_rooms[room_type]",FewShot,"

```python
class Hotel:
    """"""
    This is a class as hotel management system, managing the booking, check-in, check-out, and availability of rooms in a hotel with different room types.
    """"""

    def __init__(self, name, rooms):
        """"""
        Initialize the three fields in Hotel System.
        name is the hotel name.
        available_rooms stores the remaining rooms in the hotel
        booked_rooms stores the rooms that have been booked and the person's name who booked rooms.
        """"""
        self.name = name
        self.available_rooms = rooms
        self.booked_rooms = {}

    def book_room(self, room_type, room_number, name):
        """"""
        Check if there are any rooms of the specified type available.
        if rooms are adequate, modify available_rooms and booked_rooms and finish booking, or fail to book otherwise.
        :param room_type: str
        :param room_number: int, the expected number of specified type rooms to be booked
        :param name: str, guest name
        :return: if number of rooms about to be booked doesn't exceed the remaining rooms, return str 'Success!'
                if exceeds but quantity of available rooms is not equal to zero, return int(the remaining quantity of this room type).
                if exceeds and quantity is zero or the room_type isn't in available_room, return False.
        """"""
        # Check if room type exists in available rooms
        if room_type not in self.available_rooms:
            return False
        
        # Check if the number of rooms to book exceeds the available rooms
        if room_number > self.available_rooms[room_type]:
            # If exceeds but available rooms are not zero, return the remaining quantity
            if self.available_rooms[room_type] != 0:
                return self.available_rooms[room_type]
            # If exceeds and available rooms are zero, return False
            else:
                return False
        
        # If rooms are adequate, modify available_rooms and booked_rooms
        self.available_rooms[room_type] -= room_number
        
        # Initialize booked_rooms for the room type if it doesn't exist
        if room_type not in self.booked_rooms:
            self.booked_rooms[room_type] = {}
        
        # Add the guest to the booked rooms
        if name in self.booked_rooms[room_type]:
            self.booked_rooms[room_type][name] += room_number
        else:
            self.booked_rooms[room_type][name] = room_number
        
        return 'Success!'

    def check_in(self, room_type, room_number, name):
        """"""
        Check if the room of the specified type and number is booked by the person named name.
        Remove this name when check in successfuly(room_number is equal to specific person's booked_rooms. When the actual check in quantity (room_number) is less than the booked quantity, number in booked_rooms will be booked quantity minus actual quantity
        :param room_type: str, check in room type
        :param room_number: int, check in room number
        :param name: str, person name
        :return False: only if the room_type is not in the booked_rooms or room_number is higher than quantity in booked rooms.
        """"""
        # Check if room type exists in booked rooms
        if room_type not in self.booked_rooms:
            return False
        
        # Check if the guest has booked rooms of the specified type
        if name not in self.booked_rooms[room_type]:
            return False
        
        # Check if the number of rooms to check in exceeds the booked rooms
        if room_number > self.booked_rooms[room_type][name]:
            return False
        
        # Update the booked rooms
        self.booked_rooms[room_type][name] -= room_number
        
        # Remove the guest from the booked rooms if all rooms have been checked in
        if self.booked_rooms[room_type][name] == 0:
            del self.booked_rooms[room_type][name]
        
        # Remove the room type from the booked rooms if no guests have booked rooms of this type
        if len(self.booked_rooms[room_type]) == 0:
            del self.booked_rooms[room_type]

    def check_out(self, room_type, room_number):
        """"""
        Check out rooms, add number for specific type in available_rooms.
        If room_type is new, add new type in available_rooms.
        :param room_type: str, check out room type
        :param room_number: int, check out room number
        """"""
        # Add the checked out rooms to the available rooms
        if room_type in self.available_rooms:
            self.available_rooms[room_type] += room_number
        else:
            self.available_rooms[room_type] = room_number

    def get_available_rooms(self, room_type):
        """"""
        Get the number of specific type of available rooms.
        :param room_type: str, the room type that want to know
        :return: int, the remaining number of this type rooms.
        """"""
        # Return the number of available rooms of the specified type
        if room_type in self.available_rooms:
            return self.available_rooms[room_type]
        else:
            return 0
```",0.11272141706924314,0.13550215828929837,0.7045454545454546,0.36904761904761907,0.48437499548828133,0.5632911392405063,0.21394230769230768,0.3101045256268742,0.7045454545454546,0.36904761904761907,0.48437499548828133
Llama,43,"class HRManagementSystem:
    def __init__(self):
        self.employees = {}

    def add_employee(self, employee_id, name, position, department, salary):
        if employee_id in self.employees:
            return False
        else:
            self.employees[employee_id] = {
                'name': name,
                'position': position,
                'department': department,
                'salary': salary
            }
            return True

    def remove_employee(self, employee_id):
        if employee_id in self.employees:
            del self.employees[employee_id]
            return True
        else:
            return False

    def update_employee(self, employee_id: int, employee_info: dict):
        employee = self.get_employee(employee_id)
        if employee == False:
            return False
        else:
            for key, value in employee_info.items():
                if key not in employee:
                    return False
            for key, value in employee_info.items():
                employee[key] = value
            return True

    def get_employee(self, employee_id):
        if employee_id in self.employees:
            return self.employees[employee_id]
        else:
            return False

    def list_employees(self):
        employee_data = {}
        if self.employees:
            for employee_id, employee_info in self.employees.items():
                employee_details = {}
                employee_details[""employee_ID""] = employee_id
                for key, value in employee_info.items():
                    employee_details[key] = value
                employee_data[employee_id] = employee_details
        return employee_data",FewShot,"

```python
class HRManagementSystem:
    """"""
    This is a class as personnel management system that implements functions such as adding, deleting, querying, and updating employees
    """"""

    def __init__(self):
        """"""
        Initialize the HRManagementSystem with an attribute employees, which is an empty dictionary.
        """"""
        self.employees = {}

    def add_employee(self, employee_id, name, position, department, salary):
        """"""
        Add a new employee to the HRManagementSystem.
        :param employee_id: The employee's id, int.
        :param name: The employee's name, str.
        :param position: The employee's position, str.
        :param department: The employee's department, str.
        :param salary: The employee's salary, int.
        :return: If the employee is already in the HRManagementSystem, returns False, otherwise, returns True.
        """"""
        # Check if the employee already exists
        if employee_id in self.employees:
            return False
        # Add the new employee to the dictionary
        self.employees[employee_id] = {
            'name': name,
            'position': position,
            'department': department,
            'salary': salary
        }
        return True

    def remove_employee(self, employee_id):
        """"""
        Remove an employee from the HRManagementSystem.
        :param employee_id: The employee's id, int.
        :return: If the employee is already in the HRManagementSystem, returns True, otherwise, returns False.
        """"""
        # Check if the employee exists
        if employee_id in self.employees:
            # Remove the employee from the dictionary
            del self.employees[employee_id]
            return True
        return False

    def update_employee(self, employee_id: int, employee_info: dict):
        """"""
        Update an employee's information in the HRManagementSystem.
        :param employee_id: The employee's id, int.
        :param employee_info: The employee's information, dict.
        :return: If the employee is already in the HRManagementSystem, returns True, otherwise, returns False.
        """"""
        # Check if the employee exists
        if employee_id in self.employees:
            # Update the employee's information
            self.employees[employee_id] = employee_info
            return True
        return False

    def get_employee(self, employee_id):
        """"""
        Get an employee's information from the HRManagementSystem.
        :param employee_id: The employee's id, int.
        :return: If the employee is already in the HRManagementSystem, returns the employee's information, otherwise, returns False.
        """"""
        # Check if the employee exists
        if employee_id in self.employees:
            # Return the employee's information
            return self.employees[employee_id]
        return False

    def list_employees(self):
        """"""
        List all employees' information in the HRManagementSystem.
        :return: A dictionary of all employees' information.
        """"""
        # Create a new dictionary to store the employee information with employee ID
        employees_list = {}
        for employee_id, employee_info in self.employees.items():
            # Add the employee ID to the employee information
            employee_info['employee_ID'] = employee_id
            # Add the employee information to the list
            employees_list[employee_id] = employee_info
        return employees_list
```",0.12129380053908356,0.1473696891313836,0.7413793103448276,0.36752136752136755,0.491428566996898,0.49523809523809526,0.2311111111111111,0.31515151081267223,0.7413793103448276,0.36752136752136755,0.491428566996898
Llama,44,"import re
import string
import gensim
from bs4 import BeautifulSoup


class HtmlUtil:

    def __init__(self):
        self.SPACE_MARK = '-SPACE-'
        self.JSON_MARK = '-JSON-'
        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'
        self.URL_MARK = '-URL-'
        self.NUMBER_MARK = '-NUMBER-'
        self.TRACE_MARK = '-TRACE-'
        self.COMMAND_MARK = '-COMMAND-'
        self.COMMENT_MARK = '-COMMENT-'
        self.CODE_MARK = '-CODE-'

    @staticmethod
    def __format_line_feed(text):
        return re.sub(re.compile(r'\n+'), '\n', text)

    def format_line_html_text(self, html_text):
        if html_text is None or len(html_text) == 0:
            return ''
        soup = BeautifulSoup(html_text, 'lxml')

        code_tag = soup.find_all(name=['pre', 'blockquote'])
        for tag in code_tag:
            tag.string = self.CODE_MARK

        ul_ol_group = soup.find_all(name=['ul', 'ol'])
        for ul_ol_item in ul_ol_group:
            li_group = ul_ol_item.find_all('li')
            for li_item in li_group:
                li_item_text = li_item.get_text().strip()
                if len(li_item_text) == 0:
                    continue
                if li_item_text[-1] in string.punctuation:
                    li_item.string = '[{0}]{1}'.format('-', li_item_text)
                    continue
                li_item.string = '[{0}]{1}.'.format('-', li_item_text)

        p_group = soup.find_all(name=['p'])
        for p_item in p_group:
            p_item_text = p_item.get_text().strip()
            if p_item_text:
                if p_item_text[-1] in string.punctuation:
                    p_item.string = p_item_text
                    continue
                next_sibling = p_item.find_next_sibling()
                if next_sibling and self.CODE_MARK in next_sibling.get_text():
                    p_item.string = p_item_text + ':'
                    continue
                p_item.string = p_item_text + '.'

        clean_text = gensim.utils.decode_htmlentities(soup.get_text())
        return self.__format_line_feed(clean_text)

    def extract_code_from_html_text(self, html_text):
        text_with_code_tag = self.format_line_html_text(html_text)

        if self.CODE_MARK not in text_with_code_tag:
            return []

        code_index_start = 0
        soup = BeautifulSoup(html_text, 'lxml')
        code_tag = soup.find_all(name=['pre', 'blockquote'])
        code_count = text_with_code_tag.count(self.CODE_MARK)
        code_list = []
        for code_index in range(code_index_start, code_index_start + code_count):
            code = code_tag[code_index].get_text()
            if code:
                code_list.append(code)
        return code_list",FewShot,"

```python
import re
import string
import gensim
from bs4 import BeautifulSoup

class HtmlUtil:
    """"""
    This is a class as util for html, supporting for formatting and extracting code from HTML text, including cleaning up the text and converting certain elements into specific marks.
    """"""

    def __init__(self):
        """"""
        Initialize a series of labels
        """"""
        self.SPACE_MARK = '-SPACE-'
        self.JSON_MARK = '-JSON-'
        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'
        self.URL_MARK = '-URL-'
        self.NUMBER_MARK = '-NUMBER-'
        self.TRACE_MARK = '-TRACE-'
        self.COMMAND_MARK = '-COMMAND-'
        self.COMMENT_MARK = '-COMMENT-'
        self.CODE_MARK = '-CODE-'

    @staticmethod
    def __format_line_feed(text):
        """"""
        Replace consecutive line breaks with a single line break
        :param text: string with consecutive line breaks
        :return:string, replaced text with single line break
        """"""
        # Replace consecutive line breaks with a single line break
        text = re.sub(r'\n+', '\n', text)
        return text

    def format_line_html_text(self, html_text):
        """"""
        get the html text without the code, and add the code tag -CODE- where the code is
        :param html_text:string
        :return:string
        """"""
        # Parse the HTML text using BeautifulSoup
        soup = BeautifulSoup(html_text, 'html.parser')
        
        # Find all pre and code elements
        pre_elements = soup.find_all(['pre', 'code'])
        
        # Replace pre and code elements with -CODE- tag
        for element in pre_elements:
            element.replace_with(self.CODE_MARK)
        
        # Get the text from the soup
        text = soup.get_text()
        
        # Format the line feeds
        text = self.__format_line_feed(text)
        
        return text

    def extract_code_from_html_text(self, html_text):
        """"""
        extract codes from the html body
        :param html_text: string, html text
        :return: the list of code
        """"""
        # Parse the HTML text using BeautifulSoup
        soup = BeautifulSoup(html_text, 'html.parser')
        
        # Find all pre and code elements
        pre_elements = soup.find_all(['pre', 'code'])
        
        # Extract the code from the pre and code elements
        codes = []
        for element in pre_elements:
            code = element.get_text()
            codes.append(code)
        
        return codes
```",0.15867158671586712,0.18584561899868163,0.4358974358974359,0.40476190476190477,0.41975308142661183,0.2930232558139535,0.27391304347826084,0.2831460624214115,0.4358974358974359,0.40476190476190477,0.41975308142661183
Llama,45,"from PIL import Image, ImageEnhance, ImageChops


class ImageProcessor:
    def __init__(self):
        self.image = None

    def load_image(self, image_path):
        self.image = Image.open(image_path)

    def save_image(self, save_path):
        if self.image:
            self.image.save(save_path)

    def resize_image(self, width, height):
        if self.image:
            self.image = self.image.resize((width, height))

    def rotate_image(self, degrees):
        if self.image:
            self.image = self.image.rotate(degrees)

    def adjust_brightness(self, factor):
        if self.image:
            enhancer = ImageEnhance.Brightness(self.image)
            self.image = enhancer.enhance(factor)",FewShot,"

```python
from PIL import Image, ImageEnhance

class ImageProcessor:
    """"""
    This is a class to process image, including loading, saving, resizing, rotating, and adjusting the brightness of images.
    """"""

    def __init__(self):
        # Initialize self.image
        self.image = None

    def load_image(self, image_path):
        # Use Image util in PIL to open a image
        try:
            self.image = Image.open(image_path)
        except Exception as e:
            print(f""Failed to load image: {e}"")

    def save_image(self, save_path):
        # Save image to a path if image has opened
        if self.image:
            try:
                self.image.save(save_path)
            except Exception as e:
                print(f""Failed to save image: {e}"")
        else:
            print(""No image loaded"")

    def resize_image(self, width, height):
        # Resize the image if image has opened
        if self.image:
            try:
                self.image = self.image.resize((width, height))
            except Exception as e:
                print(f""Failed to resize image: {e}"")
        else:
            print(""No image loaded"")

    def rotate_image(self, degrees):
        # Rotate image if image has opened
        if self.image:
            try:
                self.image = self.image.rotate(degrees)
            except Exception as e:
                print(f""Failed to rotate image: {e}"")
        else:
            print(""No image loaded"")

    def adjust_brightness(self, factor):
        # Adjust the brightness of image if image has opened
        if self.image:
            try:
                enhancer = ImageEnhance.Brightness(self.image)
                self.image = enhancer.enhance(factor)
            except Exception as e:
                print(f""Failed to adjust brightness: {e}"")
        else:
            print(""No image loaded"")
```",0.10160427807486631,0.1259717966784497,0.9473684210526315,0.4235294117647059,0.5853658493885915,0.6923076923076923,0.27692307692307694,0.395604391522763,0.9473684210526315,0.4235294117647059,0.5853658493885915
Llama,46,"class Interpolation:
    def __init__(self):
        pass

    @staticmethod
    def interpolate_1d(x, y, x_interp):
        y_interp = []
        for xi in x_interp:
            for i in range(len(x) - 1):
                if x[i] <= xi <= x[i+1]:
                    yi = y[i] + (y[i+1] - y[i]) * (xi - x[i]) / (x[i+1] - x[i])
                    y_interp.append(yi)
                    break
        return y_interp
    
    @staticmethod
    def interpolate_2d(x, y, z, x_interp, y_interp):
        z_interp = []
        for xi, yi in zip(x_interp, y_interp):
            for i in range(len(x) - 1):
                if x[i] <= xi <= x[i+1]:
                    for j in range(len(y) - 1):
                        if y[j] <= yi <= y[j+1]:
                            z00 = z[i][j]
                            z01 = z[i][j+1]
                            z10 = z[i+1][j]
                            z11 = z[i+1][j+1]
                            zi = (z00 * (x[i+1] - xi) * (y[j+1] - yi) +
                                  z10 * (xi - x[i]) * (y[j+1] - yi) +
                                  z01 * (x[i+1] - xi) * (yi - y[j]) +
                                  z11 * (xi - x[i]) * (yi - y[j])) / ((x[i+1] - x[i]) * (y[j+1] - y[j]))
                            z_interp.append(zi)
                            break
                    break
        return z_interp",FewShot,"

```python
class Interpolation:
    """"""
    This is a class that implements the Linear interpolation operation of one-dimensional and two-dimensional data
    """"""

    def __init__(self):
        pass

    @staticmethod
    def interpolate_1d(x, y, x_interp):
        """"""
        Linear interpolation of one-dimensional data
        :param x: The x-coordinate of the data point, list.
        :param y: The y-coordinate of the data point, list.
        :param x_interp: The x-coordinate of the interpolation point, list.
        :return: The y-coordinate of the interpolation point, list.
        """"""
        # Initialize an empty list to store the interpolated y-coordinates
        y_interp = []
        
        # Iterate over each interpolation point
        for x_val in x_interp:
            # Find the index of the x-coordinate that is just below the interpolation point
            idx = next((i for i, val in enumerate(x) if val > x_val), len(x) - 1) - 1
            
            # Check if the interpolation point is outside the range of x-coordinates
            if idx < 0:
                # If it's below the lowest x-coordinate, use the lowest y-coordinate
                y_interp.append(y[0])
            elif idx >= len(x) - 1:
                # If it's above the highest x-coordinate, use the highest y-coordinate
                y_interp.append(y[-1])
            else:
                # Calculate the interpolated y-coordinate using linear interpolation
                y_val = y[idx] + (y[idx + 1] - y[idx]) * (x_val - x[idx]) / (x[idx + 1] - x[idx])
                y_interp.append(y_val)
        
        return y_interp

    @staticmethod
    def interpolate_2d(x, y, z, x_interp, y_interp):
        """"""
        Linear interpolation of two-dimensional data
        :param x: The x-coordinate of the data point, list.
        :param y: The y-coordinate of the data point, list.
        :param z: The z-coordinate of the data point, 2D list.
        :param x_interp: The x-coordinate of the interpolation point, list.
        :param y_interp: The y-coordinate of the interpolation point, list.
        :return: The z-coordinate of the interpolation point, list.
        """"""
        # Initialize an empty list to store the interpolated z-coordinates
        z_interp = []
        
        # Iterate over each interpolation point
        for x_val, y_val in zip(x_interp, y_interp):
            # Find the indices of the x and y coordinates that are just below the interpolation point
            idx_x = next((i for i, val in enumerate(x) if val > x_val), len(x) - 1) - 1
            idx_y = next((i for i, val in enumerate(y) if val > y_val), len(y) - 1) - 1
            
            # Check if the interpolation point is outside the range of x or y coordinates
            if idx_x < 0:
                # If it's below the lowest x-coordinate, use the lowest z-coordinate
                z_val = z[0][idx_y] + (z[0][idx_y + 1] - z[0][idx_y]) * (y_val - y[idx_y]) / (y[idx_y + 1] - y[idx_y])
            elif idx_x >= len(x) - 1:
                # If it's above the highest x-coordinate, use the highest z-coordinate
                z_val = z[-1][idx_y] + (z[-1][idx_y + 1] - z[-1][idx_y]) * (y_val - y[idx_y]) / (y[idx_y + 1] - y[idx_y])
            elif idx_y < 0:
                # If it's below the lowest y-coordinate, use the lowest z-coordinate
                z_val = z[idx_x][0] + (z[idx_x + 1][0] - z[idx_x][0]) * (x_val - x[idx_x]) / (x[idx_x + 1] - x[idx_x])
            elif idx_y >= len(y) - 1:
                # If it's above the highest y-coordinate, use the highest z-coordinate
                z_val = z[idx_x][-1] + (z[idx_x + 1][-1] - z[idx_x][-1]) * (x_val - x[idx_x]) / (x[idx_x + 1] - x[idx_x])
            else:
                # Calculate the interpolated z-coordinate using bilinear interpolation
                q11 = z[idx_x][idx_y]
                q12 = z[idx_x][idx_y + 1]
                q21 = z[idx_x + 1][idx_y]
                q22 = z[idx_x + 1][idx_y + 1]
                
                r1 = q11 + (q12 - q11) * (y_val - y[idx_y]) / (y[idx_y + 1] - y[idx_y])
                r2 = q21 + (q22 - q21) * (y_val - y[idx_y]) / (y[idx_y + 1] - y[idx_y])
                
                z_val = r1 + (r2 - r1) * (x_val - x[idx_x]) / (x[idx_x + 1] - x[idx_x])
            
            z_interp.append(z_val)
        
        return z_interp
```",0.027491408934707903,0.0412612727817785,0.4090909090909091,0.16167664670658682,0.23175965259186948,0.19298245614035087,0.0694006309148265,0.10208816316255848,0.4090909090909091,0.16167664670658682,0.23175965259186948
Llama,47,"class IPAddress:
    def __init__(self, ip_address):
        self.ip_address = ip_address

    def is_valid(self):
        octets = self.ip_address.split('.')
        if len(octets) != 4:
            return False
        for octet in octets:
            if not octet.isdigit() or int(octet) < 0 or int(octet) > 255:
                return False
        return True

    def get_octets(self):
        if self.is_valid():
            return self.ip_address.split('.')
        else:
            return []

    def get_binary(self):
        if self.is_valid():
            binary_octets = []
            for octet in self.get_octets():
                binary_octets.append(format(int(octet), '08b'))
            return '.'.join(binary_octets)
        else:
            return ''",FewShot,"

```python
class IPAddress:
    """"""
    This is a class to process IP Address, including validating, getting the octets and obtaining the binary representation of a valid IP address.
    """"""

    def __init__(self, ip_address):
        """"""
        Initialize the IP address to the specified address
        :param ip_address:string
        """"""
        self.ip_address = ip_address

    def is_valid(self):
        """"""
        Judge whether the IP address is valid, that is, whether the IP address is composed of four Decimal digits separated by '.'. 
        Each digit is greater than or equal to 0 and less than or equal to 255
        :return: bool
        """"""
        # Split the IP address into four parts
        parts = self.ip_address.split('.')
        
        # Check if the IP address has four parts
        if len(parts) != 4:
            return False
        
        # Check each part
        for part in parts:
            # Check if the part is a digit
            if not part.isdigit():
                return False
            
            # Convert the part to an integer
            num = int(part)
            
            # Check if the number is between 0 and 255
            if num < 0 or num > 255:
                return False
        
        # If all checks pass, the IP address is valid
        return True


    def get_octets(self):
        """"""
        If the IP address is valid, the list of four decimal numbers separated by ""."" constituting the IP address is returned; 
        otherwise, an empty list is returned
        :return: list
        """"""
        # Check if the IP address is valid
        if self.is_valid():
            # Split the IP address into four parts and return them as a list
            return self.ip_address.split('.')
        else:
            # If the IP address is not valid, return an empty list
            return []


    def get_binary(self):
        """"""
        If the IP address is valid, return the binary form of the IP address; otherwise, return ''
        :return: string
        """"""
        # Check if the IP address is valid
        if self.is_valid():
            # Split the IP address into four parts
            parts = self.ip_address.split('.')
            
            # Convert each part to binary and format it to 8 bits
            binary_parts = [format(int(part), '08b') for part in parts]
            
            # Join the binary parts with '.' and return the result
            return '.'.join(binary_parts)
        else:
            # If the IP address is not valid, return an empty string
            return ''
```",0.040697674418604654,0.054284173030845685,0.7674418604651163,0.2619047619047619,0.3905325405847135,0.47761194029850745,0.13445378151260504,0.20983606214544478,0.7674418604651163,0.2619047619047619,0.3905325405847135
Llama,48,"import socket


class IpUtil:

    @staticmethod
    def is_valid_ipv4(ip_address):
        try:
            socket.inet_pton(socket.AF_INET, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def is_valid_ipv6(ip_address):
        try:
            socket.inet_pton(socket.AF_INET6, ip_address)
            return True
        except socket.error:
            return False

    @staticmethod
    def get_hostname(ip_address):
        try:
            hostname = socket.gethostbyaddr(ip_address)[0]
            return hostname
        except socket.herror:
            return None",FewShot,"

```python
import socket
import netifaces
import ipaddress


class IpUtil:
    """"""
    This is a class as tool for ip that can be used to obtain the local IP address, validate its validity, and also provides the functionality to retrieve the corresponding hostname.
    """"""

    # Method to check if the given IP address is a valid IPv4 address
    @staticmethod
    def is_valid_ipv4(ip_address):
        # Try to create an IPv4Address object with the given IP address
        try:
            ipaddress.IPv4Address(ip_address)
            return True
        except ipaddress.AddressValueError:
            return False

    # Method to check if the given IP address is a valid IPv6 address
    @staticmethod
    def is_valid_ipv6(ip_address):
        # Try to create an IPv6Address object with the given IP address
        try:
            ipaddress.IPv6Address(ip_address)
            return True
        except ipaddress.AddressValueError:
            return False

    # Method to get the hostname associated with the given IP address
    @staticmethod
    def get_hostname(ip_address):
        # Try to get the hostname using the socket.gethostbyaddr method
        try:
            hostname, _, _ = socket.gethostbyaddr(ip_address)
            return hostname
        except socket.herror:
            # If the hostname cannot be found, return None
            return None
```",0.043478260869565216,0.050095676542475806,0.75,0.225,0.34615384260355037,0.42857142857142855,0.12605042016806722,0.19480519129279814,0.75,0.225,0.34615384260355037
Llama,49,"class JobMarketplace:
    def __init__(self):
        self.job_listings = []
        self.resumes = []

    def post_job(self, job_title, company, requirements):
        # requirements = ['requirement1', 'requirement2']
        job = {""job_title"": job_title, ""company"": company, ""requirements"": requirements}
        self.job_listings.append(job)

    def remove_job(self, job):
        self.job_listings.remove(job)

    def submit_resume(self, name, skills, experience):
        resume = {""name"": name, ""skills"": skills, ""experience"": experience}
        self.resumes.append(resume)

    def withdraw_resume(self, resume):
        self.resumes.remove(resume)

    def search_jobs(self, criteria):
        matching_jobs = []
        for job_listing in self.job_listings:
            if criteria.lower() in job_listing[""job_title""].lower() or criteria.lower() in [r.lower() for r in job_listing[""requirements""]]:
                matching_jobs.append(job_listing)
        return matching_jobs

    def get_job_applicants(self, job):
        applicants = []
        for resume in self.resumes:
            if self.matches_requirements(resume, job[""requirements""]):
                applicants.append(resume)
        return applicants

    @staticmethod
    def matches_requirements(resume, requirements):
        for skill in resume[""skills""]:
            if skill not in requirements:
                return False
        return True",FewShot,"

```python
class JobMarketplace:
    """"""
    This is a class that provides functionalities to publish positions, remove positions, submit resumes, withdraw resumes, search for positions, and obtain candidate information.
    """"""

    def __init__(self):
        # Initialize empty lists for job listings and resumes
        self.job_listings = []
        self.resumes = []

    def post_job(self, job_title, company, requirements):
        # Create a dictionary for the job listing and add it to the job_listings list
        job = {'job_title': job_title, 'company': company, 'requirements': requirements}
        self.job_listings.append(job)

    def remove_job(self, job):
        # Check if the job is in the job_listings list and remove it if found
        if job in self.job_listings:
            self.job_listings.remove(job)

    def submit_resume(self, name, skills, experience):
        # Create a dictionary for the resume and add it to the resumes list
        resume = {'name': name, 'skills': skills, 'experience': experience}
        self.resumes.append(resume)

    def withdraw_resume(self, resume):
        # Check if the resume is in the resumes list and remove it if found
        if resume in self.resumes:
            self.resumes.remove(resume)

    def search_jobs(self, criteria):
        # Filter the job_listings list to find jobs that match the given criteria
        matching_jobs = [job for job in self.job_listings if criteria in job['requirements']]
        return matching_jobs

    def get_job_applicants(self, job):
        # Filter the resumes list to find resumes that match the requirements of the given job
        matching_resumes = [resume for resume in self.resumes if all(requirement in resume['skills'] for requirement in job['requirements'])]
        return matching_resumes

    def matches_requirements(self, resume, job):
        # Check if the resume matches the requirements of the job
        return all(requirement in resume['skills'] for requirement in job['requirements'])
```",0.11489361702127661,0.14855560315410568,0.6176470588235294,0.42,0.499999995181406,0.4051724137931034,0.25405405405405407,0.31229235406673217,0.6176470588235294,0.42,0.499999995181406
Llama,50,"import json
import os


class JSONProcessor:
    def read_json(self, file_path):
        if not os.path.exists(file_path):
            return 0
        try:
            with open(file_path, 'r') as file:
                data = json.load(file)
            return data
        except:
            return -1

    def write_json(self, data, file_path):
        try:
            with open(file_path, 'w') as file:
                json.dump(data, file)
            return 1
        except:
            return -1

    def process_json(self, file_path, remove_key):
        data = self.read_json(file_path)
        if data == 0 or data == -1:
            return 0
        if remove_key in data:
            del data[remove_key]
            self.write_json(data, file_path)
            return 1
        else:
            return 0",FewShot,"

```python
import json
import os

class JSONProcessor:
    """"""
    This is a class to process JSON file, including reading and writing JSON files, as well as processing JSON data by removing a specified key from the JSON object.
    """"""

    def read_json(self, file_path):
        # Check if the file exists
        if not os.path.exists(file_path):
            return 0
        
        try:
            # Attempt to open and read the JSON file
            with open(file_path, 'r') as file:
                # Load the JSON data
                data = json.load(file)
                return data
        except:
            # Return -1 if an error occurs during the reading process
            return -1

    def write_json(self, data, file_path):
        try:
            # Attempt to write the data to the JSON file
            with open(file_path, 'w') as file:
                # Dump the JSON data
                json.dump(data, file)
                return 1
        except:
            # Return -1 if an error occurs during the writing process
            return -1

    def process_json(self, file_path, remove_key):
        # Read the JSON file
        data = self.read_json(file_path)
        
        # Check if the file does not exist or an error occurred
        if data == 0 or data == -1:
            return 0
        
        # Check if the key exists in the data
        if remove_key not in data:
            return 0
        
        # Remove the specified key from the data
        del data[remove_key]
        
        # Write the modified data back to the file
        result = self.write_json(data, file_path)
        
        # Return 1 if the writing process is successful
        if result == 1:
            return 1
        else:
            return 0
```",0.19196428571428573,0.21952040559690555,1.0,0.4845360824742268,0.6527777733805942,0.8115942028985508,0.3181818181818182,0.45714285309654323,1.0,0.4845360824742268,0.6527777733805942
Llama,51,"import numpy as np


class KappaCalculator:

    @staticmethod
    def kappa(testData, k):
        dataMat = np.mat(testData)
        P0 = 0.0
        for i in range(k):
            P0 += dataMat[i, i] * 1.0
        xsum = np.sum(dataMat, axis=1)
        ysum = np.sum(dataMat, axis=0)
        sum = np.sum(dataMat)
        Pe = float(ysum * xsum) / sum / sum
        P0 = float(P0 / sum * 1.0)
        cohens_coefficient = float((P0 - Pe) / (1 - Pe))
        return cohens_coefficient

    @staticmethod
    def fleiss_kappa(testData, N, k, n):
        dataMat = np.mat(testData, float)
        oneMat = np.ones((k, 1))
        sum = 0.0
        P0 = 0.0
        for i in range(N):
            temp = 0.0
            for j in range(k):
                sum += dataMat[i, j]
                temp += 1.0 * dataMat[i, j] ** 2
            temp -= n
            temp /= (n - 1) * n
            P0 += temp
        P0 = 1.0 * P0 / N
        ysum = np.sum(dataMat, axis=0)
        for i in range(k):
            ysum[0, i] = (ysum[0, i] / sum) ** 2
        Pe = ysum * oneMat * 1.0
        ans = (P0 - Pe) / (1 - Pe)
        return ans[0, 0]",FewShot,"

```python
import numpy as np

class KappaCalculator:
    """"""
    This is a class as KappaCalculator, supporting to calculate Cohen's and Fleiss' kappa coefficient.
    """"""

    @staticmethod
    def kappa(testData, k):
        """"""
        Calculate the cohens kappa value of a k-dimensional matrix
        :param testData: The k-dimensional matrix that needs to calculate the cohens kappa value
        :param k: int, Matrix dimension
        :return:float, the cohens kappa value of the matrix
        >>> KappaCalculator.kappa([[2, 1, 1], [1, 2, 1], [1, 1, 2]], 3)
        0.25
        """"""
        # Calculate the total number of observations
        total_observations = sum(sum(row) for row in testData)
        
        # Calculate the observed agreement
        observed_agreement = sum(testData[i][i] for i in range(k)) / total_observations
        
        # Calculate the expected agreement
        expected_agreement = sum((sum(testData[i]) / total_observations) * (sum(testData[j]) / total_observations) for i in range(k) for j in range(k)) / k
        
        # Calculate Cohen's kappa
        kappa = (observed_agreement - expected_agreement) / (1 - expected_agreement)
        
        return kappa

    @staticmethod
    def fleiss_kappa(testData, N, k, n):
        """"""
        Calculate the fliss kappa value of an N * k matrix
        :param testData: Input data matrix, N * k
        :param N: int, Number of samples
        :param k: int, Number of categories
        :param n: int, Number of raters
        :return: float, fleiss kappa value
        >>> KappaCalculator.fleiss_kappa([[0, 0, 0, 0, 14],
        >>>                              [0, 2, 6, 4, 2],
        >>>                              [0, 0, 3, 5, 6],
        >>>                              [0, 3, 9, 2, 0],
        >>>                              [2, 2, 8, 1, 1],
        >>>                              [7, 7, 0, 0, 0],
        >>>                              [3, 2, 6, 3, 0],
        >>>                              [2, 5, 3, 2, 2],
        >>>                              [6, 5, 2, 1, 0],
        >>>                              [0, 2, 2, 3, 7]], 10, 5, 14)
        0.20993070442195522
        """"""
        # Calculate the total number of observations
        total_observations = N * n
        
        # Calculate the observed agreement
        observed_agreement = 0
        for i in range(N):
            max_category_count = max(testData[i])
            observed_agreement += (max_category_count / n) ** 2
        
        observed_agreement = (observed_agreement - 1) / (N - 1)
        
        # Calculate the expected agreement
        expected_agreement = 0
        for j in range(k):
            category_count = sum(testData[i][j] for i in range(N))
            expected_agreement += (category_count / total_observations) ** 2
        
        # Calculate Fleiss' kappa
        kappa = (observed_agreement - expected_agreement) / (1 - expected_agreement)
        
        return kappa
```",0.05294117647058823,0.07151199798365576,0.4583333333333333,0.2323943661971831,0.3084112104882523,0.19230769230769232,0.10245901639344263,0.13368983503674697,0.4305555555555556,0.21830985915492956,0.2897196217032056
Llama,52,"import nltk
from nltk.stem import WordNetLemmatizer
from nltk import pos_tag, word_tokenize
import string

nltk.download('averaged_perceptron_tagger')
nltk.download('punkt')
nltk.download('wordnet')


class Lemmatization:
    def __init__(self):
        self.lemmatizer = WordNetLemmatizer()

    def lemmatize_sentence(self, sentence):
        lemmatized_words = []
        sentence = self.remove_punctuation(sentence)
        words = word_tokenize(sentence)
        tagged_words = pos_tag(words)
        for word, tag in tagged_words:
            if tag.startswith('V'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='v')
            elif tag.startswith('J'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='a')
            elif tag.startswith('R'):
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='r')
            else:
                lemmatized_word = self.lemmatizer.lemmatize(word)
            lemmatized_words.append(lemmatized_word)
        return lemmatized_words

    def get_pos_tag(self, sentence):
        pos_tags = []
        sentence = self.remove_punctuation(sentence)
        words = word_tokenize(sentence)
        tagged_words = pos_tag(words)
        for tagged_word in tagged_words:
            pos_tags.append(tagged_word[1])
        return pos_tags

    def remove_punctuation(self, sentence):
        return sentence.translate(str.maketrans('', '', string.punctuation))",FewShot,"

```python
class Lemmatization:
    """"""
    This is a class about Lemmatization, which utilizes the nltk library to perform lemmatization and part-of-speech tagging on sentences, as well as remove punctuation.
    """"""

    def __init__(self):
        """"""
        creates a WordNetLemmatizer object and stores it in the self.lemmatizer member variable.
        """"""
        # Initialize the WordNetLemmatizer object
        self.lemmatizer = WordNetLemmatizer()

    def lemmatize_sentence(self, sentence):
        """"""
        Remove punctuations of the sentence and tokenizes the input sentence, mark the part of speech tag of each word,
        lemmatizes the words with different parameters based on their parts of speech, and stores in a list.
        :param sentence: a sentence str
        :return: a list of words which have been lemmatized.
        >>> lemmatization = Lemmatization()
        >>> lemmatization.lemmatize_sentence(""I am running in a race."")
        ['I', 'be', 'run', 'in', 'a', 'race']

        """"""
        # Remove punctuation from the sentence
        sentence = self.remove_punctuation(sentence)
        
        # Tokenize the sentence into words
        words = word_tokenize(sentence)
        
        # Get the part of speech tags for each word
        pos_tags = self.get_pos_tag(sentence)
        
        # Initialize an empty list to store the lemmatized words
        lemmatized_words = []
        
        # Iterate over each word and its corresponding part of speech tag
        for word, pos in zip(words, pos_tags):
            # Determine the part of speech tag
            if pos.startswith('J'):
                # Adjective
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='a')
            elif pos.startswith('V'):
                # Verb
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='v')
            elif pos.startswith('N'):
                # Noun
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='n')
            elif pos.startswith('R'):
                # Adverb
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='r')
            else:
                # Default to noun
                lemmatized_word = self.lemmatizer.lemmatize(word, pos='n')
            
            # Add the lemmatized word to the list
            lemmatized_words.append(lemmatized_word)
        
        # Return the list of lemmatized words
        return lemmatized_words

    def get_pos_tag(self, sentence):
        """"""
        Remove punctuations of the sentence and tokenizes the input sentence, mark the part of speech tag of each word.
        :param sentence: a sentence str
        :return: list, part of speech tag of each word in the sentence.
        >>> lemmatization = Lemmatization()
        >>> lemmatization.get_pos_tag(""I am running in a race."")
        ['PRP', 'VBP', 'VBG', 'IN', 'DT', 'NN']

        """"""
        # Remove punctuation from the sentence
        sentence = self.remove_punctuation(sentence)
        
        # Tokenize the sentence into words
        words = word_tokenize(sentence)
        
        # Get the part of speech tags for each word
        pos_tags = pos_tag(words)
        
        # Extract the part of speech tags
        pos_tags = [tag[1] for tag in pos_tags]
        
        # Return the list of part of speech tags
        return pos_tags

    def remove_punctuation(self, sentence):
        """"""
        Removes punctuation from the input text.
        :param sentence: a sentence str
        :return: str, sentence without any punctuation
        >>> lemmatization = Lemmatization()
        >>> lemmatization.remove_punctuation(""I am running in a race."")
        'I am running in a race'

        """"""
        # Use the translate method to remove punctuation
        translator = str.maketrans('', '', string.punctuation)
        sentence = sentence.translate(translator)
        
        # Return the sentence without punctuation
        return sentence
```",0.05594405594405595,0.07231091575797113,0.7543859649122807,0.25903614457831325,0.3856502204098213,0.42857142857142855,0.13131313131313133,0.20103092424447344,0.7368421052631579,0.25301204819277107,0.3766816105443504
Llama,53,"import re
import string


class LongestWord:

    def __init__(self):
        self.word_list = []

    def add_word(self, word):
        self.word_list.append(word)

    def find_longest_word(self, sentence):
        longest_word = """"
        sentence = sentence.lower()
        sentence = re.sub('[%s]' % re.escape(string.punctuation), '', sentence)
        sentence = re.split(' ', sentence)
        for word in sentence:
            if word in self.word_list and len(word) > len(longest_word):
                longest_word = word
        return longest_word",FewShot,"

```python
import re
import string

class LongestWord:
    """"""
    This is a class allows to add words to a list and find the longest word in a given sentence by comparing the words with the ones in the word list.
    """"""

    def __init__(self):
        """"""
        Initialize a list of word.
        """"""
        # Initialize an empty list to store words
        self.word_list = []

    def add_word(self, word):
        """"""
        append the input word into self.word_list
        :param word: str, input word
        """"""
        # Append the input word to the word list
        self.word_list.append(word)

    def find_longest_word(self, sentence):
        """"""
        Remove punctuation marks and split a sentence into a list of word. Find the longest splited word that is in the self.word_list.
        Words are strictly case sensitive.
        :param sentence: a sentence str
        :return str: longest splited word that is in the self.word_list. return '' if self.word_list is empty.
        """"""
        # Remove punctuation marks from the sentence
        sentence = re.sub('['+string.punctuation+']', '', sentence)
        
        # Split the sentence into a list of words
        words = sentence.split()
        
        # Initialize the longest word and its length
        longest_word = ''
        max_length = 0
        
        # Iterate over each word in the sentence
        for word in words:
            # Check if the word is in the word list and its length is greater than the current max length
            if word in self.word_list and len(word) > max_length:
                # Update the longest word and its length
                longest_word = word
                max_length = len(word)
        
        # Return the longest word
        return longest_word
```",0.0759493670886076,0.09439960225017317,0.7631578947368421,0.29591836734693877,0.4264705842084775,0.5740740740740741,0.16489361702127658,0.25619834364046173,0.7631578947368421,0.29591836734693877,0.4264705842084775
Llama,54,"import random


class MahjongConnect:
    def __init__(self, BOARD_SIZE, ICONS):
        self.BOARD_SIZE = BOARD_SIZE
        self.ICONS = ICONS
        self.board = self.create_board()

    def create_board(self):
        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]
        return board

    def is_valid_move(self, pos1, pos2):
        x1, y1 = pos1
        x2, y2 = pos2

        # Check if positions are within the game board range
        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and 0 <= x2 < self.BOARD_SIZE[
            0] and 0 <= y2 <
                self.BOARD_SIZE[1]):
            return False

        # Check if the two positions are the same
        if pos1 == pos2:
            return False

        # Check if the two positions have the same icon
        if self.board[x1][y1] != self.board[x2][y2]:
            return False

        # Check if there is a valid path between the two positions
        if not self.has_path(pos1, pos2):
            return False

        return True

    def has_path(self, pos1, pos2):
        visited = set()
        stack = [pos1]

        while stack:
            current_pos = stack.pop()
            if current_pos == pos2:
                return True

            if current_pos in visited:
                continue

            visited.add(current_pos)
            x, y = current_pos

            # Check adjacent positions (up, down, left, right)
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                new_x, new_y = x + dx, y + dy
                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:
                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:
                        stack.append((new_x, new_y))

        return False

    def remove_icons(self, pos1, pos2):
        x1, y1 = pos1
        x2, y2 = pos2
        self.board[x1][y1] = ' '
        self.board[x2][y2] = ' '

    def is_game_over(self):
        for row in self.board:
            if any(icon != ' ' for icon in row):
                return False
        return True",FewShot,"

```python
import random

class MahjongConnect:
    """"""
    MahjongConnect is a class representing a game board for Mahjong Connect with features like creating the board, checking valid moves, finding paths, removing icons, and checking if the game is over.
    """"""

    def __init__(self, BOARD_SIZE, ICONS):
        """"""
        initialize the board size and the icon list, create the game board
        :param BOARD_SIZE: list of two integer numbers, representing the number of rows and columns of the game board
        :param ICONS: list of string, representing the icons
        """"""
        self.BOARD_SIZE = BOARD_SIZE
        self.ICONS = ICONS
        self.board = self.create_board()

    def create_board(self):
        """"""
        create the game board with the given board size and icons
        :return: 2-dimensional list, the game board
        """"""
        # Initialize an empty board with the given size
        board = [[None for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]
        
        # Fill the board with random icons
        for i in range(self.BOARD_SIZE[0]):
            for j in range(self.BOARD_SIZE[1]):
                board[i][j] = random.choice(self.ICONS)
        
        return board

    def is_valid_move(self, pos1, pos2):
        """"""
        check if the move of two icons is valid (i.e. positions are within the game board range, the two positions are not the same, the two positions have the same icon, and there is a valid path between the two positions)
        :param pos1: position tuple(x, y) of the first icon
        :param pos2: position tuple(x, y) of the second icon
        :return:True or False ,representing whether the move of two icons is valid
        """"""
        # Check if positions are within the game board range
        if (pos1[0] < 0 or pos1[0] >= self.BOARD_SIZE[0] or pos1[1] < 0 or pos1[1] >= self.BOARD_SIZE[1] or
            pos2[0] < 0 or pos2[0] >= self.BOARD_SIZE[0] or pos2[1] < 0 or pos2[1] >= self.BOARD_SIZE[1]):
            return False
        
        # Check if the two positions are not the same
        if pos1 == pos2:
            return False
        
        # Check if the two positions have the same icon
        if self.board[pos1[0]][pos1[1]] != self.board[pos2[0]][pos2[1]]:
            return False
        
        # Check if there is a valid path between the two positions
        return self.has_path(pos1, pos2)

    def has_path(self, pos1, pos2):
        """"""
        check if there is a path between two icons
        :param pos1: position tuple(x, y) of the first icon
        :param pos2: position tuple(x, y) of the second icon
        :return: True or False ,representing whether there is a path between two icons
        """"""
        # Define the possible movements (up, down, left, right)
        movements = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        
        # Perform a breadth-first search to find a path
        queue = [(pos1, [pos1])]
        while queue:
            (node, path) = queue.pop(0)
            for movement in movements:
                new_pos = (node[0] + movement[0], node[1] + movement[1])
                if (0 <= new_pos[0] < self.BOARD_SIZE[0] and 0 <= new_pos[1] < self.BOARD_SIZE[1] and
                    new_pos not in path):
                    if new_pos == pos2:
                        return True
                    queue.append((new_pos, path + [new_pos]))
        
        return False

    def remove_icons(self, pos1, pos2):
        """"""
        remove the connected icons on the game board
        :param pos1: position tuple(x, y) of the first icon to be removed
        :param pos2: position tuple(x, y) of the second icon to be removed
        :return: None
        """"""
        # Remove the icons at the given positions
        self.board[pos1[0]][pos1[1]] = None
        self.board[pos2[0]][pos2[1]] = None
        
        # Drop down the icons above the removed icons
        for j in range(self.BOARD_SIZE[1]):
            column = [self.board[i][j] for i in range(self.BOARD_SIZE[0])]
            column = [icon for icon in column if icon is not None]
            column += [None] * (self.BOARD_SIZE[0] - len(column))
            for i in range(self.BOARD_SIZE[0]):
                self.board[i][j] = column[i]

    def is_game_over(self):
        """"""
        Check if the game is over (i.e., if there are no more icons on the game board)
        :return: True or False ,representing whether the game is over
        """"""
        # Check if there are any icons left on the board
        for row in self.board:
            for icon in row:
                if icon is not None:
                    return False
        
        return True
```",0.15422885572139305,0.18256241653845262,0.6504065040650406,0.3755868544600939,0.47619047154921346,0.45495495495495497,0.2422062350119904,0.31611893130287205,0.6504065040650406,0.3755868544600939,0.47619047154921346
Llama,55,"class Manacher:
    def __init__(self, input_string) -> None:
        self.input_string = input_string

    def palindromic_length(self, center, diff, string):
        if (center - diff == -1 or center + diff == len(string)
                or string[center - diff] != string[center + diff]):
            return 0
        return 1 + self.palindromic_length(center, diff + 1, string)


    def palindromic_string(self):
        max_length = 0

        new_input_string = """"
        output_string = """"

        for i in self.input_string[:len(self.input_string) - 1]:
            new_input_string += i + ""|""
        new_input_string += self.input_string[-1]

        for i in range(len(new_input_string)):

            length =self.palindromic_length(i, 1, new_input_string)

            if max_length < length:
                max_length = length
                start = i

        for i in new_input_string[start - max_length:start + max_length + 1]:
            if i != ""|"":
                output_string += i

        return output_string",FewShot,"

```python
class Manacher:
    """"""
    This is a class that implements a manacher algorithm to find the Longest palindromic substring in a given string.
    """"""

    def __init__(self, input_string) -> None:
        """"""
        Initializes the Manacher class with the given input_string.
        :param input_string: The input_string to be searched, str.
        """"""
        self.input_string = input_string

    # Function to preprocess the input string by inserting a special character between each character
    def preprocess(self, string):
        # Initialize an empty string to store the preprocessed string
        preprocessed_string = """"
        # Iterate over each character in the input string
        for char in string:
            # Append the special character and the current character to the preprocessed string
            preprocessed_string += ""|"" + char
        # Append the special character at the end of the preprocessed string
        preprocessed_string += ""|""
        return preprocessed_string

    # Function to calculate the length of the palindromic substring based on a given center and input string
    def palindromic_length(self, center, string):
        # Initialize the length of the palindromic substring to 0
        length = 0
        # Initialize the left and right pointers
        left = center
        right = center
        # Iterate until the left or right pointer is out of bounds
        while left > 0 and right < len(string) - 1:
            # If the characters at the left and right pointers are equal, increment the length and move the pointers
            if string[left - 1] == string[right + 1]:
                length += 2
                left -= 1
                right += 1
            # If the characters at the left and right pointers are not equal, break the loop
            else:
                break
        return length

    # Function to find the longest palindromic substring in the given string
    def palindromic_string(self):
        # Preprocess the input string
        string = self.preprocess(self.input_string)
        # Initialize the maximum length and center of the longest palindromic substring
        max_length = 0
        center = 0
        # Iterate over each character in the preprocessed string
        for i in range(len(string)):
            # Calculate the length of the palindromic substring based on the current center
            length = self.palindromic_length(i, string)
            # If the length of the current palindromic substring is greater than the maximum length, update the maximum length and center
            if length > max_length:
                max_length = length
                center = i
        # Extract the longest palindromic substring from the preprocessed string
        palindromic_substring = string[center - max_length // 2: center + max_length // 2 + 1]
        # Remove the special characters from the longest palindromic substring
        palindromic_substring = palindromic_substring.replace(""|"", """")
        return palindromic_substring
```",0.02025316455696203,0.030731859266274083,0.6379310344827587,0.26811594202898553,0.37755101624114956,0.21359223300970873,0.07773851590106007,0.1139896333929771,0.5517241379310345,0.2318840579710145,0.32653060807788425
Llama,56,"class MetricsCalculator:
    def __init__(self):
        self.true_positives = 0
        self.false_positives = 0
        self.false_negatives = 0
        self.true_negatives = 0

    def update(self, predicted_labels, true_labels):
        for predicted, true in zip(predicted_labels, true_labels):
            if predicted == 1 and true == 1:
                self.true_positives += 1
            elif predicted == 1 and true == 0:
                self.false_positives += 1
            elif predicted == 0 and true == 1:
                self.false_negatives += 1
            elif predicted == 0 and true == 0:
                self.true_negatives += 1

    def precision(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        if self.true_positives + self.false_positives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_positives)

    def recall(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        if self.true_positives + self.false_negatives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_negatives)

    def f1_score(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        precision = self.precision(predicted_labels, true_labels)
        recall = self.recall(predicted_labels, true_labels)
        if precision + recall == 0.0:
            return 0.0
        return (2 * precision * recall) / (precision + recall)

    def accuracy(self, predicted_labels, true_labels):
        self.update(predicted_labels, true_labels)
        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives
        if total == 0:
            return 0.0
        return (self.true_positives + self.true_negatives) / total",FewShot,"

```python
class MetricsCalculator:
    """"""
    The class calculates precision, recall, F1 score, and accuracy based on predicted and true labels.
    """"""

    def __init__(self):
        """"""
        Initialize the number of all four samples to 0
        """"""
        # Initialize counters for true positives, false positives, false negatives, and true negatives
        self.true_positives = 0
        self.false_positives = 0
        self.false_negatives = 0
        self.true_negatives = 0


    def update(self, predicted_labels, true_labels):
        """"""
        Update the number of all four samples(true_positives, false_positives, false_negatives, true_negatives)
        :param predicted_labels: list, predicted results
        :param true_labels: list, true labels
        :return: None, change the number of corresponding samples
        """"""
        # Iterate over predicted and true labels
        for predicted, true in zip(predicted_labels, true_labels):
            # Check if the predicted label matches the true label
            if predicted == 1 and true == 1:
                # If both are 1, increment true positives
                self.true_positives += 1
            elif predicted == 1 and true == 0:
                # If predicted is 1 and true is 0, increment false positives
                self.false_positives += 1
            elif predicted == 0 and true == 1:
                # If predicted is 0 and true is 1, increment false negatives
                self.false_negatives += 1
            else:
                # If both are 0, increment true negatives
                self.true_negatives += 1


    def precision(self, predicted_labels, true_labels):
        """"""
        Calculate precision
        :param predicted_labels: list, predicted results
        :param true_labels: list, true labels
        :return: float
        """"""
        # Update counters
        self.update(predicted_labels, true_labels)
        # Calculate precision as true positives / (true positives + false positives)
        if self.true_positives + self.false_positives == 0:
            return 0
        return self.true_positives / (self.true_positives + self.false_positives)


    def recall(self, predicted_labels, true_labels):
        """"""
        Calculate recall
        :param predicted_labels: list, predicted results
        :param true_labels: list, true labels
        :return: float
        """"""
        # Update counters
        self.update(predicted_labels, true_labels)
        # Calculate recall as true positives / (true positives + false negatives)
        if self.true_positives + self.false_negatives == 0:
            return 0
        return self.true_positives / (self.true_positives + self.false_negatives)


    def f1_score(self, predicted_labels, true_labels):
        """"""
        Calculate f1 score, which is the harmonic mean of precision and recall
        :param predicted_labels: list, predicted results
        :param true_labels: list, true labels
        :return: float
        """"""
        # Calculate precision and recall
        precision = self.precision(predicted_labels, true_labels)
        recall = self.recall(predicted_labels, true_labels)
        # Calculate f1 score as 2 * (precision * recall) / (precision + recall)
        if precision + recall == 0:
            return 0
        return 2 * (precision * recall) / (precision + recall)


    def accuracy(self, predicted_labels, true_labels):
        """"""
        Calculate accuracy
        :param predicted_labels: list, predicted results
        :param true_labels: list, true labels
        :return: float
        """"""
        # Update counters
        self.update(predicted_labels, true_labels)
        # Calculate accuracy as (true positives + true negatives) / total samples
        total_samples = self.true_positives + self.false_positives + self.false_negatives + self.true_negatives
        if total_samples == 0:
            return 0
        return (self.true_positives + self.true_negatives) / total_samples
```",0.23239436619718312,0.26190122994285114,0.98,0.4224137931034483,0.590361441573523,0.8073394495412844,0.350597609561753,0.48888888466682107,0.98,0.4224137931034483,0.590361441573523
Llama,57,"import numpy as np


class MetricsCalculator2:
    def __init__(self):
        pass

    @staticmethod
    def mrr(data):
        if type(data) != list and type(data) != tuple:
            raise Exception(""the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple"")

        if len(data) == 0:
            return 0.0, [0.0]
        if type(data) == tuple:
            (sub_list, total_num) = data
            sub_list = np.array(sub_list)
            if total_num == 0:
                return 0.0, [0.0]
            else:
                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                mr_np = sub_list * ranking_array

                mr = 0.0
                for team in mr_np:
                    if team > 0:
                        mr = team
                        break
                return mr, [mr]

        if type(data) == list:
            separate_result = []
            for (sub_list, total_num) in data:
                sub_list = np.array(sub_list)

                if total_num == 0:
                    mr = 0.0
                else:
                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                    mr_np = sub_list * ranking_array

                    mr = 0.0
                    for team in mr_np:
                        if team > 0:
                            mr = team
                            break

                separate_result.append(mr)
            return np.mean(separate_result), separate_result

    @staticmethod
    def map(data):
        if type(data) != list and type(data) != tuple:
            raise Exception(""the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple"")

        if len(data) == 0:
            return 0.0, [0.0]
        if type(data) == tuple:
            (sub_list, total_num) = data
            sub_list = np.array(sub_list)
            if total_num == 0:
                return 0.0, [0.0]
            else:
                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)

                right_ranking_list = []
                count = 1
                for t in sub_list:
                    if t == 0:
                        right_ranking_list.append(0)
                    else:
                        right_ranking_list.append(count)
                        count += 1

                ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num
                return ap, [ap]

        if type(data) == list:
            separate_result = []
            for (sub_list, total_num) in data:
                sub_list = np.array(sub_list)

                if total_num == 0:
                    ap = 0.0
                else:
                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)

                    right_ranking_list = []
                    count = 1
                    for t in sub_list:
                        if t == 0:
                            right_ranking_list.append(0)
                        else:
                            right_ranking_list.append(count)
                            count += 1

                    ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num

                separate_result.append(ap)
            return np.mean(separate_result), separate_result",FewShot,"

```python
import numpy as np


class MetricsCalculator2:
    """"""
    The class provides to calculate Mean Reciprocal Rank (MRR) and Mean Average Precision (MAP) based on input data, 
    where MRR measures the ranking quality and MAP measures the average precision.
    """"""

    def __init__(self):
        pass

    @staticmethod
    def mrr(data):
        # Check if input data is a tuple or a list of tuples
        if isinstance(data, tuple):
            # Calculate MRR for a single tuple
            actual_result, ground_truth_num = data
            # Find the index of the first correct answer
            correct_answer_index = np.where(np.array(actual_result) == 1)[0]
            if len(correct_answer_index) > 0:
                # Calculate MRR
                mrr_value = 1 / (correct_answer_index[0] + 1)
            else:
                # If no correct answer is found, set MRR to 0
                mrr_value = 0
            return mrr_value, [mrr_value]
        elif isinstance(data, list):
            # Calculate MRR for a list of tuples
            mrr_values = []
            for item in data:
                mrr_value, _ = MetricsCalculator2.mrr(item)
                mrr_values.append(mrr_value)
            # Calculate average MRR
            average_mrr = np.mean(mrr_values)
            return average_mrr, mrr_values
        else:
            # Raise an error if input data is not a tuple or a list of tuples
            raise ValueError(""Invalid input data"")

    @staticmethod
    def map(data):
        # Check if input data is a tuple or a list of tuples
        if isinstance(data, tuple):
            # Calculate MAP for a single tuple
            actual_result, ground_truth_num = data
            # Calculate precision at each position
            precision_values = []
            correct_answers = 0
            for i, result in enumerate(actual_result):
                if result == 1:
                    correct_answers += 1
                    precision_values.append(correct_answers / (i + 1))
            # Calculate average precision
            if len(precision_values) > 0:
                map_value = np.mean(precision_values)
            else:
                # If no correct answer is found, set MAP to 0
                map_value = 0
            return map_value, [map_value]
        elif isinstance(data, list):
            # Calculate MAP for a list of tuples
            map_values = []
            for item in data:
                map_value, _ = MetricsCalculator2.map(item)
                map_values.append(map_value)
            # Calculate average MAP
            average_map = np.mean(map_values)
            return average_map, map_values
        else:
            # Raise an error if input data is not a tuple or a list of tuples
            raise ValueError(""Invalid input data"")
```",0.03514376996805112,0.06677662230252086,0.43529411764705883,0.2803030303030303,0.3410138201193485,0.16551724137931034,0.11214953271028037,0.13370473056075,0.43529411764705883,0.2803030303030303,0.3410138201193485
Llama,58,"import random

class MinesweeperGame:
    def __init__(self, n, k) -> None:
        self.n = n
        self.k = k
        self.minesweeper_map = self.generate_mine_sweeper_map()
        self.player_map = self.generate_playerMap()
        self.score = 0

    def generate_mine_sweeper_map(self):
        arr = [[0 for row in range(self.n)] for column in range(self.n)]
        for num in range(self.k):
            x = random.randint(0, self.n-1)
            y = random.randint(0, self.n-1)
            arr[y][x] = 'X'
            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-1):
                if arr[y][x+1] != 'X':
                    arr[y][x+1] += 1
            if (x >=1 and x <= self.n-1) and (y >= 0 and y <= self.n-1):
                if arr[y][x-1] != 'X':
                    arr[y][x-1] += 1
            if (x >= 1 and x <= self.n-1) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x-1] != 'X':
                    arr[y-1][x-1] += 1
    
            if (x >= 0 and x <= self.n-2) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x+1] != 'X':
                    arr[y-1][x+1] += 1 
            if (x >= 0 and x <= self.n-1) and (y >= 1 and y <= self.n-1):
                if arr[y-1][x] != 'X':
                    arr[y-1][x] += 1
    
            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x+1] != 'X':
                    arr[y+1][x+1] += 1
            if (x >= 1 and x <= self.n-1) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x-1] != 'X':
                    arr[y+1][x-1] += 1
            if (x >= 0 and x <= self.n-1) and (y >= 0 and y <= self.n-2):
                if arr[y+1][x] != 'X':
                    arr[y+1][x] += 1
        return arr
    
    def generate_playerMap(self):
        arr = [['-' for row in range(self.n)] for column in range(self.n)]
        return arr

    def check_won(self, map):
        for i in range(self.n):
            for j in range(self.n):
                if map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':
                    return False
        return True
    
    def sweep(self, x, y):

        if (self.minesweeper_map[x][y] == 'X'):
            return False
        else:
            self.player_map[x][y] = self.minesweeper_map[x][y]
            self.score += 1
            if self.check_won(self.player_map) == True:
                return True
            return self.player_map",FewShot,"

```python
import random

class MinesweeperGame:
    """"""
    This is a class that implements mine sweeping games including minesweeping and winning judgment.
    """"""

    def __init__(self, n, k) -> None:
        """"""
        Initializes the MinesweeperGame class with the size of the board and the number of mines.
        :param n: The size of the board, int.
        :param k: The number of mines, int.
        """"""
        self.n = n
        self.k = k
        self.minesweeper_map = self.generate_mine_sweeper_map()
        self.player_map = self.generate_playerMap()
        self.score = 0

    def generate_mine_sweeper_map(self):
        # Initialize an empty board
        board = [[0 for _ in range(self.n)] for _ in range(self.n)]
        
        # Randomly place mines on the board
        mines = set()
        while len(mines) < self.k:
            x, y = random.randint(0, self.n-1), random.randint(0, self.n-1)
            if (x, y) not in mines:
                board[x][y] = 'X'
                mines.add((x, y))
        
        # Calculate the number of mines around each cell
        for i in range(self.n):
            for j in range(self.n):
                if board[i][j] != 'X':
                    count = 0
                    for x in range(max(0, i-1), min(self.n, i+2)):
                        for y in range(max(0, j-1), min(self.n, j+2)):
                            if board[x][y] == 'X':
                                count += 1
                    board[i][j] = count
        
        return board

    def generate_playerMap(self):
        # Initialize a player map with all cells marked as unknown
        return [['-' for _ in range(self.n)] for _ in range(self.n)]

    def check_won(self, map):
        # Check if all non-mine cells have been revealed
        for i in range(self.n):
            for j in range(self.n):
                if self.minesweeper_map[i][j] != 'X' and map[i][j] == '-':
                    return False
        return True

    def sweep(self, x, y):
        # Check if the cell is a mine
        if self.minesweeper_map[x][y] == 'X':
            self.player_map[x][y] = 'X'
            return False
        
        # Reveal the cell
        self.player_map[x][y] = self.minesweeper_map[x][y]
        
        # Recursively reveal adjacent cells if the current cell has no adjacent mines
        if self.minesweeper_map[x][y] == 0:
            for i in range(max(0, x-1), min(self.n, x+2)):
                for j in range(max(0, y-1), min(self.n, y+2)):
                    if self.player_map[i][j] == '-':
                        self.sweep(i, j)
        
        # Check if the game is won
        if self.check_won(self.player_map):
            return True
        
        return self.player_map
```",0.13725490196078435,0.18074564672739513,0.6588235294117647,0.37333333333333335,0.4765957400633772,0.42105263157894735,0.26666666666666666,0.32653060749687635,0.6588235294117647,0.37333333333333335,0.4765957400633772
Llama,59,"from datetime import datetime
import numpy as np

class MovieBookingSystem:
    def __init__(self):
        self.movies = []

    def add_movie(self, name, price, start_time, end_time, n):
        movie = {
            'name': name,
            'price': price,
            'start_time': datetime.strptime(start_time, '%H:%M'),
            'end_time': datetime.strptime(end_time, '%H:%M'),
            'seats': np.zeros((n, n))
        }
        self.movies.append(movie)

    def book_ticket(self, name, seats_to_book):
        for movie in self.movies:
            if movie['name'] == name:
                for seat in seats_to_book:
                    if movie['seats'][seat[0]][seat[1]] == 0:
                        movie['seats'][seat[0]][seat[1]] = 1
                    else:
                        return ""Booking failed.""
                return ""Booking success.""
        return ""Movie not found.""


    def available_movies(self, start_time, end_time):
        start_time = datetime.strptime(start_time, '%H:%M')
        end_time = datetime.strptime(end_time, '%H:%M')

        available_movies = []
        for movie in self.movies:
            if start_time <= movie['start_time'] and movie['end_time'] <= end_time:
                available_movies.append(movie['name'])

        return available_movies",FewShot,"

```python
from datetime import datetime
import numpy as np

class MovieBookingSystem:
    """"""
    this is a class as movie booking system, which allows to add movies, book tickets and check the available movies within a given time range. 
    """"""

    def __init__(self):
        """"""
        Initialize movies contains the information about movies
        >>> system.movies
        [{'name': 'Batman', 'price': 49.9, 'start_time': datetime.datetime(1900, 1, 1, 17, 5), 'end_time': datetime.datetime(1900, 1, 1, 19, 25),
        'seats': array([[0., 0., 0.],
            [0., 0., 0.],
            [0., 0., 0.]])}]
        """"""
        self.movies = []

    def add_movie(self, name, price, start_time, end_time, n):
        """"""
        Add a new movie into self.movies
        :param name: str, movie name
        :param price: float, price for one ticket
        :param start_time: str
        :param end_time: str
        :param n: int, the size of seats(n*n)
        >>> system.add_movie('Batman', 49.9, '17:05', '19:25', 3)
        >>> system.movies
        [{'name': 'Batman', 'price': 49.9, 'start_time': datetime.datetime(1900, 1, 1, 17, 5), 'end_time': datetime.datetime(1900, 1, 1, 19, 25),
        'seats': array([[0., 0., 0.],
            [0., 0., 0.],
            [0., 0., 0.]])}]
        """"""
        # Convert time strings to datetime objects
        start_time = datetime.strptime(start_time, '%H:%M')
        start_time = start_time.replace(year=1900, month=1, day=1)
        end_time = datetime.strptime(end_time, '%H:%M')
        end_time = end_time.replace(year=1900, month=1, day=1)
        
        # Create a new movie dictionary
        movie = {
            'name': name,
            'price': price,
            'start_time': start_time,
            'end_time': end_time,
            'seats': np.zeros((n, n))  # Initialize seats as a 2D numpy array
        }
        
        # Add the movie to the list
        self.movies.append(movie)

    def book_ticket(self, name, seats_to_book):
        """"""
        Book tickets for a movie. Change the seats value in self.movies if book successfully.
        :param name: str, movie name
        :param seats_to_book: list of tuples, representing seats to book [(row1, col1), (row2, col2), ...]
        :return: str, booking status message. ""Movie not found."" for no such movie.
                ""Booking success."" for successfully booking, or ""Booking failed."" otherwise
        >>> system.add_movie('Batman', 49.9, '17:05', '19:25', 3)
        >>> system.book_ticket('Batman', [(0, 0), (0, 1)])
        'Booking success.'
        >>> system.book_ticket('Batman', [(0, 0)])
        'Booking failed.'
        >>> system.book_ticket('batman', [(0, 0)])
        'Movie not found.'
        """"""
        # Find the movie
        movie = next((m for m in self.movies if m['name'] == name), None)
        
        # Check if movie exists
        if movie is None:
            return ""Movie not found.""
        
        # Check if seats are available
        for seat in seats_to_book:
            if movie['seats'][seat[0], seat[1]] == 1:
                return ""Booking failed.""
        
        # Book the seats
        for seat in seats_to_book:
            movie['seats'][seat[0], seat[1]] = 1
        
        return ""Booking success.""

    def available_movies(self, start_time, end_time):
        """"""
        Get a list of available movies within the specified time range
        :param start_time: str, start time in HH:MM format
        :param end_time: str, end time in HH:MM format
        :return: list of str, names of available movies
        >>> system.add_movie('Batman', 49.9, '17:05', '19:25', 3)
        >>> system.available_movies('12:00', '22:00')
        ['Batman']
        """"""
        # Convert time strings to datetime objects
        start_time = datetime.strptime(start_time, '%H:%M')
        start_time = start_time.replace(year=1900, month=1, day=1)
        end_time = datetime.strptime(end_time, '%H:%M')
        end_time = end_time.replace(year=1900, month=1, day=1)
        
        # Find available movies
        available_movies = [m['name'] for m in self.movies if start_time < m['end_time'] and end_time > m['start_time']]
        
        return available_movies
```",0.08676789587852493,0.10483389540075383,0.855072463768116,0.30256410256410254,0.4469696931086433,0.6346153846153846,0.18803418803418803,0.2901098865833595,0.855072463768116,0.30256410256410254,0.4469696931086433
Llama,60,"import sqlite3


class MovieTicketDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()
        self.create_table()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS tickets (
                id INTEGER PRIMARY KEY,
                movie_name TEXT,
                theater_name TEXT,
                seat_number TEXT,
                customer_name TEXT
            )
        ''')
        self.connection.commit()

    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):
        self.cursor.execute('''
            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)
            VALUES (?, ?, ?, ?)
        ''', (movie_name, theater_name, seat_number, customer_name))
        self.connection.commit()

    def search_tickets_by_customer(self, customer_name):
        self.cursor.execute('''
            SELECT * FROM tickets WHERE customer_name = ?
        ''', (customer_name,))
        tickets = self.cursor.fetchall()
        return tickets

    def delete_ticket(self, ticket_id):
        self.cursor.execute('''
            DELETE FROM tickets WHERE id = ?
        ''', (ticket_id,))
        self.connection.commit()",FewShot,"

```python
class MovieTicketDB:
    """"""
    This is a class for movie database operations, which allows for inserting movie information, searching for movie information by name, and deleting movie information by name.
    """"""

    def __init__(self, db_name):
        """"""
        Initializes the MovieTicketDB object with the specified database name.
        :param db_name: str, the name of the SQLite database.
        """"""
        # Connect to the SQLite database
        self.connection = sqlite3.connect(db_name)
        # Create a cursor object
        self.cursor = self.connection.cursor()
        # Create the ""tickets"" table if it does not exist
        self.create_table()


    def create_table(self):
        """"""
        Creates a ""tickets"" table in the database if it does not exist already.Fields include ID of type int, movie name of type str, theater name of type str, seat number of type str, and customer name of type str
        :return: None
        """"""
        # SQL query to create the ""tickets"" table
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS tickets
            (id INTEGER PRIMARY KEY AUTOINCREMENT, 
             movie_name TEXT, 
             theater_name TEXT, 
             seat_number TEXT, 
             customer_name TEXT)
        ''')
        # Commit the changes
        self.connection.commit()


    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):
        """"""
        Inserts a new ticket into the ""tickets"" table.
        :param movie_name: str, the name of the movie.
        :param theater_name: str, the name of the theater.
        :param seat_number: str, the seat number.
        :param customer_name: str, the name of the customer.
        :return: None
        """"""
        # SQL query to insert a new ticket
        self.cursor.execute('''
            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)
            VALUES (?, ?, ?, ?)
        ''', (movie_name, theater_name, seat_number, customer_name))
        # Commit the changes
        self.connection.commit()


    def search_tickets_by_customer(self, customer_name):
        """"""
        Searches for tickets in the ""tickets"" table by customer name.
        :param customer_name: str, the name of the customer to search for.
        :return: list of tuples, the rows from the ""tickets"" table that match the search criteria.
        """"""
        # SQL query to search for tickets by customer name
        self.cursor.execute('''
            SELECT * FROM tickets
            WHERE customer_name = ?
        ''', (customer_name,))
        # Fetch all the rows that match the search criteria
        return self.cursor.fetchall()


    def delete_ticket(self, ticket_id):
        """"""
        Deletes a ticket from the ""tickets"" table by ticket ID.
        :param ticket_id: int, the ID of the ticket to delete.
        :return: None
        """"""
        # SQL query to delete a ticket by ID
        self.cursor.execute('''
            DELETE FROM tickets
            WHERE id = ?
        ''', (ticket_id,))
        # Commit the changes
        self.connection.commit()
```",0.1510989010989011,0.16936437780054528,0.921875,0.3959731543624161,0.5539906061248872,0.7340425531914894,0.2574626865671642,0.38121546576844423,0.90625,0.38926174496644295,0.5446009347633847
Llama,61,"class MusicPlayer:
    def __init__(self):
        self.playlist = []
        self.current_song = None
        self.volume = 50

    def add_song(self, song):
        self.playlist.append(song)

    def remove_song(self, song):
        if song in self.playlist:
            self.playlist.remove(song)
            if self.current_song == song:
                self.stop()

    def play(self):
        if self.playlist and self.current_song:
            return self.playlist[0]
        elif len(self.playlist): 
            return False

    def stop(self):
        if self.current_song:
            self.current_song = None
            return True
        else:
            return False

    def switch_song(self):
        if self.current_song:
            current_index = self.playlist.index(self.current_song)
            if current_index < len(self.playlist) - 1:
                self.current_song = self.playlist[current_index + 1]
                return True
            else:
                return False
        else:
            return False

    def previous_song(self):
        if self.current_song:
            current_index = self.playlist.index(self.current_song)
            if current_index > 0:
                self.current_song = self.playlist[current_index - 1]
                return True
            else:
                return False
        else:
            return False

    def set_volume(self, volume):
        if 0 <= volume <= 100:
            self.volume = volume
        else:
            return False

    def shuffle(self):
        if self.playlist:
            import random
            random.shuffle(self.playlist)
            return True
        else:
            return False",FewShot,"

```python
class MusicPlayer:
    """"""
    This is a class as a music player that provides to play, stop, add songs, remove songs, set volume, shuffle, and switch to the next or previous song.
    """"""

    def __init__(self):
        """"""
        Initializes the music player with an empty playlist, no current song, and a default volume of 50.
        """"""
        self.playlist = []
        self.current_song = None
        self.volume = 50

    # Add a song to the playlist
    def add_song(self, song):
        """"""
        Adds a song to the playlist.
        :param song: The song to add to the playlist, str.
        """"""
        # Check if the song is already in the playlist
        if song not in self.playlist:
            # Add the song to the playlist
            self.playlist.append(song)
        # If the playlist was empty, set the current song to the newly added song
        if len(self.playlist) == 1:
            self.current_song = self.playlist[0]

    # Remove a song from the playlist
    def remove_song(self, song):
        """"""
        Removes a song from the playlist.
        :param song: The song to remove from the playlist, str.
        """"""
        # Check if the song is in the playlist
        if song in self.playlist:
            # Remove the song from the playlist
            self.playlist.remove(song)
            # If the removed song was the current song, update the current song
            if self.current_song == song:
                # If the playlist is not empty, set the current song to the first song
                if self.playlist:
                    self.current_song = self.playlist[0]
                # If the playlist is empty, set the current song to None
                else:
                    self.current_song = None

    # Play the current song in the playlist
    def play(self):
        """"""
        Plays the current song in the playlist.
        :return: The current song in the playlist, or False if there is no current song.
        """"""
        # Check if there is a current song
        if self.current_song:
            # Return the current song
            return self.current_song
        # If there is no current song, return False
        else:
            return False

    # Stop the current song in the playlist
    def stop(self):
        """"""
        Stops the current song in the playlist.
        :return: True if the current song was stopped, False if there was no current song.
        """"""
        # Check if there is a current song
        if self.current_song:
            # Set the current song to None
            self.current_song = None
            # Return True
            return True
        # If there is no current song, return False
        else:
            return False

    # Switch to the next song in the playlist
    def switch_song(self):
        """"""
        Switches to the next song in the playlist.
        :return: True if the next song was switched to, False if there was no next song.
        """"""
        # Check if there is a current song
        if self.current_song:
            # Get the index of the current song in the playlist
            current_index = self.playlist.index(self.current_song)
            # Check if there is a next song
            if current_index < len(self.playlist) - 1:
                # Set the current song to the next song
                self.current_song = self.playlist[current_index + 1]
                # Return True
                return True
            # If there is no next song, return False
            else:
                return False
        # If there is no current song, return False
        else:
            return False

    # Switch to the previous song in the playlist
    def previous_song(self):
        """"""
        Switches to the previous song in the playlist.
        :return: True if the previous song was switched to, False if there was no previous song.
        """"""
        # Check if there is a current song
        if self.current_song:
            # Get the index of the current song in the playlist
            current_index = self.playlist.index(self.current_song)
            # Check if there is a previous song
            if current_index > 0:
                # Set the current song to the previous song
                self.current_song = self.playlist[current_index - 1]
                # Return True
                return True
            # If there is no previous song, return False
            else:
                return False
        # If there is no current song, return False
        else:
            return False

    # Set the volume of the music player
    def set_volume(self, volume):
        """"""
        Sets the volume of the music player,ifthe volume is between 0 and 100 is valid.
        :param volume: The volume to set the music player to,int.
        :return: True if the volume was set, False if the volume was invalid.
        """"""
        # Check if the volume is between 0 and 100
        if 0 <= volume <= 100:
            # Set the volume
            self.volume = volume
            # Return True
            return True
        # If the volume is invalid, return False
        else:
            return False

    # Shuffle the playlist
    def shuffle(self):
        """"""
        Shuffles the playlist.
        :return: True if the playlist was shuffled, False if the playlist was empty.
        """"""
        # Check if the playlist is not empty
        if self.playlist:
            # Shuffle the playlist
            import random
            random.shuffle(self.playlist)
            # Set the current song to the first song in the shuffled playlist
            self.current_song = self.playlist[0]
            # Return True
            return True
        # If the playlist is empty, return False
        else:
            return False
```",0.06119791666666668,0.0758287266193026,0.9491525423728814,0.4,0.5628140661801471,0.6634615384615384,0.21835443037974683,0.3285714248453515,0.9491525423728814,0.4,0.5628140661801471
Llama,62,"class NLPDataProcessor:

    def construct_stop_word_list(self):
        stop_word_list = ['a', 'an', 'the']
        return stop_word_list

    def remove_stop_words(self, string_list, stop_word_list):
        answer = []
        for string in string_list:
            string_split = string.split()
            for word in string_split:
                if word in stop_word_list:
                    string_split.remove(word)
            answer.append(string_split)
        return answer

    def process(self, string_list):
        stop_word_list = self.construct_stop_word_list()
        words_list = self.remove_stop_words(string_list, stop_word_list)
        return words_list",FewShot,"

```python
class NLPDataProcessor:
    """"""
    The class processes NLP data by removing stop words from a list of strings using a pre-defined stop word list.
    """"""

    def construct_stop_word_list(self):
        # Construct a stop word list including 'a', 'an', 'the'
        return ['a', 'an', 'the']

    def remove_stop_words(self, string_list, stop_word_list):
        # Remove all the stop words from the list of strings
        processed_list = []
        for string in string_list:
            # Split the string into words
            words = string.split()
            # Filter out stop words
            filtered_words = [word for word in words if word.lower() not in stop_word_list]
            # Join the filtered words back into a string
            processed_string = ' '.join(filtered_words)
            # Split the processed string into words and add to the list
            processed_list.append(processed_string.split())
        return processed_list

    def process(self, string_list):
        # Construct a stop word list including 'a', 'an', 'the'
        stop_word_list = self.construct_stop_word_list()
        # Remove all the stop words from the list of strings
        return self.remove_stop_words(string_list, stop_word_list)
```",0.0684931506849315,0.09013499082504829,0.7941176470588235,0.36,0.4954128397441293,0.48,0.1951219512195122,0.2774566432891176,0.7941176470588235,0.36,0.4954128397441293
Llama,63,"from collections import Counter
import re

class NLPDataProcessor2:

    def process_data(self, string_list):
        words_list = []
        for string in string_list:
            # Remove non-English letters and convert to lowercase
            processed_string = re.sub(r'[^a-zA-Z\s]', '', string.lower())
            # Split the string into words
            words = processed_string.split()
            words_list.append(words)
        return words_list

    def calculate_word_frequency(self, words_list):
        word_frequency = Counter()
        for words in words_list:
            word_frequency.update(words)
        sorted_word_frequency = dict(sorted(word_frequency.items(), key=lambda x: x[1], reverse=True))
        top_5_word_frequency = dict(list(sorted_word_frequency.items())[:5])
        return top_5_word_frequency

    def process(self, string_list):
        words_list = self.process_data(string_list)
        word_frequency_dict = self.calculate_word_frequency(words_list)
        return word_frequency_dict",FewShot,"

```python
import re
from collections import Counter

class NLPDataProcessor2:
    """"""
    The class processes NLP data by extracting words from a list of strings, calculating the frequency of each word, and returning the top 5 most frequent words.
    """"""

    # Method to process the data by removing non-English characters, converting to lower case, and splitting into words
    def process_data(self, string_list):
        # Initialize an empty list to store the processed words
        words_list = []
        # Iterate over each string in the input list
        for string in string_list:
            # Remove non-English characters and convert to lower case
            cleaned_string = re.sub(r'[^a-zA-Z\s]', '', string).lower()
            # Split the string into words and add to the list
            words_list.append(cleaned_string.split())
        return words_list

    # Method to calculate the word frequency of each word in the list of words
    def calculate_word_frequency(self, words_list):
        # Flatten the list of words lists into a single list of words
        flat_words_list = [word for sublist in words_list for word in sublist]
        # Calculate the word frequency using Counter
        word_frequency = Counter(flat_words_list)
        # Sort the word frequency dictionary by value in descending order and return the top 5
        return dict(sorted(word_frequency.items(), key=lambda item: item[1], reverse=True)[:5])

    # Method to process the data and calculate the word frequency
    def process(self, string_list):
        # Process the data using the process_data method
        words_list = self.process_data(string_list)
        # Calculate the word frequency using the calculate_word_frequency method
        word_frequency = self.calculate_word_frequency(words_list)
        return word_frequency
```",0.08444444444444446,0.10406517377945365,0.7017543859649122,0.36363636363636365,0.47904191167126825,0.45121951219512196,0.19473684210526315,0.2720588193176904,0.7017543859649122,0.36363636363636365,0.47904191167126825
Llama,64,"class NumberConverter:
    @staticmethod
    def decimal_to_binary(decimal_num):
        binary_num = bin(decimal_num)[2:]
        return binary_num

    @staticmethod
    def binary_to_decimal(binary_num):
        decimal_num = int(binary_num, 2)
        return decimal_num

    @staticmethod
    def decimal_to_octal(decimal_num):
        octal_num = oct(decimal_num)[2:]
        return octal_num

    @staticmethod
    def octal_to_decimal(octal_num):
        decimal_num = int(octal_num, 8)
        return decimal_num

    @staticmethod
    def decimal_to_hex(decimal_num):
        hex_num = hex(decimal_num)[2:]
        return hex_num

    @staticmethod
    def hex_to_decimal(hex_num):
        decimal_num = int(hex_num, 16)
        return decimal_num",FewShot,"

```python
class NumberConverter:
    """"""
    The class allows to convert decimal to binary, octal and hexadecimal respectively and contrarily
    """"""

    @staticmethod
    def decimal_to_binary(decimal_num):
        # Convert a number from decimal format to binary format using built-in bin() function
        # The bin() function returns a string that starts with '0b' to indicate it's a binary number, so we slice the string to remove the first two characters
        return bin(decimal_num)[2:]

    @staticmethod
    def binary_to_decimal(binary_num):
        # Convert a number from binary format to decimal format using built-in int() function with base 2
        return int(binary_num, 2)

    @staticmethod
    def decimal_to_octal(decimal_num):
        # Convert a number from decimal format to octal format using built-in oct() function
        # The oct() function returns a string that starts with '0o' to indicate it's an octal number, so we slice the string to remove the first two characters
        return oct(decimal_num)[2:]

    @staticmethod
    def octal_to_decimal(octal_num):
        # Convert a number from octal format to decimal format using built-in int() function with base 8
        return int(octal_num, 8)

    @staticmethod
    def decimal_to_hex(decimal_num):
        # Convert a number from decimal format to hex format using built-in hex() function
        # The hex() function returns a string that starts with '0x' to indicate it's a hex number, so we slice the string to remove the first two characters
        return hex(decimal_num)[2:]

    @staticmethod
    def hex_to_decimal(hex_num):
        # Convert a number from hex format to decimal format using built-in int() function with base 16
        return int(hex_num, 16)
```",0.026315789473684213,0.1293332758974884,0.8,0.273972602739726,0.40816326150562265,0.2619047619047619,0.09090909090909091,0.13496932132786343,0.68,0.2328767123287671,0.34693877170970433
Llama,65,"class NumberWordFormatter:
    def __init__(self):
        self.NUMBER = ["""", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""]
        self.NUMBER_TEEN = [""TEN"", ""ELEVEN"", ""TWELVE"", ""THIRTEEN"", ""FOURTEEN"", ""FIFTEEN"", ""SIXTEEN"", ""SEVENTEEN"",
                            ""EIGHTEEN"",
                            ""NINETEEN""]
        self.NUMBER_TEN = [""TEN"", ""TWENTY"", ""THIRTY"", ""FORTY"", ""FIFTY"", ""SIXTY"", ""SEVENTY"", ""EIGHTY"", ""NINETY""]
        self.NUMBER_MORE = ["""", ""THOUSAND"", ""MILLION"", ""BILLION""]
        self.NUMBER_SUFFIX = [""k"", ""w"", """", ""m"", """", """", ""b"", """", """", ""t"", """", """", ""p"", """", """", ""e""]

    def format(self, x):
        if x is not None:
            return self.format_string(str(x))
        else:
            return """"

    def format_string(self, x):
        lstr, rstr = (x.split('.') + [''])[:2]
        lstrrev = lstr[::-1]
        a = [''] * 5

        if len(lstrrev) % 3 == 1:
            lstrrev += ""00""
        elif len(lstrrev) % 3 == 2:
            lstrrev += ""0""

        lm = """"
        for i in range(len(lstrrev) // 3):
            a[i] = lstrrev[3 * i:3 * i + 3][::-1]
            if a[i] != ""000"":
                lm = self.trans_three(a[i]) + "" "" + self.parse_more(i) + "" "" + lm
            else:
                lm += self.trans_three(a[i])

        xs = f""AND CENTS {self.trans_two(rstr)} "" if rstr else """"
        if not lm.strip():
            return ""ZERO ONLY""
        else:
            return f""{lm.strip()} {xs}ONLY""

    def trans_two(self, s):
        s = s.zfill(2)
        if s[0] == ""0"":
            return self.NUMBER[int(s[-1])]
        elif s[0] == ""1"":
            return self.NUMBER_TEEN[int(s) - 10]
        elif s[1] == ""0"":
            return self.NUMBER_TEN[int(s[0]) - 1]
        else:
            return self.NUMBER_TEN[int(s[0]) - 1] + "" "" + self.NUMBER[int(s[-1])]

    def trans_three(self, s):
        if s[0] == ""0"":
            return self.trans_two(s[1:])
        elif s[1:] == ""00"":
            return f""{self.NUMBER[int(s[0])]} HUNDRED""
        else:
            return f""{self.NUMBER[int(s[0])]} HUNDRED AND {self.trans_two(s[1:])}""

    def parse_more(self, i):
        return self.NUMBER_MORE[i]",FewShot,"

```python
class NumberWordFormatter:
    """"""
    This is a class that provides to convert numbers into their corresponding English word representation, 
    including handling the conversion of both the integer and decimal parts, and incorporating appropriate connectors and units.
    """"""

    def __init__(self):
        """"""
        Initialize NumberWordFormatter object.
        """"""
        self.NUMBER = ["""", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""]
        self.NUMBER_TEEN = [""TEN"", ""ELEVEN"", ""TWELVE"", ""THIRTEEN"", ""FOURTEEN"", ""FIFTEEN"", ""SIXTEEN"", ""SEVENTEEN"",
                            ""EIGHTEEN"",
                            ""NINETEEN""]
        self.NUMBER_TEN = [""TEN"", ""TWENTY"", ""THIRTY"", ""FORTY"", ""FIFTY"", ""SIXTY"", ""SEVENTY"", ""EIGHTY"", ""NINETY""]
        self.NUMBER_MORE = ["""", ""THOUSAND"", ""MILLION"", ""BILLION""]
        self.NUMBER_SUFFIX = [""k"", ""w"", """", ""m"", """", """", ""b"", """", """", ""t"", """", """", ""p"", """", """", ""e""]

    def format(self, x):
        # Convert the number into a string to handle both integer and decimal parts
        x_str = str(x)
        
        # Check if the number has a decimal part
        if '.' in x_str:
            # Split the number into integer and decimal parts
            integer_part, decimal_part = x_str.split('.')
            
            # Convert the integer part into words
            integer_words = self.format_string(integer_part)
            
            # Convert the decimal part into words
            decimal_words = self.format_string(decimal_part)
            
            # Combine the integer and decimal parts into a single string
            return f""{integer_words} POINT {decimal_words}""
        else:
            # Convert the integer part into words
            return self.format_string(x_str)

    def format_string(self, x):
        # Convert the string representation of the number into an integer
        x_int = int(x)
        
        # Check if the number is less than 10
        if x_int < 10:
            # Return the word representation of the number
            return self.NUMBER[x_int]
        # Check if the number is between 10 and 19
        elif x_int < 20:
            # Return the word representation of the number
            return self.NUMBER_TEEN[x_int - 10]
        # Check if the number is between 20 and 99
        elif x_int < 100:
            # Get the tens digit
            tens_digit = x_int // 10
            
            # Get the ones digit
            ones_digit = x_int % 10
            
            # Return the word representation of the number
            if ones_digit == 0:
                return self.NUMBER_TEN[tens_digit - 1]
            else:
                return f""{self.NUMBER_TEN[tens_digit - 1]} {self.NUMBER[ones_digit]}""
        # Check if the number is between 100 and 999
        elif x_int < 1000:
            # Get the hundreds digit
            hundreds_digit = x_int // 100
            
            # Get the remaining digits
            remaining_digits = x_int % 100
            
            # Return the word representation of the number
            if remaining_digits == 0:
                return f""{self.NUMBER[hundreds_digit]} HUNDRED""
            else:
                return f""{self.NUMBER[hundreds_digit]} HUNDRED AND {self.trans_two(str(remaining_digits))}""
        # Check if the number is 1000 or more
        else:
            # Initialize the result string
            result = """"
            
            # Initialize the index
            i = 0
            
            # Loop through the number from right to left
            while x_int > 0:
                # Get the current three digits
                current_three_digits = x_int % 1000
                
                # If the current three digits are not zero, add them to the result string
                if current_three_digits != 0:
                    # Add the word representation of the current three digits to the result string
                    result = f""{self.trans_three(str(current_three_digits))} {self.parse_more(i)} {result}""
                
                # Move to the next three digits
                x_int //= 1000
                
                # Increment the index
                i += 1
            
            # Remove any trailing spaces from the result string
            result = result.strip()
            
            # Add "" ONLY"" to the end of the result string
            result += "" ONLY""
            
            # Return the result string
            return result

    def trans_two(self, s):
        # Convert the two-digit number into an integer
        s_int = int(s)
        
        # Check if the number is less than 10
        if s_int < 10:
            # Return the word representation of the number
            return self.NUMBER[s_int]
        # Check if the number is between 10 and 19
        elif s_int < 20:
            # Return the word representation of the number
            return self.NUMBER_TEEN[s_int - 10]
        # Check if the number is between 20 and 99
        else:
            # Get the tens digit
            tens_digit = s_int // 10
            
            # Get the ones digit
            ones_digit = s_int % 10
            
            # Return the word representation of the number
            if ones_digit == 0:
                return self.NUMBER_TEN[tens_digit - 1]
            else:
                return f""{self.NUMBER_TEN[tens_digit - 1]} {self.NUMBER[ones_digit]}""

    def trans_three(self, s):
        # Convert the three-digit number into an integer
        s_int = int(s)
        
        # Check if the number is less than 10
        if s_int < 10:
            # Return the word representation of the number
            return self.NUMBER[s_int]
        # Check if the number is between 10 and 19
        elif s_int < 20:
            # Return the word representation of the number
            return self.NUMBER_TEEN[s_int - 10]
        # Check if the number is between 20 and 99
        elif s_int < 100:
            # Get the tens digit
            tens_digit = s_int // 10
            
            # Get the ones digit
            ones_digit = s_int % 10
            
            # Return the word representation of the number
            if ones_digit == 0:
                return self.NUMBER_TEN[tens_digit - 1]
            else:
                return f""{self.NUMBER_TEN[tens_digit - 1]} {self.NUMBER[ones_digit]}""
        # Check if the number is between 100 and 999
        else:
            # Get the hundreds digit
            hundreds_digit = s_int // 100
            
            # Get the remaining digits
            remaining_digits = s_int % 100
            
            # Return the word representation of the number
            if remaining_digits == 0:
                return f""{self.NUMBER[hundreds_digit]} HUNDRED""
            else:
                return f""{self.NUMBER[hundreds_digit]} HUNDRED AND {self.trans_two(str(remaining_digits))}""

    def parse_more(self, i):
        # Return the word representation of the magnitude
        return self.NUMBER_MORE[i]
```",0.08292079207920793,0.10315455928366327,0.6142857142857143,0.3805309734513274,0.46994535046731767,0.3835616438356164,0.21,0.27140548815771964,0.6071428571428571,0.37610619469026546,0.4644808695930007
Llama,66,"class NumericEntityUnescaper:
    def __init__(self):
        pass

    def replace(self, string):
        out = []
        pos = 0
        length = len(string)

        while pos < length - 2:
            if string[pos] == '&' and string[pos + 1] == '#':
                start = pos + 2
                is_hex = False
                first_char = string[start]

                if first_char == 'x' or first_char == 'X':
                    start += 1
                    is_hex = True

                if start == length:
                    return ''.join(out)

                end = start
                while end < length and self.is_hex_char(string[end]):
                    end += 1

                if end < length and string[end] == ';':
                    try:
                        entity_value = int(string[start:end], 16 if is_hex else 10)
                    except:
                        return ''.join(out)

                    out.append(chr(entity_value))
                    pos = end + 1
                    continue

            out.append(string[pos])
            pos += 1

        return ''.join(out)

    @staticmethod
    def is_hex_char(char):
        return char.isdigit() or ('a' <= char.lower() <= 'f')",FewShot,"

```python
class NumericEntityUnescaper:
    """"""
    This is a class that provides functionality to replace numeric entities with their corresponding characters in a given string.
    """"""

    def __init__(self):
        # Initialize an empty dictionary to store the mapping of numeric entities to their corresponding Unicode characters
        pass

    def replace(self, string):
        """"""
        Replaces numeric character references (HTML entities) in the input string with their corresponding Unicode characters.
        :param string: str, the input string containing numeric character references.
        :return: str, the input string with numeric character references replaced with their corresponding Unicode characters.
        """"""
        # Import the html module to use its unescape function
        import html
        # Use the unescape function to replace numeric entities with their corresponding Unicode characters
        return html.unescape(string)

    @staticmethod
    def is_hex_char(char):
        """"""
        Determines whether a given character is a hexadecimal digit.
        :param char: str, the character to check.
        :return: bool, True if the character is a hexadecimal digit, False otherwise.
        """"""
        # Define a string of hexadecimal digits
        hex_digits = '0123456789abcdefABCDEF'
        # Check if the character is in the string of hexadecimal digits
        return char in hex_digits
```",0.01714285714285714,0.025977815553492375,0.22727272727272727,0.18518518518518517,0.204081627705123,0.07894736842105263,0.06766917293233082,0.07287448895671164,0.21212121212121213,0.1728395061728395,0.19047618552825224
Llama,67,"class Order:

    def __init__(self):
        self.menu = []
        # menu = [{""dish"": dish name, ""price"": price, ""count"": count}, ...]
        self.selected_dishes = []
        # selected_dish = {""dish"": dish name, ""count"": count, price: price}
        self.sales = {}
        # 


    def add_dish(self, dish):
        for menu_dish in self.menu:
            if dish[""dish""] == menu_dish[""dish""]:
                if menu_dish[""count""] < dish[""count""]:
                    return False
                else:
                    menu_dish[""count""] -= dish[""count""]
                    break
        self.selected_dishes.append(dish)
        return True

    def calculate_total(self):
        total = 0
        for dish in self.selected_dishes:
            total += dish[""price""] * dish[""count""] * self.sales[dish[""dish""]]
        return total

    def checkout(self):
        if len(self.selected_dishes) == 0:
            return False
        total = self.calculate_total()
        self.selected_dishes = []
        return total",FewShot,"

```python
class Order:
    """"""
    The class manages restaurant orders by allowing the addition of dishes, calculation of the total cost, and checkout.
    """"""

    def __init__(self):
        """"""
        Initialize the order management system
        self.menu stores the dishes of resturant inventory
        menu = [{""dish"": dish name, ""price"": price, ""count"": count}, ...]
        self.selected_dishes stores the dished selected by customer
        selected_dish = {""dish"": dish name, ""count"": count, price: price}
        self.sales stores the sales of each dish
        sales = {dish name: sales}
        """"""
        self.menu = []
        self.selected_dishes = []
        self.sales = {}

    def add_dish(self, dish):
        """"""
        Check the self.menu and add into self.selected_dish if the dish count is valid.
        And if the dish has successfully been added, change the count in self.menu.
        :param dish: dict, the information of dish. dish = {""dish"": dish name, ""count"": count, price: price}
        :return: True if successfully added, or False otherwise.
        """"""
        # Check if the dish exists in the menu
        for menu_item in self.menu:
            if menu_item[""dish""] == dish[""dish""] and menu_item[""price""] == dish[""price""]:
                # Check if the count is valid
                if menu_item[""count""] >= dish[""count""]:
                    # Add the dish to the selected dishes
                    self.selected_dishes.append({""dish"": dish[""dish""], ""count"": dish[""count""], ""price"": dish[""price""]})
                    # Update the count in the menu
                    menu_item[""count""] -= dish[""count""]
                    return True
        return False

    def calculate_total(self):
        """"""
        Calculate the total price of dishes that have been ordered. Multiply the count, price and sales.
        :return total: float, the final total price.
        """"""
        # Initialize the total
        total = 0
        # Iterate over the selected dishes
        for dish in self.selected_dishes:
            # Check if the dish has a sales value
            if dish[""dish""] in self.sales:
                # Calculate the total price with sales
                total += dish[""count""] * dish[""price""] * self.sales[dish[""dish""]]
            else:
                # Calculate the total price without sales
                total += dish[""count""] * dish[""price""]
        return total

    def checkout(self):
        """"""
        Check out the dished ordered. IF the self.selected_dishes is not empty, invoke the calculate_total
        method to check out.
        :return Flase if the self.selected_dishes is empty, or total(return value of calculate_total) otherwise.
        """"""
        # Check if there are selected dishes
        if self.selected_dishes:
            # Calculate and return the total
            return self.calculate_total()
        else:
            # Return False if there are no selected dishes
            return False
```",0.07714285714285714,0.10577577112288707,0.847457627118644,0.3401360544217687,0.4854368891163164,0.5543478260869565,0.17832167832167833,0.2698412661582823,0.8305084745762712,0.3333333333333333,0.4757281512522388
Llama,68,"class PageUtil:
    def __init__(self, data, page_size):
        self.data = data
        self.page_size = page_size
        self.total_items = len(data)
        self.total_pages = (self.total_items + page_size - 1) // page_size

    def get_page(self, page_number):
        if page_number < 1 or page_number > self.total_pages:
            return []

        start_index = (page_number - 1) * self.page_size
        end_index = start_index + self.page_size
        return self.data[start_index:end_index]

    def get_page_info(self, page_number):
        if page_number < 1 or page_number > self.total_pages:
            return {}

        start_index = (page_number - 1) * self.page_size
        end_index = min(start_index + self.page_size, self.total_items)
        page_data = self.data[start_index:end_index]

        page_info = {
            ""current_page"": page_number,
            ""per_page"": self.page_size,
            ""total_pages"": self.total_pages,
            ""total_items"": self.total_items,
            ""has_previous"": page_number > 1,
            ""has_next"": page_number < self.total_pages,
            ""data"": page_data
        }
        return page_info

    def search(self, keyword):
        results = [item for item in self.data if keyword in str(item)]
        num_results = len(results)
        num_pages = (num_results + self.page_size - 1) // self.page_size

        search_info = {
            ""keyword"": keyword,
            ""total_results"": num_results,
            ""total_pages"": num_pages,
            ""results"": results
        }
        return search_info",FewShot,"

```python
class PageUtil:
    """"""
    PageUtil class is a versatile utility for handling pagination and search functionalities in an efficient and convenient manner.
    """"""

    def __init__(self, data, page_size):
        """"""
        Initialize the PageUtil object with the given data and page size.
        :param data: list, the data to be paginated
        :param page_size: int, the number of items per page
        """"""
        self.data = data
        self.page_size = page_size
        self.total_items = len(data)
        self.total_pages = (self.total_items + page_size - 1) // page_size

    def get_page(self, page_number):
        """"""
        Retrieve a specific page of data.
        :param page_number: int, the page number to fetch
        :return: list, the data on the specified page
        """"""
        # Calculate the start and end indices for the specified page
        start_index = (page_number - 1) * self.page_size
        end_index = start_index + self.page_size
        
        # Return the data on the specified page
        return self.data[start_index:end_index]

    def get_page_info(self, page_number):
        """"""
        Retrieve information about a specific page.
        :param page_number: int, the page number to fetch information about
        :return: dict, containing page information such as current page number, total pages, etc.
        """"""
        # Calculate the start and end indices for the specified page
        start_index = (page_number - 1) * self.page_size
        end_index = start_index + self.page_size
        
        # Determine if there are previous and next pages
        has_previous = page_number > 1
        has_next = page_number < self.total_pages
        
        # Return the page information
        return {
            ""current_page"": page_number,
            ""per_page"": self.page_size,
            ""total_pages"": self.total_pages,
            ""total_items"": self.total_items,
            ""has_previous"": has_previous,
            ""has_next"": has_next,
            ""data"": self.data[start_index:end_index]
        }

    def search(self, keyword):
        """"""
        Search for items in the data that contain the given keyword.
        :param keyword: str, the keyword to search for
        :return: dict, containing search information such as total results and matching items
        """"""
        # Initialize the search results
        search_results = [item for item in self.data if str(keyword) in str(item)]
        
        # Calculate the total pages for the search results
        total_pages = (len(search_results) + self.page_size - 1) // self.page_size
        
        # Return the search information
        return {
            ""keyword"": keyword,
            ""total_results"": len(search_results),
            ""total_pages"": total_pages,
            ""results"": search_results
        }
```",0.1918238993710692,0.22193689315574186,0.7837837837837838,0.42028985507246375,0.5471698067764329,0.5669291338582677,0.288,0.38196286025371323,0.7837837837837838,0.42028985507246375,0.5471698067764329
Llama,69,"import PyPDF2


class PDFHandler:
    def __init__(self, filepaths):
        self.filepaths = filepaths
        # PdfFileReader is deprecated and was removed in PyPDF2 3.0.0. Use PdfReader instead.
        self.readers = [PyPDF2.PdfReader(fp) for fp in filepaths]

    def merge_pdfs(self, output_filepath):
        pdf_writer = PyPDF2.PdfWriter()

        for reader in self.readers:
            # reader.getNumPages is deprecated and was removed in PyPDF2 3.0.0. Use len(reader.pages) instead.
            for page_num in range(len(reader.pages)):
                # reader.getPage(pageNumber) is deprecated and was removed in PyPDF2 3.0.0. Use reader.pages[page_number] instead.
                page = reader.pages[page_num]
                # addPage is deprecated and was removed in PyPDF2 3.0.0. Use add_page instead.
                pdf_writer.add_page(page)

        with open(output_filepath, 'wb') as out:
            pdf_writer.write(out)
        return f""Merged PDFs saved at {output_filepath}""

    def extract_text_from_pdfs(self):
        pdf_texts = []
        for reader in self.readers:
            for page_num in range(len(reader.pages)):
                page = reader.pages[page_num]
                pdf_texts.append(page.extract_text())
        return pdf_texts",FewShot,"

```python
import PyPDF2

class PDFHandler:
    """"""
    The class allows merging multiple PDF files into one and extracting text from PDFs using PyPDF2 library.
    """"""

    def __init__(self, filepaths):
        """"""
        takes a list of file paths filepaths as a parameter.
        It creates a list named readers using PyPDF2, where each reader opens a file from the given paths.
        """"""
        self.filepaths = filepaths
        # Create a list of PyPDF2 readers for each file path
        self.readers = [PyPDF2.PdfFileReader(fp) for fp in filepaths]

    def merge_pdfs(self, output_filepath):
        """"""
        Read files in self.readers which stores handles to multiple PDF files.
        Merge them to one pdf and update the page number, then save in disk.
        :param output_filepath: str, ouput file path to save to
        :return: str, ""Merged PDFs saved at {output_filepath}"" if successfully merged
        """"""
        # Create a writer to hold the merged PDFs
        writer = PyPDF2.PdfFileWriter()
        # Iterate over each reader and add its pages to the writer
        for reader in self.readers:
            for page_num in range(reader.numPages):
                writer.addPage(reader.getPage(page_num))
        # Write the merged PDF to the output file path
        with open(output_filepath, 'wb') as output_file:
            writer.write(output_file)
        # Return a success message with the output file path
        return f""Merged PDFs saved at {output_filepath}""

    def extract_text_from_pdfs(self):
        """"""
        Extract text from pdf files in self.readers
        :return pdf_texts: list of str, each element is the text of one pdf file
        """"""
        # Initialize an empty list to store the extracted text
        pdf_texts = []
        # Iterate over each reader and extract its text
        for reader in self.readers:
            text = ''
            # Iterate over each page in the reader and extract its text
            for page_num in range(reader.numPages):
                page = reader.getPage(page_num)
                text += page.extractText()
            # Append the extracted text to the list
            pdf_texts.append(text)
        # Return the list of extracted text
        return pdf_texts
```",0.09473684210526317,0.11793423567162978,0.5846153846153846,0.2923076923076923,0.3897435852991454,0.40594059405940597,0.1659919028340081,0.23563217978811607,0.5846153846153846,0.2923076923076923,0.3897435852991454
Llama,70,"class PersonRequest:
    def __init__(self, name: str, sex: str, phoneNumber: str):
        self.name = self._validate_name(name)
        self.sex = self._validate_sex(sex)
        self.phoneNumber = self._validate_phoneNumber(phoneNumber)

    def _validate_name(self, name: str) -> str:
        if not name:
            return None
        if len(name) > 33:
            return None
        return name

    def _validate_sex(self, sex: str) -> str:
        if sex not in [""Man"", ""Woman"", ""UGM""]:
            return None
        return sex

    def _validate_phoneNumber(self, phoneNumber: str) -> str:
        if not phoneNumber:
            return None
        if len(phoneNumber) != 11 or not phoneNumber.isdigit():
            return None
        return phoneNumber",FewShot,"

```python
class PersonRequest:
    """"""
    This class validates input personal information data and sets invalid fields to None based to specific rules.
    """"""

    def __init__(self, name: str, sex: str, phoneNumber: str):
        """"""
        Initialize PersonRequest object with the provided information.
        :param name: str, the name of the person
        :param sex: str, the sex of the person
        :param phoneNumber: str, the phone number of the person
        """"""
        self.name = self._validate_name(name)
        self.sex = self._validate_sex(sex)
        self.phoneNumber = self._validate_phoneNumber(phoneNumber)


    def _validate_name(self, name: str) -> str:
        """"""
        Validate the name and return it. If name is empty or exceeds 33 characters in length, set to None.
        :param name: str, the name to validate
        :return: str, the validated name or None if invalid
        """"""
        # Check if the name is empty or exceeds 33 characters in length
        if not name or len(name) > 33:
            return None
        return name


    def _validate_sex(self, sex: str) -> str:
        """"""
        Validate the sex and return it. If sex is not Man, Woman, or UGM, set to None.
        :param sex: str, the sex to validate
        :return: str, the validated sex or None if invalid
        """"""
        # Check if the sex is valid
        valid_sexes = ['Man', 'Woman', 'UGM']
        if sex not in valid_sexes:
            return None
        return sex


    def _validate_phoneNumber(self, phoneNumber: str) -> str:
        """"""
        Validate the phone number and return it. If phoneNumber is empty or not an 11 digit number, set to None.
        :param phoneNumber: str, the phone number to validate
        :return: str, the validated phone number or None if invalid
        """"""
        # Check if the phone number is empty or not an 11 digit number
        if not phoneNumber or not phoneNumber.isdigit() or len(phoneNumber) != 11:
            return None
        return phoneNumber
```",0.15272727272727274,0.18017366309960156,0.8974358974358975,0.3763440860215054,0.5303030261398073,0.746268656716418,0.2840909090909091,0.411522629750885,0.8205128205128205,0.34408602150537637,0.4848484806852618
Llama,71,"class PushBoxGame:
    def __init__(self, map):
        self.map = map
        self.player_row = 0
        self.player_col = 0
        self.targets = []
        self.boxes = []
        self.target_count = 0
        self.is_game_over = False

        self.init_game()

    def init_game(self):
        for row in range(len(self.map)):
            for col in range(len(self.map[row])):
                if self.map[row][col] == ""O"":
                    self.player_row = row
                    self.player_col = col
                elif self.map[row][col] == ""G"":
                    self.targets.append((row, col))
                    self.target_count += 1
                elif self.map[row][col] == ""X"":
                    self.boxes.append((row, col))

    def check_win(self):
        box_on_target_count = 0
        for box in self.boxes:
            if box in self.targets:
                box_on_target_count += 1
        if box_on_target_count == self.target_count:
            self.is_game_over = True
        return self.is_game_over

    def move(self, direction):
        new_player_row = self.player_row
        new_player_col = self.player_col

        if direction == ""w"":
            new_player_row -= 1
        elif direction == ""s"":
            new_player_row += 1
        elif direction == ""a"":
            new_player_col -= 1
        elif direction == ""d"":
            new_player_col += 1

        if self.map[new_player_row][new_player_col] != ""#"":
            if (new_player_row, new_player_col) in self.boxes:
                new_box_row = new_player_row + (new_player_row - self.player_row)
                new_box_col = new_player_col + (new_player_col - self.player_col)

                if self.map[new_box_row][new_box_col] != ""#"":
                    self.boxes.remove((new_player_row, new_player_col))
                    self.boxes.append((new_box_row, new_box_col))
                    self.player_row = new_player_row
                    self.player_col = new_player_col
            else:
                self.player_row = new_player_row
                self.player_col = new_player_col

        return self.check_win()",FewShot,"

```python
class PushBoxGame:
    """"""
    This class implements a functionality of a sokoban game, where the player needs to move boxes to designated targets in order to win.
    """"""

    def __init__(self, map):
        """"""
        Initialize the push box game with the map and various attributes.
        :param map: list[str], the map of the push box game, represented as a list of strings. 
            Each character on the map represents a different element, including the following:
            - '#' represents a wall that neither the player nor the box can pass through;
            - 'O' represents the initial position of the player;
            - 'G' represents the target position;
            - 'X' represents the initial position of the box.
        >>> map = [""#####"", ""#O  #"", ""# X #"", ""#  G#"", ""#####""]   
        >>> game = PushBoxGame(map)                
        """"""
        self.map = map
        self.player_row = 0
        self.player_col = 0
        self.targets = []
        self.boxes = []
        self.target_count = 0
        self.is_game_over = False
        self.init_game()

    def init_game(self):
        """"""
        Initialize the game by setting the positions of the player, targets, and boxes based on the map.
        >>> game = PushBoxGame([""#####"", ""#O  #"", ""# X #"", ""#  G#"", ""#####""]) 
        >>> game.targets
        [(3, 3)]
        >>> game.boxes
        [(2, 2)]
        >>> game.player_row
        1
        >>> game.player_col
        1
        """"""
        # Iterate over each row and column in the map
        for row in range(len(self.map)):
            for col in range(len(self.map[row])):
                # Check if the current position is the player
                if self.map[row][col] == 'O':
                    self.player_row = row
                    self.player_col = col
                # Check if the current position is a target
                elif self.map[row][col] == 'G':
                    self.targets.append((row, col))
                    self.target_count += 1
                # Check if the current position is a box
                elif self.map[row][col] == 'X':
                    self.boxes.append((row, col))

    def check_win(self):
        """"""
        Check if the game is won. The game is won when all the boxes are placed on target positions.
        And update the value of self.is_game_over.
        :return self.is_game_over: True if all the boxes are placed on target positions, or False otherwise.
        >>> game = PushBoxGame([""#####"", ""#O  #"", ""# X #"", ""#  G#"", ""#####""]) 
        >>> game.check_win()
        """"""
        # Check if all boxes are on target positions
        for box in self.boxes:
            if box not in self.targets:
                self.is_game_over = False
                return self.is_game_over
        self.is_game_over = True
        return self.is_game_over

    def print_map(self):
        """"""
        Print the current state of the game map.
        """"""
        # Create a copy of the map to avoid modifying the original map
        game_map = [list(row) for row in self.map]
        # Update the player position on the map
        game_map[self.player_row][self.player_col] = 'O'
        # Update the box positions on the map
        for box in self.boxes:
            game_map[box[0]][box[1]] = 'X'
        # Print the updated map
        for row in game_map:
            print(' '.join(row))

    def move(self, direction):
        """"""
        Move the player based on the specified direction and check if the game is won.
        :param direction: str, the direction of the player's movement. 
            It can be 'w', 's', 'a', or 'd' representing up, down, left, or right respectively.

        :return: True if the game is won, False otherwise.
        >>> game = PushBoxGame([""#####"", ""#O  #"", ""# X #"", ""#  G#"", ""#####""])       
        >>> game.print_map()
        # # # # # 
        # O     #
        #   X   #
        #     G #
        # # # # #
        >>> game.move('d')
        False
        >>> game.move('s')   
        False
        >>> game.move('a')   
        False
        >>> game.move('s') 
        False
        >>> game.move('d') 
        True
        """"""
        # Get the new player position based on the direction
        new_row, new_col = self.player_row, self.player_col
        if direction == 'w':
            new_row -= 1
        elif direction == 's':
            new_row += 1
        elif direction == 'a':
            new_col -= 1
        elif direction == 'd':
            new_col += 1

        # Check if the new position is a wall
        if self.map[new_row][new_col] == '#':
            return self.check_win()

        # Check if the new position is a box
        if (new_row, new_col) in self.boxes:
            # Get the new box position
            new_box_row, new_box_col = new_row, new_col
            if direction == 'w':
                new_box_row -= 1
            elif direction == 's':
                new_box_row += 1
            elif direction == 'a':
                new_box_col -= 1
            elif direction == 'd':
                new_box_col += 1

            # Check if the new box position is a wall or another box
            if self.map[new_box_row][new_box_col] == '#' or (new_box_row, new_box_col) in self.boxes:
                return self.check_win()

            # Update the box position
            self.boxes.remove((new_row, new_col))
            self.boxes.append((new_box_row, new_box_col))

        # Update the player position
        self.player_row, self.player_col = new_row, new_col

        return self.check_win()
```",0.09158050221565732,0.11039069829767234,0.68,0.22869955156950672,0.3422818754279087,0.5205479452054794,0.16593886462882096,0.2516556254732249,0.6666666666666666,0.2242152466367713,0.3355704660319356
Llama,72,"import re


class RegexUtils:

    def match(self, pattern, text):
        ans = re.match(pattern, text)
        if ans:
            return True
        else:
            return False

    def findall(self, pattern, text):
        return re.findall(pattern, text)

    def split(self, pattern, text):
        return re.split(pattern, text)

    def sub(self, pattern, replacement, text):
        return re.sub(pattern, replacement, text)

    def generate_email_pattern(self):
        pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        return pattern

    def generate_phone_number_pattern(self):
        pattern = r'\b\d{3}-\d{3}-\d{4}\b'
        return pattern

    def generate_split_sentences_pattern(self):
        pattern = r'[.!?][\s]{1,2}(?=[A-Z])'
        return pattern

    def split_sentences(self, text):
        pattern = self.generate_split_sentences_pattern()
        return self.split(pattern, text)

    def validate_phone_number(self, phone_number):
        pattern = self.generate_phone_number_pattern()
        return self.match(pattern, phone_number)

    def extract_email(self, text):
        pattern = self.generate_email_pattern()
        return self.findall(pattern, text)",FewShot,"

```python
import re

class RegexUtils:
    """"""
    The class provides to match, find all occurrences, split, and substitute text using regular expressions. 
    It also includes predefined patterns, validating phone numbers and extracting email addresses.
    """"""

    # Check if the text matches the regular expression
    def match(self, pattern, text):
        # Use re.fullmatch to check if the entire text matches the pattern
        return bool(re.fullmatch(pattern, text))

    # Find all matching substrings and return a list of all matching substrings
    def findall(self, pattern, text):
        # Use re.findall to find all occurrences of the pattern in the text
        return re.findall(pattern, text)

    # Split text based on regular expression patterns and return a list of substrings
    def split(self, pattern, text):
        # Use re.split to split the text into substrings based on the pattern
        return re.split(pattern, text)

    # Replace the substring matched by a regular expression with the specified string
    def sub(self, pattern, replacement, text):
        # Use re.sub to replace the occurrences of the pattern in the text with the replacement
        return re.sub(pattern, replacement, text)

    # Generate regular expression patterns that match email addresses
    def generate_email_pattern(self):
        # Email pattern: one or more alphanumeric characters, dots, underscores, percent signs, plus signs, or hyphens
        # followed by '@', then one or more alphanumeric characters, dots, or hyphens, then a dot, and finally two or more letters
        return r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'

    # Generate regular expression patterns that match phone numbers
    def generate_phone_number_pattern(self):
        # Phone number pattern: three digits, a hyphen, three digits, a hyphen, and four digits
        return r'\b\d{3}-\d{3}-\d{4}\b'

    # Generate regular expression patterns that match the middle characters of two sentences
    def generate_split_sentences_pattern(self):
        # Sentence split pattern: a period, question mark, or exclamation mark, followed by one or two spaces, 
        # and then a capital letter
        return r'[.!?][\s]{1,2}(?=[A-Z])'

    # Split the text into a list of sentences without Punctuation except the last sentence
    def split_sentences(self, text):
        # Use re.split to split the text into sentences based on the sentence split pattern
        return re.split(self.generate_split_sentences_pattern(), text)

    # Verify if the phone number is valid
    def validate_phone_number(self, phone_number):
        # Use re.fullmatch to check if the phone number matches the phone number pattern
        return bool(re.fullmatch(self.generate_phone_number_pattern(), phone_number))

    # Extract all email addresses from the text
    def extract_email(self, text):
        # Use re.findall to find all occurrences of the email pattern in the text
        return re.findall(self.generate_email_pattern(), text)
```",0.04774535809018569,0.06039260739833481,0.7333333333333333,0.21019108280254778,0.32673266980443094,0.44871794871794873,0.12544802867383512,0.19607842795753597,0.7111111111111111,0.20382165605095542,0.31683167970542103
Llama,73,"class RPGCharacter:
    def __init__(self, name, hp, attack_power, defense, level=1):
        self.name = name
        self.hp = hp
        self.attack_power = attack_power
        self.defense = defense
        self.level = level
        self.exp = 0

    def attack(self, other_character):
        damage = max(self.attack_power - other_character.defense, 1)
        other_character.hp -= damage

    def heal(self):
        self.hp += 10
        if self.hp > 100:
            self.hp = 100
        return self.hp

    def gain_exp(self, amount):
        while amount != 0:
            if self.exp + amount >= self.level * 100:
                amount -= (self.level * 100 - self.exp)
                self.level_up()
            else:
                self.exp += amount
                amount = 0

    def level_up(self):
        if self.level < 100:
            self.level += 1
            self.exp = 0
            self.hp += 20
            self.attack_power += 5
            self.defense += 5
        return self.level, self.hp, self.attack_power, self.defense

    def is_alive(self):
        return self.hp > 0",FewShot,"

```python
class RPGCharacter:
    """"""
    The class represents a role-playing game character, which allows to attack other characters, heal, gain experience, level up, and check if the character is alive.
    """"""

    def __init__(self, name, hp, attack_power, defense, level=1):
        """"""
        Initialize an RPG character object.
        :param name: str, the name of the character.
        :param hp: int, The health points of the character.
        :param attack_power: int, the attack power of the character.
        :param defense: int, the defense points of the character.
        :param level: int, the level of the character. Default is 1.
        """"""
        self.name = name
        self.hp = hp
        self.attack_power = attack_power
        self.defense = defense
        self.level = level
        self.exp = 0

    # Method to attack another character
    def attack(self, other_character):
        # Calculate the damage caused to the other character
        damage = max(self.attack_power - other_character.defense, 0)
        # Subtract the damage from the other character's health points
        other_character.hp -= damage

    # Method to heal the character
    def heal(self):
        # Calculate the new health points after healing
        self.hp = min(self.hp + 10, 100)
        # Return the current health points
        return self.hp

    # Method to gain experience points
    def gain_exp(self, amount):
        # Add the experience points to the character's current experience
        self.exp += amount
        # Level up the character if the experience points are sufficient
        while self.exp >= 100 * self.level and self.level < 100:
            self.level_up()

    # Method to level up the character
    def level_up(self):
        # Increase the character's level
        self.level += 1
        # Reset the character's experience points
        self.exp -= 100 * (self.level - 1)
        # Increase the character's health points, attack power, and defense points
        self.hp += 20
        self.attack_power += 5
        self.defense += 5
        # Return the new level, health points, attack power, and defense points
        return self.level, self.hp, self.attack_power, self.defense

    # Method to check if the character is alive
    def is_alive(self):
        # Return True if the character's health points are greater than 0, False otherwise
        return self.hp > 0
```",0.1337579617834395,0.16503663180113343,0.9074074074074074,0.392,0.5474860293062016,0.6173913043478261,0.28174603174603174,0.38692097662318375,0.8888888888888888,0.384,0.5363128449486596
Llama,74,"class Server:

    def __init__(self):
        self.white_list = []
        self.send_struct = {}
        self.receive_struct = {}

    def add_white_list(self, addr):
        if addr in self.white_list:
            return False
        else:
            self.white_list.append(addr)
            return self.white_list

    def del_white_list(self, addr):
        if addr not in self.white_list:
            return False
        else:
            self.white_list.remove(addr)
            return self.white_list

    def recv(self, info):
        if not isinstance(info, dict) or ""addr"" not in info or ""content"" not in info:
            return -1
        addr = info[""addr""]
        content = info[""content""]
        if addr not in self.white_list:
            return False
        else:
            self.receive_struct = {""addr"": addr, ""content"": content}
            return self.receive_struct[""content""]

    def send(self, info):
        if not isinstance(info, dict) or ""addr"" not in info or ""content"" not in info:
            return ""info structure is not correct""
        self.send_struct = {""addr"": info[""addr""], ""content"": info[""content""]}

    def show(self, type):
        if type == ""send"":
            return self.send_struct
        elif type == ""receive"":
            return self.receive_struct
        else:
            return False",FewShot,"

```python
class Server:
    """"""
    This is a class as a server, which handles a white list, message sending and receiving, and information display.
    """"""

    def __init__(self):
        """"""
        Initialize the whitelist as an empty list, and initialize the sending and receiving information as an empty dictionary
        """"""
        # Initialize an empty whitelist and empty dictionaries for sending and receiving information
        self.white_list = []
        self.send_struct = {}
        self.receive_struct = {}

    def add_white_list(self, addr):
        """"""
        Add an address to the whitelist and do nothing if it already exists
        :param addr: int, address to be added
        :return: new whitelist, return False if the address already exists
        >>> server = Server()
        >>> server.add_white_list(88)
        [88]
        """"""
        # Check if the address already exists in the whitelist
        if addr not in self.white_list:
            # Add the address to the whitelist
            self.white_list.append(addr)
            # Return the updated whitelist
            return self.white_list
        else:
            # Return False if the address already exists
            return False

    def del_white_list(self, addr):
        """"""
        Remove an address from the whitelist and do nothing if it does not exist
        :param addr: int, address to be deleted
        :return: new whitelist, return False if the address does not exist
        >>> server.add_white_list(88)
        >>> server.del_white_list(88)
        []
        """"""
        # Check if the address exists in the whitelist
        if addr in self.white_list:
            # Remove the address from the whitelist
            self.white_list.remove(addr)
            # Return the updated whitelist
            return self.white_list
        else:
            # Return False if the address does not exist
            return False

    def recv(self, info):
        """"""
        Receive information containing address and content. If the address is on the whitelist, receive the content; otherwise, do not receive it
        :param info: dict, information dictionary containing address and content
        :return: if successfully received, return the content of the information; otherwise, return False
        >>> server.recv({""addr"":88,""content"":""abc""})
        abc
        """"""
        # Check if the address is in the whitelist
        if info[""addr""] in self.white_list:
            # Receive the content and update the receive_struct dictionary
            self.receive_struct = info
            # Return the received content
            return info[""content""]
        else:
            # Return False if the address is not in the whitelist
            return False

    def send(self, info):
        """"""
        Send information containing address and content
        :param info: dict, information dictionary containing address and content
        :return: if successfully sent, return nothing; otherwise, return a string indicating an error message
        >>> server.send({""addr"":66,""content"":""ABC""})
        self.send_struct = {""addr"":66,""content"":""ABC""}
        """"""
        # Update the send_struct dictionary with the sent information
        self.send_struct = info
        # No return value if successfully sent

    def show(self, type):
        """"""
        Returns struct of the specified type
        :param type: string, the type of struct to be returned, which can be 'send' or 'receive'
        :return: if type is equal to 'send' or 'receive', return the corresponding struct; otherwise, return False
        >>> server.recv({""addr"":88,""content"":""abc""})
        >>> server.send({""addr"":66,""content"":""ABC""})
        >>> server.show(""send"")
        {""addr"":66,""content"":""ABC""}
        """"""
        # Check the type of struct to return
        if type == ""send"":
            # Return the send_struct dictionary
            return self.send_struct
        elif type == ""receive"":
            # Return the receive_struct dictionary
            return self.receive_struct
        else:
            # Return False if the type is neither 'send' nor 'receive'
            return False
```",0.054054054054054064,0.07847426052699834,0.7321428571428571,0.2847222222222222,0.4099999959680001,0.45054945054945056,0.13398692810457516,0.2065491148543548,0.6607142857142857,0.2569444444444444,0.369999995968
Llama,75,"class ShoppingCart:
    def __init__(self):
        self.items = {}

    def add_item(self, item, price, quantity=1):
        if item in self.items:
            self.items[item] = {'price': price, 'quantity': quantity}
        else:
            self.items[item] = {'price': price, 'quantity': quantity}

    def remove_item(self, item, quantity=1):
        if item in self.items:
            self.items[item]['quantity'] -= quantity
        else:
            pass

    def view_items(self) -> dict:
        return self.items

    def total_price(self) -> float:
        return sum([item['quantity'] * item['price'] for item in self.items.values()])",FewShot,"

```python
class ShoppingCart:
    """"""
    The class manages items, their prices, quantities, and allows to for add, remove, view items, and calculate the total price.
    """"""

    def __init__(self):
        """"""
        Initialize the items representing the shopping list as an empty dictionary
        """"""
        self.items = {}

    def add_item(self, item, price, quantity=1):
        """"""
        Add item information to the shopping list items, including price and quantity. The default quantity is 1
        :param item: string, Item to be added
        :param price: float, The price of the item
        :param quantity:int, The number of items, defaults to 1
        :return:None
        """"""
        # Check if the item already exists in the shopping list
        if item in self.items:
            # If the item exists, update its quantity
            self.items[item][""quantity""] += quantity
        else:
            # If the item does not exist, add it to the shopping list
            self.items[item] = {""price"": price, ""quantity"": quantity}

    def remove_item(self, item, quantity=1):
        """"""
        Subtract the specified quantity of item from the shopping list items
        :param item:string, Item to be subtracted in quantity
        :param quantity:int, Quantity to be subtracted
        :return:None
        """"""
        # Check if the item exists in the shopping list
        if item in self.items:
            # If the item exists, subtract the specified quantity
            if self.items[item][""quantity""] <= quantity:
                # If the quantity to be subtracted is greater than or equal to the existing quantity, remove the item from the shopping list
                del self.items[item]
            else:
                # If the quantity to be subtracted is less than the existing quantity, update the quantity
                self.items[item][""quantity""] -= quantity
        else:
            # If the item does not exist, print an error message
            print(""Item not found in the shopping list"")

    def view_items(self) -> dict:
        """"""
        Return the current shopping list items
        :return:dict, the current shopping list items
        """"""
        # Return the shopping list items
        return self.items

    def total_price(self) -> float:
        """"""
        Calculate the total price of all items in the shopping list, which is the quantity of each item multiplied by the price
        :return:float, the total price of all items in the shopping list
        """"""
        # Initialize the total price to 0
        total = 0
        # Iterate over each item in the shopping list
        for item in self.items:
            # Calculate the total price of the current item
            item_total = self.items[item][""price""] * self.items[item][""quantity""]
            # Add the total price of the current item to the overall total price
            total += item_total
        # Return the total price
        return total
```",0.0544041450777202,0.06618041636689515,0.8108108108108109,0.22388059701492538,0.3508771895913273,0.5961538461538461,0.1183206106870229,0.1974522265357621,0.8108108108108109,0.22388059701492538,0.3508771895913273
Llama,76,"class SignInSystem:
    def __init__(self):
        self.users = {}

    def add_user(self, username):
        if username in self.users:
            return False
        else:
            self.users[username] = False
            return True

    def sign_in(self, username):
        if username not in self.users:
            return False
        else:
            self.users[username] = True
            return True

    def check_sign_in(self, username):
        if username not in self.users:
            return False
        else:
            if self.users[username]:
                return True
            else:
                return False

    def all_signed_in(self):
        if all(self.users.values()):
            return True
        else:
            return False

    def all_not_signed_in(self):
        not_signed_in_users = []
        for username, signed_in in self.users.items():
            if not signed_in:
                not_signed_in_users.append(username)
        return not_signed_in_users",FewShot,"

```python
class SignInSystem:
    """"""
    This is a class as sign-in system, including adding users, signing in/out, checking sign-in status, and retrieving signed-in/not signed-in users.
    """"""

    def __init__(self):
        """"""
        Initialize the sign-in system.
        """"""
        # Initialize an empty dictionary to store users and their sign-in status
        self.users = {}

    def add_user(self, username):
        """"""
        Add a user to the sign-in system if the user wasn't in the self.users.
        And the initial state is False.
        :param username: str, the username to be added.
        :return: bool, True if the user is added successfully, False if the user already exists.
        """"""
        # Check if the user already exists in the system
        if username not in self.users:
            # Add the user with an initial sign-in status of False
            self.users[username] = False
            return True
        else:
            # Return False if the user already exists
            return False

    def sign_in(self, username):
        """"""
        Sign in a user if the user was in the self.users and change the state to True.
        :param username: str, the username to be signed in.
        :return: bool, True if the user is signed in successfully, False if the user does not exist.
        """"""
        # Check if the user exists in the system
        if username in self.users:
            # Sign in the user by setting their status to True
            self.users[username] = True
            return True
        else:
            # Return False if the user does not exist
            return False

    def check_sign_in(self, username):
        """"""
        Check if a user is signed in.
        :param username: str, the username to be checked.
        :return: bool, True if the user is signed in, False if the user does not exist or is not signed in.
        """"""
        # Check if the user exists in the system
        if username in self.users:
            # Return the sign-in status of the user
            return self.users[username]
        else:
            # Return False if the user does not exist
            return False

    def all_signed_in(self):
        """"""
        Check if all users are signed in.
        :return: bool, True if all users are signed in, False otherwise.
        """"""
        # Iterate over all users in the system
        for user in self.users:
            # If any user is not signed in, return False
            if not self.users[user]:
                return False
        # If all users are signed in, return True
        return True

    def all_not_signed_in(self):
        """"""
        Get a list of usernames that are not signed in.
        :return: list[str], a list of usernames that are not signed in.
        """"""
        # Initialize an empty list to store usernames of users who are not signed in
        not_signed_in_users = []
        # Iterate over all users in the system
        for user in self.users:
            # If a user is not signed in, add them to the list
            if not self.users[user]:
                not_signed_in_users.append(user)
        # Return the list of usernames of users who are not signed in
        return not_signed_in_users
```",0.05345211581291759,0.0695252167213256,0.7714285714285715,0.25471698113207547,0.3829787196720488,0.5645161290322581,0.1483050847457627,0.2348993255637134,0.7714285714285715,0.25471698113207547,0.3829787196720488
Llama,77,"import random


class Snake:
    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):
        self.length = 1
        self.SCREEN_WIDTH = SCREEN_WIDTH
        self.SCREEN_HEIGHT = SCREEN_HEIGHT
        self.BLOCK_SIZE = BLOCK_SIZE
        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]
        self.score = 0
        self.food_position = food_position

    def move(self, direction):
        cur = self.positions[0]
        x, y = direction

        new = (
            ((cur[0] + (x * self.BLOCK_SIZE)) % self.SCREEN_WIDTH),
            (cur[1] + (y * self.BLOCK_SIZE)) % self.SCREEN_HEIGHT,
        )

        if new == self.food_position:
            self.eat_food()

        if len(self.positions) > 2 and new in self.positions[2:]:
            self.reset()
        else:
            self.positions.insert(0, new)
            if len(self.positions) > self.length:
                self.positions.pop()

    def random_food_position(self):
        while self.food_position in self.positions:
            self.food_position = (random.randint(0, self.SCREEN_WIDTH // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE,
                                  random.randint(0, self.SCREEN_HEIGHT // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE)

    def reset(self):
        self.length = 1
        self.positions = [((self.SCREEN_WIDTH / 2), (self.SCREEN_HEIGHT / 2))]
        self.score = 0
        self.random_food_position()

    def eat_food(self):
        self.length += 1
        self.score += 100
        self.random_food_position()",FewShot,"

```python
class Snake:
    """"""
    The class is a snake game, with allows snake to move and eat food, and also enables to reset, and generate a random food position.
    """"""

    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):
        """"""
        Initialize the length of the snake, screen width, screen height, block size, snake head position, score, and food position.
        :param SCREEN_WIDTH: int
        :param SCREEN_HEIGHT: int
        :param BLOCK_SIZE: int, Size of moving units
        :param food_position: tuple, representing the position(x, y) of food.
        """"""
        self.length = 1
        self.SCREEN_WIDTH = SCREEN_WIDTH
        self.SCREEN_HEIGHT = SCREEN_HEIGHT
        self.BLOCK_SIZE = BLOCK_SIZE
        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]
        self.score = 0
        self.food_position = food_position
        # Initialize the direction of the snake
        self.direction = (0, 0)

    def move(self, direction):
        """"""
        Move the snake in the specified direction. If the new position of the snake's head is equal to the position of the food, then eat the food; If the position of the snake's head is equal to the position of its body, then start over, otherwise its own length plus one.
        :param direction: tuple, representing the direction of movement (x, y).
        :return: None
        """"""
        # Update the direction of the snake
        self.direction = direction
        # Calculate the new head position
        new_head_position = (self.positions[-1][0] + self.direction[0] * self.BLOCK_SIZE, self.positions[-1][1] + self.direction[1] * self.BLOCK_SIZE)
        
        # Check if the new head position is out of the screen
        if (new_head_position[0] < 0 or new_head_position[0] >= self.SCREEN_WIDTH or 
            new_head_position[1] < 0 or new_head_position[1] >= self.SCREEN_HEIGHT):
            self.reset()
            return
        
        # Check if the new head position is equal to the position of the food
        if new_head_position == self.food_position:
            self.eat_food()
        else:
            # Check if the new head position is equal to the position of its body
            if new_head_position in self.positions:
                self.reset()
                return
            # Update the positions of the snake
            self.positions.append(new_head_position)
            if len(self.positions) > self.length:
                self.positions.pop(0)

    def random_food_position(self):
        """"""
        Randomly generate a new food position, but don't place it on the snake.
        :return: None, Change the food position
        """"""
        # Generate a random position
        while True:
            x = random.randint(0, self.SCREEN_WIDTH - self.BLOCK_SIZE) // self.BLOCK_SIZE * self.BLOCK_SIZE
            y = random.randint(0, self.SCREEN_HEIGHT - self.BLOCK_SIZE) // self.BLOCK_SIZE * self.BLOCK_SIZE
            new_food_position = (x, y)
            # Check if the new food position is not on the snake
            if new_food_position not in self.positions:
                self.food_position = new_food_position
                break

    def reset(self):
        """"""
        Reset the snake to its initial state. Set the length to 1, the snake head position to ((SCREEN_WIDTH/2), (SCREEN_HEIGHT/2)), the score to 0, and randomly generate new food position.
        :return: None
        """"""
        self.length = 1
        self.positions = [((self.SCREEN_WIDTH / 2), (self.SCREEN_HEIGHT / 2))]
        self.score = 0
        self.random_food_position()

    def eat_food(self):
        """"""
        Increase the length of the snake by 1 and increase the score by 100. Randomly generate a new food position, but
        don't place it on the snake.
        :return: None
        """"""
        self.length += 1
        self.score += 100
        self.random_food_position()
```",0.11713665943600868,0.1439816730002579,0.7435897435897436,0.3372093023255814,0.4639999957068801,0.5693430656934306,0.22740524781341107,0.3249999959209201,0.7435897435897436,0.3372093023255814,0.4639999957068801
Llama,78,"import re


class SplitSentence:

    def split_sentences(self, sentences_string):
        sentences = re.split(r'(?<!\w\.\w.)(?<![A-Z][a-z]\.)(?<=\.|\?)\s', sentences_string)
        return sentences

    def count_words(self, sentence):
        sentence = re.sub(r'[^a-zA-Z\s]', '', sentence)
        words = sentence.split()
        return len(words)

    def process_text_file(self, sentences_string):
        sentences = self.split_sentences(sentences_string)
        max_count = 0
        for sentence in sentences:
            count = self.count_words(sentence)
            if count > max_count:
                max_count = count

        return max_count",FewShot,"

```python
import re

class SplitSentence:
    """"""
    The class allows to split sentences, count words in a sentence, and process a text file to find the maximum word count.
    """"""

    def split_sentences(self, sentences_string):
        # Use regular expression to split the string into sentences
        # The pattern matches one or more whitespace characters followed by a period or question mark
        # The period or question mark is included in the match to ensure it's not lost during splitting
        sentences = re.split('(?<=[.!?]) +', sentences_string)
        return sentences

    def count_words(self, sentence):
        # Remove punctuation marks and numbers from the sentence
        # The pattern matches one or more non-word characters (everything except alphanumeric characters and underscores)
        sentence = re.sub(r'[^\w\s]', '', sentence)
        # Split the sentence into words
        words = sentence.split()
        return len(words)

    def process_text_file(self, sentences_string):
        # Split the string into sentences
        sentences = self.split_sentences(sentences_string)
        # Initialize the maximum word count
        max_word_count = 0
        # Iterate over each sentence
        for sentence in sentences:
            # Count the words in the sentence
            word_count = self.count_words(sentence)
            # Update the maximum word count if necessary
            if word_count > max_word_count:
                max_word_count = word_count
        return max_word_count
```",0.08791208791208792,0.11505866912028108,0.7894736842105263,0.3,0.43478260470489394,0.5370370370370371,0.18354430379746836,0.2735849018636526,0.7631578947368421,0.29,0.42028985108170563
Llama,79,"class SQLGenerator:
    def __init__(self, table_name):
        self.table_name = table_name

    def select(self, fields=None, condition=None):
        if fields is None:
            fields = ""*""
        else:
            fields = "", "".join(fields)
        sql = f""SELECT {fields} FROM {self.table_name}""
        if condition is not None:
            sql += f"" WHERE {condition}""
        return sql + "";""

    def insert(self, data):
        fields = "", "".join(data.keys())
        values = "", "".join([f""'{value}'"" for value in data.values()])
        sql = f""INSERT INTO {self.table_name} ({fields}) VALUES ({values})""
        return sql + "";""

    def update(self, data, condition):
        set_clause = "", "".join([f""{field} = '{value}'"" for field, value in data.items()])
        sql = f""UPDATE {self.table_name} SET {set_clause} WHERE {condition}""
        return sql + "";""

    def delete(self, condition):
        sql = f""DELETE FROM {self.table_name} WHERE {condition}""
        return sql + "";""

    def select_female_under_age(self, age):
        condition = f""age < {age} AND gender = 'female'""
        return self.select(condition=condition)

    def select_by_age_range(self, min_age, max_age):
        condition = f""age BETWEEN {min_age} AND {max_age}""
        return self.select(condition=condition)",FewShot,"

```python
class SQLGenerator:
    """"""
    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.
    """"""

    def __init__(self, table_name):
        """"""
        Initialize the table name.
        :param table_name: str
        """"""
        self.table_name = table_name

    # Generate a SELECT SQL statement based on the specified fields and conditions
    def select(self, fields=None, condition=None):
        # If fields are not specified, select all fields
        if fields is None:
            fields_str = ""*""
        else:
            # Convert the list of fields to a comma-separated string
            fields_str = "", "".join(fields)
        
        # Start building the SQL statement
        sql = f""SELECT {fields_str} FROM {self.table_name}""
        
        # If a condition is specified, add the WHERE clause
        if condition is not None:
            sql += f"" WHERE {condition};""
        else:
            sql += "";""
        
        return sql

    # Generate an INSERT SQL statement based on the given data
    def insert(self, data):
        # Get the field names and values from the data dictionary
        fields = list(data.keys())
        values = list(data.values())
        
        # Convert the list of fields to a comma-separated string
        fields_str = "", "".join(fields)
        
        # Convert the list of values to a comma-separated string, enclosing each value in single quotes
        values_str = "", "".join(f""'{value}'"" for value in values)
        
        # Build the SQL statement
        sql = f""INSERT INTO {self.table_name} ({fields_str}) VALUES ({values_str});""
        
        return sql

    # Generate an UPDATE SQL statement based on the given data and condition
    def update(self, data, condition):
        # Get the field names and new values from the data dictionary
        fields = list(data.keys())
        values = list(data.values())
        
        # Build the SET clause
        set_clause = "", "".join(f""{field} = '{value}'"" for field, value in zip(fields, values))
        
        # Build the SQL statement
        sql = f""UPDATE {self.table_name} SET {set_clause} WHERE {condition};""
        
        return sql

    # Generate a DELETE SQL statement based on the given condition
    def delete(self, condition):
        # Build the SQL statement
        sql = f""DELETE FROM {self.table_name} WHERE {condition};""
        
        return sql

    # Generate a SQL statement to select females under a specified age
    def select_female_under_age(self, age):
        # Build the SQL statement
        sql = f""SELECT * FROM {self.table_name} WHERE age < {age} AND gender = 'female';""
        
        return sql

    # Generate a SQL statement to select records within a specified age range
    def select_by_age_range(self, min_age, max_age):
        # Build the SQL statement
        sql = f""SELECT * FROM {self.table_name} WHERE age BETWEEN {min_age} AND {max_age};""
        
        return sql
```",0.12032085561497326,0.14849204680818168,0.825,0.4342105263157895,0.5689655127229489,0.603448275862069,0.28,0.3825136568724059,0.825,0.4342105263157895,0.5689655127229489
Llama,80,"class SQLQueryBuilder:

    @staticmethod
    def select(table, columns='*', where=None):
        if columns != '*':
            columns = ', '.join(columns)
        query = f""SELECT {columns} FROM {table}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query

    @staticmethod
    def insert(table, data):
        keys = ', '.join(data.keys())
        values = ', '.join(f""'{v}'"" for v in data.values())
        return f""INSERT INTO {table} ({keys}) VALUES ({values})""

    @staticmethod
    def delete(table, where=None):
        query = f""DELETE FROM {table}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query

    @staticmethod
    def update(table, data, where=None):
        update_str = ', '.join(f""{k}='{v}'"" for k, v in data.items())
        query = f""UPDATE {table} SET {update_str}""
        if where:
            query += "" WHERE "" + ' AND '.join(f""{k}='{v}'"" for k, v in where.items())
        return query",FewShot,"

```python
class SQLQueryBuilder:
    """"""
    This class provides to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements. 
    """"""

    @staticmethod
    def select(table, columns='*', where=None):
        # Start building the SELECT query
        query = ""SELECT ""
        
        # If columns is a list, join the columns with a comma
        if isinstance(columns, list):
            query += "", "".join(columns)
        else:
            query += columns
        
        # Specify the table
        query += f"" FROM {table}""
        
        # If a WHERE condition is provided, add it to the query
        if where:
            query += "" WHERE ""
            conditions = []
            for key, value in where.items():
                # Append each condition to the list
                conditions.append(f""{key}='{value}'"")
            # Join the conditions with AND
            query += "" AND "".join(conditions)
        
        return query

    @staticmethod
    def insert(table, data):
        # Start building the INSERT query
        query = f""INSERT INTO {table} ""
        
        # Get the columns and values from the data dictionary
        columns = list(data.keys())
        values = list(data.values())
        
        # Add the columns to the query
        query += f""({', '.join(columns)}) ""
        
        # Add the values to the query
        query += f""VALUES ({', '.join([f""'{value}'"" for value in values])})""
        
        return query

    @staticmethod
    def delete(table, where=None):
        # Start building the DELETE query
        query = f""DELETE FROM {table}""
        
        # If a WHERE condition is provided, add it to the query
        if where:
            query += "" WHERE ""
            conditions = []
            for key, value in where.items():
                # Append each condition to the list
                conditions.append(f""{key}='{value}'"")
            # Join the conditions with AND
            query += "" AND "".join(conditions)
        
        return query

    @staticmethod
    def update(table, data, where=None):
        # Start building the UPDATE query
        query = f""UPDATE {table} SET ""
        
        # Get the columns and values from the data dictionary
        columns = list(data.keys())
        values = list(data.values())
        
        # Add the columns and values to the query
        query += "", "".join([f""{column}='{value}'"" for column, value in zip(columns, values)])
        
        # If a WHERE condition is provided, add it to the query
        if where:
            query += "" WHERE ""
            conditions = []
            for key, value in where.items():
                # Append each condition to the list
                conditions.append(f""{key}='{value}'"")
            # Join the conditions with AND
            query += "" AND "".join(conditions)
        
        return query
```",0.10650887573964495,0.13362511956216472,0.6842105263157895,0.3644859813084112,0.47560975156231416,0.4125,0.1875,0.25781249570312503,0.6491228070175439,0.34579439252336447,0.4512195076598751
Llama,81,"import math
class Statistics3:
    @staticmethod
    def median(data):
        sorted_data = sorted(data)
        n = len(sorted_data)
        if n % 2 == 1:
            return sorted_data[n // 2]
        else:
            return (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2

    @staticmethod
    def mode(data):
        counts = {}
        for value in data:
            counts[value] = counts.get(value, 0) + 1
        max_count = max(counts.values())
        mode_values = [value for value, count in counts.items() if count == max_count]
        return mode_values

    @staticmethod
    def correlation(x, y):
        n = len(x)
        mean_x = sum(x) / n
        mean_y = sum(y) / n
        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))
        denominator = math.sqrt(sum((xi - mean_x) ** 2 for xi in x) * sum((yi - mean_y) ** 2 for yi in y))
        if denominator == 0:
            return None
        return numerator / denominator

    @staticmethod
    def mean(data):
        if len(data) == 0:
            return None
        return sum(data) / len(data)

    @staticmethod
    def correlation_matrix(data):
        matrix = []
        for i in range(len(data[0])):
            row = []
            for j in range(len(data[0])):
                column1 = [row[i] for row in data]
                column2 = [row[j] for row in data]
                correlation = Statistics3.correlation(column1, column2)
                row.append(correlation)
            matrix.append(row)
        return matrix

    @staticmethod
    def standard_deviation(data):
        n = len(data)
        if n < 2:
            return None
        mean_value = Statistics3.mean(data)
        variance = sum((x - mean_value) ** 2 for x in data) / (n - 1)
        return math.sqrt(variance)

    @staticmethod
    def z_score(data):
        mean = Statistics3.mean(data)
        std_deviation = Statistics3.standard_deviation(data)
        if std_deviation is None or std_deviation == 0:
            return None
        return [(x - mean) / std_deviation for x in data]",FewShot,"

```python
import math
from collections import Counter

class Statistics3:
    """"""
    This is a class that implements methods for calculating indicators such as median, mode, correlation matrix, and Z-score in statistics.
    """"""

    @staticmethod
    def median(data):
        # Sort the data in ascending order
        sorted_data = sorted(data)
        n = len(sorted_data)
        
        # If the length of the data is even, the median is the average of the two middle numbers
        if n % 2 == 0:
            median = (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2
        # If the length of the data is odd, the median is the middle number
        else:
            median = sorted_data[n // 2]
        return median

    @staticmethod
    def mode(data):
        # Count the frequency of each number in the data
        frequency = Counter(data)
        
        # Find the number with the highest frequency
        max_frequency = max(frequency.values())
        modes = [num for num, freq in frequency.items() if freq == max_frequency]
        return modes

    @staticmethod
    def correlation(x, y):
        # Calculate the means of x and y
        mean_x = sum(x) / len(x)
        mean_y = sum(y) / len(y)
        
        # Calculate the deviations from the means
        deviations_x = [xi - mean_x for xi in x]
        deviations_y = [yi - mean_y for yi in y]
        
        # Calculate the covariance and the variances
        covariance = sum(xi * yi for xi, yi in zip(deviations_x, deviations_y)) / len(x)
        variance_x = sum(xi ** 2 for xi in deviations_x) / len(x)
        variance_y = sum(yi ** 2 for yi in deviations_y) / len(y)
        
        # Calculate the correlation coefficient
        correlation_coefficient = covariance / math.sqrt(variance_x * variance_y)
        return correlation_coefficient

    @staticmethod
    def mean(data):
        # Calculate the sum of the data
        total = sum(data)
        
        # Calculate the mean
        mean = total / len(data)
        return mean

    @staticmethod
    def correlation_matrix(data):
        # Calculate the correlation matrix
        correlation_matrix = [[Statistics3.correlation(x, y) for y in zip(*data)] for x in zip(*data)]
        return correlation_matrix

    @staticmethod
    def standard_deviation(data):
        # Calculate the mean
        mean = Statistics3.mean(data)
        
        # Calculate the variance
        variance = sum((xi - mean) ** 2 for xi in data) / len(data)
        
        # Calculate the standard deviation
        standard_deviation = math.sqrt(variance)
        return standard_deviation

    @staticmethod
    def z_score(data):
        # Calculate the mean and standard deviation
        mean = Statistics3.mean(data)
        standard_deviation = Statistics3.standard_deviation(data)
        
        # Calculate the z-scores
        z_scores = [(xi - mean) / standard_deviation for xi in data]
        return z_scores
```",0.11716621253405995,0.15207672377098164,0.5652173913043478,0.42207792207792205,0.4832713705697821,0.29767441860465116,0.21476510067114093,0.24951266569618766,0.5391304347826087,0.4025974025974026,0.4609665378560274
Llama,82,"class StockPortfolioTracker:
    def __init__(self, cash_balance):
        self.portfolio = []
        self.cash_balance = cash_balance

    def add_stock(self, stock):
        for pf in self.portfolio:
            if pf['name'] == stock['name']:
                pf['quantity'] += stock['quantity']
                return

        self.portfolio.append(stock)

    def remove_stock(self, stock):
        for pf in self.portfolio:
            if pf['name'] == stock['name'] and pf['quantity'] >= stock['quantity']:
                pf['quantity'] -= stock['quantity']
                if pf['quantity'] == 0:
                    self.portfolio.remove(pf)
                return True
        return False

    def buy_stock(self, stock):
        if stock['price'] * stock['quantity'] > self.cash_balance:
            return False
        else:
            self.add_stock(stock)
            self.cash_balance -= stock['price'] * stock['quantity']
            return True

    def sell_stock(self, stock):
        if self.remove_stock(stock) == False:
            return False
        self.cash_balance += stock['price'] * stock['quantity']
        return True

    def calculate_portfolio_value(self):
        total_value = self.cash_balance
        for stock in self.portfolio:
            total_value += stock['price'] * stock['quantity']
        return total_value

    def get_portfolio_summary(self):
        summary = []
        for stock in self.portfolio:
            value = self.get_stock_value(stock)
            summary.append({""name"": stock[""name""], ""value"": value})
        portfolio_value = self.calculate_portfolio_value()
        return portfolio_value, summary

    def get_stock_value(self, stock):
        return stock['price'] * stock['quantity']",FewShot,"

```python
class StockPortfolioTracker:
    """"""
    This is a class as StockPortfolioTracker that allows to add stocks, remove stocks, buy stocks, sell stocks, calculate the total value of the portfolio, and obtain a summary of the portfolio.
    """"""

    def __init__(self, cash_balance):
        """"""
        Initialize the StockPortfolioTracker class with a cash balance and an empty portfolio.
        """"""
        self.portfolio = []
        self.cash_balance = cash_balance

    def add_stock(self, stock):
        # Add a stock to the portfolio
        self.portfolio.append(stock)

    def remove_stock(self, stock):
        # Remove a stock from the portfolio
        for s in self.portfolio:
            if s['name'] == stock['name'] and s['price'] == stock['price'] and s['quantity'] == stock['quantity']:
                self.portfolio.remove(s)
                return True
        return False

    def buy_stock(self, stock):
        # Buy a stock and add it to the portfolio
        total_cost = stock['price'] * stock['quantity']
        if self.cash_balance >= total_cost:
            self.cash_balance -= total_cost
            self.add_stock(stock)
            return True
        return False

    def sell_stock(self, stock):
        # Sell a stock and remove it from the portfolio and add the cash to the cash balance
        for s in self.portfolio:
            if s['name'] == stock['name'] and s['price'] == stock['price'] and s['quantity'] <= stock['quantity']:
                self.cash_balance += stock['price'] * stock['quantity']
                self.portfolio.remove(s)
                return True
        return False

    def calculate_portfolio_value(self):
        # Calculate the total value of the portfolio
        total_value = self.cash_balance
        for stock in self.portfolio:
            total_value += stock['price'] * stock['quantity']
        return total_value

    def get_portfolio_summary(self):
        # Get a summary of the portfolio
        total_value = self.calculate_portfolio_value()
        stock_values = []
        for stock in self.portfolio:
            stock_value = stock['price'] * stock['quantity']
            stock_values.append({'name': stock['name'], 'value': stock_value})
        return (total_value, stock_values)

    def get_stock_value(self, stock):
        # Get the value of a stock
        return stock['price'] * stock['quantity']
```",0.18292682926829268,0.22687183470571434,0.7,0.4421052631578947,0.5419354791259106,0.48672566371681414,0.3021978021978022,0.3728813512057455,0.6833333333333333,0.43157894736842106,0.529032253319459
Llama,83,"import sqlite3


class StudentDatabaseProcessor:

    def __init__(self, database_name):
        self.database_name = database_name

    def create_student_table(self):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        create_table_query = """"""
        CREATE TABLE IF NOT EXISTS students (
            id INTEGER PRIMARY KEY,
            name TEXT,
            age INTEGER,
            gender TEXT,
            grade INTEGER
        )
        """"""
        cursor.execute(create_table_query)

        conn.commit()
        conn.close()

    def insert_student(self, student_data):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        insert_query = """"""
        INSERT INTO students (name, age, gender, grade)
        VALUES (?, ?, ?, ?)
        """"""
        cursor.execute(insert_query,
                       (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))

        conn.commit()
        conn.close()

    def search_student_by_name(self, name):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        select_query = ""SELECT * FROM students WHERE name = ?""
        cursor.execute(select_query, (name,))
        result = cursor.fetchall()

        conn.close()

        return result

    def delete_student_by_name(self, name):
        conn = sqlite3.connect(self.database_name)
        cursor = conn.cursor()

        delete_query = ""DELETE FROM students WHERE name = ?""
        cursor.execute(delete_query, (name,))

        conn.commit()
        conn.close()",FewShot,"

```python
import sqlite3

class StudentDatabaseProcessor:
    """"""
    This is a class with database operation, including inserting student information, searching for student information by name, and deleting student information by name.
    """"""

    def __init__(self, database_name):
        """"""
        Initializes the StudentDatabaseProcessor object with the specified database name.
        :param database_name: str, the name of the SQLite database.
        """"""
        self.database_name = database_name
        # Create a connection to the database
        self.conn = sqlite3.connect(database_name)
        # Create a cursor object
        self.cursor = self.conn.cursor()

    def create_student_table(self):
        """"""
        Creates a ""students"" table in the database if it does not exist already.Fields include ID of type int, name of type str, age of type int, gender of type str, and grade of type int
        :return: None
        """"""
        # SQL query to create the table
        query = """"""
            CREATE TABLE IF NOT EXISTS students (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                age INTEGER NOT NULL,
                gender TEXT NOT NULL,
                grade INTEGER NOT NULL
            )
        """"""
        # Execute the query
        self.cursor.execute(query)
        # Commit the changes
        self.conn.commit()

    def insert_student(self, student_data):
        """"""
        Inserts a new student into the ""students"" table.
        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).
        :return: None
        """"""
        # SQL query to insert a new student
        query = """"""
            INSERT INTO students (name, age, gender, grade)
            VALUES (?, ?, ?, ?)
        """"""
        # Extract the values from the dictionary
        values = (student_data['name'], student_data['age'], student_data['gender'], student_data['grade'])
        # Execute the query
        self.cursor.execute(query, values)
        # Commit the changes
        self.conn.commit()

    def search_student_by_name(self, name):
        """"""
        Searches for a student in the ""students"" table by their name.
        :param name: str, the name of the student to search for.
        :return: list of tuples, the rows from the ""students"" table that match the search criteria.
        """"""
        # SQL query to search for a student by name
        query = """"""
            SELECT * FROM students
            WHERE name = ?
        """"""
        # Execute the query
        self.cursor.execute(query, (name,))
        # Fetch all the rows
        rows = self.cursor.fetchall()
        # Return the rows
        return rows

    def delete_student_by_name(self, name):
        """"""
        Deletes a student from the ""students"" table by their name.
        :param name: str, the name of the student to delete.
        :return: None
        """"""
        # SQL query to delete a student by name
        query = """"""
            DELETE FROM students
            WHERE name = ?
        """"""
        # Execute the query
        self.cursor.execute(query, (name,))
        # Commit the changes
        self.conn.commit()

    # Close the connection when the object is destroyed
    def __del__(self):
        self.conn.close()
```",0.0964467005076142,0.11485480941126792,0.7567567567567568,0.35668789808917195,0.48484848049399387,0.5045871559633027,0.1909722222222222,0.27707808165878856,0.7567567567567568,0.35668789808917195,0.48484848049399387
Llama,84,"import json


class TextFileProcessor:
    def __init__(self, file_path):
        self.file_path = file_path

    def read_file_as_json(self):
        with open(self.file_path, 'r') as file:
            data = json.load(file)

        return data

    def read_file(self):
        with open(self.file_path, 'r') as file:
            return file.read()

    def write_file(self, content):
        with open(self.file_path, 'w') as file:
            file.write(content)

    def process_file(self):
        content = self.read_file()
        content = ''.join([char for char in content if char.isalpha()])
        self.write_file(content)
        return content",FewShot,"

```python
import json

class TextFileProcessor:
    """"""
    The class handles reading, writing, and processing text files. It can read the file as JSON, read the raw text, write content to the file, and process the file by removing non-alphabetic characters.
    """"""

    def __init__(self, file_path):
        """"""
        Initialize the file path.
        :param file_path: str
        """"""
        self.file_path = file_path

    # Method to read the file as JSON
    def read_file_as_json(self):
        """"""
        Read the self.file_path file as json format.
        if the file content doesn't obey json format, the code will raise error.
        :return data: dict if the file is stored as json format, or str/int/float.. according to the file content otherwise.
        """"""
        try:
            # Attempt to open and read the file as JSON
            with open(self.file_path, 'r') as file:
                # Use json.load to parse the JSON data
                data = json.load(file)
                return data
        except json.JSONDecodeError:
            # If the file is not in JSON format, return None
            return None

    # Method to read the raw text from the file
    def read_file(self):
        """"""
        Read the return the content of self.file_path file.
        :return: the same return as the read() method
        """"""
        try:
            # Attempt to open and read the file
            with open(self.file_path, 'r') as file:
                # Use the read method to get the file content
                content = file.read()
                return content
        except FileNotFoundError:
            # If the file does not exist, return None
            return None

    # Method to write content to the file
    def write_file(self, content):
        """"""
        Write content into the self.file_path file, and overwrite if the file has already existed.
        :param content: any content
        """"""
        try:
            # Attempt to open and write to the file
            with open(self.file_path, 'w') as file:
                # Use the write method to write the content
                file.write(str(content))
        except Exception as e:
            # If an error occurs, print the error message
            print(f""An error occurred: {e}"")

    # Method to process the file by removing non-alphabetic characters
    def process_file(self):
        """"""
        Read the self.file_path file and filter out non-alphabetic characters from the content string.
        Overwrite the after-processed data into the same self.file_path file.
        """"""
        try:
            # Attempt to open and read the file
            with open(self.file_path, 'r') as file:
                # Use the read method to get the file content
                content = file.read()
                # Use a list comprehension to filter out non-alphabetic characters
                processed_content = ''.join([char for char in content if char.isalpha()])
                # Attempt to open and write to the file
                with open(self.file_path, 'w') as file:
                    # Use the write method to write the processed content
                    file.write(processed_content)
                return processed_content
        except Exception as e:
            # If an error occurs, print the error message
            print(f""An error occurred: {e}"")
```",0.05476190476190477,0.06780220877454933,0.9210526315789473,0.25735294117647056,0.4022988471607874,0.6379310344827587,0.1423076923076923,0.23270439953324634,0.9210526315789473,0.25735294117647056,0.4022988471607874
Llama,85,"import time

class Thermostat:
    def __init__(self, current_temperature, target_temperature, mode):
        self.current_temperature = current_temperature
        self.target_temperature = target_temperature
        self.mode = mode

    def get_target_temperature(self):
        return self.target_temperature

    def set_target_temperature(self, temperature):
        self.target_temperature = temperature

    def get_mode(self):
        return self.mode

    def set_mode(self, mode):
        if mode in ['heat', 'cool']:
            self.mode = mode
        else:
            return False

    def auto_set_mode(self):
        if self.current_temperature < self.target_temperature:
            self.mode = 'heat'
        else:
            self.mode = 'cool'

    def auto_check_conflict(self):
        if self.current_temperature > self.target_temperature:
            if self.mode == 'cool':
                return True
            else:
                self.auto_set_mode()
                return False
        else:
            if self.mode == 'heat':
                return True
            else:
                self.auto_set_mode()
                return False

    def simulate_operation(self):
        self.auto_set_mode()
        use_time = 0
        if self.mode == 'heat':
            while(self.current_temperature < self.target_temperature):
                self.current_temperature += 1
                use_time += 1
        else:
            while(self.current_temperature > self.target_temperature):
                self.current_temperature -= 1
                use_time += 1
        return use_time",FewShot,"

```python
class Thermostat:
    """"""
    The class manages temperature control, including setting and retrieving the target temperature, adjusting the mode, and simulating temperature operation.
    """"""

    def __init__(self, current_temperature, target_temperature, mode):
        """"""
        initialize instances of the Thermostat class, including the current temperature, target temperature, and operating mode.
        :param current_temperature: float
        :param target_temperature: float
        :param mode: str, the work mode
        """"""
        self.current_temperature = current_temperature
        self.target_temperature = target_temperature
        self.mode = mode

    def get_target_temperature(self):
        # Return the target temperature of the thermostat
        return self.target_temperature

    def set_target_temperature(self, temperature):
        # Set the target temperature of the thermostat
        self.target_temperature = temperature

    def get_mode(self):
        # Return the current operating mode of the thermostat
        return self.mode

    def set_mode(self, mode):
        # Set the operating mode of the thermostat
        if mode in ['heat', 'cool']:
            self.mode = mode
        else:
            raise ValueError(""Invalid mode. Mode should be either 'heat' or 'cool'."")

    def auto_set_mode(self):
        # Automatically set the operating mode based on the current and target temperatures
        if self.current_temperature < self.target_temperature:
            self.mode = 'heat'
        else:
            self.mode = 'cool'

    def auto_check_conflict(self):
        # Check if there is a conflict between the operating mode and the temperature relationship
        if (self.mode == 'heat' and self.current_temperature >= self.target_temperature) or \
           (self.mode == 'cool' and self.current_temperature <= self.target_temperature):
            self.auto_set_mode()
            return False
        return True

    def simulate_operation(self):
        # Simulate the operation of the thermostat
        start_time = time.time()
        self.auto_set_mode()
        while abs(self.current_temperature - self.target_temperature) > 0.1:
            if self.mode == 'heat':
                self.current_temperature += 0.1
            else:
                self.current_temperature -= 0.1
            time.sleep(1)  # Simulate a 1-second delay
        end_time = time.time()
        return int(end_time - start_time)
```",0.1728395061728395,0.20781871589854642,0.9148936170212766,0.3739130434782609,0.5308641934118276,0.6195652173913043,0.2651162790697674,0.3713355006886015,0.9148936170212766,0.3739130434782609,0.5308641934118276
Llama,86,"class TicTacToe:
    def __init__(self, N=3):
        self.board = [[' ' for _ in range(N)] for _ in range(3)]
        self.current_player = 'X'

    def make_move(self, row, col):
        if self.board[row][col] == ' ':
            self.board[row][col] = self.current_player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            return True
        else:
            return False

    def check_winner(self):
        for row in self.board:
            if row[0] == row[1] == row[2] != ' ':
                return row[0]
        for col in range(3):
            if self.board[0][col] == self.board[1][col] == self.board[2][col] != ' ':
                return self.board[0][col]
        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':
            return self.board[0][0]
        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':
            return self.board[0][2]
        return None

    def is_board_full(self):
        for row in self.board:
            if ' ' in row:
                return False
        return True",FewShot,"

```python
class TicTacToe:
    """"""
    The class represents a game of Tic-Tac-Toe and its functions include making a move on the board, checking for a winner, and determining if the board is full.
    """"""

    def __init__(self, N=3):
        """"""
        Initialize a 3x3 game board with all empty spaces and current symbol player, default is 'X'.
        """"""
        # Create a 3x3 game board with all empty spaces
        self.board = [[' ' for _ in range(N)] for _ in range(3)]
        # Set the current player to 'X'
        self.current_player = 'X'

    def make_move(self, row, col):
        """"""
        Place the current player's mark at the specified position on the board and switch the mark.
        :param row: int, the row index of the position
        :param col: int, the column index of the position
        :return: bool, indicating whether the move was successful or not
        """"""
        # Check if the position is empty
        if self.board[row][col] == ' ':
            # Place the current player's mark at the specified position
            self.board[row][col] = self.current_player
            # Switch the current player
            self.current_player = 'O' if self.current_player == 'X' else 'X'
            # Return True to indicate a successful move
            return True
        # Return False to indicate an unsuccessful move
        return False

    def check_winner(self):
        """"""
        Check if there is a winner on the board in rows, columns and diagonals three directions
        :return: str or None, the mark of the winner ('X' or 'O'), or None if there is no winner yet
        """"""
        # Check rows for a winner
        for row in self.board:
            if row[0] == row[1] == row[2] != ' ':
                return row[0]
        # Check columns for a winner
        for col in range(3):
            if self.board[0][col] == self.board[1][col] == self.board[2][col] != ' ':
                return self.board[0][col]
        # Check diagonals for a winner
        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':
            return self.board[0][0]
        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':
            return self.board[0][2]
        # Return None if no winner is found
        return None

    def is_board_full(self):
        """"""
        Check if the game board is completely filled.
        :return: bool, indicating whether the game board is full or not
        """"""
        # Check if any position on the board is empty
        for row in self.board:
            if ' ' in row:
                # Return False if the board is not full
                return False
        # Return True if the board is full
        return True
```",0.22281167108753316,0.2424389484800035,0.98,0.37404580152671757,0.5414364600897409,0.8350515463917526,0.2967032967032967,0.43783783396917464,0.98,0.37404580152671757,0.5414364600897409
Llama,87,"import datetime
import time

class TimeUtils:

    def __init__(self):
        self.datetime = datetime.datetime.now()

    def get_current_time(self):
        format = ""%H:%M:%S""
        return self.datetime.strftime(format)

    def get_current_date(self):
        format = ""%Y-%m-%d""
        return self.datetime.strftime(format)

    def add_seconds(self, seconds):
        new_datetime = self.datetime + datetime.timedelta(seconds=seconds)
        format = ""%H:%M:%S""
        return new_datetime.strftime(format)

    def string_to_datetime(self, string):
        return datetime.datetime.strptime(string, ""%Y-%m-%d %H:%M:%S"")

    def datetime_to_string(self, datetime):
        return datetime.strftime(""%Y-%m-%d %H:%M:%S"")

    def get_minutes(self, string_time1, string_time2):
        time1 = self.string_to_datetime(string_time1)
        time2 = self.string_to_datetime(string_time2)
        return round((time2 - time1).seconds / 60)

    def get_format_time(self, year, month, day, hour, minute, second):
        format = ""%Y-%m-%d %H:%M:%S""
        time_item = datetime.datetime(year, month, day, hour, minute, second)
        return time_item.strftime(format)",FewShot,"

```python
import datetime
import time

class TimeUtils:
    """"""
    This is a time util class, including getting the current time and date, adding seconds to a datetime, converting between strings and datetime objects, calculating the time difference in minutes, and formatting a datetime object.
    """"""

    def __init__(self):
        """"""
        Get the current datetime
        """"""
        self.datetime = datetime.datetime.now()

    def get_current_time(self):
        """"""
        Return the current time in the format of '%H:%M:%S'
        :return: string
        >>> timeutils = TimeUtils()
        >>> timeutils.get_current_time()
        ""19:19:22""
        """"""
        # Use strftime to format the current time as a string
        return self.datetime.strftime('%H:%M:%S')

    def get_current_date(self):
        """"""
        Return the current date in the format of ""%Y-%m-%d""
        :return: string
        >>> timeutils = TimeUtils()
        >>> timeutils.get_current_date()
        ""2023-06-14""
        """"""
        # Use strftime to format the current date as a string
        return self.datetime.strftime('%Y-%m-%d')

    def add_seconds(self, seconds):
        """"""
        Add the specified number of seconds to the current time
        :param seconds: int, number of seconds to add
        :return: string, time after adding the specified number of seconds in the format '%H:%M:%S'
        >>> timeutils.add_seconds(600)
        ""19:29:22""
        """"""
        # Add seconds to the current time using timedelta
        new_time = self.datetime + datetime.timedelta(seconds=seconds)
        # Use strftime to format the new time as a string
        return new_time.strftime('%H:%M:%S')

    def string_to_datetime(self, string):
        """"""
        Convert the time string to a datetime instance
        :param string: string, string before converting format
        :return: datetime instance
        >>> timeutils.string_to_datetime(""2001-7-18 1:1:1"")
        2001-07-18 01:01:01
        """"""
        # Use strptime to parse the string into a datetime object
        return datetime.datetime.strptime(string, '%Y-%m-%d %H:%M:%S')

    def datetime_to_string(self, datetime):
        """"""
        Convert a datetime instance to a string
        :param datetime: the datetime instance to convert
        :return: string, converted time string
        >>> timeutils.datetime_to_string(timeutils.datetime)
        ""2023-06-14 19:30:03""
        """"""
        # Use strftime to format the datetime object as a string
        return datetime.strftime('%Y-%m-%d %H:%M:%S')

    def get_minutes(self, string_time1, string_time2):
        """"""
        Calculate how many minutes have passed between two times, and round the results to the nearest
        :return: int, the number of minutes between two times, rounded off
        >>> timeutils.get_minutes(""2001-7-18 1:1:1"", ""2001-7-18 2:1:1"")
        60
        """"""
        # Convert the strings to datetime objects
        time1 = self.string_to_datetime(string_time1)
        time2 = self.string_to_datetime(string_time2)
        # Calculate the difference between the two times
        difference = time2 - time1
        # Convert the difference to minutes and round to the nearest minute
        minutes = round(difference.total_seconds() / 60)
        return minutes

    def get_format_time(self, year, month, day, hour, minute, second):
        """"""
        get format time
        :param year: int
        :param month: int
        :param day: int
        :param hour: int
        :param minute: int
        :param second: int
        :return: formatted time string
        >>> timeutils.get_format_time(2001, 7, 18, 1, 1, 1)
        ""2001-07-18 01:01:01""
        """"""
        # Create a datetime object from the given parameters
        datetime_object = datetime.datetime(year, month, day, hour, minute, second)
        # Use strftime to format the datetime object as a string
        return datetime_object.strftime('%Y-%m-%d %H:%M:%S')
```",0.06666666666666667,0.08327200094590817,0.8148148148148148,0.2573099415204678,0.3911111074631112,0.5411764705882353,0.1419753086419753,0.22493887201296028,0.8148148148148148,0.2573099415204678,0.3911111074631112
Llama,88,"from math import pi, fabs


class TriCalculator:

    def __init__(self):
        pass

    def cos(self, x):
        return round(self.taylor(x, 50), 10)

    def factorial(self, a):
        b = 1
        while a != 1:
            b *= a
            a -= 1
        return b

    def taylor(self, x, n):
        a = 1
        x = x / 180 * pi
        count = 1
        for k in range(1, n):
            if count % 2 != 0:
                a -= (x ** (2 * k)) / self.factorial(2 * k)
            else:
                a += (x ** (2 * k)) / self.factorial(2 * k)
            count += 1
        return a

    def sin(self, x):
        x = x / 180 * pi
        g = 0
        t = x
        n = 1

        while fabs(t) >= 1e-15:
            g += t
            n += 1
            t = -t * x * x / (2 * n - 1) / (2 * n - 2)
        return round(g, 10)

    def tan(self, x):
        if self.cos(x) != 0:
            result = self.sin(x) / self.cos(x)
            return round(result, 10)
        else:
            return False",FewShot,"

```python
from math import pi, fabs

class TriCalculator:
    """"""
    The class allows to calculate trigonometric values, including cosine, sine, and tangent, using Taylor series approximations.
    """"""

    def __init__(self):
        pass

    # Calculate the cos value of the x-degree angle using Taylor series approximation
    def cos(self, x):
        """"""
        Calculate the cos value of the x-degree angle
        :param x:float
        :return:float
        >>> tricalculator = TriCalculator()
        >>> tricalculator.cos(60)
        0.5
        """"""
        return self.taylor(x, 50)  # Use 50 terms for Taylor series approximation

    # Calculate the factorial of a number
    def factorial(self, a):
        """"""
        Calculate the factorial of a
        :param a: int
        :return: int
        >>> tricalculator.factorial(5)
        120
        """"""
        result = 1
        for i in range(1, a + 1):
            result *= i
        return result

    # Calculate the n-order Taylor expansion value of cos (x/180 * pi)
    def taylor(self, x, n):
        """"""
        Finding the n-order Taylor expansion value of cos (x/180 * pi)
        :param x: int
        :param n: int
        :return: float
        >>> tricalculator.taylor(60, 50)
        0.5000000000000001
        """"""
        result = 0
        for i in range(n):
            sign = (-1) ** i
            result += ((x / 180 * pi) ** (2 * i)) / self.factorial(2 * i) * sign
        return result

    # Calculate the sin value of the x-degree angle using Taylor series approximation
    def sin(self, x):
        """"""
        Calculate the sin value of the x-degree angle
        :param x: float
        :return: float
        >>> tricalculator.sin(30)
        0.5
        """"""
        result = 0
        for i in range(50):  # Use 50 terms for Taylor series approximation
            sign = (-1) ** i
            result += ((x / 180 * pi) ** (2 * i + 1)) / self.factorial(2 * i + 1) * sign
        return result

    # Calculate the tan value of the x-degree angle using sin and cos values
    def tan(self, x):
        """"""
        Calculate the tan value of the x-degree angle
        :param x: float
        :return: float
        >>> tricalculator.tan(45)
        1.0
        """"""
        return self.sin(x) / self.cos(x)
```",0.06600660066006599,0.07612993629842003,0.5616438356164384,0.36283185840707965,0.4408602102850041,0.26153846153846155,0.18085106382978725,0.21383647315375193,0.5068493150684932,0.3274336283185841,0.39784945759683205
Llama,89,"import random


class TwentyFourPointGame:
    def __init__(self) -> None:
        self.nums = []

    def _generate_cards(self):
        for i in range(4):
            self.nums.append(random.randint(1, 9))
        assert len(self.nums) == 4

    def get_my_cards(self):
        self.nums = []
        self._generate_cards()
        return self.nums

    def answer(self, expression):
        if expression == 'pass':
            return self.get_my_cards()
        statistic = {}
        for c in expression:
            if c.isdigit() and int(c) in self.nums:
                statistic[c] = statistic.get(c, 0) + 1

        nums_used = statistic.copy()

        for num in self.nums:
            if nums_used.get(str(num), -100) != -100 and nums_used[str(num)] > 0:
                nums_used[str(num)] -= 1
            else:
                return False

        if all(count == 0 for count in nums_used.values()) == True:
            return self.evaluate_expression(expression)
        else:
            return False

    def evaluate_expression(self, expression):
        try:
            if eval(expression) == 24:
                return True
            else:
                return False
        except Exception as e:
            return False",FewShot,"

```python
import random

class TwentyFourPointGame:
    """"""
    This is a game of twenty-four points, which provides to generate four numbers and check whether player's expression is equal to 24.
    """"""

    def __init__(self) -> None:
        # Initialize an empty list to store the generated numbers
        self.nums = []

    def _generate_cards(self):
        # Generate four random numbers between 1 and 9
        self.nums = random.sample(range(1, 10), 4)

    def get_my_cards(self):
        # Generate the numbers if they haven't been generated yet
        if not self.nums:
            self._generate_cards()
        # Return the list of generated numbers
        return self.nums

    def answer(self, expression):
        # Replace the numbers in the expression with the actual numbers
        for i, num in enumerate(self.nums):
            expression = expression.replace(str(i+1), str(num))
        # Evaluate the expression
        return self.evaluate_expression(expression)

    def evaluate_expression(self, expression):
        # Try to evaluate the expression
        try:
            # Use eval to evaluate the expression
            result = eval(expression)
            # Check if the result is 24
            return result == 24
        except:
            # If an error occurs, return False
            return False
```",0.07051282051282051,0.10488922975106714,0.4266666666666667,0.34782608695652173,0.3832335279859443,0.19827586206896552,0.1513157894736842,0.1716417861349968,0.4266666666666667,0.34782608695652173,0.3832335279859443
Llama,90,"class URLHandler:
    def __init__(self, url):
        self.url = url

    def get_scheme(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            return self.url[:scheme_end]
        return None

    def get_host(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            url_without_scheme = self.url[scheme_end + 3:]
            host_end = url_without_scheme.find(""/"")
            if host_end != -1:
                return url_without_scheme[:host_end]
            return url_without_scheme
        return None

    def get_path(self):
        scheme_end = self.url.find(""://"")
        if scheme_end != -1:
            url_without_scheme = self.url[scheme_end + 3:]
            host_end = url_without_scheme.find(""/"")
            if host_end != -1:
                return url_without_scheme[host_end:]
        return None

    def get_query_params(self):
        query_start = self.url.find(""?"")
        fragment_start = self.url.find(""#"")
        if query_start != -1:
            query_string = self.url[query_start + 1:fragment_start]
            params = {}
            if len(query_string) > 0:
                param_pairs = query_string.split(""&"")
                for pair in param_pairs:
                    key_value = pair.split(""="")
                    if len(key_value) == 2:
                        key, value = key_value
                        params[key] = value
            return params
        return None

    def get_fragment(self):
        fragment_start = self.url.find(""#"")
        if fragment_start != -1:
            return self.url[fragment_start + 1:]
        return None",FewShot,"

```python
from urllib.parse import urlparse, parse_qs

class URLHandler:
    """"""
    The class supports to handle URLs, including extracting the scheme, host, path, query parameters, and fragment.
    """"""

    def __init__(self, url):
        """"""
        Initialize URLHandler's URL
        """"""
        self.url = url

    # Get the scheme of the URL
    def get_scheme(self):
        """"""
        get the scheme of the URL
        :return: string, If successful, return the scheme of the URL
        """"""
        # Use urlparse to break the URL into its components
        parsed_url = urlparse(self.url)
        # Return the scheme
        return parsed_url.scheme

    # Get the host domain name of the URL
    def get_host(self):
        """"""
        Get the second part of the URL, which is the host domain name
        :return: string, If successful, return the host domain name of the URL
        """"""
        # Use urlparse to break the URL into its components
        parsed_url = urlparse(self.url)
        # Return the hostname
        return parsed_url.hostname

    # Get the path of the URL
    def get_path(self):
        """"""
        Get the third part of the URL, which is the address of the resource
        :return: string, If successful, return the address of the resource of the URL
        """"""
        # Use urlparse to break the URL into its components
        parsed_url = urlparse(self.url)
        # Return the path
        return parsed_url.path

    # Get the query parameters of the URL
    def get_query_params(self):
        """"""
        Get the request parameters for the URL
        :return: dict, If successful, return the request parameters of the URL
        """"""
        # Use urlparse to break the URL into its components
        parsed_url = urlparse(self.url)
        # Use parse_qs to parse the query string into a dictionary
        query_params = parse_qs(parsed_url.query)
        # Return the query parameters
        return query_params

    # Get the fragment of the URL
    def get_fragment(self):
        """"""
        Get the fragment after '#' in the URL
        :return: string, If successful, return the fragment after '#' of the URL
        """"""
        # Use urlparse to break the URL into its components
        parsed_url = urlparse(self.url)
        # Return the fragment
        return parsed_url.fragment
```",0.006451612903225806,0.06994617254607556,0.2807017543859649,0.18604651162790697,0.2237762189818574,0.10784313725490197,0.07432432432432433,0.08799999516928027,0.2807017543859649,0.18604651162790697,0.2237762189818574
Llama,91,"import urllib.parse


class UrlPath:
    def __init__(self):
        self.segments = []
        self.with_end_tag = False

    def add(self, segment):
        self.segments.append(self.fix_path(segment))

    def parse(self, path, charset):
        if path:
            if path.endswith('/'):
                self.with_end_tag = True

            path = self.fix_path(path)
            if path:
                split = path.split('/')
                for seg in split:
                    decoded_seg = urllib.parse.unquote(seg, encoding=charset)
                    self.segments.append(decoded_seg)

    @staticmethod
    def fix_path(path):
        if not path:
            return ''

        segment_str = path.strip('/')
        return segment_str",FewShot,"

```python
import urllib.parse

class UrlPath:
    """"""
    The  class is a utility for encapsulating and manipulating the path component of a URL, including adding nodes, parsing path strings, and building path strings with optional encoding.
    """"""

    def __init__(self):
        """"""
        Initializes the UrlPath object with an empty list of segments and a flag indicating the presence of an end tag.
        """"""
        # Initialize an empty list to store the path segments
        self.segments = []
        # Initialize a flag to track if an end tag is present
        self.with_end_tag = False

    def add(self, segment):
        """"""
        Adds a segment to the list of segments in the UrlPath.
        :param segment: str, the segment to add.
        """"""
        # Append the segment to the list of segments
        self.segments.append(segment)

    def parse(self, path, charset):
        """"""
        Parses a given path string and populates the list of segments in the UrlPath.
        :param path: str, the path string to parse.
        :param charset: str, the character encoding of the path string.
        """"""
        # Remove leading and trailing slashes from the path
        path = self.fix_path(path)
        # Split the path into segments using '/' as the separator
        segments = path.split('/')
        # Iterate over each segment and add it to the list of segments
        for segment in segments:
            # Check if the segment is not empty
            if segment:
                # Unquote the segment to decode any URL-encoded characters
                segment = urllib.parse.unquote(segment)
                # Add the segment to the list of segments
                self.add(segment)

    @staticmethod
    def fix_path(path):
        """"""
        Fixes the given path string by removing leading and trailing slashes.
        :param path: str, the path string to fix.
        :return: str, the fixed path string.
        """"""
        # Remove leading slashes from the path
        path = path.lstrip('/')
        # Remove trailing slashes from the path
        path = path.rstrip('/')
        # Return the fixed path
        return path
```",0.03806228373702422,0.04907947348099986,0.6744186046511628,0.2457627118644068,0.36024844328999656,0.390625,0.1152073732718894,0.1779359395428123,0.6744186046511628,0.2457627118644068,0.36024844328999656
Llama,92,"import sqlite3


class UserLoginDB:
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()

    def insert_user(self, username, password):
        self.cursor.execute('''
            INSERT INTO users (username, password)
            VALUES (?, ?)
        ''', (username, password))
        self.connection.commit()

    def search_user_by_username(self, username):
        self.cursor.execute('''
            SELECT * FROM users WHERE username = ?
        ''', (username,))
        user = self.cursor.fetchone()
        return user

    def delete_user_by_username(self, username):
        self.cursor.execute('''
            DELETE FROM users WHERE username = ?
        ''', (username,))
        self.connection.commit()

    def validate_user_login(self, username, password):
        user = self.search_user_by_username(username)
        if user is not None and user[1] == password:
            return True
        return False",FewShot,"

```python
import sqlite3

class UserLoginDB:
    """"""
    This is a database management class for user login verification, providing functions for inserting user information, searching user information, deleting user information, and validating user login.
    """"""

    def __init__(self, db_name):
        """"""
        Initializes the UserLoginDB object with the specified database name.
        :param db_name: str, the name of the SQLite database.
        """"""
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()

    # Create a table for storing user information
    def create_table(self):
        # Create table query
        query = """"""CREATE TABLE IF NOT EXISTS users (
            username TEXT PRIMARY KEY,
            password TEXT
        )""""""
        self.cursor.execute(query)
        self.connection.commit()

    def insert_user(self, username, password):
        """"""
        Inserts a new user into the ""users"" table.
        :param username: str, the username of the user.
        :param password: str, the password of the user.
        :return: None
        """"""
        # Insert user query
        query = """"""INSERT INTO users (username, password) VALUES (?, ?)""""""
        self.cursor.execute(query, (username, password))
        self.connection.commit()

    def search_user_by_username(self, username):
        """"""
        Searches for users in the ""users"" table by username.
        :param username: str, the username of the user to search for.
        :return:list of tuples, the rows from the ""users"" table that match the search criteria.
        """"""
        # Search user query
        query = """"""SELECT * FROM users WHERE username = ?""""""
        self.cursor.execute(query, (username,))
        return self.cursor.fetchall()

    def delete_user_by_username(self, username):
        """"""
        Deletes a user from the ""users"" table by username.
        :param username: str, the username of the user to delete.
        :return: None
        """"""
        # Delete user query
        query = """"""DELETE FROM users WHERE username = ?""""""
        self.cursor.execute(query, (username,))
        self.connection.commit()

    def validate_user_login(self, username, password):
        """"""
        Determine whether the user can log in, that is, the user is in the database and the password is correct
        :param username:str, the username of the user to validate.
        :param password:str, the password of the user to validate.
        :return:bool, representing whether the user can log in correctly
        """"""
        # Validate user login query
        query = """"""SELECT * FROM users WHERE username = ? AND password = ?""""""
        self.cursor.execute(query, (username, password))
        return len(self.cursor.fetchall()) > 0

# Example usage
if __name__ == ""__main__"":
    user_db = UserLoginDB(""user_database.db"")
    user_db.create_table()
    user_db.insert_user('user1', 'pass1')
    result = user_db.search_user_by_username('user1')
    print(len(result))  # Output: 1
    user_db.delete_user_by_username('user1')
    print(user_db.validate_user_login('user1', 'pass1'))  # Output: False
```",0.08645533141210375,0.1027228829575661,0.7962962962962963,0.27044025157232704,0.4037558647596377,0.5194805194805194,0.14760147601476015,0.22988505402513545,0.7962962962962963,0.27044025157232704,0.4037558647596377
Llama,93,"import numpy as np
from gensim import matutils
from numpy import dot, array


class VectorUtil:
    @staticmethod
    def similarity(vector_1, vector_2):
        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))

    @staticmethod
    def cosine_similarities(vector_1, vectors_all):
        norm = np.linalg.norm(vector_1)
        all_norms = np.linalg.norm(vectors_all, axis=1)
        dot_products = dot(vectors_all, vector_1)
        similarities = dot_products / (norm * all_norms)
        return similarities

    @staticmethod
    def n_similarity(vector_list_1, vector_list_2):
        if not (len(vector_list_1) and len(vector_list_2)):
            raise ZeroDivisionError('At least one of the passed list is empty.')

        return dot(matutils.unitvec(array(vector_list_1).mean(axis=0)),
                   matutils.unitvec(array(vector_list_2).mean(axis=0)))

    @staticmethod
    def compute_idf_weight_dict(total_num, number_dict):
        index_2_key_map = {}

        index = 0

        count_list = []
        for key, count in number_dict.items():
            index_2_key_map[index] = key
            count_list.append(count)
            index = index + 1

        a = np.array(count_list)
        ## smooth, in case the divide by zero error
        a = np.log((total_num + 1) / (a + 1))
        result = {}

        for index, w in enumerate(a):
            key = index_2_key_map[index]
            result[key] = w

        return result",FewShot,"

```python
import numpy as np
from gensim import matutils
from numpy import dot, array

class VectorUtil:
    """"""
    The class provides vector operations, including calculating similarity, cosine similarities, average similarity, and IDF weights.
    """"""

    @staticmethod
    def similarity(vector_1, vector_2):
        # Compute the cosine similarity between one vector and another vector
        # Using the dot product and magnitude of vectors
        return dot(vector_1, vector_2) / (np.linalg.norm(vector_1) * np.linalg.norm(vector_2))

    @staticmethod
    def cosine_similarities(vector_1, vectors_all):
        # Compute cosine similarities between one vector and a set of other vectors
        # Using list comprehension to calculate similarity for each vector
        return [VectorUtil.similarity(vector_1, vector) for vector in vectors_all]

    @staticmethod
    def n_similarity(vector_list_1, vector_list_2):
        # Compute cosine similarity between two sets of vectors
        # Calculate the average of the cosine similarities of the vectors
        similarities = []
        for vector1 in vector_list_1:
            for vector2 in vector_list_2:
                similarities.append(VectorUtil.similarity(vector1, vector2))
        return np.mean(similarities)

    @staticmethod
    def compute_idf_weight_dict(total_num, number_dict):
        # Calculate log(total_num+1/count+1) for each count in number_dict
        # Using dictionary comprehension to calculate IDF weights
        return {key: np.log(total_num + 1) - np.log(value + 1) for key, value in number_dict.items()}
```",0.12941176470588234,0.16803745812206125,0.4421052631578947,0.42424242424242425,0.43298968572377516,0.24444444444444444,0.21019108280254778,0.22602739228865654,0.42105263157894735,0.40404040404040403,0.4123711290227442
Llama,94,"class VendingMachine:
    def __init__(self):
        self.inventory = {}
        self.balance = 0

    def add_item(self, item_name, price, quantity):
        if not self.restock_item(item_name, quantity):
            self.inventory[item_name] = {'price': price, 'quantity': quantity}

    def insert_coin(self, amount):
        self.balance += amount
        return self.balance

    def purchase_item(self, item_name):
        if item_name in self.inventory:
            item = self.inventory[item_name]
            if item['quantity'] > 0 and self.balance >= item['price']:
                self.balance -= item['price']
                item['quantity'] -= 1
                return self.balance
            else:
                return False
        else:
            return False

    def restock_item(self, item_name, quantity):
        if item_name in self.inventory:
            self.inventory[item_name]['quantity'] += quantity
            return True
        else:
            return False

    def display_items(self):
        if not self.inventory:
            return False
        else:
            items = []
            for item_name, item_info in self.inventory.items():
                items.append(f""{item_name} - ${item_info['price']} [{item_info['quantity']}]"")
            return ""\n"".join(items)",FewShot,"

```python
class VendingMachine:
    """"""
    This is a class to simulate a vending machine, including adding products, inserting coins, purchasing products, viewing balance, replenishing product inventory, and displaying product information.
    """"""

    def __init__(self):
        """"""
        Initializes the vending machine's inventory and balance.
        """"""
        self.inventory = {}  # dictionary to store products and their details
        self.balance = 0  # initial balance of the vending machine

    def add_item(self, item_name, price, quantity):
        """"""
        Adds a product to the vending machine's inventory.
        :param item_name: The name of the product to be added, str.
        :param price: The price of the product to be added, float.
        :param quantity: The quantity of the product to be added, int.
        :return: None
        """"""
        # add product to inventory with its price and quantity
        self.inventory[item_name] = {'price': price, 'quantity': quantity}

    def insert_coin(self, amount):
        """"""
        Inserts coins into the vending machine.
        :param amount: The amount of coins to be inserted, float.
        :return: The balance of the vending machine after the coins are inserted, float.
        """"""
        # update the balance by adding the inserted amount
        self.balance += amount
        return self.balance

    def purchase_item(self, item_name):
        """"""
        Purchases a product from the vending machine and returns the balance after the purchase and display purchase unsuccessful if the product is out of stock.
        :param item_name: The name of the product to be purchased, str.
        :return: If successful, returns the balance of the vending machine after the product is purchased, float, otherwise, returns False.
        """"""
        # check if the product is available in the inventory
        if item_name in self.inventory:
            # check if the product is in stock
            if self.inventory[item_name]['quantity'] > 0:
                # check if the balance is sufficient to purchase the product
                if self.balance >= self.inventory[item_name]['price']:
                    # update the balance by subtracting the product's price
                    self.balance -= self.inventory[item_name]['price']
                    # update the product's quantity
                    self.inventory[item_name]['quantity'] -= 1
                    return self.balance
                else:
                    # not enough balance to purchase the product
                    return False
            else:
                # product is out of stock
                return False
        else:
            # product is not available in the inventory
            return False

    def restock_item(self, item_name, quantity):
        """"""
        Replenishes the inventory of a product already in the vending machine.
        :param item_name: The name of the product to be replenished, str.
        :param quantity: The quantity of the product to be replenished, int.
        :return: If the product is already in the vending machine, returns True, otherwise, returns False.
        """"""
        # check if the product is already in the inventory
        if item_name in self.inventory:
            # update the product's quantity
            self.inventory[item_name]['quantity'] += quantity
            return True
        else:
            # product is not available in the inventory
            return False

    def display_items(self):
        """"""
        Displays the products in the vending machine.
        :return: If the vending machine is empty, returns False, otherwise, returns a list of the products in the vending machine, str.
        """"""
        # check if the vending machine is empty
        if not self.inventory:
            return False
        else:
            # create a string to display the products
            items_string = ''
            for item in self.inventory:
                items_string += f""{item} - ${self.inventory[item]['price']} [{self.inventory[item]['quantity']}] ""
            return items_string
```",0.0819672131147541,0.09790749826972621,0.7758620689655172,0.30201342281879195,0.4347826046619525,0.5520833333333334,0.16878980891719744,0.2585365817794171,0.7586206896551724,0.2953020134228188,0.42512076891316025
Llama,95,"class Warehouse:
    def __init__(self):
        self.inventory = {}  # Product ID: Product
        self.orders = {}  # Order ID: Order

    def add_product(self, product_id, name, quantity):
        if product_id not in self.inventory:
            self.inventory[product_id] = {'name': name, 'quantity': quantity}
        else:
            self.inventory[product_id]['quantity'] += quantity

    def update_product_quantity(self, product_id, quantity):
        if product_id in self.inventory:
            self.inventory[product_id]['quantity'] += quantity

    def get_product_quantity(self, product_id):
        if product_id in self.inventory:
            return self.inventory[product_id]['quantity']
        else:
            return False

    def create_order(self, order_id, product_id, quantity):
        if self.get_product_quantity(product_id) >= quantity:
            self.update_product_quantity(product_id, -quantity)
            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}
        else:
            return False

    def change_order_status(self, order_id, status):
        if order_id in self.orders:
            self.orders[order_id]['status'] = status
        else:
            return False

    def track_order(self, order_id):
        if order_id in self.orders:
            return self.orders[order_id]['status']
        else:
            return False",FewShot,"

```python
class Warehouse:
    """"""
    The class manages inventory and orders, including adding products, updating product quantities, retrieving product quantities, creating orders, changing order statuses, and tracking orders.
    """"""

    def __init__(self):
        """"""
        Initialize two fields.
        self.inventory is a dict that stores the products.
        self.inventory = {Product ID: Product}
        self.orders is a dict that stores the products in a order.
        self.orders = {Order ID: Order}
        """"""
        self.inventory = {}  # Product ID: Product
        self.orders = {}  # Order ID: Order

    def add_product(self, product_id, name, quantity):
        """"""
        Add product to inventory and plus the quantity if it has existed in inventory.
        Or just add new product to dict otherwise.
        :param product_id: int
        :param name: str, product name
        :param quantity: int, product quantity
        >>> warehouse.add_product(1, ""product1"", 3)
        >>> warehouse.inventory
        {1: {'name': 'product1', 'quantity': 3}}
        """"""
        # Check if product_id already exists in inventory
        if product_id in self.inventory:
            # If it exists, update the quantity
            self.inventory[product_id]['quantity'] += quantity
        else:
            # If it doesn't exist, add a new product to the inventory
            self.inventory[product_id] = {'name': name, 'quantity': quantity}

    def update_product_quantity(self, product_id, quantity):
        """"""
        According to product_id, add the quantity to the corresponding product in inventory.
        >>> warehouse.add_product(1, ""product1"", 3)
        >>> warehouse.update_product_quantity(1, -1)
        >>> warehouse.inventory
        {1: {'name': 'product1', 'quantity': 2}}
        """"""
        # Check if product_id exists in inventory
        if product_id in self.inventory:
            # Update the quantity
            self.inventory[product_id]['quantity'] += quantity
        else:
            # If product_id doesn't exist, do nothing
            pass

    def get_product_quantity(self, product_id):
        """"""
        Get the quantity of specific product by product_id.
        :param product_id, int
        :return: if the product_id is in inventory then return the corresponding quantity,
                or False otherwise.
        >>> warehouse.add_product(1, ""product1"", 3)
        >>> warehouse.get_product_quantity(1)
        3
        >>> warehouse.get_product_quantity(2)
        False
        """"""
        # Check if product_id exists in inventory
        if product_id in self.inventory:
            # Return the quantity
            return self.inventory[product_id]['quantity']
        else:
            # If product_id doesn't exist, return False
            return False

    def create_order(self, order_id, product_id, quantity):
        """"""
        Create a order which includes the infomation of product, like id and quantity.
        And put the new order into self.orders.
        The default value of status is 'Shipped'.
        :param order_id: int
        :param product_id: int
        :param quantity: the quantity of product that be selected.
        :return False: only if product_id is not in inventory or the quantity is not adequate
        >>> warehouse.add_product(1, ""product1"", 3)
        >>> warehouse.create_order(1, 1, 2)
        >>> warehouse.orders
        {1: {'product_id': 1, 'quantity': 2, 'status': 'Shipped'}}
        >>> warehouse.create_order(1, 2, 2)
        False
        """"""
        # Check if product_id exists in inventory and if the quantity is adequate
        if product_id in self.inventory and self.inventory[product_id]['quantity'] >= quantity:
            # Create a new order
            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}
            # Update the quantity of the product in inventory
            self.inventory[product_id]['quantity'] -= quantity
            # Return True
            return True
        else:
            # If product_id doesn't exist or the quantity is not adequate, return False
            return False

    def change_order_status(self, order_id, status):
        """"""
        Change the status of order if the input order_id is in self.orders.
        :param order_id: int
        :param status: str, the state that is going to change to
        :return False: only if the order_id is not in self.orders
        >>> warehouse.add_product(1, ""product1"", 3)
        >>> warehouse.create_order(1, 1, 2)
        >>> warehouse.change_order_status(1, ""done"")
        >>> warehouse.orders
        {1: {'product_id': 1, 'quantity': 2, 'status': 'done'}}
        """"""
        # Check if order_id exists in orders
        if order_id in self.orders:
            # Update the status of the order
            self.orders[order_id]['status'] = status
            # Return True
            return True
        else:
            # If order_id doesn't exist, return False
            return False

    def track_order(self, order_id):
        """"""
        Get the status of specific order.
        :param order_id: int
        :return False: only if the order_id is not in self.orders.
        >>> warehouse.add_product(1, ""product1"", 3)
        >>> warehouse.create_order(1, 1, 2)
        >>> warehouse.track_order(1)
        'Shipped'
        """"""
        # Check if order_id exists in orders
        if order_id in self.orders:
            # Return the status of the order
            return self.orders[order_id]['status']
        else:
            # If order_id doesn't exist, return False
            return False
```",0.08957654723127036,0.10525643154493118,0.9454545454545454,0.29213483146067415,0.44635192772384835,0.7362637362637363,0.17678100263852242,0.285106379856134,0.9454545454545454,0.29213483146067415,0.44635192772384835
Llama,96,"class WeatherSystem:
    def __init__(self, city) -> None:
        self.temperature = None
        self.weather = None
        self.city = city
        self.weather_list = {}
    
    def query(self, weather_list, tmp_units = 'celsius'):
        self.weather_list = weather_list
        if self.city not in weather_list:
            return False
        else:
            self.temperature = self.weather_list[self.city]['temperature']
            self.weather = self.weather_list[self.city]['weather']
        if self.weather_list[self.city]['temperature units'] != tmp_units:
            if tmp_units == 'celsius':
                return self.fahrenheit_to_celsius(), self.weather
            elif tmp_units == 'fahrenheit':
                return self.celsius_to_fahrenheit(), self.weather
        else:
            return self.temperature, self.weather
    
    def set_city(self, city):
        self.city = city

    def celsius_to_fahrenheit(self):
        return (self.temperature * 9/5) + 32

    def fahrenheit_to_celsius(self):
        return (self.temperature - 32) * 5/9",FewShot,"

```python
class WeatherSystem:
    """"""
    This is a class representing a weather system that provides functionality to query weather information for a specific city and convert temperature units between Celsius and Fahrenheit.
    """"""

    def __init__(self, city) -> None:
        """"""
        Initialize the weather system with a city name.
        """"""
        self.temperature = None
        self.weather = None
        self.city = city
        self.weather_list = {}

    # Query the weather system for the weather and temperature of the city, and convert the temperature units based on the input parameter.
    def query(self, weather_list, tmp_units='celsius'):
        # Check if the city exists in the weather list
        if self.city in weather_list:
            # Get the weather and temperature of the city
            self.weather = weather_list[self.city]['weather']
            self.temperature = weather_list[self.city]['temperature']
            
            # Convert the temperature units if necessary
            if tmp_units == 'fahrenheit' and weather_list[self.city]['temperature units'] == 'celsius':
                self.temperature = self.celsius_to_fahrenheit()
            elif tmp_units == 'celsius' and weather_list[self.city]['temperature units'] == 'fahrenheit':
                self.temperature = self.fahrenheit_to_celsius()
            
            # Return the temperature and weather of the city
            return self.temperature, self.weather
        else:
            # Return None if the city does not exist in the weather list
            return None

    # Set the city of the weather system.
    def set_city(self, city):
        # Update the city of the weather system
        self.city = city

    # Convert the temperature from Celsius to Fahrenheit.
    def celsius_to_fahrenheit(self):
        # Check if the temperature is not None
        if self.temperature is not None:
            # Convert the temperature from Celsius to Fahrenheit
            return (self.temperature * 9/5) + 32
        else:
            # Return None if the temperature is None
            return None

    # Convert the temperature from Fahrenheit to Celsius.
    def fahrenheit_to_celsius(self):
        # Check if the temperature is not None
        if self.temperature is not None:
            # Convert the temperature from Fahrenheit to Celsius
            return (self.temperature - 32) * 5/9
        else:
            # Return None if the temperature is None
            return None
```",0.09278350515463919,0.12152705851981226,0.8846153846153846,0.4742268041237113,0.6174496598855908,0.5882352941176471,0.25906735751295334,0.35971222597044666,0.8846153846153846,0.4742268041237113,0.6174496598855908
Llama,97,"class Words2Numbers:

    def __init__(self):
        self.numwords = {}
        self.units = [
            ""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"",
            ""nine"", ""ten"", ""eleven"", ""twelve"", ""thirteen"", ""fourteen"", ""fifteen"",
            ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen"",
        ]
        self.tens = ["""", """", ""twenty"", ""thirty"", ""forty"", ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""]
        self.scales = [""hundred"", ""thousand"", ""million"", ""billion"", ""trillion""]

        self.numwords[""and""] = (1, 0)
        for idx, word in enumerate(self.units):
            self.numwords[word] = (1, idx)
        for idx, word in enumerate(self.tens):
            self.numwords[word] = (1, idx * 10)
        for idx, word in enumerate(self.scales):
            self.numwords[word] = (10 ** (idx * 3 or 2), 0)

        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}
        self.ordinal_endings = [('ieth', 'y'), ('th', '')]

    def text2int(self, textnum):
        textnum = textnum.replace('-', ' ')

        current = result = 0
        curstring = """"
        onnumber = False
        for word in textnum.split():
            if word in self.ordinal_words:
                scale, increment = (1, self.ordinal_words[word])
                current = current * scale + increment
                onnumber = True
            else:
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = ""%s%s"" % (word[:-len(ending)], replacement)

                if word not in self.numwords:
                    if onnumber:
                        curstring += repr(result + current) + "" ""
                    curstring += word + "" ""
                    result = current = 0
                    onnumber = False
                else:
                    scale, increment = self.numwords[word]
                    current = current * scale + increment
                    if scale > 100:
                        result += current
                        current = 0
                    onnumber = True

        if onnumber:
            curstring += repr(result + current)

        return curstring

    def is_valid_input(self, textnum):

        textnum = textnum.replace('-', ' ')

        for word in textnum.split():
            if word in self.ordinal_words:
                continue
            else:
                for ending, replacement in self.ordinal_endings:
                    if word.endswith(ending):
                        word = ""%s%s"" % (word[:-len(ending)], replacement)

                if word not in self.numwords:
                    return False

        return True",FewShot,"

```python
class Words2Numbers:
    """"""
    The class provides a text-to-number conversion utility, allowing conversion of written numbers (in words) to their numerical representation.
    """"""

    def __init__(self):
        """"""
        Initialize the word lists and dictionaries required for conversion
        """"""
        self.numwords = {}
        self.units = [
            ""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"",
            ""nine"", ""ten"", ""eleven"", ""twelve"", ""thirteen"", ""fourteen"", ""fifteen"",
            ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen"",
        ]
        self.tens = ["""", """", ""twenty"", ""thirty"", ""forty"", ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""]
        self.scales = [""hundred"", ""thousand"", ""million"", ""billion"", ""trillion""]

        self.numwords[""and""] = (1, 0)
        for idx, word in enumerate(self.units):
            self.numwords[word] = (1, idx)
        for idx, word in enumerate(self.tens):
            self.numwords[word] = (1, idx * 10)
        for idx, word in enumerate(self.scales):
            self.numwords[word] = (10 ** (idx * 3 or 2), 0)

        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}
        self.ordinal_endings = [('ieth', 'y'), ('th', '')]


    def text2int(self, textnum):
        """"""
        Convert the word string to the corresponding integer string
        :param textnum: string, the word string to be converted
        :return: string, the final converted integer string
        >>> w2n = Words2Numbers()
        >>> w2n.text2int(""thirty-two"")
        ""32""
        """"""
        # Replace hyphens with spaces to handle compound numbers
        textnum = textnum.replace('-', ' ')
        
        # Split the input string into words
        current = result = 0
        for word in textnum.split():
            # Check if the word is in the numwords dictionary
            if word in self.numwords:
                # Get the value and scale of the word
                scale, value = self.numwords[word]
                # If the scale is 1, add the value to the current number
                if scale == 1:
                    current += value
                # If the scale is greater than 1, multiply the current number by the scale
                else:
                    current *= scale
            # If the word is not in the numwords dictionary, it may be an ordinal word
            elif word in self.ordinal_words:
                # Get the value of the ordinal word
                value = self.ordinal_words[word]
                # Add the value to the current number
                current += value
            # If the word is not in the numwords or ordinal_words dictionaries, it may be a hyphenated number
            else:
                # Try to split the word into two parts
                for ending in self.ordinal_endings:
                    if word.endswith(ending[0]):
                        # Get the base word and the ending
                        base_word = word[:-len(ending[0])] + ending[1]
                        # Check if the base word is in the numwords dictionary
                        if base_word in self.numwords:
                            # Get the value and scale of the base word
                            scale, value = self.numwords[base_word]
                            # Add the value to the current number
                            current += value
                            break
                else:
                    # If the word is not recognized, raise a ValueError
                    raise ValueError(""Invalid input: "" + word)
            # If the current number is greater than 0, add it to the result and reset the current number
            if current > 0:
                result += current
                current = 0
        # Return the result as a string
        return str(result)


    def is_valid_input(self, textnum):
        """"""
        Check if the input text contains only valid words that can be converted into numbers.
        :param textnum: The input text containing words representing numbers.
        :return: True if input is valid, False otherwise.
        >>> w2n = Words2Numbers()
        >>> w2n.is_valid_input(""thirty-two"")
        False
        """"""
        # Replace hyphens with spaces to handle compound numbers
        textnum = textnum.replace('-', ' ')
        
        # Split the input string into words
        for word in textnum.split():
            # Check if the word is in the numwords dictionary
            if word in self.numwords:
                continue
            # If the word is not in the numwords dictionary, it may be an ordinal word
            elif word in self.ordinal_words:
                continue
            # If the word is not in the numwords or ordinal_words dictionaries, it may be a hyphenated number
            else:
                # Try to split the word into two parts
                for ending in self.ordinal_endings:
                    if word.endswith(ending[0]):
                        # Get the base word and the ending
                        base_word = word[:-len(ending[0])] + ending[1]
                        # Check if the base word is in the numwords dictionary
                        if base_word in self.numwords:
                            break
                else:
                    # If the word is not recognized, return False
                    return False
        # If all words are recognized, return True
        return True
```",0.20615384615384616,0.2349661587252344,0.8796992481203008,0.5064935064935064,0.6428571382195688,0.6778846153846154,0.349009900990099,0.46078430923832714,0.8796992481203008,0.5064935064935064,0.6428571382195688
Llama,98,"import xml.etree.ElementTree as ET


class XMLProcessor:
    def __init__(self, file_name):
        self.file_name = file_name
        self.root = None

    def read_xml(self):
        try:
            tree = ET.parse(self.file_name)
            self.root = tree.getroot()
            return self.root
        except:
            return None

    def write_xml(self, file_name):
        try:
            tree = ET.ElementTree(self.root)
            tree.write(file_name)
            return True
        except:
            return False

    def process_xml_data(self, file_name):
        for element in self.root.iter('item'):
            text = element.text
            element.text = text.upper()
        return self.write_xml(file_name)

    def find_element(self, element_name):
        elements = self.root.findall(element_name)
        return elements",FewShot,"

```python
import xml.etree.ElementTree as ET

class XMLProcessor:
    """"""
    This is a class as XML files handler, including reading, writing, processing as well as finding elements in a XML file.
    """"""

    def __init__(self, file_name):
        # Initialize the XMLProcessor object with the given file name
        self.file_name = file_name
        self.root = None

    def read_xml(self):
        # Reads the XML file and returns the root element
        try:
            # Attempt to parse the XML file
            tree = ET.parse(self.file_name)
            # Get the root element of the XML file
            self.root = tree.getroot()
            # Return the root element
            return self.root
        except:
            # Return None if an error occurs
            return None

    def write_xml(self, file_name):
        # Writes the XML data to the specified file
        try:
            # Create an ElementTree object from the root element
            tree = ET.ElementTree(self.root)
            # Write the XML data to the specified file
            tree.write(file_name)
            # Return True if the write operation is successful
            return True
        except:
            # Return False if an error occurs
            return False

    def process_xml_data(self, file_name):
        # Modifies the data in XML elements and writes the updated XML data to a new file
        # Iterate over all elements with the tag 'item'
        for element in self.root.iter('item'):
            # Get the text of the current element
            text = element.text
            # Convert the text to uppercase
            element.text = text.upper()
        # Write the updated XML data to the specified file
        return self.write_xml(file_name)

    def find_element(self, element_name):
        # Finds the XML elements with the specified name
        # Find all elements with the specified name
        elements = self.root.findall('.//' + element_name)
        # Return the list of found elements
        return elements
```",0.11372549019607843,0.13094342303054957,0.9761904761904762,0.38317757009345793,0.5503355664213324,0.7605633802816901,0.2608695652173913,0.38848920482971905,0.9761904761904762,0.38317757009345793,0.5503355664213324
